
import
  json, options, hashes, uri, openapi/rest, os, uri, strutils, httpcore

## auto-generated via openapi macro
## title: Fitness
## version: v1
## termsOfService: https://developers.google.com/terms/
## license:
##     name: Creative Commons Attribution 3.0
##     url: http://creativecommons.org/licenses/by/3.0/
## 
## Stores and accesses user data in the fitness store from apps on any platform.
## 
## https://developers.google.com/fit/rest/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_593408 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_593408](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_593408): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    if js.kind notin {JString, JInt, JFloat, JNull, JBool}:
      return
    head = $js
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  gcpServiceName = "fitness"
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_FitnessUsersDataSourcesCreate_593961 = ref object of OpenApiRestCall_593408
proc url_FitnessUsersDataSourcesCreate_593963(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesCreate_593962(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new data source that is unique across all data sources belonging to this user. The data stream ID field can be omitted and will be generated by the server with the correct format. The data stream ID is an ordered combination of some fields from the data source. In addition to the data source fields reflected into the data source ID, the developer project number that is authenticated when creating the data source is included. This developer project number is obfuscated when read by any other developer reading public data types.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   userId: JString (required)
  ##         : Create the data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `userId` field"
  var valid_593964 = path.getOrDefault("userId")
  valid_593964 = validateParameter(valid_593964, JString, required = true,
                                 default = nil)
  if valid_593964 != nil:
    section.add "userId", valid_593964
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_593965 = query.getOrDefault("fields")
  valid_593965 = validateParameter(valid_593965, JString, required = false,
                                 default = nil)
  if valid_593965 != nil:
    section.add "fields", valid_593965
  var valid_593966 = query.getOrDefault("quotaUser")
  valid_593966 = validateParameter(valid_593966, JString, required = false,
                                 default = nil)
  if valid_593966 != nil:
    section.add "quotaUser", valid_593966
  var valid_593967 = query.getOrDefault("alt")
  valid_593967 = validateParameter(valid_593967, JString, required = false,
                                 default = newJString("json"))
  if valid_593967 != nil:
    section.add "alt", valid_593967
  var valid_593968 = query.getOrDefault("oauth_token")
  valid_593968 = validateParameter(valid_593968, JString, required = false,
                                 default = nil)
  if valid_593968 != nil:
    section.add "oauth_token", valid_593968
  var valid_593969 = query.getOrDefault("userIp")
  valid_593969 = validateParameter(valid_593969, JString, required = false,
                                 default = nil)
  if valid_593969 != nil:
    section.add "userIp", valid_593969
  var valid_593970 = query.getOrDefault("key")
  valid_593970 = validateParameter(valid_593970, JString, required = false,
                                 default = nil)
  if valid_593970 != nil:
    section.add "key", valid_593970
  var valid_593971 = query.getOrDefault("prettyPrint")
  valid_593971 = validateParameter(valid_593971, JBool, required = false,
                                 default = newJBool(true))
  if valid_593971 != nil:
    section.add "prettyPrint", valid_593971
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_593973: Call_FitnessUsersDataSourcesCreate_593961; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new data source that is unique across all data sources belonging to this user. The data stream ID field can be omitted and will be generated by the server with the correct format. The data stream ID is an ordered combination of some fields from the data source. In addition to the data source fields reflected into the data source ID, the developer project number that is authenticated when creating the data source is included. This developer project number is obfuscated when read by any other developer reading public data types.
  ## 
  let valid = call_593973.validator(path, query, header, formData, body)
  let scheme = call_593973.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593973.url(scheme.get, call_593973.host, call_593973.base,
                         call_593973.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593973, url, valid)

proc call*(call_593974: Call_FitnessUsersDataSourcesCreate_593961; userId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## fitnessUsersDataSourcesCreate
  ## Creates a new data source that is unique across all data sources belonging to this user. The data stream ID field can be omitted and will be generated by the server with the correct format. The data stream ID is an ordered combination of some fields from the data source. In addition to the data source fields reflected into the data source ID, the developer project number that is authenticated when creating the data source is included. This developer project number is obfuscated when read by any other developer reading public data types.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userId: string (required)
  ##         : Create the data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  var path_593975 = newJObject()
  var query_593976 = newJObject()
  var body_593977 = newJObject()
  add(query_593976, "fields", newJString(fields))
  add(query_593976, "quotaUser", newJString(quotaUser))
  add(query_593976, "alt", newJString(alt))
  add(query_593976, "oauth_token", newJString(oauthToken))
  add(query_593976, "userIp", newJString(userIp))
  add(query_593976, "key", newJString(key))
  if body != nil:
    body_593977 = body
  add(query_593976, "prettyPrint", newJBool(prettyPrint))
  add(path_593975, "userId", newJString(userId))
  result = call_593974.call(path_593975, query_593976, nil, nil, body_593977)

var fitnessUsersDataSourcesCreate* = Call_FitnessUsersDataSourcesCreate_593961(
    name: "fitnessUsersDataSourcesCreate", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/{userId}/dataSources",
    validator: validate_FitnessUsersDataSourcesCreate_593962,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesCreate_593963,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesList_593676 = ref object of OpenApiRestCall_593408
proc url_FitnessUsersDataSourcesList_593678(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesList_593677(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all data sources that are visible to the developer, using the OAuth scopes provided. The list is not exhaustive; the user may have private data sources that are only visible to other developers, or calls using other scopes.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   userId: JString (required)
  ##         : List data sources for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `userId` field"
  var valid_593804 = path.getOrDefault("userId")
  valid_593804 = validateParameter(valid_593804, JString, required = true,
                                 default = nil)
  if valid_593804 != nil:
    section.add "userId", valid_593804
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   dataTypeName: JArray
  ##               : The names of data types to include in the list. If not specified, all data sources will be returned.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_593805 = query.getOrDefault("fields")
  valid_593805 = validateParameter(valid_593805, JString, required = false,
                                 default = nil)
  if valid_593805 != nil:
    section.add "fields", valid_593805
  var valid_593806 = query.getOrDefault("quotaUser")
  valid_593806 = validateParameter(valid_593806, JString, required = false,
                                 default = nil)
  if valid_593806 != nil:
    section.add "quotaUser", valid_593806
  var valid_593820 = query.getOrDefault("alt")
  valid_593820 = validateParameter(valid_593820, JString, required = false,
                                 default = newJString("json"))
  if valid_593820 != nil:
    section.add "alt", valid_593820
  var valid_593821 = query.getOrDefault("oauth_token")
  valid_593821 = validateParameter(valid_593821, JString, required = false,
                                 default = nil)
  if valid_593821 != nil:
    section.add "oauth_token", valid_593821
  var valid_593822 = query.getOrDefault("userIp")
  valid_593822 = validateParameter(valid_593822, JString, required = false,
                                 default = nil)
  if valid_593822 != nil:
    section.add "userIp", valid_593822
  var valid_593823 = query.getOrDefault("key")
  valid_593823 = validateParameter(valid_593823, JString, required = false,
                                 default = nil)
  if valid_593823 != nil:
    section.add "key", valid_593823
  var valid_593824 = query.getOrDefault("dataTypeName")
  valid_593824 = validateParameter(valid_593824, JArray, required = false,
                                 default = nil)
  if valid_593824 != nil:
    section.add "dataTypeName", valid_593824
  var valid_593825 = query.getOrDefault("prettyPrint")
  valid_593825 = validateParameter(valid_593825, JBool, required = false,
                                 default = newJBool(true))
  if valid_593825 != nil:
    section.add "prettyPrint", valid_593825
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593848: Call_FitnessUsersDataSourcesList_593676; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all data sources that are visible to the developer, using the OAuth scopes provided. The list is not exhaustive; the user may have private data sources that are only visible to other developers, or calls using other scopes.
  ## 
  let valid = call_593848.validator(path, query, header, formData, body)
  let scheme = call_593848.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593848.url(scheme.get, call_593848.host, call_593848.base,
                         call_593848.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593848, url, valid)

proc call*(call_593919: Call_FitnessUsersDataSourcesList_593676; userId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          dataTypeName: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## fitnessUsersDataSourcesList
  ## Lists all data sources that are visible to the developer, using the OAuth scopes provided. The list is not exhaustive; the user may have private data sources that are only visible to other developers, or calls using other scopes.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   dataTypeName: JArray
  ##               : The names of data types to include in the list. If not specified, all data sources will be returned.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userId: string (required)
  ##         : List data sources for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  var path_593920 = newJObject()
  var query_593922 = newJObject()
  add(query_593922, "fields", newJString(fields))
  add(query_593922, "quotaUser", newJString(quotaUser))
  add(query_593922, "alt", newJString(alt))
  add(query_593922, "oauth_token", newJString(oauthToken))
  add(query_593922, "userIp", newJString(userIp))
  add(query_593922, "key", newJString(key))
  if dataTypeName != nil:
    query_593922.add "dataTypeName", dataTypeName
  add(query_593922, "prettyPrint", newJBool(prettyPrint))
  add(path_593920, "userId", newJString(userId))
  result = call_593919.call(path_593920, query_593922, nil, nil, nil)

var fitnessUsersDataSourcesList* = Call_FitnessUsersDataSourcesList_593676(
    name: "fitnessUsersDataSourcesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/{userId}/dataSources",
    validator: validate_FitnessUsersDataSourcesList_593677,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesList_593678,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesUpdate_593994 = ref object of OpenApiRestCall_593408
proc url_FitnessUsersDataSourcesUpdate_593996(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "dataSourceId" in path, "`dataSourceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources/"),
               (kind: VariableSegment, value: "dataSourceId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesUpdate_593995(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the specified data source. The dataStreamId, dataType, type, dataStreamName, and device properties with the exception of version, cannot be modified.
  ## 
  ## Data sources are identified by their dataStreamId.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   dataSourceId: JString (required)
  ##               : The data stream ID of the data source to update.
  ##   userId: JString (required)
  ##         : Update the data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `dataSourceId` field"
  var valid_593997 = path.getOrDefault("dataSourceId")
  valid_593997 = validateParameter(valid_593997, JString, required = true,
                                 default = nil)
  if valid_593997 != nil:
    section.add "dataSourceId", valid_593997
  var valid_593998 = path.getOrDefault("userId")
  valid_593998 = validateParameter(valid_593998, JString, required = true,
                                 default = nil)
  if valid_593998 != nil:
    section.add "userId", valid_593998
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_593999 = query.getOrDefault("fields")
  valid_593999 = validateParameter(valid_593999, JString, required = false,
                                 default = nil)
  if valid_593999 != nil:
    section.add "fields", valid_593999
  var valid_594000 = query.getOrDefault("quotaUser")
  valid_594000 = validateParameter(valid_594000, JString, required = false,
                                 default = nil)
  if valid_594000 != nil:
    section.add "quotaUser", valid_594000
  var valid_594001 = query.getOrDefault("alt")
  valid_594001 = validateParameter(valid_594001, JString, required = false,
                                 default = newJString("json"))
  if valid_594001 != nil:
    section.add "alt", valid_594001
  var valid_594002 = query.getOrDefault("oauth_token")
  valid_594002 = validateParameter(valid_594002, JString, required = false,
                                 default = nil)
  if valid_594002 != nil:
    section.add "oauth_token", valid_594002
  var valid_594003 = query.getOrDefault("userIp")
  valid_594003 = validateParameter(valid_594003, JString, required = false,
                                 default = nil)
  if valid_594003 != nil:
    section.add "userIp", valid_594003
  var valid_594004 = query.getOrDefault("key")
  valid_594004 = validateParameter(valid_594004, JString, required = false,
                                 default = nil)
  if valid_594004 != nil:
    section.add "key", valid_594004
  var valid_594005 = query.getOrDefault("prettyPrint")
  valid_594005 = validateParameter(valid_594005, JBool, required = false,
                                 default = newJBool(true))
  if valid_594005 != nil:
    section.add "prettyPrint", valid_594005
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594007: Call_FitnessUsersDataSourcesUpdate_593994; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the specified data source. The dataStreamId, dataType, type, dataStreamName, and device properties with the exception of version, cannot be modified.
  ## 
  ## Data sources are identified by their dataStreamId.
  ## 
  let valid = call_594007.validator(path, query, header, formData, body)
  let scheme = call_594007.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594007.url(scheme.get, call_594007.host, call_594007.base,
                         call_594007.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594007, url, valid)

proc call*(call_594008: Call_FitnessUsersDataSourcesUpdate_593994;
          dataSourceId: string; userId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## fitnessUsersDataSourcesUpdate
  ## Updates the specified data source. The dataStreamId, dataType, type, dataStreamName, and device properties with the exception of version, cannot be modified.
  ## 
  ## Data sources are identified by their dataStreamId.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   dataSourceId: string (required)
  ##               : The data stream ID of the data source to update.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userId: string (required)
  ##         : Update the data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  var path_594009 = newJObject()
  var query_594010 = newJObject()
  var body_594011 = newJObject()
  add(query_594010, "fields", newJString(fields))
  add(query_594010, "quotaUser", newJString(quotaUser))
  add(query_594010, "alt", newJString(alt))
  add(query_594010, "oauth_token", newJString(oauthToken))
  add(query_594010, "userIp", newJString(userIp))
  add(path_594009, "dataSourceId", newJString(dataSourceId))
  add(query_594010, "key", newJString(key))
  if body != nil:
    body_594011 = body
  add(query_594010, "prettyPrint", newJBool(prettyPrint))
  add(path_594009, "userId", newJString(userId))
  result = call_594008.call(path_594009, query_594010, nil, nil, body_594011)

var fitnessUsersDataSourcesUpdate* = Call_FitnessUsersDataSourcesUpdate_593994(
    name: "fitnessUsersDataSourcesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/{userId}/dataSources/{dataSourceId}",
    validator: validate_FitnessUsersDataSourcesUpdate_593995,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesUpdate_593996,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesGet_593978 = ref object of OpenApiRestCall_593408
proc url_FitnessUsersDataSourcesGet_593980(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "dataSourceId" in path, "`dataSourceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources/"),
               (kind: VariableSegment, value: "dataSourceId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesGet_593979(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the specified data source.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   dataSourceId: JString (required)
  ##               : The data stream ID of the data source to retrieve.
  ##   userId: JString (required)
  ##         : Retrieve a data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `dataSourceId` field"
  var valid_593981 = path.getOrDefault("dataSourceId")
  valid_593981 = validateParameter(valid_593981, JString, required = true,
                                 default = nil)
  if valid_593981 != nil:
    section.add "dataSourceId", valid_593981
  var valid_593982 = path.getOrDefault("userId")
  valid_593982 = validateParameter(valid_593982, JString, required = true,
                                 default = nil)
  if valid_593982 != nil:
    section.add "userId", valid_593982
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_593983 = query.getOrDefault("fields")
  valid_593983 = validateParameter(valid_593983, JString, required = false,
                                 default = nil)
  if valid_593983 != nil:
    section.add "fields", valid_593983
  var valid_593984 = query.getOrDefault("quotaUser")
  valid_593984 = validateParameter(valid_593984, JString, required = false,
                                 default = nil)
  if valid_593984 != nil:
    section.add "quotaUser", valid_593984
  var valid_593985 = query.getOrDefault("alt")
  valid_593985 = validateParameter(valid_593985, JString, required = false,
                                 default = newJString("json"))
  if valid_593985 != nil:
    section.add "alt", valid_593985
  var valid_593986 = query.getOrDefault("oauth_token")
  valid_593986 = validateParameter(valid_593986, JString, required = false,
                                 default = nil)
  if valid_593986 != nil:
    section.add "oauth_token", valid_593986
  var valid_593987 = query.getOrDefault("userIp")
  valid_593987 = validateParameter(valid_593987, JString, required = false,
                                 default = nil)
  if valid_593987 != nil:
    section.add "userIp", valid_593987
  var valid_593988 = query.getOrDefault("key")
  valid_593988 = validateParameter(valid_593988, JString, required = false,
                                 default = nil)
  if valid_593988 != nil:
    section.add "key", valid_593988
  var valid_593989 = query.getOrDefault("prettyPrint")
  valid_593989 = validateParameter(valid_593989, JBool, required = false,
                                 default = newJBool(true))
  if valid_593989 != nil:
    section.add "prettyPrint", valid_593989
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593990: Call_FitnessUsersDataSourcesGet_593978; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the specified data source.
  ## 
  let valid = call_593990.validator(path, query, header, formData, body)
  let scheme = call_593990.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593990.url(scheme.get, call_593990.host, call_593990.base,
                         call_593990.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593990, url, valid)

proc call*(call_593991: Call_FitnessUsersDataSourcesGet_593978;
          dataSourceId: string; userId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## fitnessUsersDataSourcesGet
  ## Returns the specified data source.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   dataSourceId: string (required)
  ##               : The data stream ID of the data source to retrieve.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userId: string (required)
  ##         : Retrieve a data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  var path_593992 = newJObject()
  var query_593993 = newJObject()
  add(query_593993, "fields", newJString(fields))
  add(query_593993, "quotaUser", newJString(quotaUser))
  add(query_593993, "alt", newJString(alt))
  add(query_593993, "oauth_token", newJString(oauthToken))
  add(query_593993, "userIp", newJString(userIp))
  add(path_593992, "dataSourceId", newJString(dataSourceId))
  add(query_593993, "key", newJString(key))
  add(query_593993, "prettyPrint", newJBool(prettyPrint))
  add(path_593992, "userId", newJString(userId))
  result = call_593991.call(path_593992, query_593993, nil, nil, nil)

var fitnessUsersDataSourcesGet* = Call_FitnessUsersDataSourcesGet_593978(
    name: "fitnessUsersDataSourcesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/{userId}/dataSources/{dataSourceId}",
    validator: validate_FitnessUsersDataSourcesGet_593979,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesGet_593980,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesDelete_594012 = ref object of OpenApiRestCall_593408
proc url_FitnessUsersDataSourcesDelete_594014(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "dataSourceId" in path, "`dataSourceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources/"),
               (kind: VariableSegment, value: "dataSourceId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesDelete_594013(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified data source. The request will fail if the data source contains any data points.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   dataSourceId: JString (required)
  ##               : The data stream ID of the data source to delete.
  ##   userId: JString (required)
  ##         : Retrieve a data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `dataSourceId` field"
  var valid_594015 = path.getOrDefault("dataSourceId")
  valid_594015 = validateParameter(valid_594015, JString, required = true,
                                 default = nil)
  if valid_594015 != nil:
    section.add "dataSourceId", valid_594015
  var valid_594016 = path.getOrDefault("userId")
  valid_594016 = validateParameter(valid_594016, JString, required = true,
                                 default = nil)
  if valid_594016 != nil:
    section.add "userId", valid_594016
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594017 = query.getOrDefault("fields")
  valid_594017 = validateParameter(valid_594017, JString, required = false,
                                 default = nil)
  if valid_594017 != nil:
    section.add "fields", valid_594017
  var valid_594018 = query.getOrDefault("quotaUser")
  valid_594018 = validateParameter(valid_594018, JString, required = false,
                                 default = nil)
  if valid_594018 != nil:
    section.add "quotaUser", valid_594018
  var valid_594019 = query.getOrDefault("alt")
  valid_594019 = validateParameter(valid_594019, JString, required = false,
                                 default = newJString("json"))
  if valid_594019 != nil:
    section.add "alt", valid_594019
  var valid_594020 = query.getOrDefault("oauth_token")
  valid_594020 = validateParameter(valid_594020, JString, required = false,
                                 default = nil)
  if valid_594020 != nil:
    section.add "oauth_token", valid_594020
  var valid_594021 = query.getOrDefault("userIp")
  valid_594021 = validateParameter(valid_594021, JString, required = false,
                                 default = nil)
  if valid_594021 != nil:
    section.add "userIp", valid_594021
  var valid_594022 = query.getOrDefault("key")
  valid_594022 = validateParameter(valid_594022, JString, required = false,
                                 default = nil)
  if valid_594022 != nil:
    section.add "key", valid_594022
  var valid_594023 = query.getOrDefault("prettyPrint")
  valid_594023 = validateParameter(valid_594023, JBool, required = false,
                                 default = newJBool(true))
  if valid_594023 != nil:
    section.add "prettyPrint", valid_594023
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594024: Call_FitnessUsersDataSourcesDelete_594012; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified data source. The request will fail if the data source contains any data points.
  ## 
  let valid = call_594024.validator(path, query, header, formData, body)
  let scheme = call_594024.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594024.url(scheme.get, call_594024.host, call_594024.base,
                         call_594024.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594024, url, valid)

proc call*(call_594025: Call_FitnessUsersDataSourcesDelete_594012;
          dataSourceId: string; userId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## fitnessUsersDataSourcesDelete
  ## Deletes the specified data source. The request will fail if the data source contains any data points.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   dataSourceId: string (required)
  ##               : The data stream ID of the data source to delete.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userId: string (required)
  ##         : Retrieve a data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  var path_594026 = newJObject()
  var query_594027 = newJObject()
  add(query_594027, "fields", newJString(fields))
  add(query_594027, "quotaUser", newJString(quotaUser))
  add(query_594027, "alt", newJString(alt))
  add(query_594027, "oauth_token", newJString(oauthToken))
  add(query_594027, "userIp", newJString(userIp))
  add(path_594026, "dataSourceId", newJString(dataSourceId))
  add(query_594027, "key", newJString(key))
  add(query_594027, "prettyPrint", newJBool(prettyPrint))
  add(path_594026, "userId", newJString(userId))
  result = call_594025.call(path_594026, query_594027, nil, nil, nil)

var fitnessUsersDataSourcesDelete* = Call_FitnessUsersDataSourcesDelete_594012(
    name: "fitnessUsersDataSourcesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/{userId}/dataSources/{dataSourceId}",
    validator: validate_FitnessUsersDataSourcesDelete_594013,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesDelete_594014,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesDataPointChangesList_594028 = ref object of OpenApiRestCall_593408
proc url_FitnessUsersDataSourcesDataPointChangesList_594030(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "dataSourceId" in path, "`dataSourceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources/"),
               (kind: VariableSegment, value: "dataSourceId"),
               (kind: ConstantSegment, value: "/dataPointChanges")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesDataPointChangesList_594029(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Queries for user's data point changes for a particular data source.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   dataSourceId: JString (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   userId: JString (required)
  ##         : List data points for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `dataSourceId` field"
  var valid_594031 = path.getOrDefault("dataSourceId")
  valid_594031 = validateParameter(valid_594031, JString, required = true,
                                 default = nil)
  if valid_594031 != nil:
    section.add "dataSourceId", valid_594031
  var valid_594032 = path.getOrDefault("userId")
  valid_594032 = validateParameter(valid_594032, JString, required = true,
                                 default = nil)
  if valid_594032 != nil:
    section.add "userId", valid_594032
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The continuation token, which is used to page through large result sets. To get the next page of results, set this parameter to the value of nextPageToken from the previous response.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   limit: JInt
  ##        : If specified, no more than this many data point changes will be included in the response.
  section = newJObject()
  var valid_594033 = query.getOrDefault("fields")
  valid_594033 = validateParameter(valid_594033, JString, required = false,
                                 default = nil)
  if valid_594033 != nil:
    section.add "fields", valid_594033
  var valid_594034 = query.getOrDefault("pageToken")
  valid_594034 = validateParameter(valid_594034, JString, required = false,
                                 default = nil)
  if valid_594034 != nil:
    section.add "pageToken", valid_594034
  var valid_594035 = query.getOrDefault("quotaUser")
  valid_594035 = validateParameter(valid_594035, JString, required = false,
                                 default = nil)
  if valid_594035 != nil:
    section.add "quotaUser", valid_594035
  var valid_594036 = query.getOrDefault("alt")
  valid_594036 = validateParameter(valid_594036, JString, required = false,
                                 default = newJString("json"))
  if valid_594036 != nil:
    section.add "alt", valid_594036
  var valid_594037 = query.getOrDefault("oauth_token")
  valid_594037 = validateParameter(valid_594037, JString, required = false,
                                 default = nil)
  if valid_594037 != nil:
    section.add "oauth_token", valid_594037
  var valid_594038 = query.getOrDefault("userIp")
  valid_594038 = validateParameter(valid_594038, JString, required = false,
                                 default = nil)
  if valid_594038 != nil:
    section.add "userIp", valid_594038
  var valid_594039 = query.getOrDefault("key")
  valid_594039 = validateParameter(valid_594039, JString, required = false,
                                 default = nil)
  if valid_594039 != nil:
    section.add "key", valid_594039
  var valid_594040 = query.getOrDefault("prettyPrint")
  valid_594040 = validateParameter(valid_594040, JBool, required = false,
                                 default = newJBool(true))
  if valid_594040 != nil:
    section.add "prettyPrint", valid_594040
  var valid_594041 = query.getOrDefault("limit")
  valid_594041 = validateParameter(valid_594041, JInt, required = false, default = nil)
  if valid_594041 != nil:
    section.add "limit", valid_594041
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594042: Call_FitnessUsersDataSourcesDataPointChangesList_594028;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Queries for user's data point changes for a particular data source.
  ## 
  let valid = call_594042.validator(path, query, header, formData, body)
  let scheme = call_594042.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594042.url(scheme.get, call_594042.host, call_594042.base,
                         call_594042.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594042, url, valid)

proc call*(call_594043: Call_FitnessUsersDataSourcesDataPointChangesList_594028;
          dataSourceId: string; userId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true; limit: int = 0): Recallable =
  ## fitnessUsersDataSourcesDataPointChangesList
  ## Queries for user's data point changes for a particular data source.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The continuation token, which is used to page through large result sets. To get the next page of results, set this parameter to the value of nextPageToken from the previous response.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   dataSourceId: string (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   limit: int
  ##        : If specified, no more than this many data point changes will be included in the response.
  ##   userId: string (required)
  ##         : List data points for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  var path_594044 = newJObject()
  var query_594045 = newJObject()
  add(query_594045, "fields", newJString(fields))
  add(query_594045, "pageToken", newJString(pageToken))
  add(query_594045, "quotaUser", newJString(quotaUser))
  add(query_594045, "alt", newJString(alt))
  add(query_594045, "oauth_token", newJString(oauthToken))
  add(query_594045, "userIp", newJString(userIp))
  add(path_594044, "dataSourceId", newJString(dataSourceId))
  add(query_594045, "key", newJString(key))
  add(query_594045, "prettyPrint", newJBool(prettyPrint))
  add(query_594045, "limit", newJInt(limit))
  add(path_594044, "userId", newJString(userId))
  result = call_594043.call(path_594044, query_594045, nil, nil, nil)

var fitnessUsersDataSourcesDataPointChangesList* = Call_FitnessUsersDataSourcesDataPointChangesList_594028(
    name: "fitnessUsersDataSourcesDataPointChangesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/{userId}/dataSources/{dataSourceId}/dataPointChanges",
    validator: validate_FitnessUsersDataSourcesDataPointChangesList_594029,
    base: "/fitness/v1/users",
    url: url_FitnessUsersDataSourcesDataPointChangesList_594030,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesDatasetsGet_594046 = ref object of OpenApiRestCall_593408
proc url_FitnessUsersDataSourcesDatasetsGet_594048(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "dataSourceId" in path, "`dataSourceId` is a required path parameter"
  assert "datasetId" in path, "`datasetId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources/"),
               (kind: VariableSegment, value: "dataSourceId"),
               (kind: ConstantSegment, value: "/datasets/"),
               (kind: VariableSegment, value: "datasetId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesDatasetsGet_594047(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a dataset containing all data points whose start and end times overlap with the specified range of the dataset minimum start time and maximum end time. Specifically, any data point whose start time is less than or equal to the dataset end time and whose end time is greater than or equal to the dataset start time.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   datasetId: JString (required)
  ##            : Dataset identifier that is a composite of the minimum data point start time and maximum data point end time represented as nanoseconds from the epoch. The ID is formatted like: "startTime-endTime" where startTime and endTime are 64 bit integers.
  ##   dataSourceId: JString (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   userId: JString (required)
  ##         : Retrieve a dataset for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `datasetId` field"
  var valid_594049 = path.getOrDefault("datasetId")
  valid_594049 = validateParameter(valid_594049, JString, required = true,
                                 default = nil)
  if valid_594049 != nil:
    section.add "datasetId", valid_594049
  var valid_594050 = path.getOrDefault("dataSourceId")
  valid_594050 = validateParameter(valid_594050, JString, required = true,
                                 default = nil)
  if valid_594050 != nil:
    section.add "dataSourceId", valid_594050
  var valid_594051 = path.getOrDefault("userId")
  valid_594051 = validateParameter(valid_594051, JString, required = true,
                                 default = nil)
  if valid_594051 != nil:
    section.add "userId", valid_594051
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The continuation token, which is used to page through large datasets. To get the next page of a dataset, set this parameter to the value of nextPageToken from the previous response. Each subsequent call will yield a partial dataset with data point end timestamps that are strictly smaller than those in the previous partial response.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   limit: JInt
  ##        : If specified, no more than this many data points will be included in the dataset. If there are more data points in the dataset, nextPageToken will be set in the dataset response.
  section = newJObject()
  var valid_594052 = query.getOrDefault("fields")
  valid_594052 = validateParameter(valid_594052, JString, required = false,
                                 default = nil)
  if valid_594052 != nil:
    section.add "fields", valid_594052
  var valid_594053 = query.getOrDefault("pageToken")
  valid_594053 = validateParameter(valid_594053, JString, required = false,
                                 default = nil)
  if valid_594053 != nil:
    section.add "pageToken", valid_594053
  var valid_594054 = query.getOrDefault("quotaUser")
  valid_594054 = validateParameter(valid_594054, JString, required = false,
                                 default = nil)
  if valid_594054 != nil:
    section.add "quotaUser", valid_594054
  var valid_594055 = query.getOrDefault("alt")
  valid_594055 = validateParameter(valid_594055, JString, required = false,
                                 default = newJString("json"))
  if valid_594055 != nil:
    section.add "alt", valid_594055
  var valid_594056 = query.getOrDefault("oauth_token")
  valid_594056 = validateParameter(valid_594056, JString, required = false,
                                 default = nil)
  if valid_594056 != nil:
    section.add "oauth_token", valid_594056
  var valid_594057 = query.getOrDefault("userIp")
  valid_594057 = validateParameter(valid_594057, JString, required = false,
                                 default = nil)
  if valid_594057 != nil:
    section.add "userIp", valid_594057
  var valid_594058 = query.getOrDefault("key")
  valid_594058 = validateParameter(valid_594058, JString, required = false,
                                 default = nil)
  if valid_594058 != nil:
    section.add "key", valid_594058
  var valid_594059 = query.getOrDefault("prettyPrint")
  valid_594059 = validateParameter(valid_594059, JBool, required = false,
                                 default = newJBool(true))
  if valid_594059 != nil:
    section.add "prettyPrint", valid_594059
  var valid_594060 = query.getOrDefault("limit")
  valid_594060 = validateParameter(valid_594060, JInt, required = false, default = nil)
  if valid_594060 != nil:
    section.add "limit", valid_594060
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594061: Call_FitnessUsersDataSourcesDatasetsGet_594046;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a dataset containing all data points whose start and end times overlap with the specified range of the dataset minimum start time and maximum end time. Specifically, any data point whose start time is less than or equal to the dataset end time and whose end time is greater than or equal to the dataset start time.
  ## 
  let valid = call_594061.validator(path, query, header, formData, body)
  let scheme = call_594061.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594061.url(scheme.get, call_594061.host, call_594061.base,
                         call_594061.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594061, url, valid)

proc call*(call_594062: Call_FitnessUsersDataSourcesDatasetsGet_594046;
          datasetId: string; dataSourceId: string; userId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true; limit: int = 0): Recallable =
  ## fitnessUsersDataSourcesDatasetsGet
  ## Returns a dataset containing all data points whose start and end times overlap with the specified range of the dataset minimum start time and maximum end time. Specifically, any data point whose start time is less than or equal to the dataset end time and whose end time is greater than or equal to the dataset start time.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The continuation token, which is used to page through large datasets. To get the next page of a dataset, set this parameter to the value of nextPageToken from the previous response. Each subsequent call will yield a partial dataset with data point end timestamps that are strictly smaller than those in the previous partial response.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   datasetId: string (required)
  ##            : Dataset identifier that is a composite of the minimum data point start time and maximum data point end time represented as nanoseconds from the epoch. The ID is formatted like: "startTime-endTime" where startTime and endTime are 64 bit integers.
  ##   dataSourceId: string (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   limit: int
  ##        : If specified, no more than this many data points will be included in the dataset. If there are more data points in the dataset, nextPageToken will be set in the dataset response.
  ##   userId: string (required)
  ##         : Retrieve a dataset for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  var path_594063 = newJObject()
  var query_594064 = newJObject()
  add(query_594064, "fields", newJString(fields))
  add(query_594064, "pageToken", newJString(pageToken))
  add(query_594064, "quotaUser", newJString(quotaUser))
  add(query_594064, "alt", newJString(alt))
  add(query_594064, "oauth_token", newJString(oauthToken))
  add(query_594064, "userIp", newJString(userIp))
  add(path_594063, "datasetId", newJString(datasetId))
  add(path_594063, "dataSourceId", newJString(dataSourceId))
  add(query_594064, "key", newJString(key))
  add(query_594064, "prettyPrint", newJBool(prettyPrint))
  add(query_594064, "limit", newJInt(limit))
  add(path_594063, "userId", newJString(userId))
  result = call_594062.call(path_594063, query_594064, nil, nil, nil)

var fitnessUsersDataSourcesDatasetsGet* = Call_FitnessUsersDataSourcesDatasetsGet_594046(
    name: "fitnessUsersDataSourcesDatasetsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/{userId}/dataSources/{dataSourceId}/datasets/{datasetId}",
    validator: validate_FitnessUsersDataSourcesDatasetsGet_594047,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesDatasetsGet_594048,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesDatasetsPatch_594084 = ref object of OpenApiRestCall_593408
proc url_FitnessUsersDataSourcesDatasetsPatch_594086(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "dataSourceId" in path, "`dataSourceId` is a required path parameter"
  assert "datasetId" in path, "`datasetId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources/"),
               (kind: VariableSegment, value: "dataSourceId"),
               (kind: ConstantSegment, value: "/datasets/"),
               (kind: VariableSegment, value: "datasetId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesDatasetsPatch_594085(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds data points to a dataset. The dataset need not be previously created. All points within the given dataset will be returned with subsquent calls to retrieve this dataset. Data points can belong to more than one dataset. This method does not use patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   datasetId: JString (required)
  ##            : Dataset identifier that is a composite of the minimum data point start time and maximum data point end time represented as nanoseconds from the epoch. The ID is formatted like: "startTime-endTime" where startTime and endTime are 64 bit integers.
  ##   dataSourceId: JString (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   userId: JString (required)
  ##         : Patch a dataset for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `datasetId` field"
  var valid_594087 = path.getOrDefault("datasetId")
  valid_594087 = validateParameter(valid_594087, JString, required = true,
                                 default = nil)
  if valid_594087 != nil:
    section.add "datasetId", valid_594087
  var valid_594088 = path.getOrDefault("dataSourceId")
  valid_594088 = validateParameter(valid_594088, JString, required = true,
                                 default = nil)
  if valid_594088 != nil:
    section.add "dataSourceId", valid_594088
  var valid_594089 = path.getOrDefault("userId")
  valid_594089 = validateParameter(valid_594089, JString, required = true,
                                 default = nil)
  if valid_594089 != nil:
    section.add "userId", valid_594089
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   currentTimeMillis: JString
  ##                    : The client's current time in milliseconds since epoch. Note that the minStartTimeNs and maxEndTimeNs properties in the request body are in nanoseconds instead of milliseconds.
  section = newJObject()
  var valid_594090 = query.getOrDefault("fields")
  valid_594090 = validateParameter(valid_594090, JString, required = false,
                                 default = nil)
  if valid_594090 != nil:
    section.add "fields", valid_594090
  var valid_594091 = query.getOrDefault("quotaUser")
  valid_594091 = validateParameter(valid_594091, JString, required = false,
                                 default = nil)
  if valid_594091 != nil:
    section.add "quotaUser", valid_594091
  var valid_594092 = query.getOrDefault("alt")
  valid_594092 = validateParameter(valid_594092, JString, required = false,
                                 default = newJString("json"))
  if valid_594092 != nil:
    section.add "alt", valid_594092
  var valid_594093 = query.getOrDefault("oauth_token")
  valid_594093 = validateParameter(valid_594093, JString, required = false,
                                 default = nil)
  if valid_594093 != nil:
    section.add "oauth_token", valid_594093
  var valid_594094 = query.getOrDefault("userIp")
  valid_594094 = validateParameter(valid_594094, JString, required = false,
                                 default = nil)
  if valid_594094 != nil:
    section.add "userIp", valid_594094
  var valid_594095 = query.getOrDefault("key")
  valid_594095 = validateParameter(valid_594095, JString, required = false,
                                 default = nil)
  if valid_594095 != nil:
    section.add "key", valid_594095
  var valid_594096 = query.getOrDefault("prettyPrint")
  valid_594096 = validateParameter(valid_594096, JBool, required = false,
                                 default = newJBool(true))
  if valid_594096 != nil:
    section.add "prettyPrint", valid_594096
  var valid_594097 = query.getOrDefault("currentTimeMillis")
  valid_594097 = validateParameter(valid_594097, JString, required = false,
                                 default = nil)
  if valid_594097 != nil:
    section.add "currentTimeMillis", valid_594097
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594099: Call_FitnessUsersDataSourcesDatasetsPatch_594084;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Adds data points to a dataset. The dataset need not be previously created. All points within the given dataset will be returned with subsquent calls to retrieve this dataset. Data points can belong to more than one dataset. This method does not use patch semantics.
  ## 
  let valid = call_594099.validator(path, query, header, formData, body)
  let scheme = call_594099.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594099.url(scheme.get, call_594099.host, call_594099.base,
                         call_594099.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594099, url, valid)

proc call*(call_594100: Call_FitnessUsersDataSourcesDatasetsPatch_594084;
          datasetId: string; dataSourceId: string; userId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true; currentTimeMillis: string = ""): Recallable =
  ## fitnessUsersDataSourcesDatasetsPatch
  ## Adds data points to a dataset. The dataset need not be previously created. All points within the given dataset will be returned with subsquent calls to retrieve this dataset. Data points can belong to more than one dataset. This method does not use patch semantics.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   datasetId: string (required)
  ##            : Dataset identifier that is a composite of the minimum data point start time and maximum data point end time represented as nanoseconds from the epoch. The ID is formatted like: "startTime-endTime" where startTime and endTime are 64 bit integers.
  ##   dataSourceId: string (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userId: string (required)
  ##         : Patch a dataset for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   currentTimeMillis: string
  ##                    : The client's current time in milliseconds since epoch. Note that the minStartTimeNs and maxEndTimeNs properties in the request body are in nanoseconds instead of milliseconds.
  var path_594101 = newJObject()
  var query_594102 = newJObject()
  var body_594103 = newJObject()
  add(query_594102, "fields", newJString(fields))
  add(query_594102, "quotaUser", newJString(quotaUser))
  add(query_594102, "alt", newJString(alt))
  add(query_594102, "oauth_token", newJString(oauthToken))
  add(query_594102, "userIp", newJString(userIp))
  add(path_594101, "datasetId", newJString(datasetId))
  add(path_594101, "dataSourceId", newJString(dataSourceId))
  add(query_594102, "key", newJString(key))
  if body != nil:
    body_594103 = body
  add(query_594102, "prettyPrint", newJBool(prettyPrint))
  add(path_594101, "userId", newJString(userId))
  add(query_594102, "currentTimeMillis", newJString(currentTimeMillis))
  result = call_594100.call(path_594101, query_594102, nil, nil, body_594103)

var fitnessUsersDataSourcesDatasetsPatch* = Call_FitnessUsersDataSourcesDatasetsPatch_594084(
    name: "fitnessUsersDataSourcesDatasetsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/{userId}/dataSources/{dataSourceId}/datasets/{datasetId}",
    validator: validate_FitnessUsersDataSourcesDatasetsPatch_594085,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesDatasetsPatch_594086,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesDatasetsDelete_594065 = ref object of OpenApiRestCall_593408
proc url_FitnessUsersDataSourcesDatasetsDelete_594067(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "dataSourceId" in path, "`dataSourceId` is a required path parameter"
  assert "datasetId" in path, "`datasetId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources/"),
               (kind: VariableSegment, value: "dataSourceId"),
               (kind: ConstantSegment, value: "/datasets/"),
               (kind: VariableSegment, value: "datasetId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesDatasetsDelete_594066(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Performs an inclusive delete of all data points whose start and end times have any overlap with the time range specified by the dataset ID. For most data types, the entire data point will be deleted. For data types where the time span represents a consistent value (such as com.google.activity.segment), and a data point straddles either end point of the dataset, only the overlapping portion of the data point will be deleted.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   datasetId: JString (required)
  ##            : Dataset identifier that is a composite of the minimum data point start time and maximum data point end time represented as nanoseconds from the epoch. The ID is formatted like: "startTime-endTime" where startTime and endTime are 64 bit integers.
  ##   dataSourceId: JString (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   userId: JString (required)
  ##         : Delete a dataset for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `datasetId` field"
  var valid_594068 = path.getOrDefault("datasetId")
  valid_594068 = validateParameter(valid_594068, JString, required = true,
                                 default = nil)
  if valid_594068 != nil:
    section.add "datasetId", valid_594068
  var valid_594069 = path.getOrDefault("dataSourceId")
  valid_594069 = validateParameter(valid_594069, JString, required = true,
                                 default = nil)
  if valid_594069 != nil:
    section.add "dataSourceId", valid_594069
  var valid_594070 = path.getOrDefault("userId")
  valid_594070 = validateParameter(valid_594070, JString, required = true,
                                 default = nil)
  if valid_594070 != nil:
    section.add "userId", valid_594070
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   modifiedTimeMillis: JString
  ##                     : When the operation was performed on the client.
  ##   currentTimeMillis: JString
  ##                    : The client's current time in milliseconds since epoch.
  section = newJObject()
  var valid_594071 = query.getOrDefault("fields")
  valid_594071 = validateParameter(valid_594071, JString, required = false,
                                 default = nil)
  if valid_594071 != nil:
    section.add "fields", valid_594071
  var valid_594072 = query.getOrDefault("quotaUser")
  valid_594072 = validateParameter(valid_594072, JString, required = false,
                                 default = nil)
  if valid_594072 != nil:
    section.add "quotaUser", valid_594072
  var valid_594073 = query.getOrDefault("alt")
  valid_594073 = validateParameter(valid_594073, JString, required = false,
                                 default = newJString("json"))
  if valid_594073 != nil:
    section.add "alt", valid_594073
  var valid_594074 = query.getOrDefault("oauth_token")
  valid_594074 = validateParameter(valid_594074, JString, required = false,
                                 default = nil)
  if valid_594074 != nil:
    section.add "oauth_token", valid_594074
  var valid_594075 = query.getOrDefault("userIp")
  valid_594075 = validateParameter(valid_594075, JString, required = false,
                                 default = nil)
  if valid_594075 != nil:
    section.add "userIp", valid_594075
  var valid_594076 = query.getOrDefault("key")
  valid_594076 = validateParameter(valid_594076, JString, required = false,
                                 default = nil)
  if valid_594076 != nil:
    section.add "key", valid_594076
  var valid_594077 = query.getOrDefault("prettyPrint")
  valid_594077 = validateParameter(valid_594077, JBool, required = false,
                                 default = newJBool(true))
  if valid_594077 != nil:
    section.add "prettyPrint", valid_594077
  var valid_594078 = query.getOrDefault("modifiedTimeMillis")
  valid_594078 = validateParameter(valid_594078, JString, required = false,
                                 default = nil)
  if valid_594078 != nil:
    section.add "modifiedTimeMillis", valid_594078
  var valid_594079 = query.getOrDefault("currentTimeMillis")
  valid_594079 = validateParameter(valid_594079, JString, required = false,
                                 default = nil)
  if valid_594079 != nil:
    section.add "currentTimeMillis", valid_594079
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594080: Call_FitnessUsersDataSourcesDatasetsDelete_594065;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Performs an inclusive delete of all data points whose start and end times have any overlap with the time range specified by the dataset ID. For most data types, the entire data point will be deleted. For data types where the time span represents a consistent value (such as com.google.activity.segment), and a data point straddles either end point of the dataset, only the overlapping portion of the data point will be deleted.
  ## 
  let valid = call_594080.validator(path, query, header, formData, body)
  let scheme = call_594080.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594080.url(scheme.get, call_594080.host, call_594080.base,
                         call_594080.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594080, url, valid)

proc call*(call_594081: Call_FitnessUsersDataSourcesDatasetsDelete_594065;
          datasetId: string; dataSourceId: string; userId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true; modifiedTimeMillis: string = "";
          currentTimeMillis: string = ""): Recallable =
  ## fitnessUsersDataSourcesDatasetsDelete
  ## Performs an inclusive delete of all data points whose start and end times have any overlap with the time range specified by the dataset ID. For most data types, the entire data point will be deleted. For data types where the time span represents a consistent value (such as com.google.activity.segment), and a data point straddles either end point of the dataset, only the overlapping portion of the data point will be deleted.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   datasetId: string (required)
  ##            : Dataset identifier that is a composite of the minimum data point start time and maximum data point end time represented as nanoseconds from the epoch. The ID is formatted like: "startTime-endTime" where startTime and endTime are 64 bit integers.
  ##   dataSourceId: string (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   modifiedTimeMillis: string
  ##                     : When the operation was performed on the client.
  ##   userId: string (required)
  ##         : Delete a dataset for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   currentTimeMillis: string
  ##                    : The client's current time in milliseconds since epoch.
  var path_594082 = newJObject()
  var query_594083 = newJObject()
  add(query_594083, "fields", newJString(fields))
  add(query_594083, "quotaUser", newJString(quotaUser))
  add(query_594083, "alt", newJString(alt))
  add(query_594083, "oauth_token", newJString(oauthToken))
  add(query_594083, "userIp", newJString(userIp))
  add(path_594082, "datasetId", newJString(datasetId))
  add(path_594082, "dataSourceId", newJString(dataSourceId))
  add(query_594083, "key", newJString(key))
  add(query_594083, "prettyPrint", newJBool(prettyPrint))
  add(query_594083, "modifiedTimeMillis", newJString(modifiedTimeMillis))
  add(path_594082, "userId", newJString(userId))
  add(query_594083, "currentTimeMillis", newJString(currentTimeMillis))
  result = call_594081.call(path_594082, query_594083, nil, nil, nil)

var fitnessUsersDataSourcesDatasetsDelete* = Call_FitnessUsersDataSourcesDatasetsDelete_594065(
    name: "fitnessUsersDataSourcesDatasetsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/{userId}/dataSources/{dataSourceId}/datasets/{datasetId}",
    validator: validate_FitnessUsersDataSourcesDatasetsDelete_594066,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesDatasetsDelete_594067,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDatasetAggregate_594104 = ref object of OpenApiRestCall_593408
proc url_FitnessUsersDatasetAggregate_594106(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataset:aggregate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDatasetAggregate_594105(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Aggregates data of a certain type or stream into buckets divided by a given type of boundary. Multiple data sets of multiple types and from multiple sources can be aggreated into exactly one bucket type per request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   userId: JString (required)
  ##         : Aggregate data for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `userId` field"
  var valid_594107 = path.getOrDefault("userId")
  valid_594107 = validateParameter(valid_594107, JString, required = true,
                                 default = nil)
  if valid_594107 != nil:
    section.add "userId", valid_594107
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594108 = query.getOrDefault("fields")
  valid_594108 = validateParameter(valid_594108, JString, required = false,
                                 default = nil)
  if valid_594108 != nil:
    section.add "fields", valid_594108
  var valid_594109 = query.getOrDefault("quotaUser")
  valid_594109 = validateParameter(valid_594109, JString, required = false,
                                 default = nil)
  if valid_594109 != nil:
    section.add "quotaUser", valid_594109
  var valid_594110 = query.getOrDefault("alt")
  valid_594110 = validateParameter(valid_594110, JString, required = false,
                                 default = newJString("json"))
  if valid_594110 != nil:
    section.add "alt", valid_594110
  var valid_594111 = query.getOrDefault("oauth_token")
  valid_594111 = validateParameter(valid_594111, JString, required = false,
                                 default = nil)
  if valid_594111 != nil:
    section.add "oauth_token", valid_594111
  var valid_594112 = query.getOrDefault("userIp")
  valid_594112 = validateParameter(valid_594112, JString, required = false,
                                 default = nil)
  if valid_594112 != nil:
    section.add "userIp", valid_594112
  var valid_594113 = query.getOrDefault("key")
  valid_594113 = validateParameter(valid_594113, JString, required = false,
                                 default = nil)
  if valid_594113 != nil:
    section.add "key", valid_594113
  var valid_594114 = query.getOrDefault("prettyPrint")
  valid_594114 = validateParameter(valid_594114, JBool, required = false,
                                 default = newJBool(true))
  if valid_594114 != nil:
    section.add "prettyPrint", valid_594114
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594116: Call_FitnessUsersDatasetAggregate_594104; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Aggregates data of a certain type or stream into buckets divided by a given type of boundary. Multiple data sets of multiple types and from multiple sources can be aggreated into exactly one bucket type per request.
  ## 
  let valid = call_594116.validator(path, query, header, formData, body)
  let scheme = call_594116.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594116.url(scheme.get, call_594116.host, call_594116.base,
                         call_594116.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594116, url, valid)

proc call*(call_594117: Call_FitnessUsersDatasetAggregate_594104; userId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## fitnessUsersDatasetAggregate
  ## Aggregates data of a certain type or stream into buckets divided by a given type of boundary. Multiple data sets of multiple types and from multiple sources can be aggreated into exactly one bucket type per request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userId: string (required)
  ##         : Aggregate data for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  var path_594118 = newJObject()
  var query_594119 = newJObject()
  var body_594120 = newJObject()
  add(query_594119, "fields", newJString(fields))
  add(query_594119, "quotaUser", newJString(quotaUser))
  add(query_594119, "alt", newJString(alt))
  add(query_594119, "oauth_token", newJString(oauthToken))
  add(query_594119, "userIp", newJString(userIp))
  add(query_594119, "key", newJString(key))
  if body != nil:
    body_594120 = body
  add(query_594119, "prettyPrint", newJBool(prettyPrint))
  add(path_594118, "userId", newJString(userId))
  result = call_594117.call(path_594118, query_594119, nil, nil, body_594120)

var fitnessUsersDatasetAggregate* = Call_FitnessUsersDatasetAggregate_594104(
    name: "fitnessUsersDatasetAggregate", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/{userId}/dataset:aggregate",
    validator: validate_FitnessUsersDatasetAggregate_594105,
    base: "/fitness/v1/users", url: url_FitnessUsersDatasetAggregate_594106,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersSessionsList_594121 = ref object of OpenApiRestCall_593408
proc url_FitnessUsersSessionsList_594123(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/sessions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersSessionsList_594122(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists sessions previously created.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   userId: JString (required)
  ##         : List sessions for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `userId` field"
  var valid_594124 = path.getOrDefault("userId")
  valid_594124 = validateParameter(valid_594124, JString, required = true,
                                 default = nil)
  if valid_594124 != nil:
    section.add "userId", valid_594124
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The continuation token, which is used for incremental syncing. To get the next batch of changes, set this parameter to the value of nextPageToken from the previous response. This token is treated as a timestamp (in millis since epoch). If specified, the API returns sessions modified since this time. The page token is ignored if either start or end time is specified. If none of start time, end time, and the page token is specified, sessions modified in the last 30 days are returned.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   endTime: JString
  ##          : An RFC3339 timestamp. Only sessions ending between the start and end times will be included in the response.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   includeDeleted: JBool
  ##                 : If true, deleted sessions will be returned. When set to true, sessions returned in this response will only have an ID and will not have any other fields.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   startTime: JString
  ##            : An RFC3339 timestamp. Only sessions ending between the start and end times will be included in the response.
  section = newJObject()
  var valid_594125 = query.getOrDefault("fields")
  valid_594125 = validateParameter(valid_594125, JString, required = false,
                                 default = nil)
  if valid_594125 != nil:
    section.add "fields", valid_594125
  var valid_594126 = query.getOrDefault("pageToken")
  valid_594126 = validateParameter(valid_594126, JString, required = false,
                                 default = nil)
  if valid_594126 != nil:
    section.add "pageToken", valid_594126
  var valid_594127 = query.getOrDefault("quotaUser")
  valid_594127 = validateParameter(valid_594127, JString, required = false,
                                 default = nil)
  if valid_594127 != nil:
    section.add "quotaUser", valid_594127
  var valid_594128 = query.getOrDefault("alt")
  valid_594128 = validateParameter(valid_594128, JString, required = false,
                                 default = newJString("json"))
  if valid_594128 != nil:
    section.add "alt", valid_594128
  var valid_594129 = query.getOrDefault("oauth_token")
  valid_594129 = validateParameter(valid_594129, JString, required = false,
                                 default = nil)
  if valid_594129 != nil:
    section.add "oauth_token", valid_594129
  var valid_594130 = query.getOrDefault("endTime")
  valid_594130 = validateParameter(valid_594130, JString, required = false,
                                 default = nil)
  if valid_594130 != nil:
    section.add "endTime", valid_594130
  var valid_594131 = query.getOrDefault("userIp")
  valid_594131 = validateParameter(valid_594131, JString, required = false,
                                 default = nil)
  if valid_594131 != nil:
    section.add "userIp", valid_594131
  var valid_594132 = query.getOrDefault("key")
  valid_594132 = validateParameter(valid_594132, JString, required = false,
                                 default = nil)
  if valid_594132 != nil:
    section.add "key", valid_594132
  var valid_594133 = query.getOrDefault("includeDeleted")
  valid_594133 = validateParameter(valid_594133, JBool, required = false, default = nil)
  if valid_594133 != nil:
    section.add "includeDeleted", valid_594133
  var valid_594134 = query.getOrDefault("prettyPrint")
  valid_594134 = validateParameter(valid_594134, JBool, required = false,
                                 default = newJBool(true))
  if valid_594134 != nil:
    section.add "prettyPrint", valid_594134
  var valid_594135 = query.getOrDefault("startTime")
  valid_594135 = validateParameter(valid_594135, JString, required = false,
                                 default = nil)
  if valid_594135 != nil:
    section.add "startTime", valid_594135
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594136: Call_FitnessUsersSessionsList_594121; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists sessions previously created.
  ## 
  let valid = call_594136.validator(path, query, header, formData, body)
  let scheme = call_594136.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594136.url(scheme.get, call_594136.host, call_594136.base,
                         call_594136.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594136, url, valid)

proc call*(call_594137: Call_FitnessUsersSessionsList_594121; userId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; endTime: string = "";
          userIp: string = ""; key: string = ""; includeDeleted: bool = false;
          prettyPrint: bool = true; startTime: string = ""): Recallable =
  ## fitnessUsersSessionsList
  ## Lists sessions previously created.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The continuation token, which is used for incremental syncing. To get the next batch of changes, set this parameter to the value of nextPageToken from the previous response. This token is treated as a timestamp (in millis since epoch). If specified, the API returns sessions modified since this time. The page token is ignored if either start or end time is specified. If none of start time, end time, and the page token is specified, sessions modified in the last 30 days are returned.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   endTime: string
  ##          : An RFC3339 timestamp. Only sessions ending between the start and end times will be included in the response.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   includeDeleted: bool
  ##                 : If true, deleted sessions will be returned. When set to true, sessions returned in this response will only have an ID and will not have any other fields.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   startTime: string
  ##            : An RFC3339 timestamp. Only sessions ending between the start and end times will be included in the response.
  ##   userId: string (required)
  ##         : List sessions for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  var path_594138 = newJObject()
  var query_594139 = newJObject()
  add(query_594139, "fields", newJString(fields))
  add(query_594139, "pageToken", newJString(pageToken))
  add(query_594139, "quotaUser", newJString(quotaUser))
  add(query_594139, "alt", newJString(alt))
  add(query_594139, "oauth_token", newJString(oauthToken))
  add(query_594139, "endTime", newJString(endTime))
  add(query_594139, "userIp", newJString(userIp))
  add(query_594139, "key", newJString(key))
  add(query_594139, "includeDeleted", newJBool(includeDeleted))
  add(query_594139, "prettyPrint", newJBool(prettyPrint))
  add(query_594139, "startTime", newJString(startTime))
  add(path_594138, "userId", newJString(userId))
  result = call_594137.call(path_594138, query_594139, nil, nil, nil)

var fitnessUsersSessionsList* = Call_FitnessUsersSessionsList_594121(
    name: "fitnessUsersSessionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/{userId}/sessions",
    validator: validate_FitnessUsersSessionsList_594122,
    base: "/fitness/v1/users", url: url_FitnessUsersSessionsList_594123,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersSessionsUpdate_594140 = ref object of OpenApiRestCall_593408
proc url_FitnessUsersSessionsUpdate_594142(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "sessionId" in path, "`sessionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/sessions/"),
               (kind: VariableSegment, value: "sessionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersSessionsUpdate_594141(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates or insert a given session.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   sessionId: JString (required)
  ##            : The ID of the session to be created.
  ##   userId: JString (required)
  ##         : Create sessions for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `sessionId` field"
  var valid_594143 = path.getOrDefault("sessionId")
  valid_594143 = validateParameter(valid_594143, JString, required = true,
                                 default = nil)
  if valid_594143 != nil:
    section.add "sessionId", valid_594143
  var valid_594144 = path.getOrDefault("userId")
  valid_594144 = validateParameter(valid_594144, JString, required = true,
                                 default = nil)
  if valid_594144 != nil:
    section.add "userId", valid_594144
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   currentTimeMillis: JString
  ##                    : The client's current time in milliseconds since epoch.
  section = newJObject()
  var valid_594145 = query.getOrDefault("fields")
  valid_594145 = validateParameter(valid_594145, JString, required = false,
                                 default = nil)
  if valid_594145 != nil:
    section.add "fields", valid_594145
  var valid_594146 = query.getOrDefault("quotaUser")
  valid_594146 = validateParameter(valid_594146, JString, required = false,
                                 default = nil)
  if valid_594146 != nil:
    section.add "quotaUser", valid_594146
  var valid_594147 = query.getOrDefault("alt")
  valid_594147 = validateParameter(valid_594147, JString, required = false,
                                 default = newJString("json"))
  if valid_594147 != nil:
    section.add "alt", valid_594147
  var valid_594148 = query.getOrDefault("oauth_token")
  valid_594148 = validateParameter(valid_594148, JString, required = false,
                                 default = nil)
  if valid_594148 != nil:
    section.add "oauth_token", valid_594148
  var valid_594149 = query.getOrDefault("userIp")
  valid_594149 = validateParameter(valid_594149, JString, required = false,
                                 default = nil)
  if valid_594149 != nil:
    section.add "userIp", valid_594149
  var valid_594150 = query.getOrDefault("key")
  valid_594150 = validateParameter(valid_594150, JString, required = false,
                                 default = nil)
  if valid_594150 != nil:
    section.add "key", valid_594150
  var valid_594151 = query.getOrDefault("prettyPrint")
  valid_594151 = validateParameter(valid_594151, JBool, required = false,
                                 default = newJBool(true))
  if valid_594151 != nil:
    section.add "prettyPrint", valid_594151
  var valid_594152 = query.getOrDefault("currentTimeMillis")
  valid_594152 = validateParameter(valid_594152, JString, required = false,
                                 default = nil)
  if valid_594152 != nil:
    section.add "currentTimeMillis", valid_594152
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594154: Call_FitnessUsersSessionsUpdate_594140; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates or insert a given session.
  ## 
  let valid = call_594154.validator(path, query, header, formData, body)
  let scheme = call_594154.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594154.url(scheme.get, call_594154.host, call_594154.base,
                         call_594154.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594154, url, valid)

proc call*(call_594155: Call_FitnessUsersSessionsUpdate_594140; sessionId: string;
          userId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true;
          currentTimeMillis: string = ""): Recallable =
  ## fitnessUsersSessionsUpdate
  ## Updates or insert a given session.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sessionId: string (required)
  ##            : The ID of the session to be created.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userId: string (required)
  ##         : Create sessions for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   currentTimeMillis: string
  ##                    : The client's current time in milliseconds since epoch.
  var path_594156 = newJObject()
  var query_594157 = newJObject()
  var body_594158 = newJObject()
  add(query_594157, "fields", newJString(fields))
  add(query_594157, "quotaUser", newJString(quotaUser))
  add(query_594157, "alt", newJString(alt))
  add(query_594157, "oauth_token", newJString(oauthToken))
  add(query_594157, "userIp", newJString(userIp))
  add(query_594157, "key", newJString(key))
  add(path_594156, "sessionId", newJString(sessionId))
  if body != nil:
    body_594158 = body
  add(query_594157, "prettyPrint", newJBool(prettyPrint))
  add(path_594156, "userId", newJString(userId))
  add(query_594157, "currentTimeMillis", newJString(currentTimeMillis))
  result = call_594155.call(path_594156, query_594157, nil, nil, body_594158)

var fitnessUsersSessionsUpdate* = Call_FitnessUsersSessionsUpdate_594140(
    name: "fitnessUsersSessionsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/{userId}/sessions/{sessionId}",
    validator: validate_FitnessUsersSessionsUpdate_594141,
    base: "/fitness/v1/users", url: url_FitnessUsersSessionsUpdate_594142,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersSessionsDelete_594159 = ref object of OpenApiRestCall_593408
proc url_FitnessUsersSessionsDelete_594161(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "sessionId" in path, "`sessionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/sessions/"),
               (kind: VariableSegment, value: "sessionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersSessionsDelete_594160(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a session specified by the given session ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   sessionId: JString (required)
  ##            : The ID of the session to be deleted.
  ##   userId: JString (required)
  ##         : Delete a session for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `sessionId` field"
  var valid_594162 = path.getOrDefault("sessionId")
  valid_594162 = validateParameter(valid_594162, JString, required = true,
                                 default = nil)
  if valid_594162 != nil:
    section.add "sessionId", valid_594162
  var valid_594163 = path.getOrDefault("userId")
  valid_594163 = validateParameter(valid_594163, JString, required = true,
                                 default = nil)
  if valid_594163 != nil:
    section.add "userId", valid_594163
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   currentTimeMillis: JString
  ##                    : The client's current time in milliseconds since epoch.
  section = newJObject()
  var valid_594164 = query.getOrDefault("fields")
  valid_594164 = validateParameter(valid_594164, JString, required = false,
                                 default = nil)
  if valid_594164 != nil:
    section.add "fields", valid_594164
  var valid_594165 = query.getOrDefault("quotaUser")
  valid_594165 = validateParameter(valid_594165, JString, required = false,
                                 default = nil)
  if valid_594165 != nil:
    section.add "quotaUser", valid_594165
  var valid_594166 = query.getOrDefault("alt")
  valid_594166 = validateParameter(valid_594166, JString, required = false,
                                 default = newJString("json"))
  if valid_594166 != nil:
    section.add "alt", valid_594166
  var valid_594167 = query.getOrDefault("oauth_token")
  valid_594167 = validateParameter(valid_594167, JString, required = false,
                                 default = nil)
  if valid_594167 != nil:
    section.add "oauth_token", valid_594167
  var valid_594168 = query.getOrDefault("userIp")
  valid_594168 = validateParameter(valid_594168, JString, required = false,
                                 default = nil)
  if valid_594168 != nil:
    section.add "userIp", valid_594168
  var valid_594169 = query.getOrDefault("key")
  valid_594169 = validateParameter(valid_594169, JString, required = false,
                                 default = nil)
  if valid_594169 != nil:
    section.add "key", valid_594169
  var valid_594170 = query.getOrDefault("prettyPrint")
  valid_594170 = validateParameter(valid_594170, JBool, required = false,
                                 default = newJBool(true))
  if valid_594170 != nil:
    section.add "prettyPrint", valid_594170
  var valid_594171 = query.getOrDefault("currentTimeMillis")
  valid_594171 = validateParameter(valid_594171, JString, required = false,
                                 default = nil)
  if valid_594171 != nil:
    section.add "currentTimeMillis", valid_594171
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594172: Call_FitnessUsersSessionsDelete_594159; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a session specified by the given session ID.
  ## 
  let valid = call_594172.validator(path, query, header, formData, body)
  let scheme = call_594172.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594172.url(scheme.get, call_594172.host, call_594172.base,
                         call_594172.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594172, url, valid)

proc call*(call_594173: Call_FitnessUsersSessionsDelete_594159; sessionId: string;
          userId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true; currentTimeMillis: string = ""): Recallable =
  ## fitnessUsersSessionsDelete
  ## Deletes a session specified by the given session ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sessionId: string (required)
  ##            : The ID of the session to be deleted.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userId: string (required)
  ##         : Delete a session for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   currentTimeMillis: string
  ##                    : The client's current time in milliseconds since epoch.
  var path_594174 = newJObject()
  var query_594175 = newJObject()
  add(query_594175, "fields", newJString(fields))
  add(query_594175, "quotaUser", newJString(quotaUser))
  add(query_594175, "alt", newJString(alt))
  add(query_594175, "oauth_token", newJString(oauthToken))
  add(query_594175, "userIp", newJString(userIp))
  add(query_594175, "key", newJString(key))
  add(path_594174, "sessionId", newJString(sessionId))
  add(query_594175, "prettyPrint", newJBool(prettyPrint))
  add(path_594174, "userId", newJString(userId))
  add(query_594175, "currentTimeMillis", newJString(currentTimeMillis))
  result = call_594173.call(path_594174, query_594175, nil, nil, nil)

var fitnessUsersSessionsDelete* = Call_FitnessUsersSessionsDelete_594159(
    name: "fitnessUsersSessionsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/{userId}/sessions/{sessionId}",
    validator: validate_FitnessUsersSessionsDelete_594160,
    base: "/fitness/v1/users", url: url_FitnessUsersSessionsDelete_594161,
    schemes: {Scheme.Https})
export
  rest

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
