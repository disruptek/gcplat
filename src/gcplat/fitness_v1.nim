
import
  json, options, hashes, uri, rest, os, uri, strutils, times, httpcore, httpclient,
  asyncdispatch, jwt

## auto-generated via openapi macro
## title: Fitness
## version: v1
## termsOfService: https://developers.google.com/terms/
## license:
##     name: Creative Commons Attribution 3.0
##     url: http://creativecommons.org/licenses/by/3.0/
## 
## Stores and accesses user data in the fitness store from apps on any platform.
## 
## https://developers.google.com/fit/rest/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_578339 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_578339](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_578339): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  gcpServiceName = "fitness"
proc composeQueryString(query: JsonNode): string
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_FitnessUsersDataSourcesCreate_578894 = ref object of OpenApiRestCall_578339
proc url_FitnessUsersDataSourcesCreate_578896(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesCreate_578895(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new data source that is unique across all data sources belonging to this user. The data stream ID field can be omitted and will be generated by the server with the correct format. The data stream ID is an ordered combination of some fields from the data source. In addition to the data source fields reflected into the data source ID, the developer project number that is authenticated when creating the data source is included. This developer project number is obfuscated when read by any other developer reading public data types.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   userId: JString (required)
  ##         : Create the data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `userId` field"
  var valid_578897 = path.getOrDefault("userId")
  valid_578897 = validateParameter(valid_578897, JString, required = true,
                                 default = nil)
  if valid_578897 != nil:
    section.add "userId", valid_578897
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_578898 = query.getOrDefault("key")
  valid_578898 = validateParameter(valid_578898, JString, required = false,
                                 default = nil)
  if valid_578898 != nil:
    section.add "key", valid_578898
  var valid_578899 = query.getOrDefault("prettyPrint")
  valid_578899 = validateParameter(valid_578899, JBool, required = false,
                                 default = newJBool(true))
  if valid_578899 != nil:
    section.add "prettyPrint", valid_578899
  var valid_578900 = query.getOrDefault("oauth_token")
  valid_578900 = validateParameter(valid_578900, JString, required = false,
                                 default = nil)
  if valid_578900 != nil:
    section.add "oauth_token", valid_578900
  var valid_578901 = query.getOrDefault("alt")
  valid_578901 = validateParameter(valid_578901, JString, required = false,
                                 default = newJString("json"))
  if valid_578901 != nil:
    section.add "alt", valid_578901
  var valid_578902 = query.getOrDefault("userIp")
  valid_578902 = validateParameter(valid_578902, JString, required = false,
                                 default = nil)
  if valid_578902 != nil:
    section.add "userIp", valid_578902
  var valid_578903 = query.getOrDefault("quotaUser")
  valid_578903 = validateParameter(valid_578903, JString, required = false,
                                 default = nil)
  if valid_578903 != nil:
    section.add "quotaUser", valid_578903
  var valid_578904 = query.getOrDefault("fields")
  valid_578904 = validateParameter(valid_578904, JString, required = false,
                                 default = nil)
  if valid_578904 != nil:
    section.add "fields", valid_578904
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578906: Call_FitnessUsersDataSourcesCreate_578894; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new data source that is unique across all data sources belonging to this user. The data stream ID field can be omitted and will be generated by the server with the correct format. The data stream ID is an ordered combination of some fields from the data source. In addition to the data source fields reflected into the data source ID, the developer project number that is authenticated when creating the data source is included. This developer project number is obfuscated when read by any other developer reading public data types.
  ## 
  let valid = call_578906.validator(path, query, header, formData, body)
  let scheme = call_578906.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578906.url(scheme.get, call_578906.host, call_578906.base,
                         call_578906.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578906, url, valid)

proc call*(call_578907: Call_FitnessUsersDataSourcesCreate_578894; userId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## fitnessUsersDataSourcesCreate
  ## Creates a new data source that is unique across all data sources belonging to this user. The data stream ID field can be omitted and will be generated by the server with the correct format. The data stream ID is an ordered combination of some fields from the data source. In addition to the data source fields reflected into the data source ID, the developer project number that is authenticated when creating the data source is included. This developer project number is obfuscated when read by any other developer reading public data types.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   userId: string (required)
  ##         : Create the data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_578908 = newJObject()
  var query_578909 = newJObject()
  var body_578910 = newJObject()
  add(query_578909, "key", newJString(key))
  add(query_578909, "prettyPrint", newJBool(prettyPrint))
  add(query_578909, "oauth_token", newJString(oauthToken))
  add(query_578909, "alt", newJString(alt))
  add(query_578909, "userIp", newJString(userIp))
  add(query_578909, "quotaUser", newJString(quotaUser))
  add(path_578908, "userId", newJString(userId))
  if body != nil:
    body_578910 = body
  add(query_578909, "fields", newJString(fields))
  result = call_578907.call(path_578908, query_578909, nil, nil, body_578910)

var fitnessUsersDataSourcesCreate* = Call_FitnessUsersDataSourcesCreate_578894(
    name: "fitnessUsersDataSourcesCreate", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/{userId}/dataSources",
    validator: validate_FitnessUsersDataSourcesCreate_578895,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesCreate_578896,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesList_578609 = ref object of OpenApiRestCall_578339
proc url_FitnessUsersDataSourcesList_578611(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesList_578610(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all data sources that are visible to the developer, using the OAuth scopes provided. The list is not exhaustive; the user may have private data sources that are only visible to other developers, or calls using other scopes.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   userId: JString (required)
  ##         : List data sources for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `userId` field"
  var valid_578737 = path.getOrDefault("userId")
  valid_578737 = validateParameter(valid_578737, JString, required = true,
                                 default = nil)
  if valid_578737 != nil:
    section.add "userId", valid_578737
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   dataTypeName: JArray
  ##               : The names of data types to include in the list. If not specified, all data sources will be returned.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_578738 = query.getOrDefault("key")
  valid_578738 = validateParameter(valid_578738, JString, required = false,
                                 default = nil)
  if valid_578738 != nil:
    section.add "key", valid_578738
  var valid_578752 = query.getOrDefault("prettyPrint")
  valid_578752 = validateParameter(valid_578752, JBool, required = false,
                                 default = newJBool(true))
  if valid_578752 != nil:
    section.add "prettyPrint", valid_578752
  var valid_578753 = query.getOrDefault("oauth_token")
  valid_578753 = validateParameter(valid_578753, JString, required = false,
                                 default = nil)
  if valid_578753 != nil:
    section.add "oauth_token", valid_578753
  var valid_578754 = query.getOrDefault("alt")
  valid_578754 = validateParameter(valid_578754, JString, required = false,
                                 default = newJString("json"))
  if valid_578754 != nil:
    section.add "alt", valid_578754
  var valid_578755 = query.getOrDefault("userIp")
  valid_578755 = validateParameter(valid_578755, JString, required = false,
                                 default = nil)
  if valid_578755 != nil:
    section.add "userIp", valid_578755
  var valid_578756 = query.getOrDefault("quotaUser")
  valid_578756 = validateParameter(valid_578756, JString, required = false,
                                 default = nil)
  if valid_578756 != nil:
    section.add "quotaUser", valid_578756
  var valid_578757 = query.getOrDefault("dataTypeName")
  valid_578757 = validateParameter(valid_578757, JArray, required = false,
                                 default = nil)
  if valid_578757 != nil:
    section.add "dataTypeName", valid_578757
  var valid_578758 = query.getOrDefault("fields")
  valid_578758 = validateParameter(valid_578758, JString, required = false,
                                 default = nil)
  if valid_578758 != nil:
    section.add "fields", valid_578758
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578781: Call_FitnessUsersDataSourcesList_578609; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all data sources that are visible to the developer, using the OAuth scopes provided. The list is not exhaustive; the user may have private data sources that are only visible to other developers, or calls using other scopes.
  ## 
  let valid = call_578781.validator(path, query, header, formData, body)
  let scheme = call_578781.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578781.url(scheme.get, call_578781.host, call_578781.base,
                         call_578781.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578781, url, valid)

proc call*(call_578852: Call_FitnessUsersDataSourcesList_578609; userId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          dataTypeName: JsonNode = nil; fields: string = ""): Recallable =
  ## fitnessUsersDataSourcesList
  ## Lists all data sources that are visible to the developer, using the OAuth scopes provided. The list is not exhaustive; the user may have private data sources that are only visible to other developers, or calls using other scopes.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   userId: string (required)
  ##         : List data sources for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   dataTypeName: JArray
  ##               : The names of data types to include in the list. If not specified, all data sources will be returned.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_578853 = newJObject()
  var query_578855 = newJObject()
  add(query_578855, "key", newJString(key))
  add(query_578855, "prettyPrint", newJBool(prettyPrint))
  add(query_578855, "oauth_token", newJString(oauthToken))
  add(query_578855, "alt", newJString(alt))
  add(query_578855, "userIp", newJString(userIp))
  add(query_578855, "quotaUser", newJString(quotaUser))
  add(path_578853, "userId", newJString(userId))
  if dataTypeName != nil:
    query_578855.add "dataTypeName", dataTypeName
  add(query_578855, "fields", newJString(fields))
  result = call_578852.call(path_578853, query_578855, nil, nil, nil)

var fitnessUsersDataSourcesList* = Call_FitnessUsersDataSourcesList_578609(
    name: "fitnessUsersDataSourcesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/{userId}/dataSources",
    validator: validate_FitnessUsersDataSourcesList_578610,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesList_578611,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesUpdate_578927 = ref object of OpenApiRestCall_578339
proc url_FitnessUsersDataSourcesUpdate_578929(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "dataSourceId" in path, "`dataSourceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources/"),
               (kind: VariableSegment, value: "dataSourceId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesUpdate_578928(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the specified data source. The dataStreamId, dataType, type, dataStreamName, and device properties with the exception of version, cannot be modified.
  ## 
  ## Data sources are identified by their dataStreamId.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   dataSourceId: JString (required)
  ##               : The data stream ID of the data source to update.
  ##   userId: JString (required)
  ##         : Update the data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `dataSourceId` field"
  var valid_578930 = path.getOrDefault("dataSourceId")
  valid_578930 = validateParameter(valid_578930, JString, required = true,
                                 default = nil)
  if valid_578930 != nil:
    section.add "dataSourceId", valid_578930
  var valid_578931 = path.getOrDefault("userId")
  valid_578931 = validateParameter(valid_578931, JString, required = true,
                                 default = nil)
  if valid_578931 != nil:
    section.add "userId", valid_578931
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_578932 = query.getOrDefault("key")
  valid_578932 = validateParameter(valid_578932, JString, required = false,
                                 default = nil)
  if valid_578932 != nil:
    section.add "key", valid_578932
  var valid_578933 = query.getOrDefault("prettyPrint")
  valid_578933 = validateParameter(valid_578933, JBool, required = false,
                                 default = newJBool(true))
  if valid_578933 != nil:
    section.add "prettyPrint", valid_578933
  var valid_578934 = query.getOrDefault("oauth_token")
  valid_578934 = validateParameter(valid_578934, JString, required = false,
                                 default = nil)
  if valid_578934 != nil:
    section.add "oauth_token", valid_578934
  var valid_578935 = query.getOrDefault("alt")
  valid_578935 = validateParameter(valid_578935, JString, required = false,
                                 default = newJString("json"))
  if valid_578935 != nil:
    section.add "alt", valid_578935
  var valid_578936 = query.getOrDefault("userIp")
  valid_578936 = validateParameter(valid_578936, JString, required = false,
                                 default = nil)
  if valid_578936 != nil:
    section.add "userIp", valid_578936
  var valid_578937 = query.getOrDefault("quotaUser")
  valid_578937 = validateParameter(valid_578937, JString, required = false,
                                 default = nil)
  if valid_578937 != nil:
    section.add "quotaUser", valid_578937
  var valid_578938 = query.getOrDefault("fields")
  valid_578938 = validateParameter(valid_578938, JString, required = false,
                                 default = nil)
  if valid_578938 != nil:
    section.add "fields", valid_578938
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578940: Call_FitnessUsersDataSourcesUpdate_578927; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the specified data source. The dataStreamId, dataType, type, dataStreamName, and device properties with the exception of version, cannot be modified.
  ## 
  ## Data sources are identified by their dataStreamId.
  ## 
  let valid = call_578940.validator(path, query, header, formData, body)
  let scheme = call_578940.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578940.url(scheme.get, call_578940.host, call_578940.base,
                         call_578940.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578940, url, valid)

proc call*(call_578941: Call_FitnessUsersDataSourcesUpdate_578927;
          dataSourceId: string; userId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; body: JsonNode = nil;
          fields: string = ""): Recallable =
  ## fitnessUsersDataSourcesUpdate
  ## Updates the specified data source. The dataStreamId, dataType, type, dataStreamName, and device properties with the exception of version, cannot be modified.
  ## 
  ## Data sources are identified by their dataStreamId.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   dataSourceId: string (required)
  ##               : The data stream ID of the data source to update.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   userId: string (required)
  ##         : Update the data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_578942 = newJObject()
  var query_578943 = newJObject()
  var body_578944 = newJObject()
  add(query_578943, "key", newJString(key))
  add(query_578943, "prettyPrint", newJBool(prettyPrint))
  add(query_578943, "oauth_token", newJString(oauthToken))
  add(path_578942, "dataSourceId", newJString(dataSourceId))
  add(query_578943, "alt", newJString(alt))
  add(query_578943, "userIp", newJString(userIp))
  add(query_578943, "quotaUser", newJString(quotaUser))
  add(path_578942, "userId", newJString(userId))
  if body != nil:
    body_578944 = body
  add(query_578943, "fields", newJString(fields))
  result = call_578941.call(path_578942, query_578943, nil, nil, body_578944)

var fitnessUsersDataSourcesUpdate* = Call_FitnessUsersDataSourcesUpdate_578927(
    name: "fitnessUsersDataSourcesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/{userId}/dataSources/{dataSourceId}",
    validator: validate_FitnessUsersDataSourcesUpdate_578928,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesUpdate_578929,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesGet_578911 = ref object of OpenApiRestCall_578339
proc url_FitnessUsersDataSourcesGet_578913(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "dataSourceId" in path, "`dataSourceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources/"),
               (kind: VariableSegment, value: "dataSourceId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesGet_578912(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the specified data source.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   dataSourceId: JString (required)
  ##               : The data stream ID of the data source to retrieve.
  ##   userId: JString (required)
  ##         : Retrieve a data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `dataSourceId` field"
  var valid_578914 = path.getOrDefault("dataSourceId")
  valid_578914 = validateParameter(valid_578914, JString, required = true,
                                 default = nil)
  if valid_578914 != nil:
    section.add "dataSourceId", valid_578914
  var valid_578915 = path.getOrDefault("userId")
  valid_578915 = validateParameter(valid_578915, JString, required = true,
                                 default = nil)
  if valid_578915 != nil:
    section.add "userId", valid_578915
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_578916 = query.getOrDefault("key")
  valid_578916 = validateParameter(valid_578916, JString, required = false,
                                 default = nil)
  if valid_578916 != nil:
    section.add "key", valid_578916
  var valid_578917 = query.getOrDefault("prettyPrint")
  valid_578917 = validateParameter(valid_578917, JBool, required = false,
                                 default = newJBool(true))
  if valid_578917 != nil:
    section.add "prettyPrint", valid_578917
  var valid_578918 = query.getOrDefault("oauth_token")
  valid_578918 = validateParameter(valid_578918, JString, required = false,
                                 default = nil)
  if valid_578918 != nil:
    section.add "oauth_token", valid_578918
  var valid_578919 = query.getOrDefault("alt")
  valid_578919 = validateParameter(valid_578919, JString, required = false,
                                 default = newJString("json"))
  if valid_578919 != nil:
    section.add "alt", valid_578919
  var valid_578920 = query.getOrDefault("userIp")
  valid_578920 = validateParameter(valid_578920, JString, required = false,
                                 default = nil)
  if valid_578920 != nil:
    section.add "userIp", valid_578920
  var valid_578921 = query.getOrDefault("quotaUser")
  valid_578921 = validateParameter(valid_578921, JString, required = false,
                                 default = nil)
  if valid_578921 != nil:
    section.add "quotaUser", valid_578921
  var valid_578922 = query.getOrDefault("fields")
  valid_578922 = validateParameter(valid_578922, JString, required = false,
                                 default = nil)
  if valid_578922 != nil:
    section.add "fields", valid_578922
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578923: Call_FitnessUsersDataSourcesGet_578911; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the specified data source.
  ## 
  let valid = call_578923.validator(path, query, header, formData, body)
  let scheme = call_578923.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578923.url(scheme.get, call_578923.host, call_578923.base,
                         call_578923.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578923, url, valid)

proc call*(call_578924: Call_FitnessUsersDataSourcesGet_578911;
          dataSourceId: string; userId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; fields: string = ""): Recallable =
  ## fitnessUsersDataSourcesGet
  ## Returns the specified data source.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   dataSourceId: string (required)
  ##               : The data stream ID of the data source to retrieve.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   userId: string (required)
  ##         : Retrieve a data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_578925 = newJObject()
  var query_578926 = newJObject()
  add(query_578926, "key", newJString(key))
  add(query_578926, "prettyPrint", newJBool(prettyPrint))
  add(query_578926, "oauth_token", newJString(oauthToken))
  add(path_578925, "dataSourceId", newJString(dataSourceId))
  add(query_578926, "alt", newJString(alt))
  add(query_578926, "userIp", newJString(userIp))
  add(query_578926, "quotaUser", newJString(quotaUser))
  add(path_578925, "userId", newJString(userId))
  add(query_578926, "fields", newJString(fields))
  result = call_578924.call(path_578925, query_578926, nil, nil, nil)

var fitnessUsersDataSourcesGet* = Call_FitnessUsersDataSourcesGet_578911(
    name: "fitnessUsersDataSourcesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/{userId}/dataSources/{dataSourceId}",
    validator: validate_FitnessUsersDataSourcesGet_578912,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesGet_578913,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesDelete_578945 = ref object of OpenApiRestCall_578339
proc url_FitnessUsersDataSourcesDelete_578947(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "dataSourceId" in path, "`dataSourceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources/"),
               (kind: VariableSegment, value: "dataSourceId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesDelete_578946(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified data source. The request will fail if the data source contains any data points.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   dataSourceId: JString (required)
  ##               : The data stream ID of the data source to delete.
  ##   userId: JString (required)
  ##         : Retrieve a data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `dataSourceId` field"
  var valid_578948 = path.getOrDefault("dataSourceId")
  valid_578948 = validateParameter(valid_578948, JString, required = true,
                                 default = nil)
  if valid_578948 != nil:
    section.add "dataSourceId", valid_578948
  var valid_578949 = path.getOrDefault("userId")
  valid_578949 = validateParameter(valid_578949, JString, required = true,
                                 default = nil)
  if valid_578949 != nil:
    section.add "userId", valid_578949
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_578950 = query.getOrDefault("key")
  valid_578950 = validateParameter(valid_578950, JString, required = false,
                                 default = nil)
  if valid_578950 != nil:
    section.add "key", valid_578950
  var valid_578951 = query.getOrDefault("prettyPrint")
  valid_578951 = validateParameter(valid_578951, JBool, required = false,
                                 default = newJBool(true))
  if valid_578951 != nil:
    section.add "prettyPrint", valid_578951
  var valid_578952 = query.getOrDefault("oauth_token")
  valid_578952 = validateParameter(valid_578952, JString, required = false,
                                 default = nil)
  if valid_578952 != nil:
    section.add "oauth_token", valid_578952
  var valid_578953 = query.getOrDefault("alt")
  valid_578953 = validateParameter(valid_578953, JString, required = false,
                                 default = newJString("json"))
  if valid_578953 != nil:
    section.add "alt", valid_578953
  var valid_578954 = query.getOrDefault("userIp")
  valid_578954 = validateParameter(valid_578954, JString, required = false,
                                 default = nil)
  if valid_578954 != nil:
    section.add "userIp", valid_578954
  var valid_578955 = query.getOrDefault("quotaUser")
  valid_578955 = validateParameter(valid_578955, JString, required = false,
                                 default = nil)
  if valid_578955 != nil:
    section.add "quotaUser", valid_578955
  var valid_578956 = query.getOrDefault("fields")
  valid_578956 = validateParameter(valid_578956, JString, required = false,
                                 default = nil)
  if valid_578956 != nil:
    section.add "fields", valid_578956
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578957: Call_FitnessUsersDataSourcesDelete_578945; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified data source. The request will fail if the data source contains any data points.
  ## 
  let valid = call_578957.validator(path, query, header, formData, body)
  let scheme = call_578957.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578957.url(scheme.get, call_578957.host, call_578957.base,
                         call_578957.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578957, url, valid)

proc call*(call_578958: Call_FitnessUsersDataSourcesDelete_578945;
          dataSourceId: string; userId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; fields: string = ""): Recallable =
  ## fitnessUsersDataSourcesDelete
  ## Deletes the specified data source. The request will fail if the data source contains any data points.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   dataSourceId: string (required)
  ##               : The data stream ID of the data source to delete.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   userId: string (required)
  ##         : Retrieve a data source for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_578959 = newJObject()
  var query_578960 = newJObject()
  add(query_578960, "key", newJString(key))
  add(query_578960, "prettyPrint", newJBool(prettyPrint))
  add(query_578960, "oauth_token", newJString(oauthToken))
  add(path_578959, "dataSourceId", newJString(dataSourceId))
  add(query_578960, "alt", newJString(alt))
  add(query_578960, "userIp", newJString(userIp))
  add(query_578960, "quotaUser", newJString(quotaUser))
  add(path_578959, "userId", newJString(userId))
  add(query_578960, "fields", newJString(fields))
  result = call_578958.call(path_578959, query_578960, nil, nil, nil)

var fitnessUsersDataSourcesDelete* = Call_FitnessUsersDataSourcesDelete_578945(
    name: "fitnessUsersDataSourcesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/{userId}/dataSources/{dataSourceId}",
    validator: validate_FitnessUsersDataSourcesDelete_578946,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesDelete_578947,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesDataPointChangesList_578961 = ref object of OpenApiRestCall_578339
proc url_FitnessUsersDataSourcesDataPointChangesList_578963(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "dataSourceId" in path, "`dataSourceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources/"),
               (kind: VariableSegment, value: "dataSourceId"),
               (kind: ConstantSegment, value: "/dataPointChanges")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesDataPointChangesList_578962(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Queries for user's data point changes for a particular data source.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   dataSourceId: JString (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   userId: JString (required)
  ##         : List data points for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `dataSourceId` field"
  var valid_578964 = path.getOrDefault("dataSourceId")
  valid_578964 = validateParameter(valid_578964, JString, required = true,
                                 default = nil)
  if valid_578964 != nil:
    section.add "dataSourceId", valid_578964
  var valid_578965 = path.getOrDefault("userId")
  valid_578965 = validateParameter(valid_578965, JString, required = true,
                                 default = nil)
  if valid_578965 != nil:
    section.add "userId", valid_578965
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   limit: JInt
  ##        : If specified, no more than this many data point changes will be included in the response.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   pageToken: JString
  ##            : The continuation token, which is used to page through large result sets. To get the next page of results, set this parameter to the value of nextPageToken from the previous response.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_578966 = query.getOrDefault("key")
  valid_578966 = validateParameter(valid_578966, JString, required = false,
                                 default = nil)
  if valid_578966 != nil:
    section.add "key", valid_578966
  var valid_578967 = query.getOrDefault("prettyPrint")
  valid_578967 = validateParameter(valid_578967, JBool, required = false,
                                 default = newJBool(true))
  if valid_578967 != nil:
    section.add "prettyPrint", valid_578967
  var valid_578968 = query.getOrDefault("oauth_token")
  valid_578968 = validateParameter(valid_578968, JString, required = false,
                                 default = nil)
  if valid_578968 != nil:
    section.add "oauth_token", valid_578968
  var valid_578969 = query.getOrDefault("limit")
  valid_578969 = validateParameter(valid_578969, JInt, required = false, default = nil)
  if valid_578969 != nil:
    section.add "limit", valid_578969
  var valid_578970 = query.getOrDefault("alt")
  valid_578970 = validateParameter(valid_578970, JString, required = false,
                                 default = newJString("json"))
  if valid_578970 != nil:
    section.add "alt", valid_578970
  var valid_578971 = query.getOrDefault("userIp")
  valid_578971 = validateParameter(valid_578971, JString, required = false,
                                 default = nil)
  if valid_578971 != nil:
    section.add "userIp", valid_578971
  var valid_578972 = query.getOrDefault("quotaUser")
  valid_578972 = validateParameter(valid_578972, JString, required = false,
                                 default = nil)
  if valid_578972 != nil:
    section.add "quotaUser", valid_578972
  var valid_578973 = query.getOrDefault("pageToken")
  valid_578973 = validateParameter(valid_578973, JString, required = false,
                                 default = nil)
  if valid_578973 != nil:
    section.add "pageToken", valid_578973
  var valid_578974 = query.getOrDefault("fields")
  valid_578974 = validateParameter(valid_578974, JString, required = false,
                                 default = nil)
  if valid_578974 != nil:
    section.add "fields", valid_578974
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578975: Call_FitnessUsersDataSourcesDataPointChangesList_578961;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Queries for user's data point changes for a particular data source.
  ## 
  let valid = call_578975.validator(path, query, header, formData, body)
  let scheme = call_578975.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578975.url(scheme.get, call_578975.host, call_578975.base,
                         call_578975.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578975, url, valid)

proc call*(call_578976: Call_FitnessUsersDataSourcesDataPointChangesList_578961;
          dataSourceId: string; userId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; limit: int = 0;
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          pageToken: string = ""; fields: string = ""): Recallable =
  ## fitnessUsersDataSourcesDataPointChangesList
  ## Queries for user's data point changes for a particular data source.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   dataSourceId: string (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   limit: int
  ##        : If specified, no more than this many data point changes will be included in the response.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   pageToken: string
  ##            : The continuation token, which is used to page through large result sets. To get the next page of results, set this parameter to the value of nextPageToken from the previous response.
  ##   userId: string (required)
  ##         : List data points for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_578977 = newJObject()
  var query_578978 = newJObject()
  add(query_578978, "key", newJString(key))
  add(query_578978, "prettyPrint", newJBool(prettyPrint))
  add(query_578978, "oauth_token", newJString(oauthToken))
  add(path_578977, "dataSourceId", newJString(dataSourceId))
  add(query_578978, "limit", newJInt(limit))
  add(query_578978, "alt", newJString(alt))
  add(query_578978, "userIp", newJString(userIp))
  add(query_578978, "quotaUser", newJString(quotaUser))
  add(query_578978, "pageToken", newJString(pageToken))
  add(path_578977, "userId", newJString(userId))
  add(query_578978, "fields", newJString(fields))
  result = call_578976.call(path_578977, query_578978, nil, nil, nil)

var fitnessUsersDataSourcesDataPointChangesList* = Call_FitnessUsersDataSourcesDataPointChangesList_578961(
    name: "fitnessUsersDataSourcesDataPointChangesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/{userId}/dataSources/{dataSourceId}/dataPointChanges",
    validator: validate_FitnessUsersDataSourcesDataPointChangesList_578962,
    base: "/fitness/v1/users",
    url: url_FitnessUsersDataSourcesDataPointChangesList_578963,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesDatasetsGet_578979 = ref object of OpenApiRestCall_578339
proc url_FitnessUsersDataSourcesDatasetsGet_578981(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "dataSourceId" in path, "`dataSourceId` is a required path parameter"
  assert "datasetId" in path, "`datasetId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources/"),
               (kind: VariableSegment, value: "dataSourceId"),
               (kind: ConstantSegment, value: "/datasets/"),
               (kind: VariableSegment, value: "datasetId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesDatasetsGet_578980(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a dataset containing all data points whose start and end times overlap with the specified range of the dataset minimum start time and maximum end time. Specifically, any data point whose start time is less than or equal to the dataset end time and whose end time is greater than or equal to the dataset start time.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   dataSourceId: JString (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   userId: JString (required)
  ##         : Retrieve a dataset for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   datasetId: JString (required)
  ##            : Dataset identifier that is a composite of the minimum data point start time and maximum data point end time represented as nanoseconds from the epoch. The ID is formatted like: "startTime-endTime" where startTime and endTime are 64 bit integers.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `dataSourceId` field"
  var valid_578982 = path.getOrDefault("dataSourceId")
  valid_578982 = validateParameter(valid_578982, JString, required = true,
                                 default = nil)
  if valid_578982 != nil:
    section.add "dataSourceId", valid_578982
  var valid_578983 = path.getOrDefault("userId")
  valid_578983 = validateParameter(valid_578983, JString, required = true,
                                 default = nil)
  if valid_578983 != nil:
    section.add "userId", valid_578983
  var valid_578984 = path.getOrDefault("datasetId")
  valid_578984 = validateParameter(valid_578984, JString, required = true,
                                 default = nil)
  if valid_578984 != nil:
    section.add "datasetId", valid_578984
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   limit: JInt
  ##        : If specified, no more than this many data points will be included in the dataset. If there are more data points in the dataset, nextPageToken will be set in the dataset response.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   pageToken: JString
  ##            : The continuation token, which is used to page through large datasets. To get the next page of a dataset, set this parameter to the value of nextPageToken from the previous response. Each subsequent call will yield a partial dataset with data point end timestamps that are strictly smaller than those in the previous partial response.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_578985 = query.getOrDefault("key")
  valid_578985 = validateParameter(valid_578985, JString, required = false,
                                 default = nil)
  if valid_578985 != nil:
    section.add "key", valid_578985
  var valid_578986 = query.getOrDefault("prettyPrint")
  valid_578986 = validateParameter(valid_578986, JBool, required = false,
                                 default = newJBool(true))
  if valid_578986 != nil:
    section.add "prettyPrint", valid_578986
  var valid_578987 = query.getOrDefault("oauth_token")
  valid_578987 = validateParameter(valid_578987, JString, required = false,
                                 default = nil)
  if valid_578987 != nil:
    section.add "oauth_token", valid_578987
  var valid_578988 = query.getOrDefault("limit")
  valid_578988 = validateParameter(valid_578988, JInt, required = false, default = nil)
  if valid_578988 != nil:
    section.add "limit", valid_578988
  var valid_578989 = query.getOrDefault("alt")
  valid_578989 = validateParameter(valid_578989, JString, required = false,
                                 default = newJString("json"))
  if valid_578989 != nil:
    section.add "alt", valid_578989
  var valid_578990 = query.getOrDefault("userIp")
  valid_578990 = validateParameter(valid_578990, JString, required = false,
                                 default = nil)
  if valid_578990 != nil:
    section.add "userIp", valid_578990
  var valid_578991 = query.getOrDefault("quotaUser")
  valid_578991 = validateParameter(valid_578991, JString, required = false,
                                 default = nil)
  if valid_578991 != nil:
    section.add "quotaUser", valid_578991
  var valid_578992 = query.getOrDefault("pageToken")
  valid_578992 = validateParameter(valid_578992, JString, required = false,
                                 default = nil)
  if valid_578992 != nil:
    section.add "pageToken", valid_578992
  var valid_578993 = query.getOrDefault("fields")
  valid_578993 = validateParameter(valid_578993, JString, required = false,
                                 default = nil)
  if valid_578993 != nil:
    section.add "fields", valid_578993
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578994: Call_FitnessUsersDataSourcesDatasetsGet_578979;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a dataset containing all data points whose start and end times overlap with the specified range of the dataset minimum start time and maximum end time. Specifically, any data point whose start time is less than or equal to the dataset end time and whose end time is greater than or equal to the dataset start time.
  ## 
  let valid = call_578994.validator(path, query, header, formData, body)
  let scheme = call_578994.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578994.url(scheme.get, call_578994.host, call_578994.base,
                         call_578994.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578994, url, valid)

proc call*(call_578995: Call_FitnessUsersDataSourcesDatasetsGet_578979;
          dataSourceId: string; userId: string; datasetId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; limit: int = 0;
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          pageToken: string = ""; fields: string = ""): Recallable =
  ## fitnessUsersDataSourcesDatasetsGet
  ## Returns a dataset containing all data points whose start and end times overlap with the specified range of the dataset minimum start time and maximum end time. Specifically, any data point whose start time is less than or equal to the dataset end time and whose end time is greater than or equal to the dataset start time.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   dataSourceId: string (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   limit: int
  ##        : If specified, no more than this many data points will be included in the dataset. If there are more data points in the dataset, nextPageToken will be set in the dataset response.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   pageToken: string
  ##            : The continuation token, which is used to page through large datasets. To get the next page of a dataset, set this parameter to the value of nextPageToken from the previous response. Each subsequent call will yield a partial dataset with data point end timestamps that are strictly smaller than those in the previous partial response.
  ##   userId: string (required)
  ##         : Retrieve a dataset for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   datasetId: string (required)
  ##            : Dataset identifier that is a composite of the minimum data point start time and maximum data point end time represented as nanoseconds from the epoch. The ID is formatted like: "startTime-endTime" where startTime and endTime are 64 bit integers.
  var path_578996 = newJObject()
  var query_578997 = newJObject()
  add(query_578997, "key", newJString(key))
  add(query_578997, "prettyPrint", newJBool(prettyPrint))
  add(query_578997, "oauth_token", newJString(oauthToken))
  add(path_578996, "dataSourceId", newJString(dataSourceId))
  add(query_578997, "limit", newJInt(limit))
  add(query_578997, "alt", newJString(alt))
  add(query_578997, "userIp", newJString(userIp))
  add(query_578997, "quotaUser", newJString(quotaUser))
  add(query_578997, "pageToken", newJString(pageToken))
  add(path_578996, "userId", newJString(userId))
  add(query_578997, "fields", newJString(fields))
  add(path_578996, "datasetId", newJString(datasetId))
  result = call_578995.call(path_578996, query_578997, nil, nil, nil)

var fitnessUsersDataSourcesDatasetsGet* = Call_FitnessUsersDataSourcesDatasetsGet_578979(
    name: "fitnessUsersDataSourcesDatasetsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/{userId}/dataSources/{dataSourceId}/datasets/{datasetId}",
    validator: validate_FitnessUsersDataSourcesDatasetsGet_578980,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesDatasetsGet_578981,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesDatasetsPatch_579017 = ref object of OpenApiRestCall_578339
proc url_FitnessUsersDataSourcesDatasetsPatch_579019(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "dataSourceId" in path, "`dataSourceId` is a required path parameter"
  assert "datasetId" in path, "`datasetId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources/"),
               (kind: VariableSegment, value: "dataSourceId"),
               (kind: ConstantSegment, value: "/datasets/"),
               (kind: VariableSegment, value: "datasetId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesDatasetsPatch_579018(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds data points to a dataset. The dataset need not be previously created. All points within the given dataset will be returned with subsquent calls to retrieve this dataset. Data points can belong to more than one dataset. This method does not use patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   dataSourceId: JString (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   userId: JString (required)
  ##         : Patch a dataset for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   datasetId: JString (required)
  ##            : Dataset identifier that is a composite of the minimum data point start time and maximum data point end time represented as nanoseconds from the epoch. The ID is formatted like: "startTime-endTime" where startTime and endTime are 64 bit integers.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `dataSourceId` field"
  var valid_579020 = path.getOrDefault("dataSourceId")
  valid_579020 = validateParameter(valid_579020, JString, required = true,
                                 default = nil)
  if valid_579020 != nil:
    section.add "dataSourceId", valid_579020
  var valid_579021 = path.getOrDefault("userId")
  valid_579021 = validateParameter(valid_579021, JString, required = true,
                                 default = nil)
  if valid_579021 != nil:
    section.add "userId", valid_579021
  var valid_579022 = path.getOrDefault("datasetId")
  valid_579022 = validateParameter(valid_579022, JString, required = true,
                                 default = nil)
  if valid_579022 != nil:
    section.add "datasetId", valid_579022
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   currentTimeMillis: JString
  ##                    : The client's current time in milliseconds since epoch. Note that the minStartTimeNs and maxEndTimeNs properties in the request body are in nanoseconds instead of milliseconds.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579023 = query.getOrDefault("key")
  valid_579023 = validateParameter(valid_579023, JString, required = false,
                                 default = nil)
  if valid_579023 != nil:
    section.add "key", valid_579023
  var valid_579024 = query.getOrDefault("prettyPrint")
  valid_579024 = validateParameter(valid_579024, JBool, required = false,
                                 default = newJBool(true))
  if valid_579024 != nil:
    section.add "prettyPrint", valid_579024
  var valid_579025 = query.getOrDefault("oauth_token")
  valid_579025 = validateParameter(valid_579025, JString, required = false,
                                 default = nil)
  if valid_579025 != nil:
    section.add "oauth_token", valid_579025
  var valid_579026 = query.getOrDefault("currentTimeMillis")
  valid_579026 = validateParameter(valid_579026, JString, required = false,
                                 default = nil)
  if valid_579026 != nil:
    section.add "currentTimeMillis", valid_579026
  var valid_579027 = query.getOrDefault("alt")
  valid_579027 = validateParameter(valid_579027, JString, required = false,
                                 default = newJString("json"))
  if valid_579027 != nil:
    section.add "alt", valid_579027
  var valid_579028 = query.getOrDefault("userIp")
  valid_579028 = validateParameter(valid_579028, JString, required = false,
                                 default = nil)
  if valid_579028 != nil:
    section.add "userIp", valid_579028
  var valid_579029 = query.getOrDefault("quotaUser")
  valid_579029 = validateParameter(valid_579029, JString, required = false,
                                 default = nil)
  if valid_579029 != nil:
    section.add "quotaUser", valid_579029
  var valid_579030 = query.getOrDefault("fields")
  valid_579030 = validateParameter(valid_579030, JString, required = false,
                                 default = nil)
  if valid_579030 != nil:
    section.add "fields", valid_579030
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579032: Call_FitnessUsersDataSourcesDatasetsPatch_579017;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Adds data points to a dataset. The dataset need not be previously created. All points within the given dataset will be returned with subsquent calls to retrieve this dataset. Data points can belong to more than one dataset. This method does not use patch semantics.
  ## 
  let valid = call_579032.validator(path, query, header, formData, body)
  let scheme = call_579032.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579032.url(scheme.get, call_579032.host, call_579032.base,
                         call_579032.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579032, url, valid)

proc call*(call_579033: Call_FitnessUsersDataSourcesDatasetsPatch_579017;
          dataSourceId: string; userId: string; datasetId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = "";
          currentTimeMillis: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## fitnessUsersDataSourcesDatasetsPatch
  ## Adds data points to a dataset. The dataset need not be previously created. All points within the given dataset will be returned with subsquent calls to retrieve this dataset. Data points can belong to more than one dataset. This method does not use patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   dataSourceId: string (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   currentTimeMillis: string
  ##                    : The client's current time in milliseconds since epoch. Note that the minStartTimeNs and maxEndTimeNs properties in the request body are in nanoseconds instead of milliseconds.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   userId: string (required)
  ##         : Patch a dataset for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   datasetId: string (required)
  ##            : Dataset identifier that is a composite of the minimum data point start time and maximum data point end time represented as nanoseconds from the epoch. The ID is formatted like: "startTime-endTime" where startTime and endTime are 64 bit integers.
  var path_579034 = newJObject()
  var query_579035 = newJObject()
  var body_579036 = newJObject()
  add(query_579035, "key", newJString(key))
  add(query_579035, "prettyPrint", newJBool(prettyPrint))
  add(query_579035, "oauth_token", newJString(oauthToken))
  add(path_579034, "dataSourceId", newJString(dataSourceId))
  add(query_579035, "currentTimeMillis", newJString(currentTimeMillis))
  add(query_579035, "alt", newJString(alt))
  add(query_579035, "userIp", newJString(userIp))
  add(query_579035, "quotaUser", newJString(quotaUser))
  add(path_579034, "userId", newJString(userId))
  if body != nil:
    body_579036 = body
  add(query_579035, "fields", newJString(fields))
  add(path_579034, "datasetId", newJString(datasetId))
  result = call_579033.call(path_579034, query_579035, nil, nil, body_579036)

var fitnessUsersDataSourcesDatasetsPatch* = Call_FitnessUsersDataSourcesDatasetsPatch_579017(
    name: "fitnessUsersDataSourcesDatasetsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/{userId}/dataSources/{dataSourceId}/datasets/{datasetId}",
    validator: validate_FitnessUsersDataSourcesDatasetsPatch_579018,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesDatasetsPatch_579019,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDataSourcesDatasetsDelete_578998 = ref object of OpenApiRestCall_578339
proc url_FitnessUsersDataSourcesDatasetsDelete_579000(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "dataSourceId" in path, "`dataSourceId` is a required path parameter"
  assert "datasetId" in path, "`datasetId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataSources/"),
               (kind: VariableSegment, value: "dataSourceId"),
               (kind: ConstantSegment, value: "/datasets/"),
               (kind: VariableSegment, value: "datasetId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDataSourcesDatasetsDelete_578999(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Performs an inclusive delete of all data points whose start and end times have any overlap with the time range specified by the dataset ID. For most data types, the entire data point will be deleted. For data types where the time span represents a consistent value (such as com.google.activity.segment), and a data point straddles either end point of the dataset, only the overlapping portion of the data point will be deleted.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   datasetId: JString (required)
  ##            : Dataset identifier that is a composite of the minimum data point start time and maximum data point end time represented as nanoseconds from the epoch. The ID is formatted like: "startTime-endTime" where startTime and endTime are 64 bit integers.
  ##   dataSourceId: JString (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   userId: JString (required)
  ##         : Delete a dataset for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `datasetId` field"
  var valid_579001 = path.getOrDefault("datasetId")
  valid_579001 = validateParameter(valid_579001, JString, required = true,
                                 default = nil)
  if valid_579001 != nil:
    section.add "datasetId", valid_579001
  var valid_579002 = path.getOrDefault("dataSourceId")
  valid_579002 = validateParameter(valid_579002, JString, required = true,
                                 default = nil)
  if valid_579002 != nil:
    section.add "dataSourceId", valid_579002
  var valid_579003 = path.getOrDefault("userId")
  valid_579003 = validateParameter(valid_579003, JString, required = true,
                                 default = nil)
  if valid_579003 != nil:
    section.add "userId", valid_579003
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   currentTimeMillis: JString
  ##                    : The client's current time in milliseconds since epoch.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   modifiedTimeMillis: JString
  ##                     : When the operation was performed on the client.
  section = newJObject()
  var valid_579004 = query.getOrDefault("key")
  valid_579004 = validateParameter(valid_579004, JString, required = false,
                                 default = nil)
  if valid_579004 != nil:
    section.add "key", valid_579004
  var valid_579005 = query.getOrDefault("prettyPrint")
  valid_579005 = validateParameter(valid_579005, JBool, required = false,
                                 default = newJBool(true))
  if valid_579005 != nil:
    section.add "prettyPrint", valid_579005
  var valid_579006 = query.getOrDefault("oauth_token")
  valid_579006 = validateParameter(valid_579006, JString, required = false,
                                 default = nil)
  if valid_579006 != nil:
    section.add "oauth_token", valid_579006
  var valid_579007 = query.getOrDefault("currentTimeMillis")
  valid_579007 = validateParameter(valid_579007, JString, required = false,
                                 default = nil)
  if valid_579007 != nil:
    section.add "currentTimeMillis", valid_579007
  var valid_579008 = query.getOrDefault("alt")
  valid_579008 = validateParameter(valid_579008, JString, required = false,
                                 default = newJString("json"))
  if valid_579008 != nil:
    section.add "alt", valid_579008
  var valid_579009 = query.getOrDefault("userIp")
  valid_579009 = validateParameter(valid_579009, JString, required = false,
                                 default = nil)
  if valid_579009 != nil:
    section.add "userIp", valid_579009
  var valid_579010 = query.getOrDefault("quotaUser")
  valid_579010 = validateParameter(valid_579010, JString, required = false,
                                 default = nil)
  if valid_579010 != nil:
    section.add "quotaUser", valid_579010
  var valid_579011 = query.getOrDefault("fields")
  valid_579011 = validateParameter(valid_579011, JString, required = false,
                                 default = nil)
  if valid_579011 != nil:
    section.add "fields", valid_579011
  var valid_579012 = query.getOrDefault("modifiedTimeMillis")
  valid_579012 = validateParameter(valid_579012, JString, required = false,
                                 default = nil)
  if valid_579012 != nil:
    section.add "modifiedTimeMillis", valid_579012
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579013: Call_FitnessUsersDataSourcesDatasetsDelete_578998;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Performs an inclusive delete of all data points whose start and end times have any overlap with the time range specified by the dataset ID. For most data types, the entire data point will be deleted. For data types where the time span represents a consistent value (such as com.google.activity.segment), and a data point straddles either end point of the dataset, only the overlapping portion of the data point will be deleted.
  ## 
  let valid = call_579013.validator(path, query, header, formData, body)
  let scheme = call_579013.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579013.url(scheme.get, call_579013.host, call_579013.base,
                         call_579013.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579013, url, valid)

proc call*(call_579014: Call_FitnessUsersDataSourcesDatasetsDelete_578998;
          datasetId: string; dataSourceId: string; userId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = "";
          currentTimeMillis: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""; modifiedTimeMillis: string = ""): Recallable =
  ## fitnessUsersDataSourcesDatasetsDelete
  ## Performs an inclusive delete of all data points whose start and end times have any overlap with the time range specified by the dataset ID. For most data types, the entire data point will be deleted. For data types where the time span represents a consistent value (such as com.google.activity.segment), and a data point straddles either end point of the dataset, only the overlapping portion of the data point will be deleted.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   datasetId: string (required)
  ##            : Dataset identifier that is a composite of the minimum data point start time and maximum data point end time represented as nanoseconds from the epoch. The ID is formatted like: "startTime-endTime" where startTime and endTime are 64 bit integers.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   dataSourceId: string (required)
  ##               : The data stream ID of the data source that created the dataset.
  ##   currentTimeMillis: string
  ##                    : The client's current time in milliseconds since epoch.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   userId: string (required)
  ##         : Delete a dataset for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   modifiedTimeMillis: string
  ##                     : When the operation was performed on the client.
  var path_579015 = newJObject()
  var query_579016 = newJObject()
  add(query_579016, "key", newJString(key))
  add(path_579015, "datasetId", newJString(datasetId))
  add(query_579016, "prettyPrint", newJBool(prettyPrint))
  add(query_579016, "oauth_token", newJString(oauthToken))
  add(path_579015, "dataSourceId", newJString(dataSourceId))
  add(query_579016, "currentTimeMillis", newJString(currentTimeMillis))
  add(query_579016, "alt", newJString(alt))
  add(query_579016, "userIp", newJString(userIp))
  add(query_579016, "quotaUser", newJString(quotaUser))
  add(path_579015, "userId", newJString(userId))
  add(query_579016, "fields", newJString(fields))
  add(query_579016, "modifiedTimeMillis", newJString(modifiedTimeMillis))
  result = call_579014.call(path_579015, query_579016, nil, nil, nil)

var fitnessUsersDataSourcesDatasetsDelete* = Call_FitnessUsersDataSourcesDatasetsDelete_578998(
    name: "fitnessUsersDataSourcesDatasetsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/{userId}/dataSources/{dataSourceId}/datasets/{datasetId}",
    validator: validate_FitnessUsersDataSourcesDatasetsDelete_578999,
    base: "/fitness/v1/users", url: url_FitnessUsersDataSourcesDatasetsDelete_579000,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersDatasetAggregate_579037 = ref object of OpenApiRestCall_578339
proc url_FitnessUsersDatasetAggregate_579039(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/dataset:aggregate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersDatasetAggregate_579038(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Aggregates data of a certain type or stream into buckets divided by a given type of boundary. Multiple data sets of multiple types and from multiple sources can be aggreated into exactly one bucket type per request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   userId: JString (required)
  ##         : Aggregate data for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `userId` field"
  var valid_579040 = path.getOrDefault("userId")
  valid_579040 = validateParameter(valid_579040, JString, required = true,
                                 default = nil)
  if valid_579040 != nil:
    section.add "userId", valid_579040
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579041 = query.getOrDefault("key")
  valid_579041 = validateParameter(valid_579041, JString, required = false,
                                 default = nil)
  if valid_579041 != nil:
    section.add "key", valid_579041
  var valid_579042 = query.getOrDefault("prettyPrint")
  valid_579042 = validateParameter(valid_579042, JBool, required = false,
                                 default = newJBool(true))
  if valid_579042 != nil:
    section.add "prettyPrint", valid_579042
  var valid_579043 = query.getOrDefault("oauth_token")
  valid_579043 = validateParameter(valid_579043, JString, required = false,
                                 default = nil)
  if valid_579043 != nil:
    section.add "oauth_token", valid_579043
  var valid_579044 = query.getOrDefault("alt")
  valid_579044 = validateParameter(valid_579044, JString, required = false,
                                 default = newJString("json"))
  if valid_579044 != nil:
    section.add "alt", valid_579044
  var valid_579045 = query.getOrDefault("userIp")
  valid_579045 = validateParameter(valid_579045, JString, required = false,
                                 default = nil)
  if valid_579045 != nil:
    section.add "userIp", valid_579045
  var valid_579046 = query.getOrDefault("quotaUser")
  valid_579046 = validateParameter(valid_579046, JString, required = false,
                                 default = nil)
  if valid_579046 != nil:
    section.add "quotaUser", valid_579046
  var valid_579047 = query.getOrDefault("fields")
  valid_579047 = validateParameter(valid_579047, JString, required = false,
                                 default = nil)
  if valid_579047 != nil:
    section.add "fields", valid_579047
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579049: Call_FitnessUsersDatasetAggregate_579037; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Aggregates data of a certain type or stream into buckets divided by a given type of boundary. Multiple data sets of multiple types and from multiple sources can be aggreated into exactly one bucket type per request.
  ## 
  let valid = call_579049.validator(path, query, header, formData, body)
  let scheme = call_579049.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579049.url(scheme.get, call_579049.host, call_579049.base,
                         call_579049.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579049, url, valid)

proc call*(call_579050: Call_FitnessUsersDatasetAggregate_579037; userId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## fitnessUsersDatasetAggregate
  ## Aggregates data of a certain type or stream into buckets divided by a given type of boundary. Multiple data sets of multiple types and from multiple sources can be aggreated into exactly one bucket type per request.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   userId: string (required)
  ##         : Aggregate data for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579051 = newJObject()
  var query_579052 = newJObject()
  var body_579053 = newJObject()
  add(query_579052, "key", newJString(key))
  add(query_579052, "prettyPrint", newJBool(prettyPrint))
  add(query_579052, "oauth_token", newJString(oauthToken))
  add(query_579052, "alt", newJString(alt))
  add(query_579052, "userIp", newJString(userIp))
  add(query_579052, "quotaUser", newJString(quotaUser))
  add(path_579051, "userId", newJString(userId))
  if body != nil:
    body_579053 = body
  add(query_579052, "fields", newJString(fields))
  result = call_579050.call(path_579051, query_579052, nil, nil, body_579053)

var fitnessUsersDatasetAggregate* = Call_FitnessUsersDatasetAggregate_579037(
    name: "fitnessUsersDatasetAggregate", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/{userId}/dataset:aggregate",
    validator: validate_FitnessUsersDatasetAggregate_579038,
    base: "/fitness/v1/users", url: url_FitnessUsersDatasetAggregate_579039,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersSessionsList_579054 = ref object of OpenApiRestCall_578339
proc url_FitnessUsersSessionsList_579056(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/sessions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersSessionsList_579055(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists sessions previously created.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   userId: JString (required)
  ##         : List sessions for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `userId` field"
  var valid_579057 = path.getOrDefault("userId")
  valid_579057 = validateParameter(valid_579057, JString, required = true,
                                 default = nil)
  if valid_579057 != nil:
    section.add "userId", valid_579057
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   startTime: JString
  ##            : An RFC3339 timestamp. Only sessions ending between the start and end times will be included in the response.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   pageToken: JString
  ##            : The continuation token, which is used for incremental syncing. To get the next batch of changes, set this parameter to the value of nextPageToken from the previous response. This token is treated as a timestamp (in millis since epoch). If specified, the API returns sessions modified since this time. The page token is ignored if either start or end time is specified. If none of start time, end time, and the page token is specified, sessions modified in the last 30 days are returned.
  ##   includeDeleted: JBool
  ##                 : If true, deleted sessions will be returned. When set to true, sessions returned in this response will only have an ID and will not have any other fields.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   endTime: JString
  ##          : An RFC3339 timestamp. Only sessions ending between the start and end times will be included in the response.
  section = newJObject()
  var valid_579058 = query.getOrDefault("key")
  valid_579058 = validateParameter(valid_579058, JString, required = false,
                                 default = nil)
  if valid_579058 != nil:
    section.add "key", valid_579058
  var valid_579059 = query.getOrDefault("prettyPrint")
  valid_579059 = validateParameter(valid_579059, JBool, required = false,
                                 default = newJBool(true))
  if valid_579059 != nil:
    section.add "prettyPrint", valid_579059
  var valid_579060 = query.getOrDefault("oauth_token")
  valid_579060 = validateParameter(valid_579060, JString, required = false,
                                 default = nil)
  if valid_579060 != nil:
    section.add "oauth_token", valid_579060
  var valid_579061 = query.getOrDefault("startTime")
  valid_579061 = validateParameter(valid_579061, JString, required = false,
                                 default = nil)
  if valid_579061 != nil:
    section.add "startTime", valid_579061
  var valid_579062 = query.getOrDefault("alt")
  valid_579062 = validateParameter(valid_579062, JString, required = false,
                                 default = newJString("json"))
  if valid_579062 != nil:
    section.add "alt", valid_579062
  var valid_579063 = query.getOrDefault("userIp")
  valid_579063 = validateParameter(valid_579063, JString, required = false,
                                 default = nil)
  if valid_579063 != nil:
    section.add "userIp", valid_579063
  var valid_579064 = query.getOrDefault("quotaUser")
  valid_579064 = validateParameter(valid_579064, JString, required = false,
                                 default = nil)
  if valid_579064 != nil:
    section.add "quotaUser", valid_579064
  var valid_579065 = query.getOrDefault("pageToken")
  valid_579065 = validateParameter(valid_579065, JString, required = false,
                                 default = nil)
  if valid_579065 != nil:
    section.add "pageToken", valid_579065
  var valid_579066 = query.getOrDefault("includeDeleted")
  valid_579066 = validateParameter(valid_579066, JBool, required = false, default = nil)
  if valid_579066 != nil:
    section.add "includeDeleted", valid_579066
  var valid_579067 = query.getOrDefault("fields")
  valid_579067 = validateParameter(valid_579067, JString, required = false,
                                 default = nil)
  if valid_579067 != nil:
    section.add "fields", valid_579067
  var valid_579068 = query.getOrDefault("endTime")
  valid_579068 = validateParameter(valid_579068, JString, required = false,
                                 default = nil)
  if valid_579068 != nil:
    section.add "endTime", valid_579068
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579069: Call_FitnessUsersSessionsList_579054; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists sessions previously created.
  ## 
  let valid = call_579069.validator(path, query, header, formData, body)
  let scheme = call_579069.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579069.url(scheme.get, call_579069.host, call_579069.base,
                         call_579069.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579069, url, valid)

proc call*(call_579070: Call_FitnessUsersSessionsList_579054; userId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          startTime: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; pageToken: string = ""; includeDeleted: bool = false;
          fields: string = ""; endTime: string = ""): Recallable =
  ## fitnessUsersSessionsList
  ## Lists sessions previously created.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   startTime: string
  ##            : An RFC3339 timestamp. Only sessions ending between the start and end times will be included in the response.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   pageToken: string
  ##            : The continuation token, which is used for incremental syncing. To get the next batch of changes, set this parameter to the value of nextPageToken from the previous response. This token is treated as a timestamp (in millis since epoch). If specified, the API returns sessions modified since this time. The page token is ignored if either start or end time is specified. If none of start time, end time, and the page token is specified, sessions modified in the last 30 days are returned.
  ##   userId: string (required)
  ##         : List sessions for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   includeDeleted: bool
  ##                 : If true, deleted sessions will be returned. When set to true, sessions returned in this response will only have an ID and will not have any other fields.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   endTime: string
  ##          : An RFC3339 timestamp. Only sessions ending between the start and end times will be included in the response.
  var path_579071 = newJObject()
  var query_579072 = newJObject()
  add(query_579072, "key", newJString(key))
  add(query_579072, "prettyPrint", newJBool(prettyPrint))
  add(query_579072, "oauth_token", newJString(oauthToken))
  add(query_579072, "startTime", newJString(startTime))
  add(query_579072, "alt", newJString(alt))
  add(query_579072, "userIp", newJString(userIp))
  add(query_579072, "quotaUser", newJString(quotaUser))
  add(query_579072, "pageToken", newJString(pageToken))
  add(path_579071, "userId", newJString(userId))
  add(query_579072, "includeDeleted", newJBool(includeDeleted))
  add(query_579072, "fields", newJString(fields))
  add(query_579072, "endTime", newJString(endTime))
  result = call_579070.call(path_579071, query_579072, nil, nil, nil)

var fitnessUsersSessionsList* = Call_FitnessUsersSessionsList_579054(
    name: "fitnessUsersSessionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/{userId}/sessions",
    validator: validate_FitnessUsersSessionsList_579055,
    base: "/fitness/v1/users", url: url_FitnessUsersSessionsList_579056,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersSessionsUpdate_579073 = ref object of OpenApiRestCall_578339
proc url_FitnessUsersSessionsUpdate_579075(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "sessionId" in path, "`sessionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/sessions/"),
               (kind: VariableSegment, value: "sessionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersSessionsUpdate_579074(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates or insert a given session.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   sessionId: JString (required)
  ##            : The ID of the session to be created.
  ##   userId: JString (required)
  ##         : Create sessions for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `sessionId` field"
  var valid_579076 = path.getOrDefault("sessionId")
  valid_579076 = validateParameter(valid_579076, JString, required = true,
                                 default = nil)
  if valid_579076 != nil:
    section.add "sessionId", valid_579076
  var valid_579077 = path.getOrDefault("userId")
  valid_579077 = validateParameter(valid_579077, JString, required = true,
                                 default = nil)
  if valid_579077 != nil:
    section.add "userId", valid_579077
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   currentTimeMillis: JString
  ##                    : The client's current time in milliseconds since epoch.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579078 = query.getOrDefault("key")
  valid_579078 = validateParameter(valid_579078, JString, required = false,
                                 default = nil)
  if valid_579078 != nil:
    section.add "key", valid_579078
  var valid_579079 = query.getOrDefault("prettyPrint")
  valid_579079 = validateParameter(valid_579079, JBool, required = false,
                                 default = newJBool(true))
  if valid_579079 != nil:
    section.add "prettyPrint", valid_579079
  var valid_579080 = query.getOrDefault("oauth_token")
  valid_579080 = validateParameter(valid_579080, JString, required = false,
                                 default = nil)
  if valid_579080 != nil:
    section.add "oauth_token", valid_579080
  var valid_579081 = query.getOrDefault("currentTimeMillis")
  valid_579081 = validateParameter(valid_579081, JString, required = false,
                                 default = nil)
  if valid_579081 != nil:
    section.add "currentTimeMillis", valid_579081
  var valid_579082 = query.getOrDefault("alt")
  valid_579082 = validateParameter(valid_579082, JString, required = false,
                                 default = newJString("json"))
  if valid_579082 != nil:
    section.add "alt", valid_579082
  var valid_579083 = query.getOrDefault("userIp")
  valid_579083 = validateParameter(valid_579083, JString, required = false,
                                 default = nil)
  if valid_579083 != nil:
    section.add "userIp", valid_579083
  var valid_579084 = query.getOrDefault("quotaUser")
  valid_579084 = validateParameter(valid_579084, JString, required = false,
                                 default = nil)
  if valid_579084 != nil:
    section.add "quotaUser", valid_579084
  var valid_579085 = query.getOrDefault("fields")
  valid_579085 = validateParameter(valid_579085, JString, required = false,
                                 default = nil)
  if valid_579085 != nil:
    section.add "fields", valid_579085
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579087: Call_FitnessUsersSessionsUpdate_579073; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates or insert a given session.
  ## 
  let valid = call_579087.validator(path, query, header, formData, body)
  let scheme = call_579087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579087.url(scheme.get, call_579087.host, call_579087.base,
                         call_579087.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579087, url, valid)

proc call*(call_579088: Call_FitnessUsersSessionsUpdate_579073; sessionId: string;
          userId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; currentTimeMillis: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; body: JsonNode = nil;
          fields: string = ""): Recallable =
  ## fitnessUsersSessionsUpdate
  ## Updates or insert a given session.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   sessionId: string (required)
  ##            : The ID of the session to be created.
  ##   currentTimeMillis: string
  ##                    : The client's current time in milliseconds since epoch.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   userId: string (required)
  ##         : Create sessions for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579089 = newJObject()
  var query_579090 = newJObject()
  var body_579091 = newJObject()
  add(query_579090, "key", newJString(key))
  add(query_579090, "prettyPrint", newJBool(prettyPrint))
  add(query_579090, "oauth_token", newJString(oauthToken))
  add(path_579089, "sessionId", newJString(sessionId))
  add(query_579090, "currentTimeMillis", newJString(currentTimeMillis))
  add(query_579090, "alt", newJString(alt))
  add(query_579090, "userIp", newJString(userIp))
  add(query_579090, "quotaUser", newJString(quotaUser))
  add(path_579089, "userId", newJString(userId))
  if body != nil:
    body_579091 = body
  add(query_579090, "fields", newJString(fields))
  result = call_579088.call(path_579089, query_579090, nil, nil, body_579091)

var fitnessUsersSessionsUpdate* = Call_FitnessUsersSessionsUpdate_579073(
    name: "fitnessUsersSessionsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/{userId}/sessions/{sessionId}",
    validator: validate_FitnessUsersSessionsUpdate_579074,
    base: "/fitness/v1/users", url: url_FitnessUsersSessionsUpdate_579075,
    schemes: {Scheme.Https})
type
  Call_FitnessUsersSessionsDelete_579092 = ref object of OpenApiRestCall_578339
proc url_FitnessUsersSessionsDelete_579094(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "userId" in path, "`userId` is a required path parameter"
  assert "sessionId" in path, "`sessionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "userId"),
               (kind: ConstantSegment, value: "/sessions/"),
               (kind: VariableSegment, value: "sessionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_FitnessUsersSessionsDelete_579093(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a session specified by the given session ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   sessionId: JString (required)
  ##            : The ID of the session to be deleted.
  ##   userId: JString (required)
  ##         : Delete a session for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `sessionId` field"
  var valid_579095 = path.getOrDefault("sessionId")
  valid_579095 = validateParameter(valid_579095, JString, required = true,
                                 default = nil)
  if valid_579095 != nil:
    section.add "sessionId", valid_579095
  var valid_579096 = path.getOrDefault("userId")
  valid_579096 = validateParameter(valid_579096, JString, required = true,
                                 default = nil)
  if valid_579096 != nil:
    section.add "userId", valid_579096
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   currentTimeMillis: JString
  ##                    : The client's current time in milliseconds since epoch.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: JString
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579097 = query.getOrDefault("key")
  valid_579097 = validateParameter(valid_579097, JString, required = false,
                                 default = nil)
  if valid_579097 != nil:
    section.add "key", valid_579097
  var valid_579098 = query.getOrDefault("prettyPrint")
  valid_579098 = validateParameter(valid_579098, JBool, required = false,
                                 default = newJBool(true))
  if valid_579098 != nil:
    section.add "prettyPrint", valid_579098
  var valid_579099 = query.getOrDefault("oauth_token")
  valid_579099 = validateParameter(valid_579099, JString, required = false,
                                 default = nil)
  if valid_579099 != nil:
    section.add "oauth_token", valid_579099
  var valid_579100 = query.getOrDefault("currentTimeMillis")
  valid_579100 = validateParameter(valid_579100, JString, required = false,
                                 default = nil)
  if valid_579100 != nil:
    section.add "currentTimeMillis", valid_579100
  var valid_579101 = query.getOrDefault("alt")
  valid_579101 = validateParameter(valid_579101, JString, required = false,
                                 default = newJString("json"))
  if valid_579101 != nil:
    section.add "alt", valid_579101
  var valid_579102 = query.getOrDefault("userIp")
  valid_579102 = validateParameter(valid_579102, JString, required = false,
                                 default = nil)
  if valid_579102 != nil:
    section.add "userIp", valid_579102
  var valid_579103 = query.getOrDefault("quotaUser")
  valid_579103 = validateParameter(valid_579103, JString, required = false,
                                 default = nil)
  if valid_579103 != nil:
    section.add "quotaUser", valid_579103
  var valid_579104 = query.getOrDefault("fields")
  valid_579104 = validateParameter(valid_579104, JString, required = false,
                                 default = nil)
  if valid_579104 != nil:
    section.add "fields", valid_579104
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579105: Call_FitnessUsersSessionsDelete_579092; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a session specified by the given session ID.
  ## 
  let valid = call_579105.validator(path, query, header, formData, body)
  let scheme = call_579105.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579105.url(scheme.get, call_579105.host, call_579105.base,
                         call_579105.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579105, url, valid)

proc call*(call_579106: Call_FitnessUsersSessionsDelete_579092; sessionId: string;
          userId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; currentTimeMillis: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; fields: string = ""): Recallable =
  ## fitnessUsersSessionsDelete
  ## Deletes a session specified by the given session ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   sessionId: string (required)
  ##            : The ID of the session to be deleted.
  ##   currentTimeMillis: string
  ##                    : The client's current time in milliseconds since epoch.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : Deprecated. Please use quotaUser instead.
  ##   quotaUser: string
  ##            : An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
  ##   userId: string (required)
  ##         : Delete a session for the person identified. Use me to indicate the authenticated user. Only me is supported at this time.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579107 = newJObject()
  var query_579108 = newJObject()
  add(query_579108, "key", newJString(key))
  add(query_579108, "prettyPrint", newJBool(prettyPrint))
  add(query_579108, "oauth_token", newJString(oauthToken))
  add(path_579107, "sessionId", newJString(sessionId))
  add(query_579108, "currentTimeMillis", newJString(currentTimeMillis))
  add(query_579108, "alt", newJString(alt))
  add(query_579108, "userIp", newJString(userIp))
  add(query_579108, "quotaUser", newJString(quotaUser))
  add(path_579107, "userId", newJString(userId))
  add(query_579108, "fields", newJString(fields))
  result = call_579106.call(path_579107, query_579108, nil, nil, nil)

var fitnessUsersSessionsDelete* = Call_FitnessUsersSessionsDelete_579092(
    name: "fitnessUsersSessionsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/{userId}/sessions/{sessionId}",
    validator: validate_FitnessUsersSessionsDelete_579093,
    base: "/fitness/v1/users", url: url_FitnessUsersSessionsDelete_579094,
    schemes: {Scheme.Https})
export
  rest

type
  GoogleAuth = ref object
    endpoint*: Uri
    token: string
    expiry*: float64
    issued*: float64
    email: string
    key: string
    scope*: seq[string]
    form: string
    digest: Hash

const
  endpoint = "https://www.googleapis.com/oauth2/v4/token".parseUri
var auth = GoogleAuth(endpoint: endpoint)
proc hash(auth: GoogleAuth): Hash =
  ## yield differing values for effectively different auth payloads
  result = hash($auth.endpoint)
  result = result !& hash(auth.email)
  result = result !& hash(auth.key)
  result = result !& hash(auth.scope.join(" "))
  result = !$result

proc newAuthenticator*(path: string): GoogleAuth =
  let
    input = readFile(path)
    js = parseJson(input)
  auth.email = js["client_email"].getStr
  auth.key = js["private_key"].getStr
  result = auth

proc store(auth: var GoogleAuth; token: string; expiry: int; form: string) =
  auth.token = token
  auth.issued = epochTime()
  auth.expiry = auth.issued + expiry.float64
  auth.form = form
  auth.digest = auth.hash

proc authenticate*(fresh: float64 = 3600.0; lifetime: int = 3600): Future[bool] {.async.} =
  ## get or refresh an authentication token; provide `fresh`
  ## to ensure that the token won't expire in the next N seconds.
  ## provide `lifetime` to indicate how long the token should last.
  let clock = epochTime()
  if auth.expiry > clock + fresh:
    if auth.hash == auth.digest:
      return true
  let
    expiry = clock.int + lifetime
    header = JOSEHeader(alg: RS256, typ: "JWT")
    claims = %*{"iss": auth.email, "scope": auth.scope.join(" "),
              "aud": "https://www.googleapis.com/oauth2/v4/token", "exp": expiry,
              "iat": clock.int}
  var tok = JWT(header: header, claims: toClaims(claims))
  tok.sign(auth.key)
  let post = encodeQuery({"grant_type": "urn:ietf:params:oauth:grant-type:jwt-bearer",
                       "assertion": $tok}, usePlus = false, omitEq = false)
  var client = newAsyncHttpClient()
  client.headers = newHttpHeaders({"Content-Type": "application/x-www-form-urlencoded",
                                 "Content-Length": $post.len})
  let response = await client.request($auth.endpoint, HttpPost, body = post)
  if not response.code.is2xx:
    return false
  let body = await response.body
  client.close
  try:
    let js = parseJson(body)
    auth.store(js["access_token"].getStr, js["expires_in"].getInt,
               js["token_type"].getStr)
  except KeyError:
    return false
  except JsonParsingError:
    return false
  return true

proc composeQueryString(query: JsonNode): string =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs, usePlus = false, omitEq = false)

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  var headers = massageHeaders(input.getOrDefault("header"))
  let body = input.getOrDefault("body").getStr
  if auth.scope.len == 0:
    raise newException(ValueError, "specify authentication scopes")
  if not waitfor authenticate(fresh = 10.0):
    raise newException(IOError, "unable to refresh authentication token")
  headers.add ("Authorization", auth.form & " " & auth.token)
  headers.add ("Content-Type", "application/json")
  headers.add ("Content-Length", $body.len)
  result = newRecallable(call, url, headers, body = body)
