
import
  json, options, hashes, uri, rest, os, uri, strutils, times, httpcore, httpclient,
  asyncdispatch, jwt

## auto-generated via openapi macro
## title: DCM/DFA Reporting And Trafficking
## version: v2.7
## termsOfService: (not provided)
## license: (not provided)
## 
## Manages your DoubleClick Campaign Manager ad campaigns and reports.
## 
## https://developers.google.com/doubleclick-advertisers/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_578364 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_578364](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_578364): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  gcpServiceName = "dfareporting"
proc composeQueryString(query: JsonNode): string
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_DfareportingFilesGet_578635 = ref object of OpenApiRestCall_578364
proc url_DfareportingFilesGet_578637(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "reportId" in path, "`reportId` is a required path parameter"
  assert "fileId" in path, "`fileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/files/"),
               (kind: VariableSegment, value: "fileId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFilesGet_578636(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a report file by its report ID and file ID. This method supports media download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   fileId: JString (required)
  ##         : The ID of the report file.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `fileId` field"
  var valid_578763 = path.getOrDefault("fileId")
  valid_578763 = validateParameter(valid_578763, JString, required = true,
                                 default = nil)
  if valid_578763 != nil:
    section.add "fileId", valid_578763
  var valid_578764 = path.getOrDefault("reportId")
  valid_578764 = validateParameter(valid_578764, JString, required = true,
                                 default = nil)
  if valid_578764 != nil:
    section.add "reportId", valid_578764
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_578765 = query.getOrDefault("key")
  valid_578765 = validateParameter(valid_578765, JString, required = false,
                                 default = nil)
  if valid_578765 != nil:
    section.add "key", valid_578765
  var valid_578779 = query.getOrDefault("prettyPrint")
  valid_578779 = validateParameter(valid_578779, JBool, required = false,
                                 default = newJBool(true))
  if valid_578779 != nil:
    section.add "prettyPrint", valid_578779
  var valid_578780 = query.getOrDefault("oauth_token")
  valid_578780 = validateParameter(valid_578780, JString, required = false,
                                 default = nil)
  if valid_578780 != nil:
    section.add "oauth_token", valid_578780
  var valid_578781 = query.getOrDefault("alt")
  valid_578781 = validateParameter(valid_578781, JString, required = false,
                                 default = newJString("json"))
  if valid_578781 != nil:
    section.add "alt", valid_578781
  var valid_578782 = query.getOrDefault("userIp")
  valid_578782 = validateParameter(valid_578782, JString, required = false,
                                 default = nil)
  if valid_578782 != nil:
    section.add "userIp", valid_578782
  var valid_578783 = query.getOrDefault("quotaUser")
  valid_578783 = validateParameter(valid_578783, JString, required = false,
                                 default = nil)
  if valid_578783 != nil:
    section.add "quotaUser", valid_578783
  var valid_578784 = query.getOrDefault("fields")
  valid_578784 = validateParameter(valid_578784, JString, required = false,
                                 default = nil)
  if valid_578784 != nil:
    section.add "fields", valid_578784
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578807: Call_DfareportingFilesGet_578635; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a report file by its report ID and file ID. This method supports media download.
  ## 
  let valid = call_578807.validator(path, query, header, formData, body)
  let scheme = call_578807.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578807.url(scheme.get, call_578807.host, call_578807.base,
                         call_578807.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578807, url, valid)

proc call*(call_578878: Call_DfareportingFilesGet_578635; fileId: string;
          reportId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingFilesGet
  ## Retrieves a report file by its report ID and file ID. This method supports media download.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fileId: string (required)
  ##         : The ID of the report file.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_578879 = newJObject()
  var query_578881 = newJObject()
  add(query_578881, "key", newJString(key))
  add(query_578881, "prettyPrint", newJBool(prettyPrint))
  add(query_578881, "oauth_token", newJString(oauthToken))
  add(query_578881, "alt", newJString(alt))
  add(query_578881, "userIp", newJString(userIp))
  add(query_578881, "quotaUser", newJString(quotaUser))
  add(path_578879, "fileId", newJString(fileId))
  add(path_578879, "reportId", newJString(reportId))
  add(query_578881, "fields", newJString(fields))
  result = call_578878.call(path_578879, query_578881, nil, nil, nil)

var dfareportingFilesGet* = Call_DfareportingFilesGet_578635(
    name: "dfareportingFilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/reports/{reportId}/files/{fileId}",
    validator: validate_DfareportingFilesGet_578636, base: "/dfareporting/v2.7",
    url: url_DfareportingFilesGet_578637, schemes: {Scheme.Https})
type
  Call_DfareportingUserProfilesList_578920 = ref object of OpenApiRestCall_578364
proc url_DfareportingUserProfilesList_578922(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  result.path = base & route

proc validate_DfareportingUserProfilesList_578921(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves list of user profiles for a user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_578923 = query.getOrDefault("key")
  valid_578923 = validateParameter(valid_578923, JString, required = false,
                                 default = nil)
  if valid_578923 != nil:
    section.add "key", valid_578923
  var valid_578924 = query.getOrDefault("prettyPrint")
  valid_578924 = validateParameter(valid_578924, JBool, required = false,
                                 default = newJBool(true))
  if valid_578924 != nil:
    section.add "prettyPrint", valid_578924
  var valid_578925 = query.getOrDefault("oauth_token")
  valid_578925 = validateParameter(valid_578925, JString, required = false,
                                 default = nil)
  if valid_578925 != nil:
    section.add "oauth_token", valid_578925
  var valid_578926 = query.getOrDefault("alt")
  valid_578926 = validateParameter(valid_578926, JString, required = false,
                                 default = newJString("json"))
  if valid_578926 != nil:
    section.add "alt", valid_578926
  var valid_578927 = query.getOrDefault("userIp")
  valid_578927 = validateParameter(valid_578927, JString, required = false,
                                 default = nil)
  if valid_578927 != nil:
    section.add "userIp", valid_578927
  var valid_578928 = query.getOrDefault("quotaUser")
  valid_578928 = validateParameter(valid_578928, JString, required = false,
                                 default = nil)
  if valid_578928 != nil:
    section.add "quotaUser", valid_578928
  var valid_578929 = query.getOrDefault("fields")
  valid_578929 = validateParameter(valid_578929, JString, required = false,
                                 default = nil)
  if valid_578929 != nil:
    section.add "fields", valid_578929
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578930: Call_DfareportingUserProfilesList_578920; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves list of user profiles for a user.
  ## 
  let valid = call_578930.validator(path, query, header, formData, body)
  let scheme = call_578930.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578930.url(scheme.get, call_578930.host, call_578930.base,
                         call_578930.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578930, url, valid)

proc call*(call_578931: Call_DfareportingUserProfilesList_578920; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingUserProfilesList
  ## Retrieves list of user profiles for a user.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var query_578932 = newJObject()
  add(query_578932, "key", newJString(key))
  add(query_578932, "prettyPrint", newJBool(prettyPrint))
  add(query_578932, "oauth_token", newJString(oauthToken))
  add(query_578932, "alt", newJString(alt))
  add(query_578932, "userIp", newJString(userIp))
  add(query_578932, "quotaUser", newJString(quotaUser))
  add(query_578932, "fields", newJString(fields))
  result = call_578931.call(nil, query_578932, nil, nil, nil)

var dfareportingUserProfilesList* = Call_DfareportingUserProfilesList_578920(
    name: "dfareportingUserProfilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles",
    validator: validate_DfareportingUserProfilesList_578921,
    base: "/dfareporting/v2.7", url: url_DfareportingUserProfilesList_578922,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserProfilesGet_578933 = ref object of OpenApiRestCall_578364
proc url_DfareportingUserProfilesGet_578935(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserProfilesGet_578934(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user profile by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_578936 = path.getOrDefault("profileId")
  valid_578936 = validateParameter(valid_578936, JString, required = true,
                                 default = nil)
  if valid_578936 != nil:
    section.add "profileId", valid_578936
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_578937 = query.getOrDefault("key")
  valid_578937 = validateParameter(valid_578937, JString, required = false,
                                 default = nil)
  if valid_578937 != nil:
    section.add "key", valid_578937
  var valid_578938 = query.getOrDefault("prettyPrint")
  valid_578938 = validateParameter(valid_578938, JBool, required = false,
                                 default = newJBool(true))
  if valid_578938 != nil:
    section.add "prettyPrint", valid_578938
  var valid_578939 = query.getOrDefault("oauth_token")
  valid_578939 = validateParameter(valid_578939, JString, required = false,
                                 default = nil)
  if valid_578939 != nil:
    section.add "oauth_token", valid_578939
  var valid_578940 = query.getOrDefault("alt")
  valid_578940 = validateParameter(valid_578940, JString, required = false,
                                 default = newJString("json"))
  if valid_578940 != nil:
    section.add "alt", valid_578940
  var valid_578941 = query.getOrDefault("userIp")
  valid_578941 = validateParameter(valid_578941, JString, required = false,
                                 default = nil)
  if valid_578941 != nil:
    section.add "userIp", valid_578941
  var valid_578942 = query.getOrDefault("quotaUser")
  valid_578942 = validateParameter(valid_578942, JString, required = false,
                                 default = nil)
  if valid_578942 != nil:
    section.add "quotaUser", valid_578942
  var valid_578943 = query.getOrDefault("fields")
  valid_578943 = validateParameter(valid_578943, JString, required = false,
                                 default = nil)
  if valid_578943 != nil:
    section.add "fields", valid_578943
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578944: Call_DfareportingUserProfilesGet_578933; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one user profile by ID.
  ## 
  let valid = call_578944.validator(path, query, header, formData, body)
  let scheme = call_578944.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578944.url(scheme.get, call_578944.host, call_578944.base,
                         call_578944.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578944, url, valid)

proc call*(call_578945: Call_DfareportingUserProfilesGet_578933; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingUserProfilesGet
  ## Gets one user profile by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : The user profile ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_578946 = newJObject()
  var query_578947 = newJObject()
  add(query_578947, "key", newJString(key))
  add(query_578947, "prettyPrint", newJBool(prettyPrint))
  add(query_578947, "oauth_token", newJString(oauthToken))
  add(path_578946, "profileId", newJString(profileId))
  add(query_578947, "alt", newJString(alt))
  add(query_578947, "userIp", newJString(userIp))
  add(query_578947, "quotaUser", newJString(quotaUser))
  add(query_578947, "fields", newJString(fields))
  result = call_578945.call(path_578946, query_578947, nil, nil, nil)

var dfareportingUserProfilesGet* = Call_DfareportingUserProfilesGet_578933(
    name: "dfareportingUserProfilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}",
    validator: validate_DfareportingUserProfilesGet_578934,
    base: "/dfareporting/v2.7", url: url_DfareportingUserProfilesGet_578935,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountActiveAdSummariesGet_578948 = ref object of OpenApiRestCall_578364
proc url_DfareportingAccountActiveAdSummariesGet_578950(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "summaryAccountId" in path,
        "`summaryAccountId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountActiveAdSummaries/"),
               (kind: VariableSegment, value: "summaryAccountId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountActiveAdSummariesGet_578949(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the account's active ad summary by account ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   summaryAccountId: JString (required)
  ##                   : Account ID.
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `summaryAccountId` field"
  var valid_578951 = path.getOrDefault("summaryAccountId")
  valid_578951 = validateParameter(valid_578951, JString, required = true,
                                 default = nil)
  if valid_578951 != nil:
    section.add "summaryAccountId", valid_578951
  var valid_578952 = path.getOrDefault("profileId")
  valid_578952 = validateParameter(valid_578952, JString, required = true,
                                 default = nil)
  if valid_578952 != nil:
    section.add "profileId", valid_578952
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_578953 = query.getOrDefault("key")
  valid_578953 = validateParameter(valid_578953, JString, required = false,
                                 default = nil)
  if valid_578953 != nil:
    section.add "key", valid_578953
  var valid_578954 = query.getOrDefault("prettyPrint")
  valid_578954 = validateParameter(valid_578954, JBool, required = false,
                                 default = newJBool(true))
  if valid_578954 != nil:
    section.add "prettyPrint", valid_578954
  var valid_578955 = query.getOrDefault("oauth_token")
  valid_578955 = validateParameter(valid_578955, JString, required = false,
                                 default = nil)
  if valid_578955 != nil:
    section.add "oauth_token", valid_578955
  var valid_578956 = query.getOrDefault("alt")
  valid_578956 = validateParameter(valid_578956, JString, required = false,
                                 default = newJString("json"))
  if valid_578956 != nil:
    section.add "alt", valid_578956
  var valid_578957 = query.getOrDefault("userIp")
  valid_578957 = validateParameter(valid_578957, JString, required = false,
                                 default = nil)
  if valid_578957 != nil:
    section.add "userIp", valid_578957
  var valid_578958 = query.getOrDefault("quotaUser")
  valid_578958 = validateParameter(valid_578958, JString, required = false,
                                 default = nil)
  if valid_578958 != nil:
    section.add "quotaUser", valid_578958
  var valid_578959 = query.getOrDefault("fields")
  valid_578959 = validateParameter(valid_578959, JString, required = false,
                                 default = nil)
  if valid_578959 != nil:
    section.add "fields", valid_578959
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578960: Call_DfareportingAccountActiveAdSummariesGet_578948;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the account's active ad summary by account ID.
  ## 
  let valid = call_578960.validator(path, query, header, formData, body)
  let scheme = call_578960.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578960.url(scheme.get, call_578960.host, call_578960.base,
                         call_578960.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578960, url, valid)

proc call*(call_578961: Call_DfareportingAccountActiveAdSummariesGet_578948;
          summaryAccountId: string; profileId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingAccountActiveAdSummariesGet
  ## Gets the account's active ad summary by account ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   summaryAccountId: string (required)
  ##                   : Account ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_578962 = newJObject()
  var query_578963 = newJObject()
  add(query_578963, "key", newJString(key))
  add(query_578963, "prettyPrint", newJBool(prettyPrint))
  add(query_578963, "oauth_token", newJString(oauthToken))
  add(path_578962, "summaryAccountId", newJString(summaryAccountId))
  add(path_578962, "profileId", newJString(profileId))
  add(query_578963, "alt", newJString(alt))
  add(query_578963, "userIp", newJString(userIp))
  add(query_578963, "quotaUser", newJString(quotaUser))
  add(query_578963, "fields", newJString(fields))
  result = call_578961.call(path_578962, query_578963, nil, nil, nil)

var dfareportingAccountActiveAdSummariesGet* = Call_DfareportingAccountActiveAdSummariesGet_578948(
    name: "dfareportingAccountActiveAdSummariesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accountActiveAdSummaries/{summaryAccountId}",
    validator: validate_DfareportingAccountActiveAdSummariesGet_578949,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountActiveAdSummariesGet_578950,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionGroupsList_578964 = ref object of OpenApiRestCall_578364
proc url_DfareportingAccountPermissionGroupsList_578966(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissionGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionGroupsList_578965(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of account permission groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_578967 = path.getOrDefault("profileId")
  valid_578967 = validateParameter(valid_578967, JString, required = true,
                                 default = nil)
  if valid_578967 != nil:
    section.add "profileId", valid_578967
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_578968 = query.getOrDefault("key")
  valid_578968 = validateParameter(valid_578968, JString, required = false,
                                 default = nil)
  if valid_578968 != nil:
    section.add "key", valid_578968
  var valid_578969 = query.getOrDefault("prettyPrint")
  valid_578969 = validateParameter(valid_578969, JBool, required = false,
                                 default = newJBool(true))
  if valid_578969 != nil:
    section.add "prettyPrint", valid_578969
  var valid_578970 = query.getOrDefault("oauth_token")
  valid_578970 = validateParameter(valid_578970, JString, required = false,
                                 default = nil)
  if valid_578970 != nil:
    section.add "oauth_token", valid_578970
  var valid_578971 = query.getOrDefault("alt")
  valid_578971 = validateParameter(valid_578971, JString, required = false,
                                 default = newJString("json"))
  if valid_578971 != nil:
    section.add "alt", valid_578971
  var valid_578972 = query.getOrDefault("userIp")
  valid_578972 = validateParameter(valid_578972, JString, required = false,
                                 default = nil)
  if valid_578972 != nil:
    section.add "userIp", valid_578972
  var valid_578973 = query.getOrDefault("quotaUser")
  valid_578973 = validateParameter(valid_578973, JString, required = false,
                                 default = nil)
  if valid_578973 != nil:
    section.add "quotaUser", valid_578973
  var valid_578974 = query.getOrDefault("fields")
  valid_578974 = validateParameter(valid_578974, JString, required = false,
                                 default = nil)
  if valid_578974 != nil:
    section.add "fields", valid_578974
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578975: Call_DfareportingAccountPermissionGroupsList_578964;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves the list of account permission groups.
  ## 
  let valid = call_578975.validator(path, query, header, formData, body)
  let scheme = call_578975.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578975.url(scheme.get, call_578975.host, call_578975.base,
                         call_578975.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578975, url, valid)

proc call*(call_578976: Call_DfareportingAccountPermissionGroupsList_578964;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingAccountPermissionGroupsList
  ## Retrieves the list of account permission groups.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_578977 = newJObject()
  var query_578978 = newJObject()
  add(query_578978, "key", newJString(key))
  add(query_578978, "prettyPrint", newJBool(prettyPrint))
  add(query_578978, "oauth_token", newJString(oauthToken))
  add(path_578977, "profileId", newJString(profileId))
  add(query_578978, "alt", newJString(alt))
  add(query_578978, "userIp", newJString(userIp))
  add(query_578978, "quotaUser", newJString(quotaUser))
  add(query_578978, "fields", newJString(fields))
  result = call_578976.call(path_578977, query_578978, nil, nil, nil)

var dfareportingAccountPermissionGroupsList* = Call_DfareportingAccountPermissionGroupsList_578964(
    name: "dfareportingAccountPermissionGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissionGroups",
    validator: validate_DfareportingAccountPermissionGroupsList_578965,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionGroupsList_578966,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionGroupsGet_578979 = ref object of OpenApiRestCall_578364
proc url_DfareportingAccountPermissionGroupsGet_578981(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissionGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionGroupsGet_578980(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account permission group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Account permission group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_578982 = path.getOrDefault("profileId")
  valid_578982 = validateParameter(valid_578982, JString, required = true,
                                 default = nil)
  if valid_578982 != nil:
    section.add "profileId", valid_578982
  var valid_578983 = path.getOrDefault("id")
  valid_578983 = validateParameter(valid_578983, JString, required = true,
                                 default = nil)
  if valid_578983 != nil:
    section.add "id", valid_578983
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_578984 = query.getOrDefault("key")
  valid_578984 = validateParameter(valid_578984, JString, required = false,
                                 default = nil)
  if valid_578984 != nil:
    section.add "key", valid_578984
  var valid_578985 = query.getOrDefault("prettyPrint")
  valid_578985 = validateParameter(valid_578985, JBool, required = false,
                                 default = newJBool(true))
  if valid_578985 != nil:
    section.add "prettyPrint", valid_578985
  var valid_578986 = query.getOrDefault("oauth_token")
  valid_578986 = validateParameter(valid_578986, JString, required = false,
                                 default = nil)
  if valid_578986 != nil:
    section.add "oauth_token", valid_578986
  var valid_578987 = query.getOrDefault("alt")
  valid_578987 = validateParameter(valid_578987, JString, required = false,
                                 default = newJString("json"))
  if valid_578987 != nil:
    section.add "alt", valid_578987
  var valid_578988 = query.getOrDefault("userIp")
  valid_578988 = validateParameter(valid_578988, JString, required = false,
                                 default = nil)
  if valid_578988 != nil:
    section.add "userIp", valid_578988
  var valid_578989 = query.getOrDefault("quotaUser")
  valid_578989 = validateParameter(valid_578989, JString, required = false,
                                 default = nil)
  if valid_578989 != nil:
    section.add "quotaUser", valid_578989
  var valid_578990 = query.getOrDefault("fields")
  valid_578990 = validateParameter(valid_578990, JString, required = false,
                                 default = nil)
  if valid_578990 != nil:
    section.add "fields", valid_578990
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578991: Call_DfareportingAccountPermissionGroupsGet_578979;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one account permission group by ID.
  ## 
  let valid = call_578991.validator(path, query, header, formData, body)
  let scheme = call_578991.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578991.url(scheme.get, call_578991.host, call_578991.base,
                         call_578991.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578991, url, valid)

proc call*(call_578992: Call_DfareportingAccountPermissionGroupsGet_578979;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingAccountPermissionGroupsGet
  ## Gets one account permission group by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Account permission group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_578993 = newJObject()
  var query_578994 = newJObject()
  add(query_578994, "key", newJString(key))
  add(query_578994, "prettyPrint", newJBool(prettyPrint))
  add(query_578994, "oauth_token", newJString(oauthToken))
  add(path_578993, "profileId", newJString(profileId))
  add(path_578993, "id", newJString(id))
  add(query_578994, "alt", newJString(alt))
  add(query_578994, "userIp", newJString(userIp))
  add(query_578994, "quotaUser", newJString(quotaUser))
  add(query_578994, "fields", newJString(fields))
  result = call_578992.call(path_578993, query_578994, nil, nil, nil)

var dfareportingAccountPermissionGroupsGet* = Call_DfareportingAccountPermissionGroupsGet_578979(
    name: "dfareportingAccountPermissionGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissionGroups/{id}",
    validator: validate_DfareportingAccountPermissionGroupsGet_578980,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionGroupsGet_578981,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionsList_578995 = ref object of OpenApiRestCall_578364
proc url_DfareportingAccountPermissionsList_578997(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionsList_578996(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of account permissions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_578998 = path.getOrDefault("profileId")
  valid_578998 = validateParameter(valid_578998, JString, required = true,
                                 default = nil)
  if valid_578998 != nil:
    section.add "profileId", valid_578998
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_578999 = query.getOrDefault("key")
  valid_578999 = validateParameter(valid_578999, JString, required = false,
                                 default = nil)
  if valid_578999 != nil:
    section.add "key", valid_578999
  var valid_579000 = query.getOrDefault("prettyPrint")
  valid_579000 = validateParameter(valid_579000, JBool, required = false,
                                 default = newJBool(true))
  if valid_579000 != nil:
    section.add "prettyPrint", valid_579000
  var valid_579001 = query.getOrDefault("oauth_token")
  valid_579001 = validateParameter(valid_579001, JString, required = false,
                                 default = nil)
  if valid_579001 != nil:
    section.add "oauth_token", valid_579001
  var valid_579002 = query.getOrDefault("alt")
  valid_579002 = validateParameter(valid_579002, JString, required = false,
                                 default = newJString("json"))
  if valid_579002 != nil:
    section.add "alt", valid_579002
  var valid_579003 = query.getOrDefault("userIp")
  valid_579003 = validateParameter(valid_579003, JString, required = false,
                                 default = nil)
  if valid_579003 != nil:
    section.add "userIp", valid_579003
  var valid_579004 = query.getOrDefault("quotaUser")
  valid_579004 = validateParameter(valid_579004, JString, required = false,
                                 default = nil)
  if valid_579004 != nil:
    section.add "quotaUser", valid_579004
  var valid_579005 = query.getOrDefault("fields")
  valid_579005 = validateParameter(valid_579005, JString, required = false,
                                 default = nil)
  if valid_579005 != nil:
    section.add "fields", valid_579005
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579006: Call_DfareportingAccountPermissionsList_578995;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves the list of account permissions.
  ## 
  let valid = call_579006.validator(path, query, header, formData, body)
  let scheme = call_579006.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579006.url(scheme.get, call_579006.host, call_579006.base,
                         call_579006.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579006, url, valid)

proc call*(call_579007: Call_DfareportingAccountPermissionsList_578995;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingAccountPermissionsList
  ## Retrieves the list of account permissions.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579008 = newJObject()
  var query_579009 = newJObject()
  add(query_579009, "key", newJString(key))
  add(query_579009, "prettyPrint", newJBool(prettyPrint))
  add(query_579009, "oauth_token", newJString(oauthToken))
  add(path_579008, "profileId", newJString(profileId))
  add(query_579009, "alt", newJString(alt))
  add(query_579009, "userIp", newJString(userIp))
  add(query_579009, "quotaUser", newJString(quotaUser))
  add(query_579009, "fields", newJString(fields))
  result = call_579007.call(path_579008, query_579009, nil, nil, nil)

var dfareportingAccountPermissionsList* = Call_DfareportingAccountPermissionsList_578995(
    name: "dfareportingAccountPermissionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissions",
    validator: validate_DfareportingAccountPermissionsList_578996,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionsList_578997,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionsGet_579010 = ref object of OpenApiRestCall_578364
proc url_DfareportingAccountPermissionsGet_579012(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissions/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionsGet_579011(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account permission by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Account permission ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579013 = path.getOrDefault("profileId")
  valid_579013 = validateParameter(valid_579013, JString, required = true,
                                 default = nil)
  if valid_579013 != nil:
    section.add "profileId", valid_579013
  var valid_579014 = path.getOrDefault("id")
  valid_579014 = validateParameter(valid_579014, JString, required = true,
                                 default = nil)
  if valid_579014 != nil:
    section.add "id", valid_579014
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579015 = query.getOrDefault("key")
  valid_579015 = validateParameter(valid_579015, JString, required = false,
                                 default = nil)
  if valid_579015 != nil:
    section.add "key", valid_579015
  var valid_579016 = query.getOrDefault("prettyPrint")
  valid_579016 = validateParameter(valid_579016, JBool, required = false,
                                 default = newJBool(true))
  if valid_579016 != nil:
    section.add "prettyPrint", valid_579016
  var valid_579017 = query.getOrDefault("oauth_token")
  valid_579017 = validateParameter(valid_579017, JString, required = false,
                                 default = nil)
  if valid_579017 != nil:
    section.add "oauth_token", valid_579017
  var valid_579018 = query.getOrDefault("alt")
  valid_579018 = validateParameter(valid_579018, JString, required = false,
                                 default = newJString("json"))
  if valid_579018 != nil:
    section.add "alt", valid_579018
  var valid_579019 = query.getOrDefault("userIp")
  valid_579019 = validateParameter(valid_579019, JString, required = false,
                                 default = nil)
  if valid_579019 != nil:
    section.add "userIp", valid_579019
  var valid_579020 = query.getOrDefault("quotaUser")
  valid_579020 = validateParameter(valid_579020, JString, required = false,
                                 default = nil)
  if valid_579020 != nil:
    section.add "quotaUser", valid_579020
  var valid_579021 = query.getOrDefault("fields")
  valid_579021 = validateParameter(valid_579021, JString, required = false,
                                 default = nil)
  if valid_579021 != nil:
    section.add "fields", valid_579021
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579022: Call_DfareportingAccountPermissionsGet_579010;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one account permission by ID.
  ## 
  let valid = call_579022.validator(path, query, header, formData, body)
  let scheme = call_579022.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579022.url(scheme.get, call_579022.host, call_579022.base,
                         call_579022.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579022, url, valid)

proc call*(call_579023: Call_DfareportingAccountPermissionsGet_579010;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingAccountPermissionsGet
  ## Gets one account permission by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Account permission ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579024 = newJObject()
  var query_579025 = newJObject()
  add(query_579025, "key", newJString(key))
  add(query_579025, "prettyPrint", newJBool(prettyPrint))
  add(query_579025, "oauth_token", newJString(oauthToken))
  add(path_579024, "profileId", newJString(profileId))
  add(path_579024, "id", newJString(id))
  add(query_579025, "alt", newJString(alt))
  add(query_579025, "userIp", newJString(userIp))
  add(query_579025, "quotaUser", newJString(quotaUser))
  add(query_579025, "fields", newJString(fields))
  result = call_579023.call(path_579024, query_579025, nil, nil, nil)

var dfareportingAccountPermissionsGet* = Call_DfareportingAccountPermissionsGet_579010(
    name: "dfareportingAccountPermissionsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissions/{id}",
    validator: validate_DfareportingAccountPermissionsGet_579011,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionsGet_579012,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesUpdate_579051 = ref object of OpenApiRestCall_578364
proc url_DfareportingAccountUserProfilesUpdate_579053(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesUpdate_579052(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account user profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579054 = path.getOrDefault("profileId")
  valid_579054 = validateParameter(valid_579054, JString, required = true,
                                 default = nil)
  if valid_579054 != nil:
    section.add "profileId", valid_579054
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579055 = query.getOrDefault("key")
  valid_579055 = validateParameter(valid_579055, JString, required = false,
                                 default = nil)
  if valid_579055 != nil:
    section.add "key", valid_579055
  var valid_579056 = query.getOrDefault("prettyPrint")
  valid_579056 = validateParameter(valid_579056, JBool, required = false,
                                 default = newJBool(true))
  if valid_579056 != nil:
    section.add "prettyPrint", valid_579056
  var valid_579057 = query.getOrDefault("oauth_token")
  valid_579057 = validateParameter(valid_579057, JString, required = false,
                                 default = nil)
  if valid_579057 != nil:
    section.add "oauth_token", valid_579057
  var valid_579058 = query.getOrDefault("alt")
  valid_579058 = validateParameter(valid_579058, JString, required = false,
                                 default = newJString("json"))
  if valid_579058 != nil:
    section.add "alt", valid_579058
  var valid_579059 = query.getOrDefault("userIp")
  valid_579059 = validateParameter(valid_579059, JString, required = false,
                                 default = nil)
  if valid_579059 != nil:
    section.add "userIp", valid_579059
  var valid_579060 = query.getOrDefault("quotaUser")
  valid_579060 = validateParameter(valid_579060, JString, required = false,
                                 default = nil)
  if valid_579060 != nil:
    section.add "quotaUser", valid_579060
  var valid_579061 = query.getOrDefault("fields")
  valid_579061 = validateParameter(valid_579061, JString, required = false,
                                 default = nil)
  if valid_579061 != nil:
    section.add "fields", valid_579061
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579063: Call_DfareportingAccountUserProfilesUpdate_579051;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing account user profile.
  ## 
  let valid = call_579063.validator(path, query, header, formData, body)
  let scheme = call_579063.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579063.url(scheme.get, call_579063.host, call_579063.base,
                         call_579063.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579063, url, valid)

proc call*(call_579064: Call_DfareportingAccountUserProfilesUpdate_579051;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingAccountUserProfilesUpdate
  ## Updates an existing account user profile.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579065 = newJObject()
  var query_579066 = newJObject()
  var body_579067 = newJObject()
  add(query_579066, "key", newJString(key))
  add(query_579066, "prettyPrint", newJBool(prettyPrint))
  add(query_579066, "oauth_token", newJString(oauthToken))
  add(path_579065, "profileId", newJString(profileId))
  add(query_579066, "alt", newJString(alt))
  add(query_579066, "userIp", newJString(userIp))
  add(query_579066, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_579067 = body
  add(query_579066, "fields", newJString(fields))
  result = call_579064.call(path_579065, query_579066, nil, nil, body_579067)

var dfareportingAccountUserProfilesUpdate* = Call_DfareportingAccountUserProfilesUpdate_579051(
    name: "dfareportingAccountUserProfilesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesUpdate_579052,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesUpdate_579053,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesInsert_579068 = ref object of OpenApiRestCall_578364
proc url_DfareportingAccountUserProfilesInsert_579070(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesInsert_579069(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new account user profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579071 = path.getOrDefault("profileId")
  valid_579071 = validateParameter(valid_579071, JString, required = true,
                                 default = nil)
  if valid_579071 != nil:
    section.add "profileId", valid_579071
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579072 = query.getOrDefault("key")
  valid_579072 = validateParameter(valid_579072, JString, required = false,
                                 default = nil)
  if valid_579072 != nil:
    section.add "key", valid_579072
  var valid_579073 = query.getOrDefault("prettyPrint")
  valid_579073 = validateParameter(valid_579073, JBool, required = false,
                                 default = newJBool(true))
  if valid_579073 != nil:
    section.add "prettyPrint", valid_579073
  var valid_579074 = query.getOrDefault("oauth_token")
  valid_579074 = validateParameter(valid_579074, JString, required = false,
                                 default = nil)
  if valid_579074 != nil:
    section.add "oauth_token", valid_579074
  var valid_579075 = query.getOrDefault("alt")
  valid_579075 = validateParameter(valid_579075, JString, required = false,
                                 default = newJString("json"))
  if valid_579075 != nil:
    section.add "alt", valid_579075
  var valid_579076 = query.getOrDefault("userIp")
  valid_579076 = validateParameter(valid_579076, JString, required = false,
                                 default = nil)
  if valid_579076 != nil:
    section.add "userIp", valid_579076
  var valid_579077 = query.getOrDefault("quotaUser")
  valid_579077 = validateParameter(valid_579077, JString, required = false,
                                 default = nil)
  if valid_579077 != nil:
    section.add "quotaUser", valid_579077
  var valid_579078 = query.getOrDefault("fields")
  valid_579078 = validateParameter(valid_579078, JString, required = false,
                                 default = nil)
  if valid_579078 != nil:
    section.add "fields", valid_579078
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579080: Call_DfareportingAccountUserProfilesInsert_579068;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new account user profile.
  ## 
  let valid = call_579080.validator(path, query, header, formData, body)
  let scheme = call_579080.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579080.url(scheme.get, call_579080.host, call_579080.base,
                         call_579080.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579080, url, valid)

proc call*(call_579081: Call_DfareportingAccountUserProfilesInsert_579068;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingAccountUserProfilesInsert
  ## Inserts a new account user profile.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579082 = newJObject()
  var query_579083 = newJObject()
  var body_579084 = newJObject()
  add(query_579083, "key", newJString(key))
  add(query_579083, "prettyPrint", newJBool(prettyPrint))
  add(query_579083, "oauth_token", newJString(oauthToken))
  add(path_579082, "profileId", newJString(profileId))
  add(query_579083, "alt", newJString(alt))
  add(query_579083, "userIp", newJString(userIp))
  add(query_579083, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_579084 = body
  add(query_579083, "fields", newJString(fields))
  result = call_579081.call(path_579082, query_579083, nil, nil, body_579084)

var dfareportingAccountUserProfilesInsert* = Call_DfareportingAccountUserProfilesInsert_579068(
    name: "dfareportingAccountUserProfilesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesInsert_579069,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesInsert_579070,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesList_579026 = ref object of OpenApiRestCall_578364
proc url_DfareportingAccountUserProfilesList_579028(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesList_579027(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of account user profiles, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579029 = path.getOrDefault("profileId")
  valid_579029 = validateParameter(valid_579029, JString, required = true,
                                 default = nil)
  if valid_579029 != nil:
    section.add "profileId", valid_579029
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   active: JBool
  ##         : Select only active user profiles.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "user profile*2015" will return objects with names like "user profile June 2015", "user profile April 2015", or simply "user profile 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "user profile" will match objects with name "my user profile", "user profile 2015", or simply "user profile".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   userRoleId: JString
  ##             : Select only user profiles with the specified user role ID.
  ##   subaccountId: JString
  ##               : Select only user profiles with the specified subaccount ID.
  ##   ids: JArray
  ##      : Select only user profiles with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_579030 = query.getOrDefault("key")
  valid_579030 = validateParameter(valid_579030, JString, required = false,
                                 default = nil)
  if valid_579030 != nil:
    section.add "key", valid_579030
  var valid_579031 = query.getOrDefault("prettyPrint")
  valid_579031 = validateParameter(valid_579031, JBool, required = false,
                                 default = newJBool(true))
  if valid_579031 != nil:
    section.add "prettyPrint", valid_579031
  var valid_579032 = query.getOrDefault("oauth_token")
  valid_579032 = validateParameter(valid_579032, JString, required = false,
                                 default = nil)
  if valid_579032 != nil:
    section.add "oauth_token", valid_579032
  var valid_579033 = query.getOrDefault("active")
  valid_579033 = validateParameter(valid_579033, JBool, required = false, default = nil)
  if valid_579033 != nil:
    section.add "active", valid_579033
  var valid_579034 = query.getOrDefault("sortField")
  valid_579034 = validateParameter(valid_579034, JString, required = false,
                                 default = newJString("ID"))
  if valid_579034 != nil:
    section.add "sortField", valid_579034
  var valid_579035 = query.getOrDefault("alt")
  valid_579035 = validateParameter(valid_579035, JString, required = false,
                                 default = newJString("json"))
  if valid_579035 != nil:
    section.add "alt", valid_579035
  var valid_579036 = query.getOrDefault("userIp")
  valid_579036 = validateParameter(valid_579036, JString, required = false,
                                 default = nil)
  if valid_579036 != nil:
    section.add "userIp", valid_579036
  var valid_579037 = query.getOrDefault("quotaUser")
  valid_579037 = validateParameter(valid_579037, JString, required = false,
                                 default = nil)
  if valid_579037 != nil:
    section.add "quotaUser", valid_579037
  var valid_579038 = query.getOrDefault("pageToken")
  valid_579038 = validateParameter(valid_579038, JString, required = false,
                                 default = nil)
  if valid_579038 != nil:
    section.add "pageToken", valid_579038
  var valid_579039 = query.getOrDefault("searchString")
  valid_579039 = validateParameter(valid_579039, JString, required = false,
                                 default = nil)
  if valid_579039 != nil:
    section.add "searchString", valid_579039
  var valid_579040 = query.getOrDefault("sortOrder")
  valid_579040 = validateParameter(valid_579040, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_579040 != nil:
    section.add "sortOrder", valid_579040
  var valid_579041 = query.getOrDefault("userRoleId")
  valid_579041 = validateParameter(valid_579041, JString, required = false,
                                 default = nil)
  if valid_579041 != nil:
    section.add "userRoleId", valid_579041
  var valid_579042 = query.getOrDefault("subaccountId")
  valid_579042 = validateParameter(valid_579042, JString, required = false,
                                 default = nil)
  if valid_579042 != nil:
    section.add "subaccountId", valid_579042
  var valid_579043 = query.getOrDefault("ids")
  valid_579043 = validateParameter(valid_579043, JArray, required = false,
                                 default = nil)
  if valid_579043 != nil:
    section.add "ids", valid_579043
  var valid_579044 = query.getOrDefault("fields")
  valid_579044 = validateParameter(valid_579044, JString, required = false,
                                 default = nil)
  if valid_579044 != nil:
    section.add "fields", valid_579044
  var valid_579046 = query.getOrDefault("maxResults")
  valid_579046 = validateParameter(valid_579046, JInt, required = false,
                                 default = newJInt(1000))
  if valid_579046 != nil:
    section.add "maxResults", valid_579046
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579047: Call_DfareportingAccountUserProfilesList_579026;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of account user profiles, possibly filtered. This method supports paging.
  ## 
  let valid = call_579047.validator(path, query, header, formData, body)
  let scheme = call_579047.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579047.url(scheme.get, call_579047.host, call_579047.base,
                         call_579047.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579047, url, valid)

proc call*(call_579048: Call_DfareportingAccountUserProfilesList_579026;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; active: bool = false; sortField: string = "ID";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          pageToken: string = ""; searchString: string = "";
          sortOrder: string = "ASCENDING"; userRoleId: string = "";
          subaccountId: string = ""; ids: JsonNode = nil; fields: string = "";
          maxResults: int = 1000): Recallable =
  ## dfareportingAccountUserProfilesList
  ## Retrieves a list of account user profiles, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   active: bool
  ##         : Select only active user profiles.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "user profile*2015" will return objects with names like "user profile June 2015", "user profile April 2015", or simply "user profile 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "user profile" will match objects with name "my user profile", "user profile 2015", or simply "user profile".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   userRoleId: string
  ##             : Select only user profiles with the specified user role ID.
  ##   subaccountId: string
  ##               : Select only user profiles with the specified subaccount ID.
  ##   ids: JArray
  ##      : Select only user profiles with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_579049 = newJObject()
  var query_579050 = newJObject()
  add(query_579050, "key", newJString(key))
  add(query_579050, "prettyPrint", newJBool(prettyPrint))
  add(query_579050, "oauth_token", newJString(oauthToken))
  add(query_579050, "active", newJBool(active))
  add(path_579049, "profileId", newJString(profileId))
  add(query_579050, "sortField", newJString(sortField))
  add(query_579050, "alt", newJString(alt))
  add(query_579050, "userIp", newJString(userIp))
  add(query_579050, "quotaUser", newJString(quotaUser))
  add(query_579050, "pageToken", newJString(pageToken))
  add(query_579050, "searchString", newJString(searchString))
  add(query_579050, "sortOrder", newJString(sortOrder))
  add(query_579050, "userRoleId", newJString(userRoleId))
  add(query_579050, "subaccountId", newJString(subaccountId))
  if ids != nil:
    query_579050.add "ids", ids
  add(query_579050, "fields", newJString(fields))
  add(query_579050, "maxResults", newJInt(maxResults))
  result = call_579048.call(path_579049, query_579050, nil, nil, nil)

var dfareportingAccountUserProfilesList* = Call_DfareportingAccountUserProfilesList_579026(
    name: "dfareportingAccountUserProfilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesList_579027,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesList_579028,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesPatch_579085 = ref object of OpenApiRestCall_578364
proc url_DfareportingAccountUserProfilesPatch_579087(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesPatch_579086(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account user profile. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579088 = path.getOrDefault("profileId")
  valid_579088 = validateParameter(valid_579088, JString, required = true,
                                 default = nil)
  if valid_579088 != nil:
    section.add "profileId", valid_579088
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : User profile ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579089 = query.getOrDefault("key")
  valid_579089 = validateParameter(valid_579089, JString, required = false,
                                 default = nil)
  if valid_579089 != nil:
    section.add "key", valid_579089
  var valid_579090 = query.getOrDefault("prettyPrint")
  valid_579090 = validateParameter(valid_579090, JBool, required = false,
                                 default = newJBool(true))
  if valid_579090 != nil:
    section.add "prettyPrint", valid_579090
  var valid_579091 = query.getOrDefault("oauth_token")
  valid_579091 = validateParameter(valid_579091, JString, required = false,
                                 default = nil)
  if valid_579091 != nil:
    section.add "oauth_token", valid_579091
  var valid_579092 = query.getOrDefault("alt")
  valid_579092 = validateParameter(valid_579092, JString, required = false,
                                 default = newJString("json"))
  if valid_579092 != nil:
    section.add "alt", valid_579092
  var valid_579093 = query.getOrDefault("userIp")
  valid_579093 = validateParameter(valid_579093, JString, required = false,
                                 default = nil)
  if valid_579093 != nil:
    section.add "userIp", valid_579093
  var valid_579094 = query.getOrDefault("quotaUser")
  valid_579094 = validateParameter(valid_579094, JString, required = false,
                                 default = nil)
  if valid_579094 != nil:
    section.add "quotaUser", valid_579094
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_579095 = query.getOrDefault("id")
  valid_579095 = validateParameter(valid_579095, JString, required = true,
                                 default = nil)
  if valid_579095 != nil:
    section.add "id", valid_579095
  var valid_579096 = query.getOrDefault("fields")
  valid_579096 = validateParameter(valid_579096, JString, required = false,
                                 default = nil)
  if valid_579096 != nil:
    section.add "fields", valid_579096
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579098: Call_DfareportingAccountUserProfilesPatch_579085;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing account user profile. This method supports patch semantics.
  ## 
  let valid = call_579098.validator(path, query, header, formData, body)
  let scheme = call_579098.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579098.url(scheme.get, call_579098.host, call_579098.base,
                         call_579098.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579098, url, valid)

proc call*(call_579099: Call_DfareportingAccountUserProfilesPatch_579085;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingAccountUserProfilesPatch
  ## Updates an existing account user profile. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : User profile ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579100 = newJObject()
  var query_579101 = newJObject()
  var body_579102 = newJObject()
  add(query_579101, "key", newJString(key))
  add(query_579101, "prettyPrint", newJBool(prettyPrint))
  add(query_579101, "oauth_token", newJString(oauthToken))
  add(path_579100, "profileId", newJString(profileId))
  add(query_579101, "alt", newJString(alt))
  add(query_579101, "userIp", newJString(userIp))
  add(query_579101, "quotaUser", newJString(quotaUser))
  add(query_579101, "id", newJString(id))
  if body != nil:
    body_579102 = body
  add(query_579101, "fields", newJString(fields))
  result = call_579099.call(path_579100, query_579101, nil, nil, body_579102)

var dfareportingAccountUserProfilesPatch* = Call_DfareportingAccountUserProfilesPatch_579085(
    name: "dfareportingAccountUserProfilesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesPatch_579086,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesPatch_579087,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesGet_579103 = ref object of OpenApiRestCall_578364
proc url_DfareportingAccountUserProfilesGet_579105(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesGet_579104(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account user profile by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579106 = path.getOrDefault("profileId")
  valid_579106 = validateParameter(valid_579106, JString, required = true,
                                 default = nil)
  if valid_579106 != nil:
    section.add "profileId", valid_579106
  var valid_579107 = path.getOrDefault("id")
  valid_579107 = validateParameter(valid_579107, JString, required = true,
                                 default = nil)
  if valid_579107 != nil:
    section.add "id", valid_579107
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579108 = query.getOrDefault("key")
  valid_579108 = validateParameter(valid_579108, JString, required = false,
                                 default = nil)
  if valid_579108 != nil:
    section.add "key", valid_579108
  var valid_579109 = query.getOrDefault("prettyPrint")
  valid_579109 = validateParameter(valid_579109, JBool, required = false,
                                 default = newJBool(true))
  if valid_579109 != nil:
    section.add "prettyPrint", valid_579109
  var valid_579110 = query.getOrDefault("oauth_token")
  valid_579110 = validateParameter(valid_579110, JString, required = false,
                                 default = nil)
  if valid_579110 != nil:
    section.add "oauth_token", valid_579110
  var valid_579111 = query.getOrDefault("alt")
  valid_579111 = validateParameter(valid_579111, JString, required = false,
                                 default = newJString("json"))
  if valid_579111 != nil:
    section.add "alt", valid_579111
  var valid_579112 = query.getOrDefault("userIp")
  valid_579112 = validateParameter(valid_579112, JString, required = false,
                                 default = nil)
  if valid_579112 != nil:
    section.add "userIp", valid_579112
  var valid_579113 = query.getOrDefault("quotaUser")
  valid_579113 = validateParameter(valid_579113, JString, required = false,
                                 default = nil)
  if valid_579113 != nil:
    section.add "quotaUser", valid_579113
  var valid_579114 = query.getOrDefault("fields")
  valid_579114 = validateParameter(valid_579114, JString, required = false,
                                 default = nil)
  if valid_579114 != nil:
    section.add "fields", valid_579114
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579115: Call_DfareportingAccountUserProfilesGet_579103;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one account user profile by ID.
  ## 
  let valid = call_579115.validator(path, query, header, formData, body)
  let scheme = call_579115.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579115.url(scheme.get, call_579115.host, call_579115.base,
                         call_579115.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579115, url, valid)

proc call*(call_579116: Call_DfareportingAccountUserProfilesGet_579103;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingAccountUserProfilesGet
  ## Gets one account user profile by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : User profile ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579117 = newJObject()
  var query_579118 = newJObject()
  add(query_579118, "key", newJString(key))
  add(query_579118, "prettyPrint", newJBool(prettyPrint))
  add(query_579118, "oauth_token", newJString(oauthToken))
  add(path_579117, "profileId", newJString(profileId))
  add(path_579117, "id", newJString(id))
  add(query_579118, "alt", newJString(alt))
  add(query_579118, "userIp", newJString(userIp))
  add(query_579118, "quotaUser", newJString(quotaUser))
  add(query_579118, "fields", newJString(fields))
  result = call_579116.call(path_579117, query_579118, nil, nil, nil)

var dfareportingAccountUserProfilesGet* = Call_DfareportingAccountUserProfilesGet_579103(
    name: "dfareportingAccountUserProfilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles/{id}",
    validator: validate_DfareportingAccountUserProfilesGet_579104,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesGet_579105,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsUpdate_579141 = ref object of OpenApiRestCall_578364
proc url_DfareportingAccountsUpdate_579143(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsUpdate_579142(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579144 = path.getOrDefault("profileId")
  valid_579144 = validateParameter(valid_579144, JString, required = true,
                                 default = nil)
  if valid_579144 != nil:
    section.add "profileId", valid_579144
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579145 = query.getOrDefault("key")
  valid_579145 = validateParameter(valid_579145, JString, required = false,
                                 default = nil)
  if valid_579145 != nil:
    section.add "key", valid_579145
  var valid_579146 = query.getOrDefault("prettyPrint")
  valid_579146 = validateParameter(valid_579146, JBool, required = false,
                                 default = newJBool(true))
  if valid_579146 != nil:
    section.add "prettyPrint", valid_579146
  var valid_579147 = query.getOrDefault("oauth_token")
  valid_579147 = validateParameter(valid_579147, JString, required = false,
                                 default = nil)
  if valid_579147 != nil:
    section.add "oauth_token", valid_579147
  var valid_579148 = query.getOrDefault("alt")
  valid_579148 = validateParameter(valid_579148, JString, required = false,
                                 default = newJString("json"))
  if valid_579148 != nil:
    section.add "alt", valid_579148
  var valid_579149 = query.getOrDefault("userIp")
  valid_579149 = validateParameter(valid_579149, JString, required = false,
                                 default = nil)
  if valid_579149 != nil:
    section.add "userIp", valid_579149
  var valid_579150 = query.getOrDefault("quotaUser")
  valid_579150 = validateParameter(valid_579150, JString, required = false,
                                 default = nil)
  if valid_579150 != nil:
    section.add "quotaUser", valid_579150
  var valid_579151 = query.getOrDefault("fields")
  valid_579151 = validateParameter(valid_579151, JString, required = false,
                                 default = nil)
  if valid_579151 != nil:
    section.add "fields", valid_579151
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579153: Call_DfareportingAccountsUpdate_579141; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing account.
  ## 
  let valid = call_579153.validator(path, query, header, formData, body)
  let scheme = call_579153.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579153.url(scheme.get, call_579153.host, call_579153.base,
                         call_579153.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579153, url, valid)

proc call*(call_579154: Call_DfareportingAccountsUpdate_579141; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingAccountsUpdate
  ## Updates an existing account.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579155 = newJObject()
  var query_579156 = newJObject()
  var body_579157 = newJObject()
  add(query_579156, "key", newJString(key))
  add(query_579156, "prettyPrint", newJBool(prettyPrint))
  add(query_579156, "oauth_token", newJString(oauthToken))
  add(path_579155, "profileId", newJString(profileId))
  add(query_579156, "alt", newJString(alt))
  add(query_579156, "userIp", newJString(userIp))
  add(query_579156, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_579157 = body
  add(query_579156, "fields", newJString(fields))
  result = call_579154.call(path_579155, query_579156, nil, nil, body_579157)

var dfareportingAccountsUpdate* = Call_DfareportingAccountsUpdate_579141(
    name: "dfareportingAccountsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts",
    validator: validate_DfareportingAccountsUpdate_579142,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsUpdate_579143,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsList_579119 = ref object of OpenApiRestCall_578364
proc url_DfareportingAccountsList_579121(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsList_579120(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of accounts, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579122 = path.getOrDefault("profileId")
  valid_579122 = validateParameter(valid_579122, JString, required = true,
                                 default = nil)
  if valid_579122 != nil:
    section.add "profileId", valid_579122
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   active: JBool
  ##         : Select only active accounts. Don't set this field to select both active and non-active accounts.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "account*2015" will return objects with names like "account June 2015", "account April 2015", or simply "account 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "account" will match objects with name "my account", "account 2015", or simply "account".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only accounts with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_579123 = query.getOrDefault("key")
  valid_579123 = validateParameter(valid_579123, JString, required = false,
                                 default = nil)
  if valid_579123 != nil:
    section.add "key", valid_579123
  var valid_579124 = query.getOrDefault("prettyPrint")
  valid_579124 = validateParameter(valid_579124, JBool, required = false,
                                 default = newJBool(true))
  if valid_579124 != nil:
    section.add "prettyPrint", valid_579124
  var valid_579125 = query.getOrDefault("oauth_token")
  valid_579125 = validateParameter(valid_579125, JString, required = false,
                                 default = nil)
  if valid_579125 != nil:
    section.add "oauth_token", valid_579125
  var valid_579126 = query.getOrDefault("active")
  valid_579126 = validateParameter(valid_579126, JBool, required = false, default = nil)
  if valid_579126 != nil:
    section.add "active", valid_579126
  var valid_579127 = query.getOrDefault("sortField")
  valid_579127 = validateParameter(valid_579127, JString, required = false,
                                 default = newJString("ID"))
  if valid_579127 != nil:
    section.add "sortField", valid_579127
  var valid_579128 = query.getOrDefault("alt")
  valid_579128 = validateParameter(valid_579128, JString, required = false,
                                 default = newJString("json"))
  if valid_579128 != nil:
    section.add "alt", valid_579128
  var valid_579129 = query.getOrDefault("userIp")
  valid_579129 = validateParameter(valid_579129, JString, required = false,
                                 default = nil)
  if valid_579129 != nil:
    section.add "userIp", valid_579129
  var valid_579130 = query.getOrDefault("quotaUser")
  valid_579130 = validateParameter(valid_579130, JString, required = false,
                                 default = nil)
  if valid_579130 != nil:
    section.add "quotaUser", valid_579130
  var valid_579131 = query.getOrDefault("pageToken")
  valid_579131 = validateParameter(valid_579131, JString, required = false,
                                 default = nil)
  if valid_579131 != nil:
    section.add "pageToken", valid_579131
  var valid_579132 = query.getOrDefault("searchString")
  valid_579132 = validateParameter(valid_579132, JString, required = false,
                                 default = nil)
  if valid_579132 != nil:
    section.add "searchString", valid_579132
  var valid_579133 = query.getOrDefault("sortOrder")
  valid_579133 = validateParameter(valid_579133, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_579133 != nil:
    section.add "sortOrder", valid_579133
  var valid_579134 = query.getOrDefault("ids")
  valid_579134 = validateParameter(valid_579134, JArray, required = false,
                                 default = nil)
  if valid_579134 != nil:
    section.add "ids", valid_579134
  var valid_579135 = query.getOrDefault("fields")
  valid_579135 = validateParameter(valid_579135, JString, required = false,
                                 default = nil)
  if valid_579135 != nil:
    section.add "fields", valid_579135
  var valid_579136 = query.getOrDefault("maxResults")
  valid_579136 = validateParameter(valid_579136, JInt, required = false,
                                 default = newJInt(1000))
  if valid_579136 != nil:
    section.add "maxResults", valid_579136
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579137: Call_DfareportingAccountsList_579119; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves the list of accounts, possibly filtered. This method supports paging.
  ## 
  let valid = call_579137.validator(path, query, header, formData, body)
  let scheme = call_579137.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579137.url(scheme.get, call_579137.host, call_579137.base,
                         call_579137.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579137, url, valid)

proc call*(call_579138: Call_DfareportingAccountsList_579119; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          active: bool = false; sortField: string = "ID"; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; pageToken: string = "";
          searchString: string = ""; sortOrder: string = "ASCENDING";
          ids: JsonNode = nil; fields: string = ""; maxResults: int = 1000): Recallable =
  ## dfareportingAccountsList
  ## Retrieves the list of accounts, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   active: bool
  ##         : Select only active accounts. Don't set this field to select both active and non-active accounts.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "account*2015" will return objects with names like "account June 2015", "account April 2015", or simply "account 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "account" will match objects with name "my account", "account 2015", or simply "account".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only accounts with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_579139 = newJObject()
  var query_579140 = newJObject()
  add(query_579140, "key", newJString(key))
  add(query_579140, "prettyPrint", newJBool(prettyPrint))
  add(query_579140, "oauth_token", newJString(oauthToken))
  add(query_579140, "active", newJBool(active))
  add(path_579139, "profileId", newJString(profileId))
  add(query_579140, "sortField", newJString(sortField))
  add(query_579140, "alt", newJString(alt))
  add(query_579140, "userIp", newJString(userIp))
  add(query_579140, "quotaUser", newJString(quotaUser))
  add(query_579140, "pageToken", newJString(pageToken))
  add(query_579140, "searchString", newJString(searchString))
  add(query_579140, "sortOrder", newJString(sortOrder))
  if ids != nil:
    query_579140.add "ids", ids
  add(query_579140, "fields", newJString(fields))
  add(query_579140, "maxResults", newJInt(maxResults))
  result = call_579138.call(path_579139, query_579140, nil, nil, nil)

var dfareportingAccountsList* = Call_DfareportingAccountsList_579119(
    name: "dfareportingAccountsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts",
    validator: validate_DfareportingAccountsList_579120,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsList_579121,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsPatch_579158 = ref object of OpenApiRestCall_578364
proc url_DfareportingAccountsPatch_579160(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsPatch_579159(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579161 = path.getOrDefault("profileId")
  valid_579161 = validateParameter(valid_579161, JString, required = true,
                                 default = nil)
  if valid_579161 != nil:
    section.add "profileId", valid_579161
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Account ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579162 = query.getOrDefault("key")
  valid_579162 = validateParameter(valid_579162, JString, required = false,
                                 default = nil)
  if valid_579162 != nil:
    section.add "key", valid_579162
  var valid_579163 = query.getOrDefault("prettyPrint")
  valid_579163 = validateParameter(valid_579163, JBool, required = false,
                                 default = newJBool(true))
  if valid_579163 != nil:
    section.add "prettyPrint", valid_579163
  var valid_579164 = query.getOrDefault("oauth_token")
  valid_579164 = validateParameter(valid_579164, JString, required = false,
                                 default = nil)
  if valid_579164 != nil:
    section.add "oauth_token", valid_579164
  var valid_579165 = query.getOrDefault("alt")
  valid_579165 = validateParameter(valid_579165, JString, required = false,
                                 default = newJString("json"))
  if valid_579165 != nil:
    section.add "alt", valid_579165
  var valid_579166 = query.getOrDefault("userIp")
  valid_579166 = validateParameter(valid_579166, JString, required = false,
                                 default = nil)
  if valid_579166 != nil:
    section.add "userIp", valid_579166
  var valid_579167 = query.getOrDefault("quotaUser")
  valid_579167 = validateParameter(valid_579167, JString, required = false,
                                 default = nil)
  if valid_579167 != nil:
    section.add "quotaUser", valid_579167
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_579168 = query.getOrDefault("id")
  valid_579168 = validateParameter(valid_579168, JString, required = true,
                                 default = nil)
  if valid_579168 != nil:
    section.add "id", valid_579168
  var valid_579169 = query.getOrDefault("fields")
  valid_579169 = validateParameter(valid_579169, JString, required = false,
                                 default = nil)
  if valid_579169 != nil:
    section.add "fields", valid_579169
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579171: Call_DfareportingAccountsPatch_579158; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing account. This method supports patch semantics.
  ## 
  let valid = call_579171.validator(path, query, header, formData, body)
  let scheme = call_579171.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579171.url(scheme.get, call_579171.host, call_579171.base,
                         call_579171.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579171, url, valid)

proc call*(call_579172: Call_DfareportingAccountsPatch_579158; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingAccountsPatch
  ## Updates an existing account. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Account ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579173 = newJObject()
  var query_579174 = newJObject()
  var body_579175 = newJObject()
  add(query_579174, "key", newJString(key))
  add(query_579174, "prettyPrint", newJBool(prettyPrint))
  add(query_579174, "oauth_token", newJString(oauthToken))
  add(path_579173, "profileId", newJString(profileId))
  add(query_579174, "alt", newJString(alt))
  add(query_579174, "userIp", newJString(userIp))
  add(query_579174, "quotaUser", newJString(quotaUser))
  add(query_579174, "id", newJString(id))
  if body != nil:
    body_579175 = body
  add(query_579174, "fields", newJString(fields))
  result = call_579172.call(path_579173, query_579174, nil, nil, body_579175)

var dfareportingAccountsPatch* = Call_DfareportingAccountsPatch_579158(
    name: "dfareportingAccountsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts",
    validator: validate_DfareportingAccountsPatch_579159,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsPatch_579160,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsGet_579176 = ref object of OpenApiRestCall_578364
proc url_DfareportingAccountsGet_579178(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsGet_579177(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Account ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579179 = path.getOrDefault("profileId")
  valid_579179 = validateParameter(valid_579179, JString, required = true,
                                 default = nil)
  if valid_579179 != nil:
    section.add "profileId", valid_579179
  var valid_579180 = path.getOrDefault("id")
  valid_579180 = validateParameter(valid_579180, JString, required = true,
                                 default = nil)
  if valid_579180 != nil:
    section.add "id", valid_579180
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579181 = query.getOrDefault("key")
  valid_579181 = validateParameter(valid_579181, JString, required = false,
                                 default = nil)
  if valid_579181 != nil:
    section.add "key", valid_579181
  var valid_579182 = query.getOrDefault("prettyPrint")
  valid_579182 = validateParameter(valid_579182, JBool, required = false,
                                 default = newJBool(true))
  if valid_579182 != nil:
    section.add "prettyPrint", valid_579182
  var valid_579183 = query.getOrDefault("oauth_token")
  valid_579183 = validateParameter(valid_579183, JString, required = false,
                                 default = nil)
  if valid_579183 != nil:
    section.add "oauth_token", valid_579183
  var valid_579184 = query.getOrDefault("alt")
  valid_579184 = validateParameter(valid_579184, JString, required = false,
                                 default = newJString("json"))
  if valid_579184 != nil:
    section.add "alt", valid_579184
  var valid_579185 = query.getOrDefault("userIp")
  valid_579185 = validateParameter(valid_579185, JString, required = false,
                                 default = nil)
  if valid_579185 != nil:
    section.add "userIp", valid_579185
  var valid_579186 = query.getOrDefault("quotaUser")
  valid_579186 = validateParameter(valid_579186, JString, required = false,
                                 default = nil)
  if valid_579186 != nil:
    section.add "quotaUser", valid_579186
  var valid_579187 = query.getOrDefault("fields")
  valid_579187 = validateParameter(valid_579187, JString, required = false,
                                 default = nil)
  if valid_579187 != nil:
    section.add "fields", valid_579187
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579188: Call_DfareportingAccountsGet_579176; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one account by ID.
  ## 
  let valid = call_579188.validator(path, query, header, formData, body)
  let scheme = call_579188.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579188.url(scheme.get, call_579188.host, call_579188.base,
                         call_579188.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579188, url, valid)

proc call*(call_579189: Call_DfareportingAccountsGet_579176; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingAccountsGet
  ## Gets one account by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Account ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579190 = newJObject()
  var query_579191 = newJObject()
  add(query_579191, "key", newJString(key))
  add(query_579191, "prettyPrint", newJBool(prettyPrint))
  add(query_579191, "oauth_token", newJString(oauthToken))
  add(path_579190, "profileId", newJString(profileId))
  add(path_579190, "id", newJString(id))
  add(query_579191, "alt", newJString(alt))
  add(query_579191, "userIp", newJString(userIp))
  add(query_579191, "quotaUser", newJString(quotaUser))
  add(query_579191, "fields", newJString(fields))
  result = call_579189.call(path_579190, query_579191, nil, nil, nil)

var dfareportingAccountsGet* = Call_DfareportingAccountsGet_579176(
    name: "dfareportingAccountsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts/{id}",
    validator: validate_DfareportingAccountsGet_579177,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsGet_579178,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdsUpdate_579230 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdsUpdate_579232(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsUpdate_579231(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing ad.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579233 = path.getOrDefault("profileId")
  valid_579233 = validateParameter(valid_579233, JString, required = true,
                                 default = nil)
  if valid_579233 != nil:
    section.add "profileId", valid_579233
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579234 = query.getOrDefault("key")
  valid_579234 = validateParameter(valid_579234, JString, required = false,
                                 default = nil)
  if valid_579234 != nil:
    section.add "key", valid_579234
  var valid_579235 = query.getOrDefault("prettyPrint")
  valid_579235 = validateParameter(valid_579235, JBool, required = false,
                                 default = newJBool(true))
  if valid_579235 != nil:
    section.add "prettyPrint", valid_579235
  var valid_579236 = query.getOrDefault("oauth_token")
  valid_579236 = validateParameter(valid_579236, JString, required = false,
                                 default = nil)
  if valid_579236 != nil:
    section.add "oauth_token", valid_579236
  var valid_579237 = query.getOrDefault("alt")
  valid_579237 = validateParameter(valid_579237, JString, required = false,
                                 default = newJString("json"))
  if valid_579237 != nil:
    section.add "alt", valid_579237
  var valid_579238 = query.getOrDefault("userIp")
  valid_579238 = validateParameter(valid_579238, JString, required = false,
                                 default = nil)
  if valid_579238 != nil:
    section.add "userIp", valid_579238
  var valid_579239 = query.getOrDefault("quotaUser")
  valid_579239 = validateParameter(valid_579239, JString, required = false,
                                 default = nil)
  if valid_579239 != nil:
    section.add "quotaUser", valid_579239
  var valid_579240 = query.getOrDefault("fields")
  valid_579240 = validateParameter(valid_579240, JString, required = false,
                                 default = nil)
  if valid_579240 != nil:
    section.add "fields", valid_579240
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579242: Call_DfareportingAdsUpdate_579230; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing ad.
  ## 
  let valid = call_579242.validator(path, query, header, formData, body)
  let scheme = call_579242.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579242.url(scheme.get, call_579242.host, call_579242.base,
                         call_579242.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579242, url, valid)

proc call*(call_579243: Call_DfareportingAdsUpdate_579230; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingAdsUpdate
  ## Updates an existing ad.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579244 = newJObject()
  var query_579245 = newJObject()
  var body_579246 = newJObject()
  add(query_579245, "key", newJString(key))
  add(query_579245, "prettyPrint", newJBool(prettyPrint))
  add(query_579245, "oauth_token", newJString(oauthToken))
  add(path_579244, "profileId", newJString(profileId))
  add(query_579245, "alt", newJString(alt))
  add(query_579245, "userIp", newJString(userIp))
  add(query_579245, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_579246 = body
  add(query_579245, "fields", newJString(fields))
  result = call_579243.call(path_579244, query_579245, nil, nil, body_579246)

var dfareportingAdsUpdate* = Call_DfareportingAdsUpdate_579230(
    name: "dfareportingAdsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsUpdate_579231, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsUpdate_579232, schemes: {Scheme.Https})
type
  Call_DfareportingAdsInsert_579247 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdsInsert_579249(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsInsert_579248(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new ad.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579250 = path.getOrDefault("profileId")
  valid_579250 = validateParameter(valid_579250, JString, required = true,
                                 default = nil)
  if valid_579250 != nil:
    section.add "profileId", valid_579250
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579251 = query.getOrDefault("key")
  valid_579251 = validateParameter(valid_579251, JString, required = false,
                                 default = nil)
  if valid_579251 != nil:
    section.add "key", valid_579251
  var valid_579252 = query.getOrDefault("prettyPrint")
  valid_579252 = validateParameter(valid_579252, JBool, required = false,
                                 default = newJBool(true))
  if valid_579252 != nil:
    section.add "prettyPrint", valid_579252
  var valid_579253 = query.getOrDefault("oauth_token")
  valid_579253 = validateParameter(valid_579253, JString, required = false,
                                 default = nil)
  if valid_579253 != nil:
    section.add "oauth_token", valid_579253
  var valid_579254 = query.getOrDefault("alt")
  valid_579254 = validateParameter(valid_579254, JString, required = false,
                                 default = newJString("json"))
  if valid_579254 != nil:
    section.add "alt", valid_579254
  var valid_579255 = query.getOrDefault("userIp")
  valid_579255 = validateParameter(valid_579255, JString, required = false,
                                 default = nil)
  if valid_579255 != nil:
    section.add "userIp", valid_579255
  var valid_579256 = query.getOrDefault("quotaUser")
  valid_579256 = validateParameter(valid_579256, JString, required = false,
                                 default = nil)
  if valid_579256 != nil:
    section.add "quotaUser", valid_579256
  var valid_579257 = query.getOrDefault("fields")
  valid_579257 = validateParameter(valid_579257, JString, required = false,
                                 default = nil)
  if valid_579257 != nil:
    section.add "fields", valid_579257
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579259: Call_DfareportingAdsInsert_579247; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new ad.
  ## 
  let valid = call_579259.validator(path, query, header, formData, body)
  let scheme = call_579259.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579259.url(scheme.get, call_579259.host, call_579259.base,
                         call_579259.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579259, url, valid)

proc call*(call_579260: Call_DfareportingAdsInsert_579247; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingAdsInsert
  ## Inserts a new ad.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579261 = newJObject()
  var query_579262 = newJObject()
  var body_579263 = newJObject()
  add(query_579262, "key", newJString(key))
  add(query_579262, "prettyPrint", newJBool(prettyPrint))
  add(query_579262, "oauth_token", newJString(oauthToken))
  add(path_579261, "profileId", newJString(profileId))
  add(query_579262, "alt", newJString(alt))
  add(query_579262, "userIp", newJString(userIp))
  add(query_579262, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_579263 = body
  add(query_579262, "fields", newJString(fields))
  result = call_579260.call(path_579261, query_579262, nil, nil, body_579263)

var dfareportingAdsInsert* = Call_DfareportingAdsInsert_579247(
    name: "dfareportingAdsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsInsert_579248, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsInsert_579249, schemes: {Scheme.Https})
type
  Call_DfareportingAdsList_579192 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdsList_579194(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsList_579193(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Retrieves a list of ads, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579195 = path.getOrDefault("profileId")
  valid_579195 = validateParameter(valid_579195, JString, required = true,
                                 default = nil)
  if valid_579195 != nil:
    section.add "profileId", valid_579195
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   remarketingListIds: JArray
  ##                     : Select only ads whose list targeting expression use these remarketing list IDs.
  ##   audienceSegmentIds: JArray
  ##                     : Select only ads with these audience segment IDs.
  ##   active: JBool
  ##         : Select only active ads.
  ##   landingPageIds: JArray
  ##                 : Select only ads with these landing page IDs.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: JBool
  ##           : Select only archived ads.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   placementIds: JArray
  ##               : Select only ads with these placement IDs assigned.
  ##   overriddenEventTagId: JString
  ##                       : Select only ads with this event tag override ID.
  ##   type: JArray
  ##       : Select only ads with these types.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "ad*2015" will return objects with names like "ad June 2015", "ad April 2015", or simply "ad 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "ad" will match objects with name "my ad", "ad 2015", or simply "ad".
  ##   compatibility: JString
  ##                : Select default ads with the specified compatibility. Applicable when type is AD_SERVING_DEFAULT_AD. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads, respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering an in-stream video ads developed with the VAST standard.
  ##   sizeIds: JArray
  ##          : Select only ads with these size IDs.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   sslCompliant: JBool
  ##               : Select only ads that are SSL-compliant.
  ##   advertiserId: JString
  ##               : Select only ads with this advertiser ID.
  ##   dynamicClickTracker: JBool
  ##                      : Select only dynamic click trackers. Applicable when type is AD_SERVING_CLICK_TRACKER. If true, select dynamic click trackers. If false, select static click trackers. Leave unset to select both.
  ##   campaignIds: JArray
  ##              : Select only ads with these campaign IDs.
  ##   ids: JArray
  ##      : Select only ads with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   creativeOptimizationConfigurationIds: JArray
  ##                                       : Select only ads with these creative optimization configuration IDs.
  ##   sslRequired: JBool
  ##              : Select only ads that require SSL.
  ##   creativeIds: JArray
  ##              : Select only ads with these creative IDs assigned.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_579196 = query.getOrDefault("key")
  valid_579196 = validateParameter(valid_579196, JString, required = false,
                                 default = nil)
  if valid_579196 != nil:
    section.add "key", valid_579196
  var valid_579197 = query.getOrDefault("prettyPrint")
  valid_579197 = validateParameter(valid_579197, JBool, required = false,
                                 default = newJBool(true))
  if valid_579197 != nil:
    section.add "prettyPrint", valid_579197
  var valid_579198 = query.getOrDefault("oauth_token")
  valid_579198 = validateParameter(valid_579198, JString, required = false,
                                 default = nil)
  if valid_579198 != nil:
    section.add "oauth_token", valid_579198
  var valid_579199 = query.getOrDefault("remarketingListIds")
  valid_579199 = validateParameter(valid_579199, JArray, required = false,
                                 default = nil)
  if valid_579199 != nil:
    section.add "remarketingListIds", valid_579199
  var valid_579200 = query.getOrDefault("audienceSegmentIds")
  valid_579200 = validateParameter(valid_579200, JArray, required = false,
                                 default = nil)
  if valid_579200 != nil:
    section.add "audienceSegmentIds", valid_579200
  var valid_579201 = query.getOrDefault("active")
  valid_579201 = validateParameter(valid_579201, JBool, required = false, default = nil)
  if valid_579201 != nil:
    section.add "active", valid_579201
  var valid_579202 = query.getOrDefault("landingPageIds")
  valid_579202 = validateParameter(valid_579202, JArray, required = false,
                                 default = nil)
  if valid_579202 != nil:
    section.add "landingPageIds", valid_579202
  var valid_579203 = query.getOrDefault("sortField")
  valid_579203 = validateParameter(valid_579203, JString, required = false,
                                 default = newJString("ID"))
  if valid_579203 != nil:
    section.add "sortField", valid_579203
  var valid_579204 = query.getOrDefault("alt")
  valid_579204 = validateParameter(valid_579204, JString, required = false,
                                 default = newJString("json"))
  if valid_579204 != nil:
    section.add "alt", valid_579204
  var valid_579205 = query.getOrDefault("userIp")
  valid_579205 = validateParameter(valid_579205, JString, required = false,
                                 default = nil)
  if valid_579205 != nil:
    section.add "userIp", valid_579205
  var valid_579206 = query.getOrDefault("archived")
  valid_579206 = validateParameter(valid_579206, JBool, required = false, default = nil)
  if valid_579206 != nil:
    section.add "archived", valid_579206
  var valid_579207 = query.getOrDefault("quotaUser")
  valid_579207 = validateParameter(valid_579207, JString, required = false,
                                 default = nil)
  if valid_579207 != nil:
    section.add "quotaUser", valid_579207
  var valid_579208 = query.getOrDefault("placementIds")
  valid_579208 = validateParameter(valid_579208, JArray, required = false,
                                 default = nil)
  if valid_579208 != nil:
    section.add "placementIds", valid_579208
  var valid_579209 = query.getOrDefault("overriddenEventTagId")
  valid_579209 = validateParameter(valid_579209, JString, required = false,
                                 default = nil)
  if valid_579209 != nil:
    section.add "overriddenEventTagId", valid_579209
  var valid_579210 = query.getOrDefault("type")
  valid_579210 = validateParameter(valid_579210, JArray, required = false,
                                 default = nil)
  if valid_579210 != nil:
    section.add "type", valid_579210
  var valid_579211 = query.getOrDefault("pageToken")
  valid_579211 = validateParameter(valid_579211, JString, required = false,
                                 default = nil)
  if valid_579211 != nil:
    section.add "pageToken", valid_579211
  var valid_579212 = query.getOrDefault("searchString")
  valid_579212 = validateParameter(valid_579212, JString, required = false,
                                 default = nil)
  if valid_579212 != nil:
    section.add "searchString", valid_579212
  var valid_579213 = query.getOrDefault("compatibility")
  valid_579213 = validateParameter(valid_579213, JString, required = false,
                                 default = newJString("APP"))
  if valid_579213 != nil:
    section.add "compatibility", valid_579213
  var valid_579214 = query.getOrDefault("sizeIds")
  valid_579214 = validateParameter(valid_579214, JArray, required = false,
                                 default = nil)
  if valid_579214 != nil:
    section.add "sizeIds", valid_579214
  var valid_579215 = query.getOrDefault("sortOrder")
  valid_579215 = validateParameter(valid_579215, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_579215 != nil:
    section.add "sortOrder", valid_579215
  var valid_579216 = query.getOrDefault("sslCompliant")
  valid_579216 = validateParameter(valid_579216, JBool, required = false, default = nil)
  if valid_579216 != nil:
    section.add "sslCompliant", valid_579216
  var valid_579217 = query.getOrDefault("advertiserId")
  valid_579217 = validateParameter(valid_579217, JString, required = false,
                                 default = nil)
  if valid_579217 != nil:
    section.add "advertiserId", valid_579217
  var valid_579218 = query.getOrDefault("dynamicClickTracker")
  valid_579218 = validateParameter(valid_579218, JBool, required = false, default = nil)
  if valid_579218 != nil:
    section.add "dynamicClickTracker", valid_579218
  var valid_579219 = query.getOrDefault("campaignIds")
  valid_579219 = validateParameter(valid_579219, JArray, required = false,
                                 default = nil)
  if valid_579219 != nil:
    section.add "campaignIds", valid_579219
  var valid_579220 = query.getOrDefault("ids")
  valid_579220 = validateParameter(valid_579220, JArray, required = false,
                                 default = nil)
  if valid_579220 != nil:
    section.add "ids", valid_579220
  var valid_579221 = query.getOrDefault("fields")
  valid_579221 = validateParameter(valid_579221, JString, required = false,
                                 default = nil)
  if valid_579221 != nil:
    section.add "fields", valid_579221
  var valid_579222 = query.getOrDefault("creativeOptimizationConfigurationIds")
  valid_579222 = validateParameter(valid_579222, JArray, required = false,
                                 default = nil)
  if valid_579222 != nil:
    section.add "creativeOptimizationConfigurationIds", valid_579222
  var valid_579223 = query.getOrDefault("sslRequired")
  valid_579223 = validateParameter(valid_579223, JBool, required = false, default = nil)
  if valid_579223 != nil:
    section.add "sslRequired", valid_579223
  var valid_579224 = query.getOrDefault("creativeIds")
  valid_579224 = validateParameter(valid_579224, JArray, required = false,
                                 default = nil)
  if valid_579224 != nil:
    section.add "creativeIds", valid_579224
  var valid_579225 = query.getOrDefault("maxResults")
  valid_579225 = validateParameter(valid_579225, JInt, required = false,
                                 default = newJInt(1000))
  if valid_579225 != nil:
    section.add "maxResults", valid_579225
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579226: Call_DfareportingAdsList_579192; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of ads, possibly filtered. This method supports paging.
  ## 
  let valid = call_579226.validator(path, query, header, formData, body)
  let scheme = call_579226.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579226.url(scheme.get, call_579226.host, call_579226.base,
                         call_579226.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579226, url, valid)

proc call*(call_579227: Call_DfareportingAdsList_579192; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          remarketingListIds: JsonNode = nil; audienceSegmentIds: JsonNode = nil;
          active: bool = false; landingPageIds: JsonNode = nil;
          sortField: string = "ID"; alt: string = "json"; userIp: string = "";
          archived: bool = false; quotaUser: string = ""; placementIds: JsonNode = nil;
          overriddenEventTagId: string = ""; `type`: JsonNode = nil;
          pageToken: string = ""; searchString: string = "";
          compatibility: string = "APP"; sizeIds: JsonNode = nil;
          sortOrder: string = "ASCENDING"; sslCompliant: bool = false;
          advertiserId: string = ""; dynamicClickTracker: bool = false;
          campaignIds: JsonNode = nil; ids: JsonNode = nil; fields: string = "";
          creativeOptimizationConfigurationIds: JsonNode = nil;
          sslRequired: bool = false; creativeIds: JsonNode = nil; maxResults: int = 1000): Recallable =
  ## dfareportingAdsList
  ## Retrieves a list of ads, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   remarketingListIds: JArray
  ##                     : Select only ads whose list targeting expression use these remarketing list IDs.
  ##   audienceSegmentIds: JArray
  ##                     : Select only ads with these audience segment IDs.
  ##   active: bool
  ##         : Select only active ads.
  ##   landingPageIds: JArray
  ##                 : Select only ads with these landing page IDs.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: bool
  ##           : Select only archived ads.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   placementIds: JArray
  ##               : Select only ads with these placement IDs assigned.
  ##   overriddenEventTagId: string
  ##                       : Select only ads with this event tag override ID.
  ##   type: JArray
  ##       : Select only ads with these types.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "ad*2015" will return objects with names like "ad June 2015", "ad April 2015", or simply "ad 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "ad" will match objects with name "my ad", "ad 2015", or simply "ad".
  ##   compatibility: string
  ##                : Select default ads with the specified compatibility. Applicable when type is AD_SERVING_DEFAULT_AD. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads, respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering an in-stream video ads developed with the VAST standard.
  ##   sizeIds: JArray
  ##          : Select only ads with these size IDs.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   sslCompliant: bool
  ##               : Select only ads that are SSL-compliant.
  ##   advertiserId: string
  ##               : Select only ads with this advertiser ID.
  ##   dynamicClickTracker: bool
  ##                      : Select only dynamic click trackers. Applicable when type is AD_SERVING_CLICK_TRACKER. If true, select dynamic click trackers. If false, select static click trackers. Leave unset to select both.
  ##   campaignIds: JArray
  ##              : Select only ads with these campaign IDs.
  ##   ids: JArray
  ##      : Select only ads with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   creativeOptimizationConfigurationIds: JArray
  ##                                       : Select only ads with these creative optimization configuration IDs.
  ##   sslRequired: bool
  ##              : Select only ads that require SSL.
  ##   creativeIds: JArray
  ##              : Select only ads with these creative IDs assigned.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_579228 = newJObject()
  var query_579229 = newJObject()
  add(query_579229, "key", newJString(key))
  add(query_579229, "prettyPrint", newJBool(prettyPrint))
  add(query_579229, "oauth_token", newJString(oauthToken))
  if remarketingListIds != nil:
    query_579229.add "remarketingListIds", remarketingListIds
  if audienceSegmentIds != nil:
    query_579229.add "audienceSegmentIds", audienceSegmentIds
  add(query_579229, "active", newJBool(active))
  if landingPageIds != nil:
    query_579229.add "landingPageIds", landingPageIds
  add(path_579228, "profileId", newJString(profileId))
  add(query_579229, "sortField", newJString(sortField))
  add(query_579229, "alt", newJString(alt))
  add(query_579229, "userIp", newJString(userIp))
  add(query_579229, "archived", newJBool(archived))
  add(query_579229, "quotaUser", newJString(quotaUser))
  if placementIds != nil:
    query_579229.add "placementIds", placementIds
  add(query_579229, "overriddenEventTagId", newJString(overriddenEventTagId))
  if `type` != nil:
    query_579229.add "type", `type`
  add(query_579229, "pageToken", newJString(pageToken))
  add(query_579229, "searchString", newJString(searchString))
  add(query_579229, "compatibility", newJString(compatibility))
  if sizeIds != nil:
    query_579229.add "sizeIds", sizeIds
  add(query_579229, "sortOrder", newJString(sortOrder))
  add(query_579229, "sslCompliant", newJBool(sslCompliant))
  add(query_579229, "advertiserId", newJString(advertiserId))
  add(query_579229, "dynamicClickTracker", newJBool(dynamicClickTracker))
  if campaignIds != nil:
    query_579229.add "campaignIds", campaignIds
  if ids != nil:
    query_579229.add "ids", ids
  add(query_579229, "fields", newJString(fields))
  if creativeOptimizationConfigurationIds != nil:
    query_579229.add "creativeOptimizationConfigurationIds",
                    creativeOptimizationConfigurationIds
  add(query_579229, "sslRequired", newJBool(sslRequired))
  if creativeIds != nil:
    query_579229.add "creativeIds", creativeIds
  add(query_579229, "maxResults", newJInt(maxResults))
  result = call_579227.call(path_579228, query_579229, nil, nil, nil)

var dfareportingAdsList* = Call_DfareportingAdsList_579192(
    name: "dfareportingAdsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsList_579193, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsList_579194, schemes: {Scheme.Https})
type
  Call_DfareportingAdsPatch_579264 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdsPatch_579266(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsPatch_579265(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing ad. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579267 = path.getOrDefault("profileId")
  valid_579267 = validateParameter(valid_579267, JString, required = true,
                                 default = nil)
  if valid_579267 != nil:
    section.add "profileId", valid_579267
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Ad ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579268 = query.getOrDefault("key")
  valid_579268 = validateParameter(valid_579268, JString, required = false,
                                 default = nil)
  if valid_579268 != nil:
    section.add "key", valid_579268
  var valid_579269 = query.getOrDefault("prettyPrint")
  valid_579269 = validateParameter(valid_579269, JBool, required = false,
                                 default = newJBool(true))
  if valid_579269 != nil:
    section.add "prettyPrint", valid_579269
  var valid_579270 = query.getOrDefault("oauth_token")
  valid_579270 = validateParameter(valid_579270, JString, required = false,
                                 default = nil)
  if valid_579270 != nil:
    section.add "oauth_token", valid_579270
  var valid_579271 = query.getOrDefault("alt")
  valid_579271 = validateParameter(valid_579271, JString, required = false,
                                 default = newJString("json"))
  if valid_579271 != nil:
    section.add "alt", valid_579271
  var valid_579272 = query.getOrDefault("userIp")
  valid_579272 = validateParameter(valid_579272, JString, required = false,
                                 default = nil)
  if valid_579272 != nil:
    section.add "userIp", valid_579272
  var valid_579273 = query.getOrDefault("quotaUser")
  valid_579273 = validateParameter(valid_579273, JString, required = false,
                                 default = nil)
  if valid_579273 != nil:
    section.add "quotaUser", valid_579273
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_579274 = query.getOrDefault("id")
  valid_579274 = validateParameter(valid_579274, JString, required = true,
                                 default = nil)
  if valid_579274 != nil:
    section.add "id", valid_579274
  var valid_579275 = query.getOrDefault("fields")
  valid_579275 = validateParameter(valid_579275, JString, required = false,
                                 default = nil)
  if valid_579275 != nil:
    section.add "fields", valid_579275
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579277: Call_DfareportingAdsPatch_579264; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing ad. This method supports patch semantics.
  ## 
  let valid = call_579277.validator(path, query, header, formData, body)
  let scheme = call_579277.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579277.url(scheme.get, call_579277.host, call_579277.base,
                         call_579277.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579277, url, valid)

proc call*(call_579278: Call_DfareportingAdsPatch_579264; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingAdsPatch
  ## Updates an existing ad. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Ad ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579279 = newJObject()
  var query_579280 = newJObject()
  var body_579281 = newJObject()
  add(query_579280, "key", newJString(key))
  add(query_579280, "prettyPrint", newJBool(prettyPrint))
  add(query_579280, "oauth_token", newJString(oauthToken))
  add(path_579279, "profileId", newJString(profileId))
  add(query_579280, "alt", newJString(alt))
  add(query_579280, "userIp", newJString(userIp))
  add(query_579280, "quotaUser", newJString(quotaUser))
  add(query_579280, "id", newJString(id))
  if body != nil:
    body_579281 = body
  add(query_579280, "fields", newJString(fields))
  result = call_579278.call(path_579279, query_579280, nil, nil, body_579281)

var dfareportingAdsPatch* = Call_DfareportingAdsPatch_579264(
    name: "dfareportingAdsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsPatch_579265, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsPatch_579266, schemes: {Scheme.Https})
type
  Call_DfareportingAdsGet_579282 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdsGet_579284(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsGet_579283(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Gets one ad by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Ad ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579285 = path.getOrDefault("profileId")
  valid_579285 = validateParameter(valid_579285, JString, required = true,
                                 default = nil)
  if valid_579285 != nil:
    section.add "profileId", valid_579285
  var valid_579286 = path.getOrDefault("id")
  valid_579286 = validateParameter(valid_579286, JString, required = true,
                                 default = nil)
  if valid_579286 != nil:
    section.add "id", valid_579286
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579287 = query.getOrDefault("key")
  valid_579287 = validateParameter(valid_579287, JString, required = false,
                                 default = nil)
  if valid_579287 != nil:
    section.add "key", valid_579287
  var valid_579288 = query.getOrDefault("prettyPrint")
  valid_579288 = validateParameter(valid_579288, JBool, required = false,
                                 default = newJBool(true))
  if valid_579288 != nil:
    section.add "prettyPrint", valid_579288
  var valid_579289 = query.getOrDefault("oauth_token")
  valid_579289 = validateParameter(valid_579289, JString, required = false,
                                 default = nil)
  if valid_579289 != nil:
    section.add "oauth_token", valid_579289
  var valid_579290 = query.getOrDefault("alt")
  valid_579290 = validateParameter(valid_579290, JString, required = false,
                                 default = newJString("json"))
  if valid_579290 != nil:
    section.add "alt", valid_579290
  var valid_579291 = query.getOrDefault("userIp")
  valid_579291 = validateParameter(valid_579291, JString, required = false,
                                 default = nil)
  if valid_579291 != nil:
    section.add "userIp", valid_579291
  var valid_579292 = query.getOrDefault("quotaUser")
  valid_579292 = validateParameter(valid_579292, JString, required = false,
                                 default = nil)
  if valid_579292 != nil:
    section.add "quotaUser", valid_579292
  var valid_579293 = query.getOrDefault("fields")
  valid_579293 = validateParameter(valid_579293, JString, required = false,
                                 default = nil)
  if valid_579293 != nil:
    section.add "fields", valid_579293
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579294: Call_DfareportingAdsGet_579282; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one ad by ID.
  ## 
  let valid = call_579294.validator(path, query, header, formData, body)
  let scheme = call_579294.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579294.url(scheme.get, call_579294.host, call_579294.base,
                         call_579294.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579294, url, valid)

proc call*(call_579295: Call_DfareportingAdsGet_579282; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingAdsGet
  ## Gets one ad by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Ad ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579296 = newJObject()
  var query_579297 = newJObject()
  add(query_579297, "key", newJString(key))
  add(query_579297, "prettyPrint", newJBool(prettyPrint))
  add(query_579297, "oauth_token", newJString(oauthToken))
  add(path_579296, "profileId", newJString(profileId))
  add(path_579296, "id", newJString(id))
  add(query_579297, "alt", newJString(alt))
  add(query_579297, "userIp", newJString(userIp))
  add(query_579297, "quotaUser", newJString(quotaUser))
  add(query_579297, "fields", newJString(fields))
  result = call_579295.call(path_579296, query_579297, nil, nil, nil)

var dfareportingAdsGet* = Call_DfareportingAdsGet_579282(
    name: "dfareportingAdsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads/{id}",
    validator: validate_DfareportingAdsGet_579283, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsGet_579284, schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsUpdate_579319 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdvertiserGroupsUpdate_579321(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsUpdate_579320(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579322 = path.getOrDefault("profileId")
  valid_579322 = validateParameter(valid_579322, JString, required = true,
                                 default = nil)
  if valid_579322 != nil:
    section.add "profileId", valid_579322
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579323 = query.getOrDefault("key")
  valid_579323 = validateParameter(valid_579323, JString, required = false,
                                 default = nil)
  if valid_579323 != nil:
    section.add "key", valid_579323
  var valid_579324 = query.getOrDefault("prettyPrint")
  valid_579324 = validateParameter(valid_579324, JBool, required = false,
                                 default = newJBool(true))
  if valid_579324 != nil:
    section.add "prettyPrint", valid_579324
  var valid_579325 = query.getOrDefault("oauth_token")
  valid_579325 = validateParameter(valid_579325, JString, required = false,
                                 default = nil)
  if valid_579325 != nil:
    section.add "oauth_token", valid_579325
  var valid_579326 = query.getOrDefault("alt")
  valid_579326 = validateParameter(valid_579326, JString, required = false,
                                 default = newJString("json"))
  if valid_579326 != nil:
    section.add "alt", valid_579326
  var valid_579327 = query.getOrDefault("userIp")
  valid_579327 = validateParameter(valid_579327, JString, required = false,
                                 default = nil)
  if valid_579327 != nil:
    section.add "userIp", valid_579327
  var valid_579328 = query.getOrDefault("quotaUser")
  valid_579328 = validateParameter(valid_579328, JString, required = false,
                                 default = nil)
  if valid_579328 != nil:
    section.add "quotaUser", valid_579328
  var valid_579329 = query.getOrDefault("fields")
  valid_579329 = validateParameter(valid_579329, JString, required = false,
                                 default = nil)
  if valid_579329 != nil:
    section.add "fields", valid_579329
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579331: Call_DfareportingAdvertiserGroupsUpdate_579319;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing advertiser group.
  ## 
  let valid = call_579331.validator(path, query, header, formData, body)
  let scheme = call_579331.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579331.url(scheme.get, call_579331.host, call_579331.base,
                         call_579331.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579331, url, valid)

proc call*(call_579332: Call_DfareportingAdvertiserGroupsUpdate_579319;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingAdvertiserGroupsUpdate
  ## Updates an existing advertiser group.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579333 = newJObject()
  var query_579334 = newJObject()
  var body_579335 = newJObject()
  add(query_579334, "key", newJString(key))
  add(query_579334, "prettyPrint", newJBool(prettyPrint))
  add(query_579334, "oauth_token", newJString(oauthToken))
  add(path_579333, "profileId", newJString(profileId))
  add(query_579334, "alt", newJString(alt))
  add(query_579334, "userIp", newJString(userIp))
  add(query_579334, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_579335 = body
  add(query_579334, "fields", newJString(fields))
  result = call_579332.call(path_579333, query_579334, nil, nil, body_579335)

var dfareportingAdvertiserGroupsUpdate* = Call_DfareportingAdvertiserGroupsUpdate_579319(
    name: "dfareportingAdvertiserGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsUpdate_579320,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsUpdate_579321,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsInsert_579336 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdvertiserGroupsInsert_579338(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsInsert_579337(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new advertiser group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579339 = path.getOrDefault("profileId")
  valid_579339 = validateParameter(valid_579339, JString, required = true,
                                 default = nil)
  if valid_579339 != nil:
    section.add "profileId", valid_579339
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579340 = query.getOrDefault("key")
  valid_579340 = validateParameter(valid_579340, JString, required = false,
                                 default = nil)
  if valid_579340 != nil:
    section.add "key", valid_579340
  var valid_579341 = query.getOrDefault("prettyPrint")
  valid_579341 = validateParameter(valid_579341, JBool, required = false,
                                 default = newJBool(true))
  if valid_579341 != nil:
    section.add "prettyPrint", valid_579341
  var valid_579342 = query.getOrDefault("oauth_token")
  valid_579342 = validateParameter(valid_579342, JString, required = false,
                                 default = nil)
  if valid_579342 != nil:
    section.add "oauth_token", valid_579342
  var valid_579343 = query.getOrDefault("alt")
  valid_579343 = validateParameter(valid_579343, JString, required = false,
                                 default = newJString("json"))
  if valid_579343 != nil:
    section.add "alt", valid_579343
  var valid_579344 = query.getOrDefault("userIp")
  valid_579344 = validateParameter(valid_579344, JString, required = false,
                                 default = nil)
  if valid_579344 != nil:
    section.add "userIp", valid_579344
  var valid_579345 = query.getOrDefault("quotaUser")
  valid_579345 = validateParameter(valid_579345, JString, required = false,
                                 default = nil)
  if valid_579345 != nil:
    section.add "quotaUser", valid_579345
  var valid_579346 = query.getOrDefault("fields")
  valid_579346 = validateParameter(valid_579346, JString, required = false,
                                 default = nil)
  if valid_579346 != nil:
    section.add "fields", valid_579346
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579348: Call_DfareportingAdvertiserGroupsInsert_579336;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new advertiser group.
  ## 
  let valid = call_579348.validator(path, query, header, formData, body)
  let scheme = call_579348.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579348.url(scheme.get, call_579348.host, call_579348.base,
                         call_579348.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579348, url, valid)

proc call*(call_579349: Call_DfareportingAdvertiserGroupsInsert_579336;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingAdvertiserGroupsInsert
  ## Inserts a new advertiser group.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579350 = newJObject()
  var query_579351 = newJObject()
  var body_579352 = newJObject()
  add(query_579351, "key", newJString(key))
  add(query_579351, "prettyPrint", newJBool(prettyPrint))
  add(query_579351, "oauth_token", newJString(oauthToken))
  add(path_579350, "profileId", newJString(profileId))
  add(query_579351, "alt", newJString(alt))
  add(query_579351, "userIp", newJString(userIp))
  add(query_579351, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_579352 = body
  add(query_579351, "fields", newJString(fields))
  result = call_579349.call(path_579350, query_579351, nil, nil, body_579352)

var dfareportingAdvertiserGroupsInsert* = Call_DfareportingAdvertiserGroupsInsert_579336(
    name: "dfareportingAdvertiserGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsInsert_579337,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsInsert_579338,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsList_579298 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdvertiserGroupsList_579300(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsList_579299(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of advertiser groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579301 = path.getOrDefault("profileId")
  valid_579301 = validateParameter(valid_579301, JString, required = true,
                                 default = nil)
  if valid_579301 != nil:
    section.add "profileId", valid_579301
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser group June 2015", "advertiser group April 2015", or simply "advertiser group 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertisergroup" will match objects with name "my advertisergroup", "advertisergroup 2015", or simply "advertisergroup".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only advertiser groups with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_579302 = query.getOrDefault("key")
  valid_579302 = validateParameter(valid_579302, JString, required = false,
                                 default = nil)
  if valid_579302 != nil:
    section.add "key", valid_579302
  var valid_579303 = query.getOrDefault("prettyPrint")
  valid_579303 = validateParameter(valid_579303, JBool, required = false,
                                 default = newJBool(true))
  if valid_579303 != nil:
    section.add "prettyPrint", valid_579303
  var valid_579304 = query.getOrDefault("oauth_token")
  valid_579304 = validateParameter(valid_579304, JString, required = false,
                                 default = nil)
  if valid_579304 != nil:
    section.add "oauth_token", valid_579304
  var valid_579305 = query.getOrDefault("sortField")
  valid_579305 = validateParameter(valid_579305, JString, required = false,
                                 default = newJString("ID"))
  if valid_579305 != nil:
    section.add "sortField", valid_579305
  var valid_579306 = query.getOrDefault("alt")
  valid_579306 = validateParameter(valid_579306, JString, required = false,
                                 default = newJString("json"))
  if valid_579306 != nil:
    section.add "alt", valid_579306
  var valid_579307 = query.getOrDefault("userIp")
  valid_579307 = validateParameter(valid_579307, JString, required = false,
                                 default = nil)
  if valid_579307 != nil:
    section.add "userIp", valid_579307
  var valid_579308 = query.getOrDefault("quotaUser")
  valid_579308 = validateParameter(valid_579308, JString, required = false,
                                 default = nil)
  if valid_579308 != nil:
    section.add "quotaUser", valid_579308
  var valid_579309 = query.getOrDefault("pageToken")
  valid_579309 = validateParameter(valid_579309, JString, required = false,
                                 default = nil)
  if valid_579309 != nil:
    section.add "pageToken", valid_579309
  var valid_579310 = query.getOrDefault("searchString")
  valid_579310 = validateParameter(valid_579310, JString, required = false,
                                 default = nil)
  if valid_579310 != nil:
    section.add "searchString", valid_579310
  var valid_579311 = query.getOrDefault("sortOrder")
  valid_579311 = validateParameter(valid_579311, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_579311 != nil:
    section.add "sortOrder", valid_579311
  var valid_579312 = query.getOrDefault("ids")
  valid_579312 = validateParameter(valid_579312, JArray, required = false,
                                 default = nil)
  if valid_579312 != nil:
    section.add "ids", valid_579312
  var valid_579313 = query.getOrDefault("fields")
  valid_579313 = validateParameter(valid_579313, JString, required = false,
                                 default = nil)
  if valid_579313 != nil:
    section.add "fields", valid_579313
  var valid_579314 = query.getOrDefault("maxResults")
  valid_579314 = validateParameter(valid_579314, JInt, required = false,
                                 default = newJInt(1000))
  if valid_579314 != nil:
    section.add "maxResults", valid_579314
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579315: Call_DfareportingAdvertiserGroupsList_579298;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of advertiser groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_579315.validator(path, query, header, formData, body)
  let scheme = call_579315.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579315.url(scheme.get, call_579315.host, call_579315.base,
                         call_579315.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579315, url, valid)

proc call*(call_579316: Call_DfareportingAdvertiserGroupsList_579298;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; sortField: string = "ID"; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; pageToken: string = "";
          searchString: string = ""; sortOrder: string = "ASCENDING";
          ids: JsonNode = nil; fields: string = ""; maxResults: int = 1000): Recallable =
  ## dfareportingAdvertiserGroupsList
  ## Retrieves a list of advertiser groups, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser group June 2015", "advertiser group April 2015", or simply "advertiser group 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertisergroup" will match objects with name "my advertisergroup", "advertisergroup 2015", or simply "advertisergroup".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only advertiser groups with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_579317 = newJObject()
  var query_579318 = newJObject()
  add(query_579318, "key", newJString(key))
  add(query_579318, "prettyPrint", newJBool(prettyPrint))
  add(query_579318, "oauth_token", newJString(oauthToken))
  add(path_579317, "profileId", newJString(profileId))
  add(query_579318, "sortField", newJString(sortField))
  add(query_579318, "alt", newJString(alt))
  add(query_579318, "userIp", newJString(userIp))
  add(query_579318, "quotaUser", newJString(quotaUser))
  add(query_579318, "pageToken", newJString(pageToken))
  add(query_579318, "searchString", newJString(searchString))
  add(query_579318, "sortOrder", newJString(sortOrder))
  if ids != nil:
    query_579318.add "ids", ids
  add(query_579318, "fields", newJString(fields))
  add(query_579318, "maxResults", newJInt(maxResults))
  result = call_579316.call(path_579317, query_579318, nil, nil, nil)

var dfareportingAdvertiserGroupsList* = Call_DfareportingAdvertiserGroupsList_579298(
    name: "dfareportingAdvertiserGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsList_579299,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsList_579300,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsPatch_579353 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdvertiserGroupsPatch_579355(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsPatch_579354(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579356 = path.getOrDefault("profileId")
  valid_579356 = validateParameter(valid_579356, JString, required = true,
                                 default = nil)
  if valid_579356 != nil:
    section.add "profileId", valid_579356
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Advertiser group ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579357 = query.getOrDefault("key")
  valid_579357 = validateParameter(valid_579357, JString, required = false,
                                 default = nil)
  if valid_579357 != nil:
    section.add "key", valid_579357
  var valid_579358 = query.getOrDefault("prettyPrint")
  valid_579358 = validateParameter(valid_579358, JBool, required = false,
                                 default = newJBool(true))
  if valid_579358 != nil:
    section.add "prettyPrint", valid_579358
  var valid_579359 = query.getOrDefault("oauth_token")
  valid_579359 = validateParameter(valid_579359, JString, required = false,
                                 default = nil)
  if valid_579359 != nil:
    section.add "oauth_token", valid_579359
  var valid_579360 = query.getOrDefault("alt")
  valid_579360 = validateParameter(valid_579360, JString, required = false,
                                 default = newJString("json"))
  if valid_579360 != nil:
    section.add "alt", valid_579360
  var valid_579361 = query.getOrDefault("userIp")
  valid_579361 = validateParameter(valid_579361, JString, required = false,
                                 default = nil)
  if valid_579361 != nil:
    section.add "userIp", valid_579361
  var valid_579362 = query.getOrDefault("quotaUser")
  valid_579362 = validateParameter(valid_579362, JString, required = false,
                                 default = nil)
  if valid_579362 != nil:
    section.add "quotaUser", valid_579362
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_579363 = query.getOrDefault("id")
  valid_579363 = validateParameter(valid_579363, JString, required = true,
                                 default = nil)
  if valid_579363 != nil:
    section.add "id", valid_579363
  var valid_579364 = query.getOrDefault("fields")
  valid_579364 = validateParameter(valid_579364, JString, required = false,
                                 default = nil)
  if valid_579364 != nil:
    section.add "fields", valid_579364
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579366: Call_DfareportingAdvertiserGroupsPatch_579353;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing advertiser group. This method supports patch semantics.
  ## 
  let valid = call_579366.validator(path, query, header, formData, body)
  let scheme = call_579366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579366.url(scheme.get, call_579366.host, call_579366.base,
                         call_579366.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579366, url, valid)

proc call*(call_579367: Call_DfareportingAdvertiserGroupsPatch_579353;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingAdvertiserGroupsPatch
  ## Updates an existing advertiser group. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Advertiser group ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579368 = newJObject()
  var query_579369 = newJObject()
  var body_579370 = newJObject()
  add(query_579369, "key", newJString(key))
  add(query_579369, "prettyPrint", newJBool(prettyPrint))
  add(query_579369, "oauth_token", newJString(oauthToken))
  add(path_579368, "profileId", newJString(profileId))
  add(query_579369, "alt", newJString(alt))
  add(query_579369, "userIp", newJString(userIp))
  add(query_579369, "quotaUser", newJString(quotaUser))
  add(query_579369, "id", newJString(id))
  if body != nil:
    body_579370 = body
  add(query_579369, "fields", newJString(fields))
  result = call_579367.call(path_579368, query_579369, nil, nil, body_579370)

var dfareportingAdvertiserGroupsPatch* = Call_DfareportingAdvertiserGroupsPatch_579353(
    name: "dfareportingAdvertiserGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsPatch_579354,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsPatch_579355,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsGet_579371 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdvertiserGroupsGet_579373(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsGet_579372(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one advertiser group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Advertiser group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579374 = path.getOrDefault("profileId")
  valid_579374 = validateParameter(valid_579374, JString, required = true,
                                 default = nil)
  if valid_579374 != nil:
    section.add "profileId", valid_579374
  var valid_579375 = path.getOrDefault("id")
  valid_579375 = validateParameter(valid_579375, JString, required = true,
                                 default = nil)
  if valid_579375 != nil:
    section.add "id", valid_579375
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579376 = query.getOrDefault("key")
  valid_579376 = validateParameter(valid_579376, JString, required = false,
                                 default = nil)
  if valid_579376 != nil:
    section.add "key", valid_579376
  var valid_579377 = query.getOrDefault("prettyPrint")
  valid_579377 = validateParameter(valid_579377, JBool, required = false,
                                 default = newJBool(true))
  if valid_579377 != nil:
    section.add "prettyPrint", valid_579377
  var valid_579378 = query.getOrDefault("oauth_token")
  valid_579378 = validateParameter(valid_579378, JString, required = false,
                                 default = nil)
  if valid_579378 != nil:
    section.add "oauth_token", valid_579378
  var valid_579379 = query.getOrDefault("alt")
  valid_579379 = validateParameter(valid_579379, JString, required = false,
                                 default = newJString("json"))
  if valid_579379 != nil:
    section.add "alt", valid_579379
  var valid_579380 = query.getOrDefault("userIp")
  valid_579380 = validateParameter(valid_579380, JString, required = false,
                                 default = nil)
  if valid_579380 != nil:
    section.add "userIp", valid_579380
  var valid_579381 = query.getOrDefault("quotaUser")
  valid_579381 = validateParameter(valid_579381, JString, required = false,
                                 default = nil)
  if valid_579381 != nil:
    section.add "quotaUser", valid_579381
  var valid_579382 = query.getOrDefault("fields")
  valid_579382 = validateParameter(valid_579382, JString, required = false,
                                 default = nil)
  if valid_579382 != nil:
    section.add "fields", valid_579382
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579383: Call_DfareportingAdvertiserGroupsGet_579371;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one advertiser group by ID.
  ## 
  let valid = call_579383.validator(path, query, header, formData, body)
  let scheme = call_579383.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579383.url(scheme.get, call_579383.host, call_579383.base,
                         call_579383.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579383, url, valid)

proc call*(call_579384: Call_DfareportingAdvertiserGroupsGet_579371;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingAdvertiserGroupsGet
  ## Gets one advertiser group by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Advertiser group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579385 = newJObject()
  var query_579386 = newJObject()
  add(query_579386, "key", newJString(key))
  add(query_579386, "prettyPrint", newJBool(prettyPrint))
  add(query_579386, "oauth_token", newJString(oauthToken))
  add(path_579385, "profileId", newJString(profileId))
  add(path_579385, "id", newJString(id))
  add(query_579386, "alt", newJString(alt))
  add(query_579386, "userIp", newJString(userIp))
  add(query_579386, "quotaUser", newJString(quotaUser))
  add(query_579386, "fields", newJString(fields))
  result = call_579384.call(path_579385, query_579386, nil, nil, nil)

var dfareportingAdvertiserGroupsGet* = Call_DfareportingAdvertiserGroupsGet_579371(
    name: "dfareportingAdvertiserGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups/{id}",
    validator: validate_DfareportingAdvertiserGroupsGet_579372,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsGet_579373,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsDelete_579387 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdvertiserGroupsDelete_579389(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsDelete_579388(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing advertiser group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Advertiser group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579390 = path.getOrDefault("profileId")
  valid_579390 = validateParameter(valid_579390, JString, required = true,
                                 default = nil)
  if valid_579390 != nil:
    section.add "profileId", valid_579390
  var valid_579391 = path.getOrDefault("id")
  valid_579391 = validateParameter(valid_579391, JString, required = true,
                                 default = nil)
  if valid_579391 != nil:
    section.add "id", valid_579391
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579392 = query.getOrDefault("key")
  valid_579392 = validateParameter(valid_579392, JString, required = false,
                                 default = nil)
  if valid_579392 != nil:
    section.add "key", valid_579392
  var valid_579393 = query.getOrDefault("prettyPrint")
  valid_579393 = validateParameter(valid_579393, JBool, required = false,
                                 default = newJBool(true))
  if valid_579393 != nil:
    section.add "prettyPrint", valid_579393
  var valid_579394 = query.getOrDefault("oauth_token")
  valid_579394 = validateParameter(valid_579394, JString, required = false,
                                 default = nil)
  if valid_579394 != nil:
    section.add "oauth_token", valid_579394
  var valid_579395 = query.getOrDefault("alt")
  valid_579395 = validateParameter(valid_579395, JString, required = false,
                                 default = newJString("json"))
  if valid_579395 != nil:
    section.add "alt", valid_579395
  var valid_579396 = query.getOrDefault("userIp")
  valid_579396 = validateParameter(valid_579396, JString, required = false,
                                 default = nil)
  if valid_579396 != nil:
    section.add "userIp", valid_579396
  var valid_579397 = query.getOrDefault("quotaUser")
  valid_579397 = validateParameter(valid_579397, JString, required = false,
                                 default = nil)
  if valid_579397 != nil:
    section.add "quotaUser", valid_579397
  var valid_579398 = query.getOrDefault("fields")
  valid_579398 = validateParameter(valid_579398, JString, required = false,
                                 default = nil)
  if valid_579398 != nil:
    section.add "fields", valid_579398
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579399: Call_DfareportingAdvertiserGroupsDelete_579387;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing advertiser group.
  ## 
  let valid = call_579399.validator(path, query, header, formData, body)
  let scheme = call_579399.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579399.url(scheme.get, call_579399.host, call_579399.base,
                         call_579399.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579399, url, valid)

proc call*(call_579400: Call_DfareportingAdvertiserGroupsDelete_579387;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingAdvertiserGroupsDelete
  ## Deletes an existing advertiser group.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Advertiser group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579401 = newJObject()
  var query_579402 = newJObject()
  add(query_579402, "key", newJString(key))
  add(query_579402, "prettyPrint", newJBool(prettyPrint))
  add(query_579402, "oauth_token", newJString(oauthToken))
  add(path_579401, "profileId", newJString(profileId))
  add(path_579401, "id", newJString(id))
  add(query_579402, "alt", newJString(alt))
  add(query_579402, "userIp", newJString(userIp))
  add(query_579402, "quotaUser", newJString(quotaUser))
  add(query_579402, "fields", newJString(fields))
  result = call_579400.call(path_579401, query_579402, nil, nil, nil)

var dfareportingAdvertiserGroupsDelete* = Call_DfareportingAdvertiserGroupsDelete_579387(
    name: "dfareportingAdvertiserGroupsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups/{id}",
    validator: validate_DfareportingAdvertiserGroupsDelete_579388,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsDelete_579389,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersUpdate_579430 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdvertisersUpdate_579432(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersUpdate_579431(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579433 = path.getOrDefault("profileId")
  valid_579433 = validateParameter(valid_579433, JString, required = true,
                                 default = nil)
  if valid_579433 != nil:
    section.add "profileId", valid_579433
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579434 = query.getOrDefault("key")
  valid_579434 = validateParameter(valid_579434, JString, required = false,
                                 default = nil)
  if valid_579434 != nil:
    section.add "key", valid_579434
  var valid_579435 = query.getOrDefault("prettyPrint")
  valid_579435 = validateParameter(valid_579435, JBool, required = false,
                                 default = newJBool(true))
  if valid_579435 != nil:
    section.add "prettyPrint", valid_579435
  var valid_579436 = query.getOrDefault("oauth_token")
  valid_579436 = validateParameter(valid_579436, JString, required = false,
                                 default = nil)
  if valid_579436 != nil:
    section.add "oauth_token", valid_579436
  var valid_579437 = query.getOrDefault("alt")
  valid_579437 = validateParameter(valid_579437, JString, required = false,
                                 default = newJString("json"))
  if valid_579437 != nil:
    section.add "alt", valid_579437
  var valid_579438 = query.getOrDefault("userIp")
  valid_579438 = validateParameter(valid_579438, JString, required = false,
                                 default = nil)
  if valid_579438 != nil:
    section.add "userIp", valid_579438
  var valid_579439 = query.getOrDefault("quotaUser")
  valid_579439 = validateParameter(valid_579439, JString, required = false,
                                 default = nil)
  if valid_579439 != nil:
    section.add "quotaUser", valid_579439
  var valid_579440 = query.getOrDefault("fields")
  valid_579440 = validateParameter(valid_579440, JString, required = false,
                                 default = nil)
  if valid_579440 != nil:
    section.add "fields", valid_579440
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579442: Call_DfareportingAdvertisersUpdate_579430; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing advertiser.
  ## 
  let valid = call_579442.validator(path, query, header, formData, body)
  let scheme = call_579442.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579442.url(scheme.get, call_579442.host, call_579442.base,
                         call_579442.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579442, url, valid)

proc call*(call_579443: Call_DfareportingAdvertisersUpdate_579430;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingAdvertisersUpdate
  ## Updates an existing advertiser.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579444 = newJObject()
  var query_579445 = newJObject()
  var body_579446 = newJObject()
  add(query_579445, "key", newJString(key))
  add(query_579445, "prettyPrint", newJBool(prettyPrint))
  add(query_579445, "oauth_token", newJString(oauthToken))
  add(path_579444, "profileId", newJString(profileId))
  add(query_579445, "alt", newJString(alt))
  add(query_579445, "userIp", newJString(userIp))
  add(query_579445, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_579446 = body
  add(query_579445, "fields", newJString(fields))
  result = call_579443.call(path_579444, query_579445, nil, nil, body_579446)

var dfareportingAdvertisersUpdate* = Call_DfareportingAdvertisersUpdate_579430(
    name: "dfareportingAdvertisersUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersUpdate_579431,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersUpdate_579432,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersInsert_579447 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdvertisersInsert_579449(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersInsert_579448(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new advertiser.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579450 = path.getOrDefault("profileId")
  valid_579450 = validateParameter(valid_579450, JString, required = true,
                                 default = nil)
  if valid_579450 != nil:
    section.add "profileId", valid_579450
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579451 = query.getOrDefault("key")
  valid_579451 = validateParameter(valid_579451, JString, required = false,
                                 default = nil)
  if valid_579451 != nil:
    section.add "key", valid_579451
  var valid_579452 = query.getOrDefault("prettyPrint")
  valid_579452 = validateParameter(valid_579452, JBool, required = false,
                                 default = newJBool(true))
  if valid_579452 != nil:
    section.add "prettyPrint", valid_579452
  var valid_579453 = query.getOrDefault("oauth_token")
  valid_579453 = validateParameter(valid_579453, JString, required = false,
                                 default = nil)
  if valid_579453 != nil:
    section.add "oauth_token", valid_579453
  var valid_579454 = query.getOrDefault("alt")
  valid_579454 = validateParameter(valid_579454, JString, required = false,
                                 default = newJString("json"))
  if valid_579454 != nil:
    section.add "alt", valid_579454
  var valid_579455 = query.getOrDefault("userIp")
  valid_579455 = validateParameter(valid_579455, JString, required = false,
                                 default = nil)
  if valid_579455 != nil:
    section.add "userIp", valid_579455
  var valid_579456 = query.getOrDefault("quotaUser")
  valid_579456 = validateParameter(valid_579456, JString, required = false,
                                 default = nil)
  if valid_579456 != nil:
    section.add "quotaUser", valid_579456
  var valid_579457 = query.getOrDefault("fields")
  valid_579457 = validateParameter(valid_579457, JString, required = false,
                                 default = nil)
  if valid_579457 != nil:
    section.add "fields", valid_579457
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579459: Call_DfareportingAdvertisersInsert_579447; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new advertiser.
  ## 
  let valid = call_579459.validator(path, query, header, formData, body)
  let scheme = call_579459.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579459.url(scheme.get, call_579459.host, call_579459.base,
                         call_579459.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579459, url, valid)

proc call*(call_579460: Call_DfareportingAdvertisersInsert_579447;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingAdvertisersInsert
  ## Inserts a new advertiser.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579461 = newJObject()
  var query_579462 = newJObject()
  var body_579463 = newJObject()
  add(query_579462, "key", newJString(key))
  add(query_579462, "prettyPrint", newJBool(prettyPrint))
  add(query_579462, "oauth_token", newJString(oauthToken))
  add(path_579461, "profileId", newJString(profileId))
  add(query_579462, "alt", newJString(alt))
  add(query_579462, "userIp", newJString(userIp))
  add(query_579462, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_579463 = body
  add(query_579462, "fields", newJString(fields))
  result = call_579460.call(path_579461, query_579462, nil, nil, body_579463)

var dfareportingAdvertisersInsert* = Call_DfareportingAdvertisersInsert_579447(
    name: "dfareportingAdvertisersInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersInsert_579448,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersInsert_579449,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersList_579403 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdvertisersList_579405(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersList_579404(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of advertisers, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579406 = path.getOrDefault("profileId")
  valid_579406 = validateParameter(valid_579406, JString, required = true,
                                 default = nil)
  if valid_579406 != nil:
    section.add "profileId", valid_579406
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   floodlightConfigurationIds: JArray
  ##                             : Select only advertisers with these floodlight configuration IDs.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser June 2015", "advertiser April 2015", or simply "advertiser 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertiser" will match objects with name "my advertiser", "advertiser 2015", or simply "advertiser".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   subaccountId: JString
  ##               : Select only advertisers with these subaccount IDs.
  ##   onlyParent: JBool
  ##             : Select only advertisers which use another advertiser's floodlight configuration.
  ##   status: JString
  ##         : Select only advertisers with the specified status.
  ##   ids: JArray
  ##      : Select only advertisers with these IDs.
  ##   includeAdvertisersWithoutGroupsOnly: JBool
  ##                                      : Select only advertisers which do not belong to any advertiser group.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   advertiserGroupIds: JArray
  ##                     : Select only advertisers with these advertiser group IDs.
  section = newJObject()
  var valid_579407 = query.getOrDefault("key")
  valid_579407 = validateParameter(valid_579407, JString, required = false,
                                 default = nil)
  if valid_579407 != nil:
    section.add "key", valid_579407
  var valid_579408 = query.getOrDefault("prettyPrint")
  valid_579408 = validateParameter(valid_579408, JBool, required = false,
                                 default = newJBool(true))
  if valid_579408 != nil:
    section.add "prettyPrint", valid_579408
  var valid_579409 = query.getOrDefault("oauth_token")
  valid_579409 = validateParameter(valid_579409, JString, required = false,
                                 default = nil)
  if valid_579409 != nil:
    section.add "oauth_token", valid_579409
  var valid_579410 = query.getOrDefault("floodlightConfigurationIds")
  valid_579410 = validateParameter(valid_579410, JArray, required = false,
                                 default = nil)
  if valid_579410 != nil:
    section.add "floodlightConfigurationIds", valid_579410
  var valid_579411 = query.getOrDefault("sortField")
  valid_579411 = validateParameter(valid_579411, JString, required = false,
                                 default = newJString("ID"))
  if valid_579411 != nil:
    section.add "sortField", valid_579411
  var valid_579412 = query.getOrDefault("alt")
  valid_579412 = validateParameter(valid_579412, JString, required = false,
                                 default = newJString("json"))
  if valid_579412 != nil:
    section.add "alt", valid_579412
  var valid_579413 = query.getOrDefault("userIp")
  valid_579413 = validateParameter(valid_579413, JString, required = false,
                                 default = nil)
  if valid_579413 != nil:
    section.add "userIp", valid_579413
  var valid_579414 = query.getOrDefault("quotaUser")
  valid_579414 = validateParameter(valid_579414, JString, required = false,
                                 default = nil)
  if valid_579414 != nil:
    section.add "quotaUser", valid_579414
  var valid_579415 = query.getOrDefault("pageToken")
  valid_579415 = validateParameter(valid_579415, JString, required = false,
                                 default = nil)
  if valid_579415 != nil:
    section.add "pageToken", valid_579415
  var valid_579416 = query.getOrDefault("searchString")
  valid_579416 = validateParameter(valid_579416, JString, required = false,
                                 default = nil)
  if valid_579416 != nil:
    section.add "searchString", valid_579416
  var valid_579417 = query.getOrDefault("sortOrder")
  valid_579417 = validateParameter(valid_579417, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_579417 != nil:
    section.add "sortOrder", valid_579417
  var valid_579418 = query.getOrDefault("subaccountId")
  valid_579418 = validateParameter(valid_579418, JString, required = false,
                                 default = nil)
  if valid_579418 != nil:
    section.add "subaccountId", valid_579418
  var valid_579419 = query.getOrDefault("onlyParent")
  valid_579419 = validateParameter(valid_579419, JBool, required = false, default = nil)
  if valid_579419 != nil:
    section.add "onlyParent", valid_579419
  var valid_579420 = query.getOrDefault("status")
  valid_579420 = validateParameter(valid_579420, JString, required = false,
                                 default = newJString("APPROVED"))
  if valid_579420 != nil:
    section.add "status", valid_579420
  var valid_579421 = query.getOrDefault("ids")
  valid_579421 = validateParameter(valid_579421, JArray, required = false,
                                 default = nil)
  if valid_579421 != nil:
    section.add "ids", valid_579421
  var valid_579422 = query.getOrDefault("includeAdvertisersWithoutGroupsOnly")
  valid_579422 = validateParameter(valid_579422, JBool, required = false, default = nil)
  if valid_579422 != nil:
    section.add "includeAdvertisersWithoutGroupsOnly", valid_579422
  var valid_579423 = query.getOrDefault("fields")
  valid_579423 = validateParameter(valid_579423, JString, required = false,
                                 default = nil)
  if valid_579423 != nil:
    section.add "fields", valid_579423
  var valid_579424 = query.getOrDefault("maxResults")
  valid_579424 = validateParameter(valid_579424, JInt, required = false,
                                 default = newJInt(1000))
  if valid_579424 != nil:
    section.add "maxResults", valid_579424
  var valid_579425 = query.getOrDefault("advertiserGroupIds")
  valid_579425 = validateParameter(valid_579425, JArray, required = false,
                                 default = nil)
  if valid_579425 != nil:
    section.add "advertiserGroupIds", valid_579425
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579426: Call_DfareportingAdvertisersList_579403; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of advertisers, possibly filtered. This method supports paging.
  ## 
  let valid = call_579426.validator(path, query, header, formData, body)
  let scheme = call_579426.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579426.url(scheme.get, call_579426.host, call_579426.base,
                         call_579426.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579426, url, valid)

proc call*(call_579427: Call_DfareportingAdvertisersList_579403; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          floodlightConfigurationIds: JsonNode = nil; sortField: string = "ID";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          pageToken: string = ""; searchString: string = "";
          sortOrder: string = "ASCENDING"; subaccountId: string = "";
          onlyParent: bool = false; status: string = "APPROVED"; ids: JsonNode = nil;
          includeAdvertisersWithoutGroupsOnly: bool = false; fields: string = "";
          maxResults: int = 1000; advertiserGroupIds: JsonNode = nil): Recallable =
  ## dfareportingAdvertisersList
  ## Retrieves a list of advertisers, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   floodlightConfigurationIds: JArray
  ##                             : Select only advertisers with these floodlight configuration IDs.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser June 2015", "advertiser April 2015", or simply "advertiser 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertiser" will match objects with name "my advertiser", "advertiser 2015", or simply "advertiser".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   subaccountId: string
  ##               : Select only advertisers with these subaccount IDs.
  ##   onlyParent: bool
  ##             : Select only advertisers which use another advertiser's floodlight configuration.
  ##   status: string
  ##         : Select only advertisers with the specified status.
  ##   ids: JArray
  ##      : Select only advertisers with these IDs.
  ##   includeAdvertisersWithoutGroupsOnly: bool
  ##                                      : Select only advertisers which do not belong to any advertiser group.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   advertiserGroupIds: JArray
  ##                     : Select only advertisers with these advertiser group IDs.
  var path_579428 = newJObject()
  var query_579429 = newJObject()
  add(query_579429, "key", newJString(key))
  add(query_579429, "prettyPrint", newJBool(prettyPrint))
  add(query_579429, "oauth_token", newJString(oauthToken))
  if floodlightConfigurationIds != nil:
    query_579429.add "floodlightConfigurationIds", floodlightConfigurationIds
  add(path_579428, "profileId", newJString(profileId))
  add(query_579429, "sortField", newJString(sortField))
  add(query_579429, "alt", newJString(alt))
  add(query_579429, "userIp", newJString(userIp))
  add(query_579429, "quotaUser", newJString(quotaUser))
  add(query_579429, "pageToken", newJString(pageToken))
  add(query_579429, "searchString", newJString(searchString))
  add(query_579429, "sortOrder", newJString(sortOrder))
  add(query_579429, "subaccountId", newJString(subaccountId))
  add(query_579429, "onlyParent", newJBool(onlyParent))
  add(query_579429, "status", newJString(status))
  if ids != nil:
    query_579429.add "ids", ids
  add(query_579429, "includeAdvertisersWithoutGroupsOnly",
      newJBool(includeAdvertisersWithoutGroupsOnly))
  add(query_579429, "fields", newJString(fields))
  add(query_579429, "maxResults", newJInt(maxResults))
  if advertiserGroupIds != nil:
    query_579429.add "advertiserGroupIds", advertiserGroupIds
  result = call_579427.call(path_579428, query_579429, nil, nil, nil)

var dfareportingAdvertisersList* = Call_DfareportingAdvertisersList_579403(
    name: "dfareportingAdvertisersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersList_579404,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersList_579405,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersPatch_579464 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdvertisersPatch_579466(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersPatch_579465(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579467 = path.getOrDefault("profileId")
  valid_579467 = validateParameter(valid_579467, JString, required = true,
                                 default = nil)
  if valid_579467 != nil:
    section.add "profileId", valid_579467
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Advertiser ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579468 = query.getOrDefault("key")
  valid_579468 = validateParameter(valid_579468, JString, required = false,
                                 default = nil)
  if valid_579468 != nil:
    section.add "key", valid_579468
  var valid_579469 = query.getOrDefault("prettyPrint")
  valid_579469 = validateParameter(valid_579469, JBool, required = false,
                                 default = newJBool(true))
  if valid_579469 != nil:
    section.add "prettyPrint", valid_579469
  var valid_579470 = query.getOrDefault("oauth_token")
  valid_579470 = validateParameter(valid_579470, JString, required = false,
                                 default = nil)
  if valid_579470 != nil:
    section.add "oauth_token", valid_579470
  var valid_579471 = query.getOrDefault("alt")
  valid_579471 = validateParameter(valid_579471, JString, required = false,
                                 default = newJString("json"))
  if valid_579471 != nil:
    section.add "alt", valid_579471
  var valid_579472 = query.getOrDefault("userIp")
  valid_579472 = validateParameter(valid_579472, JString, required = false,
                                 default = nil)
  if valid_579472 != nil:
    section.add "userIp", valid_579472
  var valid_579473 = query.getOrDefault("quotaUser")
  valid_579473 = validateParameter(valid_579473, JString, required = false,
                                 default = nil)
  if valid_579473 != nil:
    section.add "quotaUser", valid_579473
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_579474 = query.getOrDefault("id")
  valid_579474 = validateParameter(valid_579474, JString, required = true,
                                 default = nil)
  if valid_579474 != nil:
    section.add "id", valid_579474
  var valid_579475 = query.getOrDefault("fields")
  valid_579475 = validateParameter(valid_579475, JString, required = false,
                                 default = nil)
  if valid_579475 != nil:
    section.add "fields", valid_579475
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579477: Call_DfareportingAdvertisersPatch_579464; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing advertiser. This method supports patch semantics.
  ## 
  let valid = call_579477.validator(path, query, header, formData, body)
  let scheme = call_579477.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579477.url(scheme.get, call_579477.host, call_579477.base,
                         call_579477.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579477, url, valid)

proc call*(call_579478: Call_DfareportingAdvertisersPatch_579464;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingAdvertisersPatch
  ## Updates an existing advertiser. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Advertiser ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579479 = newJObject()
  var query_579480 = newJObject()
  var body_579481 = newJObject()
  add(query_579480, "key", newJString(key))
  add(query_579480, "prettyPrint", newJBool(prettyPrint))
  add(query_579480, "oauth_token", newJString(oauthToken))
  add(path_579479, "profileId", newJString(profileId))
  add(query_579480, "alt", newJString(alt))
  add(query_579480, "userIp", newJString(userIp))
  add(query_579480, "quotaUser", newJString(quotaUser))
  add(query_579480, "id", newJString(id))
  if body != nil:
    body_579481 = body
  add(query_579480, "fields", newJString(fields))
  result = call_579478.call(path_579479, query_579480, nil, nil, body_579481)

var dfareportingAdvertisersPatch* = Call_DfareportingAdvertisersPatch_579464(
    name: "dfareportingAdvertisersPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersPatch_579465,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersPatch_579466,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersGet_579482 = ref object of OpenApiRestCall_578364
proc url_DfareportingAdvertisersGet_579484(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersGet_579483(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one advertiser by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Advertiser ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579485 = path.getOrDefault("profileId")
  valid_579485 = validateParameter(valid_579485, JString, required = true,
                                 default = nil)
  if valid_579485 != nil:
    section.add "profileId", valid_579485
  var valid_579486 = path.getOrDefault("id")
  valid_579486 = validateParameter(valid_579486, JString, required = true,
                                 default = nil)
  if valid_579486 != nil:
    section.add "id", valid_579486
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579487 = query.getOrDefault("key")
  valid_579487 = validateParameter(valid_579487, JString, required = false,
                                 default = nil)
  if valid_579487 != nil:
    section.add "key", valid_579487
  var valid_579488 = query.getOrDefault("prettyPrint")
  valid_579488 = validateParameter(valid_579488, JBool, required = false,
                                 default = newJBool(true))
  if valid_579488 != nil:
    section.add "prettyPrint", valid_579488
  var valid_579489 = query.getOrDefault("oauth_token")
  valid_579489 = validateParameter(valid_579489, JString, required = false,
                                 default = nil)
  if valid_579489 != nil:
    section.add "oauth_token", valid_579489
  var valid_579490 = query.getOrDefault("alt")
  valid_579490 = validateParameter(valid_579490, JString, required = false,
                                 default = newJString("json"))
  if valid_579490 != nil:
    section.add "alt", valid_579490
  var valid_579491 = query.getOrDefault("userIp")
  valid_579491 = validateParameter(valid_579491, JString, required = false,
                                 default = nil)
  if valid_579491 != nil:
    section.add "userIp", valid_579491
  var valid_579492 = query.getOrDefault("quotaUser")
  valid_579492 = validateParameter(valid_579492, JString, required = false,
                                 default = nil)
  if valid_579492 != nil:
    section.add "quotaUser", valid_579492
  var valid_579493 = query.getOrDefault("fields")
  valid_579493 = validateParameter(valid_579493, JString, required = false,
                                 default = nil)
  if valid_579493 != nil:
    section.add "fields", valid_579493
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579494: Call_DfareportingAdvertisersGet_579482; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one advertiser by ID.
  ## 
  let valid = call_579494.validator(path, query, header, formData, body)
  let scheme = call_579494.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579494.url(scheme.get, call_579494.host, call_579494.base,
                         call_579494.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579494, url, valid)

proc call*(call_579495: Call_DfareportingAdvertisersGet_579482; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingAdvertisersGet
  ## Gets one advertiser by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Advertiser ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579496 = newJObject()
  var query_579497 = newJObject()
  add(query_579497, "key", newJString(key))
  add(query_579497, "prettyPrint", newJBool(prettyPrint))
  add(query_579497, "oauth_token", newJString(oauthToken))
  add(path_579496, "profileId", newJString(profileId))
  add(path_579496, "id", newJString(id))
  add(query_579497, "alt", newJString(alt))
  add(query_579497, "userIp", newJString(userIp))
  add(query_579497, "quotaUser", newJString(quotaUser))
  add(query_579497, "fields", newJString(fields))
  result = call_579495.call(path_579496, query_579497, nil, nil, nil)

var dfareportingAdvertisersGet* = Call_DfareportingAdvertisersGet_579482(
    name: "dfareportingAdvertisersGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertisers/{id}",
    validator: validate_DfareportingAdvertisersGet_579483,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersGet_579484,
    schemes: {Scheme.Https})
type
  Call_DfareportingBrowsersList_579498 = ref object of OpenApiRestCall_578364
proc url_DfareportingBrowsersList_579500(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/browsers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingBrowsersList_579499(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of browsers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579501 = path.getOrDefault("profileId")
  valid_579501 = validateParameter(valid_579501, JString, required = true,
                                 default = nil)
  if valid_579501 != nil:
    section.add "profileId", valid_579501
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579502 = query.getOrDefault("key")
  valid_579502 = validateParameter(valid_579502, JString, required = false,
                                 default = nil)
  if valid_579502 != nil:
    section.add "key", valid_579502
  var valid_579503 = query.getOrDefault("prettyPrint")
  valid_579503 = validateParameter(valid_579503, JBool, required = false,
                                 default = newJBool(true))
  if valid_579503 != nil:
    section.add "prettyPrint", valid_579503
  var valid_579504 = query.getOrDefault("oauth_token")
  valid_579504 = validateParameter(valid_579504, JString, required = false,
                                 default = nil)
  if valid_579504 != nil:
    section.add "oauth_token", valid_579504
  var valid_579505 = query.getOrDefault("alt")
  valid_579505 = validateParameter(valid_579505, JString, required = false,
                                 default = newJString("json"))
  if valid_579505 != nil:
    section.add "alt", valid_579505
  var valid_579506 = query.getOrDefault("userIp")
  valid_579506 = validateParameter(valid_579506, JString, required = false,
                                 default = nil)
  if valid_579506 != nil:
    section.add "userIp", valid_579506
  var valid_579507 = query.getOrDefault("quotaUser")
  valid_579507 = validateParameter(valid_579507, JString, required = false,
                                 default = nil)
  if valid_579507 != nil:
    section.add "quotaUser", valid_579507
  var valid_579508 = query.getOrDefault("fields")
  valid_579508 = validateParameter(valid_579508, JString, required = false,
                                 default = nil)
  if valid_579508 != nil:
    section.add "fields", valid_579508
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579509: Call_DfareportingBrowsersList_579498; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of browsers.
  ## 
  let valid = call_579509.validator(path, query, header, formData, body)
  let scheme = call_579509.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579509.url(scheme.get, call_579509.host, call_579509.base,
                         call_579509.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579509, url, valid)

proc call*(call_579510: Call_DfareportingBrowsersList_579498; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingBrowsersList
  ## Retrieves a list of browsers.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579511 = newJObject()
  var query_579512 = newJObject()
  add(query_579512, "key", newJString(key))
  add(query_579512, "prettyPrint", newJBool(prettyPrint))
  add(query_579512, "oauth_token", newJString(oauthToken))
  add(path_579511, "profileId", newJString(profileId))
  add(query_579512, "alt", newJString(alt))
  add(query_579512, "userIp", newJString(userIp))
  add(query_579512, "quotaUser", newJString(quotaUser))
  add(query_579512, "fields", newJString(fields))
  result = call_579510.call(path_579511, query_579512, nil, nil, nil)

var dfareportingBrowsersList* = Call_DfareportingBrowsersList_579498(
    name: "dfareportingBrowsersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/browsers",
    validator: validate_DfareportingBrowsersList_579499,
    base: "/dfareporting/v2.7", url: url_DfareportingBrowsersList_579500,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsUpdate_579541 = ref object of OpenApiRestCall_578364
proc url_DfareportingCampaignsUpdate_579543(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsUpdate_579542(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579544 = path.getOrDefault("profileId")
  valid_579544 = validateParameter(valid_579544, JString, required = true,
                                 default = nil)
  if valid_579544 != nil:
    section.add "profileId", valid_579544
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579545 = query.getOrDefault("key")
  valid_579545 = validateParameter(valid_579545, JString, required = false,
                                 default = nil)
  if valid_579545 != nil:
    section.add "key", valid_579545
  var valid_579546 = query.getOrDefault("prettyPrint")
  valid_579546 = validateParameter(valid_579546, JBool, required = false,
                                 default = newJBool(true))
  if valid_579546 != nil:
    section.add "prettyPrint", valid_579546
  var valid_579547 = query.getOrDefault("oauth_token")
  valid_579547 = validateParameter(valid_579547, JString, required = false,
                                 default = nil)
  if valid_579547 != nil:
    section.add "oauth_token", valid_579547
  var valid_579548 = query.getOrDefault("alt")
  valid_579548 = validateParameter(valid_579548, JString, required = false,
                                 default = newJString("json"))
  if valid_579548 != nil:
    section.add "alt", valid_579548
  var valid_579549 = query.getOrDefault("userIp")
  valid_579549 = validateParameter(valid_579549, JString, required = false,
                                 default = nil)
  if valid_579549 != nil:
    section.add "userIp", valid_579549
  var valid_579550 = query.getOrDefault("quotaUser")
  valid_579550 = validateParameter(valid_579550, JString, required = false,
                                 default = nil)
  if valid_579550 != nil:
    section.add "quotaUser", valid_579550
  var valid_579551 = query.getOrDefault("fields")
  valid_579551 = validateParameter(valid_579551, JString, required = false,
                                 default = nil)
  if valid_579551 != nil:
    section.add "fields", valid_579551
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579553: Call_DfareportingCampaignsUpdate_579541; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign.
  ## 
  let valid = call_579553.validator(path, query, header, formData, body)
  let scheme = call_579553.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579553.url(scheme.get, call_579553.host, call_579553.base,
                         call_579553.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579553, url, valid)

proc call*(call_579554: Call_DfareportingCampaignsUpdate_579541; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingCampaignsUpdate
  ## Updates an existing campaign.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579555 = newJObject()
  var query_579556 = newJObject()
  var body_579557 = newJObject()
  add(query_579556, "key", newJString(key))
  add(query_579556, "prettyPrint", newJBool(prettyPrint))
  add(query_579556, "oauth_token", newJString(oauthToken))
  add(path_579555, "profileId", newJString(profileId))
  add(query_579556, "alt", newJString(alt))
  add(query_579556, "userIp", newJString(userIp))
  add(query_579556, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_579557 = body
  add(query_579556, "fields", newJString(fields))
  result = call_579554.call(path_579555, query_579556, nil, nil, body_579557)

var dfareportingCampaignsUpdate* = Call_DfareportingCampaignsUpdate_579541(
    name: "dfareportingCampaignsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsUpdate_579542,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsUpdate_579543,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsInsert_579558 = ref object of OpenApiRestCall_578364
proc url_DfareportingCampaignsInsert_579560(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsInsert_579559(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579561 = path.getOrDefault("profileId")
  valid_579561 = validateParameter(valid_579561, JString, required = true,
                                 default = nil)
  if valid_579561 != nil:
    section.add "profileId", valid_579561
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   defaultLandingPageUrl: JString (required)
  ##                        : Default landing page URL for this new campaign.
  ##   defaultLandingPageName: JString (required)
  ##                         : Default landing page name for this new campaign. Must be less than 256 characters long.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579562 = query.getOrDefault("key")
  valid_579562 = validateParameter(valid_579562, JString, required = false,
                                 default = nil)
  if valid_579562 != nil:
    section.add "key", valid_579562
  var valid_579563 = query.getOrDefault("prettyPrint")
  valid_579563 = validateParameter(valid_579563, JBool, required = false,
                                 default = newJBool(true))
  if valid_579563 != nil:
    section.add "prettyPrint", valid_579563
  var valid_579564 = query.getOrDefault("oauth_token")
  valid_579564 = validateParameter(valid_579564, JString, required = false,
                                 default = nil)
  if valid_579564 != nil:
    section.add "oauth_token", valid_579564
  assert query != nil, "query argument is necessary due to required `defaultLandingPageUrl` field"
  var valid_579565 = query.getOrDefault("defaultLandingPageUrl")
  valid_579565 = validateParameter(valid_579565, JString, required = true,
                                 default = nil)
  if valid_579565 != nil:
    section.add "defaultLandingPageUrl", valid_579565
  var valid_579566 = query.getOrDefault("defaultLandingPageName")
  valid_579566 = validateParameter(valid_579566, JString, required = true,
                                 default = nil)
  if valid_579566 != nil:
    section.add "defaultLandingPageName", valid_579566
  var valid_579567 = query.getOrDefault("alt")
  valid_579567 = validateParameter(valid_579567, JString, required = false,
                                 default = newJString("json"))
  if valid_579567 != nil:
    section.add "alt", valid_579567
  var valid_579568 = query.getOrDefault("userIp")
  valid_579568 = validateParameter(valid_579568, JString, required = false,
                                 default = nil)
  if valid_579568 != nil:
    section.add "userIp", valid_579568
  var valid_579569 = query.getOrDefault("quotaUser")
  valid_579569 = validateParameter(valid_579569, JString, required = false,
                                 default = nil)
  if valid_579569 != nil:
    section.add "quotaUser", valid_579569
  var valid_579570 = query.getOrDefault("fields")
  valid_579570 = validateParameter(valid_579570, JString, required = false,
                                 default = nil)
  if valid_579570 != nil:
    section.add "fields", valid_579570
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579572: Call_DfareportingCampaignsInsert_579558; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new campaign.
  ## 
  let valid = call_579572.validator(path, query, header, formData, body)
  let scheme = call_579572.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579572.url(scheme.get, call_579572.host, call_579572.base,
                         call_579572.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579572, url, valid)

proc call*(call_579573: Call_DfareportingCampaignsInsert_579558;
          defaultLandingPageUrl: string; defaultLandingPageName: string;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingCampaignsInsert
  ## Inserts a new campaign.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   defaultLandingPageUrl: string (required)
  ##                        : Default landing page URL for this new campaign.
  ##   defaultLandingPageName: string (required)
  ##                         : Default landing page name for this new campaign. Must be less than 256 characters long.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579574 = newJObject()
  var query_579575 = newJObject()
  var body_579576 = newJObject()
  add(query_579575, "key", newJString(key))
  add(query_579575, "prettyPrint", newJBool(prettyPrint))
  add(query_579575, "oauth_token", newJString(oauthToken))
  add(query_579575, "defaultLandingPageUrl", newJString(defaultLandingPageUrl))
  add(query_579575, "defaultLandingPageName", newJString(defaultLandingPageName))
  add(path_579574, "profileId", newJString(profileId))
  add(query_579575, "alt", newJString(alt))
  add(query_579575, "userIp", newJString(userIp))
  add(query_579575, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_579576 = body
  add(query_579575, "fields", newJString(fields))
  result = call_579573.call(path_579574, query_579575, nil, nil, body_579576)

var dfareportingCampaignsInsert* = Call_DfareportingCampaignsInsert_579558(
    name: "dfareportingCampaignsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsInsert_579559,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsInsert_579560,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsList_579513 = ref object of OpenApiRestCall_578364
proc url_DfareportingCampaignsList_579515(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsList_579514(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of campaigns, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579516 = path.getOrDefault("profileId")
  valid_579516 = validateParameter(valid_579516, JString, required = true,
                                 default = nil)
  if valid_579516 != nil:
    section.add "profileId", valid_579516
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   advertiserIds: JArray
  ##                : Select only campaigns that belong to these advertisers.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: JBool
  ##           : Select only archived campaigns. Don't set this field to select both archived and non-archived campaigns.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   overriddenEventTagId: JString
  ##                       : Select only campaigns that have overridden this event tag ID.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for campaigns by name or ID. Wildcards (*) are allowed. For example, "campaign*2015" will return campaigns with names like "campaign June 2015", "campaign April 2015", or simply "campaign 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "campaign" will match campaigns with name "my campaign", "campaign 2015", or simply "campaign".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   subaccountId: JString
  ##               : Select only campaigns that belong to this subaccount.
  ##   atLeastOneOptimizationActivity: JBool
  ##                                 : Select only campaigns that have at least one optimization activity.
  ##   ids: JArray
  ##      : Select only campaigns with these IDs.
  ##   excludedIds: JArray
  ##              : Exclude campaigns with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   advertiserGroupIds: JArray
  ##                     : Select only campaigns whose advertisers belong to these advertiser groups.
  section = newJObject()
  var valid_579517 = query.getOrDefault("key")
  valid_579517 = validateParameter(valid_579517, JString, required = false,
                                 default = nil)
  if valid_579517 != nil:
    section.add "key", valid_579517
  var valid_579518 = query.getOrDefault("prettyPrint")
  valid_579518 = validateParameter(valid_579518, JBool, required = false,
                                 default = newJBool(true))
  if valid_579518 != nil:
    section.add "prettyPrint", valid_579518
  var valid_579519 = query.getOrDefault("oauth_token")
  valid_579519 = validateParameter(valid_579519, JString, required = false,
                                 default = nil)
  if valid_579519 != nil:
    section.add "oauth_token", valid_579519
  var valid_579520 = query.getOrDefault("sortField")
  valid_579520 = validateParameter(valid_579520, JString, required = false,
                                 default = newJString("ID"))
  if valid_579520 != nil:
    section.add "sortField", valid_579520
  var valid_579521 = query.getOrDefault("advertiserIds")
  valid_579521 = validateParameter(valid_579521, JArray, required = false,
                                 default = nil)
  if valid_579521 != nil:
    section.add "advertiserIds", valid_579521
  var valid_579522 = query.getOrDefault("alt")
  valid_579522 = validateParameter(valid_579522, JString, required = false,
                                 default = newJString("json"))
  if valid_579522 != nil:
    section.add "alt", valid_579522
  var valid_579523 = query.getOrDefault("userIp")
  valid_579523 = validateParameter(valid_579523, JString, required = false,
                                 default = nil)
  if valid_579523 != nil:
    section.add "userIp", valid_579523
  var valid_579524 = query.getOrDefault("archived")
  valid_579524 = validateParameter(valid_579524, JBool, required = false, default = nil)
  if valid_579524 != nil:
    section.add "archived", valid_579524
  var valid_579525 = query.getOrDefault("quotaUser")
  valid_579525 = validateParameter(valid_579525, JString, required = false,
                                 default = nil)
  if valid_579525 != nil:
    section.add "quotaUser", valid_579525
  var valid_579526 = query.getOrDefault("overriddenEventTagId")
  valid_579526 = validateParameter(valid_579526, JString, required = false,
                                 default = nil)
  if valid_579526 != nil:
    section.add "overriddenEventTagId", valid_579526
  var valid_579527 = query.getOrDefault("pageToken")
  valid_579527 = validateParameter(valid_579527, JString, required = false,
                                 default = nil)
  if valid_579527 != nil:
    section.add "pageToken", valid_579527
  var valid_579528 = query.getOrDefault("searchString")
  valid_579528 = validateParameter(valid_579528, JString, required = false,
                                 default = nil)
  if valid_579528 != nil:
    section.add "searchString", valid_579528
  var valid_579529 = query.getOrDefault("sortOrder")
  valid_579529 = validateParameter(valid_579529, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_579529 != nil:
    section.add "sortOrder", valid_579529
  var valid_579530 = query.getOrDefault("subaccountId")
  valid_579530 = validateParameter(valid_579530, JString, required = false,
                                 default = nil)
  if valid_579530 != nil:
    section.add "subaccountId", valid_579530
  var valid_579531 = query.getOrDefault("atLeastOneOptimizationActivity")
  valid_579531 = validateParameter(valid_579531, JBool, required = false, default = nil)
  if valid_579531 != nil:
    section.add "atLeastOneOptimizationActivity", valid_579531
  var valid_579532 = query.getOrDefault("ids")
  valid_579532 = validateParameter(valid_579532, JArray, required = false,
                                 default = nil)
  if valid_579532 != nil:
    section.add "ids", valid_579532
  var valid_579533 = query.getOrDefault("excludedIds")
  valid_579533 = validateParameter(valid_579533, JArray, required = false,
                                 default = nil)
  if valid_579533 != nil:
    section.add "excludedIds", valid_579533
  var valid_579534 = query.getOrDefault("fields")
  valid_579534 = validateParameter(valid_579534, JString, required = false,
                                 default = nil)
  if valid_579534 != nil:
    section.add "fields", valid_579534
  var valid_579535 = query.getOrDefault("maxResults")
  valid_579535 = validateParameter(valid_579535, JInt, required = false,
                                 default = newJInt(1000))
  if valid_579535 != nil:
    section.add "maxResults", valid_579535
  var valid_579536 = query.getOrDefault("advertiserGroupIds")
  valid_579536 = validateParameter(valid_579536, JArray, required = false,
                                 default = nil)
  if valid_579536 != nil:
    section.add "advertiserGroupIds", valid_579536
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579537: Call_DfareportingCampaignsList_579513; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of campaigns, possibly filtered. This method supports paging.
  ## 
  let valid = call_579537.validator(path, query, header, formData, body)
  let scheme = call_579537.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579537.url(scheme.get, call_579537.host, call_579537.base,
                         call_579537.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579537, url, valid)

proc call*(call_579538: Call_DfareportingCampaignsList_579513; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          sortField: string = "ID"; advertiserIds: JsonNode = nil; alt: string = "json";
          userIp: string = ""; archived: bool = false; quotaUser: string = "";
          overriddenEventTagId: string = ""; pageToken: string = "";
          searchString: string = ""; sortOrder: string = "ASCENDING";
          subaccountId: string = ""; atLeastOneOptimizationActivity: bool = false;
          ids: JsonNode = nil; excludedIds: JsonNode = nil; fields: string = "";
          maxResults: int = 1000; advertiserGroupIds: JsonNode = nil): Recallable =
  ## dfareportingCampaignsList
  ## Retrieves a list of campaigns, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   advertiserIds: JArray
  ##                : Select only campaigns that belong to these advertisers.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: bool
  ##           : Select only archived campaigns. Don't set this field to select both archived and non-archived campaigns.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   overriddenEventTagId: string
  ##                       : Select only campaigns that have overridden this event tag ID.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for campaigns by name or ID. Wildcards (*) are allowed. For example, "campaign*2015" will return campaigns with names like "campaign June 2015", "campaign April 2015", or simply "campaign 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "campaign" will match campaigns with name "my campaign", "campaign 2015", or simply "campaign".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   subaccountId: string
  ##               : Select only campaigns that belong to this subaccount.
  ##   atLeastOneOptimizationActivity: bool
  ##                                 : Select only campaigns that have at least one optimization activity.
  ##   ids: JArray
  ##      : Select only campaigns with these IDs.
  ##   excludedIds: JArray
  ##              : Exclude campaigns with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   advertiserGroupIds: JArray
  ##                     : Select only campaigns whose advertisers belong to these advertiser groups.
  var path_579539 = newJObject()
  var query_579540 = newJObject()
  add(query_579540, "key", newJString(key))
  add(query_579540, "prettyPrint", newJBool(prettyPrint))
  add(query_579540, "oauth_token", newJString(oauthToken))
  add(path_579539, "profileId", newJString(profileId))
  add(query_579540, "sortField", newJString(sortField))
  if advertiserIds != nil:
    query_579540.add "advertiserIds", advertiserIds
  add(query_579540, "alt", newJString(alt))
  add(query_579540, "userIp", newJString(userIp))
  add(query_579540, "archived", newJBool(archived))
  add(query_579540, "quotaUser", newJString(quotaUser))
  add(query_579540, "overriddenEventTagId", newJString(overriddenEventTagId))
  add(query_579540, "pageToken", newJString(pageToken))
  add(query_579540, "searchString", newJString(searchString))
  add(query_579540, "sortOrder", newJString(sortOrder))
  add(query_579540, "subaccountId", newJString(subaccountId))
  add(query_579540, "atLeastOneOptimizationActivity",
      newJBool(atLeastOneOptimizationActivity))
  if ids != nil:
    query_579540.add "ids", ids
  if excludedIds != nil:
    query_579540.add "excludedIds", excludedIds
  add(query_579540, "fields", newJString(fields))
  add(query_579540, "maxResults", newJInt(maxResults))
  if advertiserGroupIds != nil:
    query_579540.add "advertiserGroupIds", advertiserGroupIds
  result = call_579538.call(path_579539, query_579540, nil, nil, nil)

var dfareportingCampaignsList* = Call_DfareportingCampaignsList_579513(
    name: "dfareportingCampaignsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsList_579514,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsList_579515,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsPatch_579577 = ref object of OpenApiRestCall_578364
proc url_DfareportingCampaignsPatch_579579(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsPatch_579578(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579580 = path.getOrDefault("profileId")
  valid_579580 = validateParameter(valid_579580, JString, required = true,
                                 default = nil)
  if valid_579580 != nil:
    section.add "profileId", valid_579580
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Campaign ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579581 = query.getOrDefault("key")
  valid_579581 = validateParameter(valid_579581, JString, required = false,
                                 default = nil)
  if valid_579581 != nil:
    section.add "key", valid_579581
  var valid_579582 = query.getOrDefault("prettyPrint")
  valid_579582 = validateParameter(valid_579582, JBool, required = false,
                                 default = newJBool(true))
  if valid_579582 != nil:
    section.add "prettyPrint", valid_579582
  var valid_579583 = query.getOrDefault("oauth_token")
  valid_579583 = validateParameter(valid_579583, JString, required = false,
                                 default = nil)
  if valid_579583 != nil:
    section.add "oauth_token", valid_579583
  var valid_579584 = query.getOrDefault("alt")
  valid_579584 = validateParameter(valid_579584, JString, required = false,
                                 default = newJString("json"))
  if valid_579584 != nil:
    section.add "alt", valid_579584
  var valid_579585 = query.getOrDefault("userIp")
  valid_579585 = validateParameter(valid_579585, JString, required = false,
                                 default = nil)
  if valid_579585 != nil:
    section.add "userIp", valid_579585
  var valid_579586 = query.getOrDefault("quotaUser")
  valid_579586 = validateParameter(valid_579586, JString, required = false,
                                 default = nil)
  if valid_579586 != nil:
    section.add "quotaUser", valid_579586
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_579587 = query.getOrDefault("id")
  valid_579587 = validateParameter(valid_579587, JString, required = true,
                                 default = nil)
  if valid_579587 != nil:
    section.add "id", valid_579587
  var valid_579588 = query.getOrDefault("fields")
  valid_579588 = validateParameter(valid_579588, JString, required = false,
                                 default = nil)
  if valid_579588 != nil:
    section.add "fields", valid_579588
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579590: Call_DfareportingCampaignsPatch_579577; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign. This method supports patch semantics.
  ## 
  let valid = call_579590.validator(path, query, header, formData, body)
  let scheme = call_579590.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579590.url(scheme.get, call_579590.host, call_579590.base,
                         call_579590.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579590, url, valid)

proc call*(call_579591: Call_DfareportingCampaignsPatch_579577; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingCampaignsPatch
  ## Updates an existing campaign. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Campaign ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579592 = newJObject()
  var query_579593 = newJObject()
  var body_579594 = newJObject()
  add(query_579593, "key", newJString(key))
  add(query_579593, "prettyPrint", newJBool(prettyPrint))
  add(query_579593, "oauth_token", newJString(oauthToken))
  add(path_579592, "profileId", newJString(profileId))
  add(query_579593, "alt", newJString(alt))
  add(query_579593, "userIp", newJString(userIp))
  add(query_579593, "quotaUser", newJString(quotaUser))
  add(query_579593, "id", newJString(id))
  if body != nil:
    body_579594 = body
  add(query_579593, "fields", newJString(fields))
  result = call_579591.call(path_579592, query_579593, nil, nil, body_579594)

var dfareportingCampaignsPatch* = Call_DfareportingCampaignsPatch_579577(
    name: "dfareportingCampaignsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsPatch_579578,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsPatch_579579,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignCreativeAssociationsInsert_579614 = ref object of OpenApiRestCall_578364
proc url_DfareportingCampaignCreativeAssociationsInsert_579616(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/campaignCreativeAssociations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignCreativeAssociationsInsert_579615(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Associates a creative with the specified campaign. This method creates a default ad with dimensions matching the creative in the campaign if such a default ad does not exist already.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Campaign ID in this association.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579617 = path.getOrDefault("profileId")
  valid_579617 = validateParameter(valid_579617, JString, required = true,
                                 default = nil)
  if valid_579617 != nil:
    section.add "profileId", valid_579617
  var valid_579618 = path.getOrDefault("campaignId")
  valid_579618 = validateParameter(valid_579618, JString, required = true,
                                 default = nil)
  if valid_579618 != nil:
    section.add "campaignId", valid_579618
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579619 = query.getOrDefault("key")
  valid_579619 = validateParameter(valid_579619, JString, required = false,
                                 default = nil)
  if valid_579619 != nil:
    section.add "key", valid_579619
  var valid_579620 = query.getOrDefault("prettyPrint")
  valid_579620 = validateParameter(valid_579620, JBool, required = false,
                                 default = newJBool(true))
  if valid_579620 != nil:
    section.add "prettyPrint", valid_579620
  var valid_579621 = query.getOrDefault("oauth_token")
  valid_579621 = validateParameter(valid_579621, JString, required = false,
                                 default = nil)
  if valid_579621 != nil:
    section.add "oauth_token", valid_579621
  var valid_579622 = query.getOrDefault("alt")
  valid_579622 = validateParameter(valid_579622, JString, required = false,
                                 default = newJString("json"))
  if valid_579622 != nil:
    section.add "alt", valid_579622
  var valid_579623 = query.getOrDefault("userIp")
  valid_579623 = validateParameter(valid_579623, JString, required = false,
                                 default = nil)
  if valid_579623 != nil:
    section.add "userIp", valid_579623
  var valid_579624 = query.getOrDefault("quotaUser")
  valid_579624 = validateParameter(valid_579624, JString, required = false,
                                 default = nil)
  if valid_579624 != nil:
    section.add "quotaUser", valid_579624
  var valid_579625 = query.getOrDefault("fields")
  valid_579625 = validateParameter(valid_579625, JString, required = false,
                                 default = nil)
  if valid_579625 != nil:
    section.add "fields", valid_579625
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579627: Call_DfareportingCampaignCreativeAssociationsInsert_579614;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Associates a creative with the specified campaign. This method creates a default ad with dimensions matching the creative in the campaign if such a default ad does not exist already.
  ## 
  let valid = call_579627.validator(path, query, header, formData, body)
  let scheme = call_579627.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579627.url(scheme.get, call_579627.host, call_579627.base,
                         call_579627.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579627, url, valid)

proc call*(call_579628: Call_DfareportingCampaignCreativeAssociationsInsert_579614;
          profileId: string; campaignId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; body: JsonNode = nil;
          fields: string = ""): Recallable =
  ## dfareportingCampaignCreativeAssociationsInsert
  ## Associates a creative with the specified campaign. This method creates a default ad with dimensions matching the creative in the campaign if such a default ad does not exist already.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   campaignId: string (required)
  ##             : Campaign ID in this association.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579629 = newJObject()
  var query_579630 = newJObject()
  var body_579631 = newJObject()
  add(query_579630, "key", newJString(key))
  add(query_579630, "prettyPrint", newJBool(prettyPrint))
  add(query_579630, "oauth_token", newJString(oauthToken))
  add(path_579629, "profileId", newJString(profileId))
  add(query_579630, "alt", newJString(alt))
  add(query_579630, "userIp", newJString(userIp))
  add(query_579630, "quotaUser", newJString(quotaUser))
  add(path_579629, "campaignId", newJString(campaignId))
  if body != nil:
    body_579631 = body
  add(query_579630, "fields", newJString(fields))
  result = call_579628.call(path_579629, query_579630, nil, nil, body_579631)

var dfareportingCampaignCreativeAssociationsInsert* = Call_DfareportingCampaignCreativeAssociationsInsert_579614(
    name: "dfareportingCampaignCreativeAssociationsInsert",
    meth: HttpMethod.HttpPost, host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/campaignCreativeAssociations",
    validator: validate_DfareportingCampaignCreativeAssociationsInsert_579615,
    base: "/dfareporting/v2.7",
    url: url_DfareportingCampaignCreativeAssociationsInsert_579616,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignCreativeAssociationsList_579595 = ref object of OpenApiRestCall_578364
proc url_DfareportingCampaignCreativeAssociationsList_579597(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/campaignCreativeAssociations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignCreativeAssociationsList_579596(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of creative IDs associated with the specified campaign. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Campaign ID in this association.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579598 = path.getOrDefault("profileId")
  valid_579598 = validateParameter(valid_579598, JString, required = true,
                                 default = nil)
  if valid_579598 != nil:
    section.add "profileId", valid_579598
  var valid_579599 = path.getOrDefault("campaignId")
  valid_579599 = validateParameter(valid_579599, JString, required = true,
                                 default = nil)
  if valid_579599 != nil:
    section.add "campaignId", valid_579599
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_579600 = query.getOrDefault("key")
  valid_579600 = validateParameter(valid_579600, JString, required = false,
                                 default = nil)
  if valid_579600 != nil:
    section.add "key", valid_579600
  var valid_579601 = query.getOrDefault("prettyPrint")
  valid_579601 = validateParameter(valid_579601, JBool, required = false,
                                 default = newJBool(true))
  if valid_579601 != nil:
    section.add "prettyPrint", valid_579601
  var valid_579602 = query.getOrDefault("oauth_token")
  valid_579602 = validateParameter(valid_579602, JString, required = false,
                                 default = nil)
  if valid_579602 != nil:
    section.add "oauth_token", valid_579602
  var valid_579603 = query.getOrDefault("alt")
  valid_579603 = validateParameter(valid_579603, JString, required = false,
                                 default = newJString("json"))
  if valid_579603 != nil:
    section.add "alt", valid_579603
  var valid_579604 = query.getOrDefault("userIp")
  valid_579604 = validateParameter(valid_579604, JString, required = false,
                                 default = nil)
  if valid_579604 != nil:
    section.add "userIp", valid_579604
  var valid_579605 = query.getOrDefault("quotaUser")
  valid_579605 = validateParameter(valid_579605, JString, required = false,
                                 default = nil)
  if valid_579605 != nil:
    section.add "quotaUser", valid_579605
  var valid_579606 = query.getOrDefault("pageToken")
  valid_579606 = validateParameter(valid_579606, JString, required = false,
                                 default = nil)
  if valid_579606 != nil:
    section.add "pageToken", valid_579606
  var valid_579607 = query.getOrDefault("sortOrder")
  valid_579607 = validateParameter(valid_579607, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_579607 != nil:
    section.add "sortOrder", valid_579607
  var valid_579608 = query.getOrDefault("fields")
  valid_579608 = validateParameter(valid_579608, JString, required = false,
                                 default = nil)
  if valid_579608 != nil:
    section.add "fields", valid_579608
  var valid_579609 = query.getOrDefault("maxResults")
  valid_579609 = validateParameter(valid_579609, JInt, required = false,
                                 default = newJInt(1000))
  if valid_579609 != nil:
    section.add "maxResults", valid_579609
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579610: Call_DfareportingCampaignCreativeAssociationsList_579595;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves the list of creative IDs associated with the specified campaign. This method supports paging.
  ## 
  let valid = call_579610.validator(path, query, header, formData, body)
  let scheme = call_579610.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579610.url(scheme.get, call_579610.host, call_579610.base,
                         call_579610.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579610, url, valid)

proc call*(call_579611: Call_DfareportingCampaignCreativeAssociationsList_579595;
          profileId: string; campaignId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; pageToken: string = "";
          sortOrder: string = "ASCENDING"; fields: string = ""; maxResults: int = 1000): Recallable =
  ## dfareportingCampaignCreativeAssociationsList
  ## Retrieves the list of creative IDs associated with the specified campaign. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   campaignId: string (required)
  ##             : Campaign ID in this association.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_579612 = newJObject()
  var query_579613 = newJObject()
  add(query_579613, "key", newJString(key))
  add(query_579613, "prettyPrint", newJBool(prettyPrint))
  add(query_579613, "oauth_token", newJString(oauthToken))
  add(path_579612, "profileId", newJString(profileId))
  add(query_579613, "alt", newJString(alt))
  add(query_579613, "userIp", newJString(userIp))
  add(query_579613, "quotaUser", newJString(quotaUser))
  add(query_579613, "pageToken", newJString(pageToken))
  add(query_579613, "sortOrder", newJString(sortOrder))
  add(path_579612, "campaignId", newJString(campaignId))
  add(query_579613, "fields", newJString(fields))
  add(query_579613, "maxResults", newJInt(maxResults))
  result = call_579611.call(path_579612, query_579613, nil, nil, nil)

var dfareportingCampaignCreativeAssociationsList* = Call_DfareportingCampaignCreativeAssociationsList_579595(
    name: "dfareportingCampaignCreativeAssociationsList",
    meth: HttpMethod.HttpGet, host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/campaignCreativeAssociations",
    validator: validate_DfareportingCampaignCreativeAssociationsList_579596,
    base: "/dfareporting/v2.7",
    url: url_DfareportingCampaignCreativeAssociationsList_579597,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesUpdate_579648 = ref object of OpenApiRestCall_578364
proc url_DfareportingLandingPagesUpdate_579650(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesUpdate_579649(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign landing page.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579651 = path.getOrDefault("profileId")
  valid_579651 = validateParameter(valid_579651, JString, required = true,
                                 default = nil)
  if valid_579651 != nil:
    section.add "profileId", valid_579651
  var valid_579652 = path.getOrDefault("campaignId")
  valid_579652 = validateParameter(valid_579652, JString, required = true,
                                 default = nil)
  if valid_579652 != nil:
    section.add "campaignId", valid_579652
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579653 = query.getOrDefault("key")
  valid_579653 = validateParameter(valid_579653, JString, required = false,
                                 default = nil)
  if valid_579653 != nil:
    section.add "key", valid_579653
  var valid_579654 = query.getOrDefault("prettyPrint")
  valid_579654 = validateParameter(valid_579654, JBool, required = false,
                                 default = newJBool(true))
  if valid_579654 != nil:
    section.add "prettyPrint", valid_579654
  var valid_579655 = query.getOrDefault("oauth_token")
  valid_579655 = validateParameter(valid_579655, JString, required = false,
                                 default = nil)
  if valid_579655 != nil:
    section.add "oauth_token", valid_579655
  var valid_579656 = query.getOrDefault("alt")
  valid_579656 = validateParameter(valid_579656, JString, required = false,
                                 default = newJString("json"))
  if valid_579656 != nil:
    section.add "alt", valid_579656
  var valid_579657 = query.getOrDefault("userIp")
  valid_579657 = validateParameter(valid_579657, JString, required = false,
                                 default = nil)
  if valid_579657 != nil:
    section.add "userIp", valid_579657
  var valid_579658 = query.getOrDefault("quotaUser")
  valid_579658 = validateParameter(valid_579658, JString, required = false,
                                 default = nil)
  if valid_579658 != nil:
    section.add "quotaUser", valid_579658
  var valid_579659 = query.getOrDefault("fields")
  valid_579659 = validateParameter(valid_579659, JString, required = false,
                                 default = nil)
  if valid_579659 != nil:
    section.add "fields", valid_579659
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579661: Call_DfareportingLandingPagesUpdate_579648; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign landing page.
  ## 
  let valid = call_579661.validator(path, query, header, formData, body)
  let scheme = call_579661.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579661.url(scheme.get, call_579661.host, call_579661.base,
                         call_579661.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579661, url, valid)

proc call*(call_579662: Call_DfareportingLandingPagesUpdate_579648;
          profileId: string; campaignId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; body: JsonNode = nil;
          fields: string = ""): Recallable =
  ## dfareportingLandingPagesUpdate
  ## Updates an existing campaign landing page.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579663 = newJObject()
  var query_579664 = newJObject()
  var body_579665 = newJObject()
  add(query_579664, "key", newJString(key))
  add(query_579664, "prettyPrint", newJBool(prettyPrint))
  add(query_579664, "oauth_token", newJString(oauthToken))
  add(path_579663, "profileId", newJString(profileId))
  add(query_579664, "alt", newJString(alt))
  add(query_579664, "userIp", newJString(userIp))
  add(query_579664, "quotaUser", newJString(quotaUser))
  add(path_579663, "campaignId", newJString(campaignId))
  if body != nil:
    body_579665 = body
  add(query_579664, "fields", newJString(fields))
  result = call_579662.call(path_579663, query_579664, nil, nil, body_579665)

var dfareportingLandingPagesUpdate* = Call_DfareportingLandingPagesUpdate_579648(
    name: "dfareportingLandingPagesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesUpdate_579649,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesUpdate_579650,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesInsert_579666 = ref object of OpenApiRestCall_578364
proc url_DfareportingLandingPagesInsert_579668(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesInsert_579667(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new landing page for the specified campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579669 = path.getOrDefault("profileId")
  valid_579669 = validateParameter(valid_579669, JString, required = true,
                                 default = nil)
  if valid_579669 != nil:
    section.add "profileId", valid_579669
  var valid_579670 = path.getOrDefault("campaignId")
  valid_579670 = validateParameter(valid_579670, JString, required = true,
                                 default = nil)
  if valid_579670 != nil:
    section.add "campaignId", valid_579670
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579671 = query.getOrDefault("key")
  valid_579671 = validateParameter(valid_579671, JString, required = false,
                                 default = nil)
  if valid_579671 != nil:
    section.add "key", valid_579671
  var valid_579672 = query.getOrDefault("prettyPrint")
  valid_579672 = validateParameter(valid_579672, JBool, required = false,
                                 default = newJBool(true))
  if valid_579672 != nil:
    section.add "prettyPrint", valid_579672
  var valid_579673 = query.getOrDefault("oauth_token")
  valid_579673 = validateParameter(valid_579673, JString, required = false,
                                 default = nil)
  if valid_579673 != nil:
    section.add "oauth_token", valid_579673
  var valid_579674 = query.getOrDefault("alt")
  valid_579674 = validateParameter(valid_579674, JString, required = false,
                                 default = newJString("json"))
  if valid_579674 != nil:
    section.add "alt", valid_579674
  var valid_579675 = query.getOrDefault("userIp")
  valid_579675 = validateParameter(valid_579675, JString, required = false,
                                 default = nil)
  if valid_579675 != nil:
    section.add "userIp", valid_579675
  var valid_579676 = query.getOrDefault("quotaUser")
  valid_579676 = validateParameter(valid_579676, JString, required = false,
                                 default = nil)
  if valid_579676 != nil:
    section.add "quotaUser", valid_579676
  var valid_579677 = query.getOrDefault("fields")
  valid_579677 = validateParameter(valid_579677, JString, required = false,
                                 default = nil)
  if valid_579677 != nil:
    section.add "fields", valid_579677
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579679: Call_DfareportingLandingPagesInsert_579666; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new landing page for the specified campaign.
  ## 
  let valid = call_579679.validator(path, query, header, formData, body)
  let scheme = call_579679.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579679.url(scheme.get, call_579679.host, call_579679.base,
                         call_579679.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579679, url, valid)

proc call*(call_579680: Call_DfareportingLandingPagesInsert_579666;
          profileId: string; campaignId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; body: JsonNode = nil;
          fields: string = ""): Recallable =
  ## dfareportingLandingPagesInsert
  ## Inserts a new landing page for the specified campaign.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579681 = newJObject()
  var query_579682 = newJObject()
  var body_579683 = newJObject()
  add(query_579682, "key", newJString(key))
  add(query_579682, "prettyPrint", newJBool(prettyPrint))
  add(query_579682, "oauth_token", newJString(oauthToken))
  add(path_579681, "profileId", newJString(profileId))
  add(query_579682, "alt", newJString(alt))
  add(query_579682, "userIp", newJString(userIp))
  add(query_579682, "quotaUser", newJString(quotaUser))
  add(path_579681, "campaignId", newJString(campaignId))
  if body != nil:
    body_579683 = body
  add(query_579682, "fields", newJString(fields))
  result = call_579680.call(path_579681, query_579682, nil, nil, body_579683)

var dfareportingLandingPagesInsert* = Call_DfareportingLandingPagesInsert_579666(
    name: "dfareportingLandingPagesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesInsert_579667,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesInsert_579668,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesList_579632 = ref object of OpenApiRestCall_578364
proc url_DfareportingLandingPagesList_579634(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesList_579633(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of landing pages for the specified campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579635 = path.getOrDefault("profileId")
  valid_579635 = validateParameter(valid_579635, JString, required = true,
                                 default = nil)
  if valid_579635 != nil:
    section.add "profileId", valid_579635
  var valid_579636 = path.getOrDefault("campaignId")
  valid_579636 = validateParameter(valid_579636, JString, required = true,
                                 default = nil)
  if valid_579636 != nil:
    section.add "campaignId", valid_579636
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579637 = query.getOrDefault("key")
  valid_579637 = validateParameter(valid_579637, JString, required = false,
                                 default = nil)
  if valid_579637 != nil:
    section.add "key", valid_579637
  var valid_579638 = query.getOrDefault("prettyPrint")
  valid_579638 = validateParameter(valid_579638, JBool, required = false,
                                 default = newJBool(true))
  if valid_579638 != nil:
    section.add "prettyPrint", valid_579638
  var valid_579639 = query.getOrDefault("oauth_token")
  valid_579639 = validateParameter(valid_579639, JString, required = false,
                                 default = nil)
  if valid_579639 != nil:
    section.add "oauth_token", valid_579639
  var valid_579640 = query.getOrDefault("alt")
  valid_579640 = validateParameter(valid_579640, JString, required = false,
                                 default = newJString("json"))
  if valid_579640 != nil:
    section.add "alt", valid_579640
  var valid_579641 = query.getOrDefault("userIp")
  valid_579641 = validateParameter(valid_579641, JString, required = false,
                                 default = nil)
  if valid_579641 != nil:
    section.add "userIp", valid_579641
  var valid_579642 = query.getOrDefault("quotaUser")
  valid_579642 = validateParameter(valid_579642, JString, required = false,
                                 default = nil)
  if valid_579642 != nil:
    section.add "quotaUser", valid_579642
  var valid_579643 = query.getOrDefault("fields")
  valid_579643 = validateParameter(valid_579643, JString, required = false,
                                 default = nil)
  if valid_579643 != nil:
    section.add "fields", valid_579643
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579644: Call_DfareportingLandingPagesList_579632; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves the list of landing pages for the specified campaign.
  ## 
  let valid = call_579644.validator(path, query, header, formData, body)
  let scheme = call_579644.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579644.url(scheme.get, call_579644.host, call_579644.base,
                         call_579644.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579644, url, valid)

proc call*(call_579645: Call_DfareportingLandingPagesList_579632;
          profileId: string; campaignId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingLandingPagesList
  ## Retrieves the list of landing pages for the specified campaign.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579646 = newJObject()
  var query_579647 = newJObject()
  add(query_579647, "key", newJString(key))
  add(query_579647, "prettyPrint", newJBool(prettyPrint))
  add(query_579647, "oauth_token", newJString(oauthToken))
  add(path_579646, "profileId", newJString(profileId))
  add(query_579647, "alt", newJString(alt))
  add(query_579647, "userIp", newJString(userIp))
  add(query_579647, "quotaUser", newJString(quotaUser))
  add(path_579646, "campaignId", newJString(campaignId))
  add(query_579647, "fields", newJString(fields))
  result = call_579645.call(path_579646, query_579647, nil, nil, nil)

var dfareportingLandingPagesList* = Call_DfareportingLandingPagesList_579632(
    name: "dfareportingLandingPagesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesList_579633,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesList_579634,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesPatch_579684 = ref object of OpenApiRestCall_578364
proc url_DfareportingLandingPagesPatch_579686(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesPatch_579685(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign landing page. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579687 = path.getOrDefault("profileId")
  valid_579687 = validateParameter(valid_579687, JString, required = true,
                                 default = nil)
  if valid_579687 != nil:
    section.add "profileId", valid_579687
  var valid_579688 = path.getOrDefault("campaignId")
  valid_579688 = validateParameter(valid_579688, JString, required = true,
                                 default = nil)
  if valid_579688 != nil:
    section.add "campaignId", valid_579688
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Landing page ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579689 = query.getOrDefault("key")
  valid_579689 = validateParameter(valid_579689, JString, required = false,
                                 default = nil)
  if valid_579689 != nil:
    section.add "key", valid_579689
  var valid_579690 = query.getOrDefault("prettyPrint")
  valid_579690 = validateParameter(valid_579690, JBool, required = false,
                                 default = newJBool(true))
  if valid_579690 != nil:
    section.add "prettyPrint", valid_579690
  var valid_579691 = query.getOrDefault("oauth_token")
  valid_579691 = validateParameter(valid_579691, JString, required = false,
                                 default = nil)
  if valid_579691 != nil:
    section.add "oauth_token", valid_579691
  var valid_579692 = query.getOrDefault("alt")
  valid_579692 = validateParameter(valid_579692, JString, required = false,
                                 default = newJString("json"))
  if valid_579692 != nil:
    section.add "alt", valid_579692
  var valid_579693 = query.getOrDefault("userIp")
  valid_579693 = validateParameter(valid_579693, JString, required = false,
                                 default = nil)
  if valid_579693 != nil:
    section.add "userIp", valid_579693
  var valid_579694 = query.getOrDefault("quotaUser")
  valid_579694 = validateParameter(valid_579694, JString, required = false,
                                 default = nil)
  if valid_579694 != nil:
    section.add "quotaUser", valid_579694
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_579695 = query.getOrDefault("id")
  valid_579695 = validateParameter(valid_579695, JString, required = true,
                                 default = nil)
  if valid_579695 != nil:
    section.add "id", valid_579695
  var valid_579696 = query.getOrDefault("fields")
  valid_579696 = validateParameter(valid_579696, JString, required = false,
                                 default = nil)
  if valid_579696 != nil:
    section.add "fields", valid_579696
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579698: Call_DfareportingLandingPagesPatch_579684; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign landing page. This method supports patch semantics.
  ## 
  let valid = call_579698.validator(path, query, header, formData, body)
  let scheme = call_579698.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579698.url(scheme.get, call_579698.host, call_579698.base,
                         call_579698.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579698, url, valid)

proc call*(call_579699: Call_DfareportingLandingPagesPatch_579684;
          profileId: string; id: string; campaignId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; body: JsonNode = nil;
          fields: string = ""): Recallable =
  ## dfareportingLandingPagesPatch
  ## Updates an existing campaign landing page. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Landing page ID.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579700 = newJObject()
  var query_579701 = newJObject()
  var body_579702 = newJObject()
  add(query_579701, "key", newJString(key))
  add(query_579701, "prettyPrint", newJBool(prettyPrint))
  add(query_579701, "oauth_token", newJString(oauthToken))
  add(path_579700, "profileId", newJString(profileId))
  add(query_579701, "alt", newJString(alt))
  add(query_579701, "userIp", newJString(userIp))
  add(query_579701, "quotaUser", newJString(quotaUser))
  add(query_579701, "id", newJString(id))
  add(path_579700, "campaignId", newJString(campaignId))
  if body != nil:
    body_579702 = body
  add(query_579701, "fields", newJString(fields))
  result = call_579699.call(path_579700, query_579701, nil, nil, body_579702)

var dfareportingLandingPagesPatch* = Call_DfareportingLandingPagesPatch_579684(
    name: "dfareportingLandingPagesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesPatch_579685,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesPatch_579686,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesGet_579703 = ref object of OpenApiRestCall_578364
proc url_DfareportingLandingPagesGet_579705(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesGet_579704(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one campaign landing page by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Landing page ID.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579706 = path.getOrDefault("profileId")
  valid_579706 = validateParameter(valid_579706, JString, required = true,
                                 default = nil)
  if valid_579706 != nil:
    section.add "profileId", valid_579706
  var valid_579707 = path.getOrDefault("id")
  valid_579707 = validateParameter(valid_579707, JString, required = true,
                                 default = nil)
  if valid_579707 != nil:
    section.add "id", valid_579707
  var valid_579708 = path.getOrDefault("campaignId")
  valid_579708 = validateParameter(valid_579708, JString, required = true,
                                 default = nil)
  if valid_579708 != nil:
    section.add "campaignId", valid_579708
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579709 = query.getOrDefault("key")
  valid_579709 = validateParameter(valid_579709, JString, required = false,
                                 default = nil)
  if valid_579709 != nil:
    section.add "key", valid_579709
  var valid_579710 = query.getOrDefault("prettyPrint")
  valid_579710 = validateParameter(valid_579710, JBool, required = false,
                                 default = newJBool(true))
  if valid_579710 != nil:
    section.add "prettyPrint", valid_579710
  var valid_579711 = query.getOrDefault("oauth_token")
  valid_579711 = validateParameter(valid_579711, JString, required = false,
                                 default = nil)
  if valid_579711 != nil:
    section.add "oauth_token", valid_579711
  var valid_579712 = query.getOrDefault("alt")
  valid_579712 = validateParameter(valid_579712, JString, required = false,
                                 default = newJString("json"))
  if valid_579712 != nil:
    section.add "alt", valid_579712
  var valid_579713 = query.getOrDefault("userIp")
  valid_579713 = validateParameter(valid_579713, JString, required = false,
                                 default = nil)
  if valid_579713 != nil:
    section.add "userIp", valid_579713
  var valid_579714 = query.getOrDefault("quotaUser")
  valid_579714 = validateParameter(valid_579714, JString, required = false,
                                 default = nil)
  if valid_579714 != nil:
    section.add "quotaUser", valid_579714
  var valid_579715 = query.getOrDefault("fields")
  valid_579715 = validateParameter(valid_579715, JString, required = false,
                                 default = nil)
  if valid_579715 != nil:
    section.add "fields", valid_579715
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579716: Call_DfareportingLandingPagesGet_579703; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one campaign landing page by ID.
  ## 
  let valid = call_579716.validator(path, query, header, formData, body)
  let scheme = call_579716.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579716.url(scheme.get, call_579716.host, call_579716.base,
                         call_579716.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579716, url, valid)

proc call*(call_579717: Call_DfareportingLandingPagesGet_579703; profileId: string;
          id: string; campaignId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingLandingPagesGet
  ## Gets one campaign landing page by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Landing page ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579718 = newJObject()
  var query_579719 = newJObject()
  add(query_579719, "key", newJString(key))
  add(query_579719, "prettyPrint", newJBool(prettyPrint))
  add(query_579719, "oauth_token", newJString(oauthToken))
  add(path_579718, "profileId", newJString(profileId))
  add(path_579718, "id", newJString(id))
  add(query_579719, "alt", newJString(alt))
  add(query_579719, "userIp", newJString(userIp))
  add(query_579719, "quotaUser", newJString(quotaUser))
  add(path_579718, "campaignId", newJString(campaignId))
  add(query_579719, "fields", newJString(fields))
  result = call_579717.call(path_579718, query_579719, nil, nil, nil)

var dfareportingLandingPagesGet* = Call_DfareportingLandingPagesGet_579703(
    name: "dfareportingLandingPagesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages/{id}",
    validator: validate_DfareportingLandingPagesGet_579704,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesGet_579705,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesDelete_579720 = ref object of OpenApiRestCall_578364
proc url_DfareportingLandingPagesDelete_579722(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesDelete_579721(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing campaign landing page.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Landing page ID.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579723 = path.getOrDefault("profileId")
  valid_579723 = validateParameter(valid_579723, JString, required = true,
                                 default = nil)
  if valid_579723 != nil:
    section.add "profileId", valid_579723
  var valid_579724 = path.getOrDefault("id")
  valid_579724 = validateParameter(valid_579724, JString, required = true,
                                 default = nil)
  if valid_579724 != nil:
    section.add "id", valid_579724
  var valid_579725 = path.getOrDefault("campaignId")
  valid_579725 = validateParameter(valid_579725, JString, required = true,
                                 default = nil)
  if valid_579725 != nil:
    section.add "campaignId", valid_579725
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579726 = query.getOrDefault("key")
  valid_579726 = validateParameter(valid_579726, JString, required = false,
                                 default = nil)
  if valid_579726 != nil:
    section.add "key", valid_579726
  var valid_579727 = query.getOrDefault("prettyPrint")
  valid_579727 = validateParameter(valid_579727, JBool, required = false,
                                 default = newJBool(true))
  if valid_579727 != nil:
    section.add "prettyPrint", valid_579727
  var valid_579728 = query.getOrDefault("oauth_token")
  valid_579728 = validateParameter(valid_579728, JString, required = false,
                                 default = nil)
  if valid_579728 != nil:
    section.add "oauth_token", valid_579728
  var valid_579729 = query.getOrDefault("alt")
  valid_579729 = validateParameter(valid_579729, JString, required = false,
                                 default = newJString("json"))
  if valid_579729 != nil:
    section.add "alt", valid_579729
  var valid_579730 = query.getOrDefault("userIp")
  valid_579730 = validateParameter(valid_579730, JString, required = false,
                                 default = nil)
  if valid_579730 != nil:
    section.add "userIp", valid_579730
  var valid_579731 = query.getOrDefault("quotaUser")
  valid_579731 = validateParameter(valid_579731, JString, required = false,
                                 default = nil)
  if valid_579731 != nil:
    section.add "quotaUser", valid_579731
  var valid_579732 = query.getOrDefault("fields")
  valid_579732 = validateParameter(valid_579732, JString, required = false,
                                 default = nil)
  if valid_579732 != nil:
    section.add "fields", valid_579732
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579733: Call_DfareportingLandingPagesDelete_579720; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing campaign landing page.
  ## 
  let valid = call_579733.validator(path, query, header, formData, body)
  let scheme = call_579733.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579733.url(scheme.get, call_579733.host, call_579733.base,
                         call_579733.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579733, url, valid)

proc call*(call_579734: Call_DfareportingLandingPagesDelete_579720;
          profileId: string; id: string; campaignId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingLandingPagesDelete
  ## Deletes an existing campaign landing page.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Landing page ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579735 = newJObject()
  var query_579736 = newJObject()
  add(query_579736, "key", newJString(key))
  add(query_579736, "prettyPrint", newJBool(prettyPrint))
  add(query_579736, "oauth_token", newJString(oauthToken))
  add(path_579735, "profileId", newJString(profileId))
  add(path_579735, "id", newJString(id))
  add(query_579736, "alt", newJString(alt))
  add(query_579736, "userIp", newJString(userIp))
  add(query_579736, "quotaUser", newJString(quotaUser))
  add(path_579735, "campaignId", newJString(campaignId))
  add(query_579736, "fields", newJString(fields))
  result = call_579734.call(path_579735, query_579736, nil, nil, nil)

var dfareportingLandingPagesDelete* = Call_DfareportingLandingPagesDelete_579720(
    name: "dfareportingLandingPagesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages/{id}",
    validator: validate_DfareportingLandingPagesDelete_579721,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesDelete_579722,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsGet_579737 = ref object of OpenApiRestCall_578364
proc url_DfareportingCampaignsGet_579739(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsGet_579738(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one campaign by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579740 = path.getOrDefault("profileId")
  valid_579740 = validateParameter(valid_579740, JString, required = true,
                                 default = nil)
  if valid_579740 != nil:
    section.add "profileId", valid_579740
  var valid_579741 = path.getOrDefault("id")
  valid_579741 = validateParameter(valid_579741, JString, required = true,
                                 default = nil)
  if valid_579741 != nil:
    section.add "id", valid_579741
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579742 = query.getOrDefault("key")
  valid_579742 = validateParameter(valid_579742, JString, required = false,
                                 default = nil)
  if valid_579742 != nil:
    section.add "key", valid_579742
  var valid_579743 = query.getOrDefault("prettyPrint")
  valid_579743 = validateParameter(valid_579743, JBool, required = false,
                                 default = newJBool(true))
  if valid_579743 != nil:
    section.add "prettyPrint", valid_579743
  var valid_579744 = query.getOrDefault("oauth_token")
  valid_579744 = validateParameter(valid_579744, JString, required = false,
                                 default = nil)
  if valid_579744 != nil:
    section.add "oauth_token", valid_579744
  var valid_579745 = query.getOrDefault("alt")
  valid_579745 = validateParameter(valid_579745, JString, required = false,
                                 default = newJString("json"))
  if valid_579745 != nil:
    section.add "alt", valid_579745
  var valid_579746 = query.getOrDefault("userIp")
  valid_579746 = validateParameter(valid_579746, JString, required = false,
                                 default = nil)
  if valid_579746 != nil:
    section.add "userIp", valid_579746
  var valid_579747 = query.getOrDefault("quotaUser")
  valid_579747 = validateParameter(valid_579747, JString, required = false,
                                 default = nil)
  if valid_579747 != nil:
    section.add "quotaUser", valid_579747
  var valid_579748 = query.getOrDefault("fields")
  valid_579748 = validateParameter(valid_579748, JString, required = false,
                                 default = nil)
  if valid_579748 != nil:
    section.add "fields", valid_579748
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579749: Call_DfareportingCampaignsGet_579737; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one campaign by ID.
  ## 
  let valid = call_579749.validator(path, query, header, formData, body)
  let scheme = call_579749.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579749.url(scheme.get, call_579749.host, call_579749.base,
                         call_579749.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579749, url, valid)

proc call*(call_579750: Call_DfareportingCampaignsGet_579737; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingCampaignsGet
  ## Gets one campaign by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Campaign ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579751 = newJObject()
  var query_579752 = newJObject()
  add(query_579752, "key", newJString(key))
  add(query_579752, "prettyPrint", newJBool(prettyPrint))
  add(query_579752, "oauth_token", newJString(oauthToken))
  add(path_579751, "profileId", newJString(profileId))
  add(path_579751, "id", newJString(id))
  add(query_579752, "alt", newJString(alt))
  add(query_579752, "userIp", newJString(userIp))
  add(query_579752, "quotaUser", newJString(quotaUser))
  add(query_579752, "fields", newJString(fields))
  result = call_579750.call(path_579751, query_579752, nil, nil, nil)

var dfareportingCampaignsGet* = Call_DfareportingCampaignsGet_579737(
    name: "dfareportingCampaignsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{id}",
    validator: validate_DfareportingCampaignsGet_579738,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsGet_579739,
    schemes: {Scheme.Https})
type
  Call_DfareportingChangeLogsList_579753 = ref object of OpenApiRestCall_578364
proc url_DfareportingChangeLogsList_579755(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/changeLogs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingChangeLogsList_579754(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of change logs. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579756 = path.getOrDefault("profileId")
  valid_579756 = validateParameter(valid_579756, JString, required = true,
                                 default = nil)
  if valid_579756 != nil:
    section.add "profileId", valid_579756
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   objectType: JString
  ##             : Select only change logs with the specified object type.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   action: JString
  ##         : Select only change logs with the specified action.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   objectIds: JArray
  ##            : Select only change logs with these object IDs.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Select only change logs whose object ID, user name, old or new values match the search string.
  ##   userProfileIds: JArray
  ##                 : Select only change logs with these user profile IDs.
  ##   maxChangeTime: JString
  ##                : Select only change logs whose change time is before the specified maxChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   ids: JArray
  ##      : Select only change logs with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   minChangeTime: JString
  ##                : Select only change logs whose change time is before the specified minChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_579757 = query.getOrDefault("key")
  valid_579757 = validateParameter(valid_579757, JString, required = false,
                                 default = nil)
  if valid_579757 != nil:
    section.add "key", valid_579757
  var valid_579758 = query.getOrDefault("objectType")
  valid_579758 = validateParameter(valid_579758, JString, required = false,
                                 default = newJString("OBJECT_ACCOUNT"))
  if valid_579758 != nil:
    section.add "objectType", valid_579758
  var valid_579759 = query.getOrDefault("prettyPrint")
  valid_579759 = validateParameter(valid_579759, JBool, required = false,
                                 default = newJBool(true))
  if valid_579759 != nil:
    section.add "prettyPrint", valid_579759
  var valid_579760 = query.getOrDefault("oauth_token")
  valid_579760 = validateParameter(valid_579760, JString, required = false,
                                 default = nil)
  if valid_579760 != nil:
    section.add "oauth_token", valid_579760
  var valid_579761 = query.getOrDefault("action")
  valid_579761 = validateParameter(valid_579761, JString, required = false,
                                 default = newJString("ACTION_ADD"))
  if valid_579761 != nil:
    section.add "action", valid_579761
  var valid_579762 = query.getOrDefault("alt")
  valid_579762 = validateParameter(valid_579762, JString, required = false,
                                 default = newJString("json"))
  if valid_579762 != nil:
    section.add "alt", valid_579762
  var valid_579763 = query.getOrDefault("userIp")
  valid_579763 = validateParameter(valid_579763, JString, required = false,
                                 default = nil)
  if valid_579763 != nil:
    section.add "userIp", valid_579763
  var valid_579764 = query.getOrDefault("quotaUser")
  valid_579764 = validateParameter(valid_579764, JString, required = false,
                                 default = nil)
  if valid_579764 != nil:
    section.add "quotaUser", valid_579764
  var valid_579765 = query.getOrDefault("objectIds")
  valid_579765 = validateParameter(valid_579765, JArray, required = false,
                                 default = nil)
  if valid_579765 != nil:
    section.add "objectIds", valid_579765
  var valid_579766 = query.getOrDefault("pageToken")
  valid_579766 = validateParameter(valid_579766, JString, required = false,
                                 default = nil)
  if valid_579766 != nil:
    section.add "pageToken", valid_579766
  var valid_579767 = query.getOrDefault("searchString")
  valid_579767 = validateParameter(valid_579767, JString, required = false,
                                 default = nil)
  if valid_579767 != nil:
    section.add "searchString", valid_579767
  var valid_579768 = query.getOrDefault("userProfileIds")
  valid_579768 = validateParameter(valid_579768, JArray, required = false,
                                 default = nil)
  if valid_579768 != nil:
    section.add "userProfileIds", valid_579768
  var valid_579769 = query.getOrDefault("maxChangeTime")
  valid_579769 = validateParameter(valid_579769, JString, required = false,
                                 default = nil)
  if valid_579769 != nil:
    section.add "maxChangeTime", valid_579769
  var valid_579770 = query.getOrDefault("ids")
  valid_579770 = validateParameter(valid_579770, JArray, required = false,
                                 default = nil)
  if valid_579770 != nil:
    section.add "ids", valid_579770
  var valid_579771 = query.getOrDefault("fields")
  valid_579771 = validateParameter(valid_579771, JString, required = false,
                                 default = nil)
  if valid_579771 != nil:
    section.add "fields", valid_579771
  var valid_579772 = query.getOrDefault("minChangeTime")
  valid_579772 = validateParameter(valid_579772, JString, required = false,
                                 default = nil)
  if valid_579772 != nil:
    section.add "minChangeTime", valid_579772
  var valid_579773 = query.getOrDefault("maxResults")
  valid_579773 = validateParameter(valid_579773, JInt, required = false,
                                 default = newJInt(1000))
  if valid_579773 != nil:
    section.add "maxResults", valid_579773
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579774: Call_DfareportingChangeLogsList_579753; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of change logs. This method supports paging.
  ## 
  let valid = call_579774.validator(path, query, header, formData, body)
  let scheme = call_579774.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579774.url(scheme.get, call_579774.host, call_579774.base,
                         call_579774.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579774, url, valid)

proc call*(call_579775: Call_DfareportingChangeLogsList_579753; profileId: string;
          key: string = ""; objectType: string = "OBJECT_ACCOUNT";
          prettyPrint: bool = true; oauthToken: string = "";
          action: string = "ACTION_ADD"; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; objectIds: JsonNode = nil; pageToken: string = "";
          searchString: string = ""; userProfileIds: JsonNode = nil;
          maxChangeTime: string = ""; ids: JsonNode = nil; fields: string = "";
          minChangeTime: string = ""; maxResults: int = 1000): Recallable =
  ## dfareportingChangeLogsList
  ## Retrieves a list of change logs. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   objectType: string
  ##             : Select only change logs with the specified object type.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   action: string
  ##         : Select only change logs with the specified action.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   objectIds: JArray
  ##            : Select only change logs with these object IDs.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Select only change logs whose object ID, user name, old or new values match the search string.
  ##   userProfileIds: JArray
  ##                 : Select only change logs with these user profile IDs.
  ##   maxChangeTime: string
  ##                : Select only change logs whose change time is before the specified maxChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   ids: JArray
  ##      : Select only change logs with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   minChangeTime: string
  ##                : Select only change logs whose change time is before the specified minChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_579776 = newJObject()
  var query_579777 = newJObject()
  add(query_579777, "key", newJString(key))
  add(query_579777, "objectType", newJString(objectType))
  add(query_579777, "prettyPrint", newJBool(prettyPrint))
  add(query_579777, "oauth_token", newJString(oauthToken))
  add(path_579776, "profileId", newJString(profileId))
  add(query_579777, "action", newJString(action))
  add(query_579777, "alt", newJString(alt))
  add(query_579777, "userIp", newJString(userIp))
  add(query_579777, "quotaUser", newJString(quotaUser))
  if objectIds != nil:
    query_579777.add "objectIds", objectIds
  add(query_579777, "pageToken", newJString(pageToken))
  add(query_579777, "searchString", newJString(searchString))
  if userProfileIds != nil:
    query_579777.add "userProfileIds", userProfileIds
  add(query_579777, "maxChangeTime", newJString(maxChangeTime))
  if ids != nil:
    query_579777.add "ids", ids
  add(query_579777, "fields", newJString(fields))
  add(query_579777, "minChangeTime", newJString(minChangeTime))
  add(query_579777, "maxResults", newJInt(maxResults))
  result = call_579775.call(path_579776, query_579777, nil, nil, nil)

var dfareportingChangeLogsList* = Call_DfareportingChangeLogsList_579753(
    name: "dfareportingChangeLogsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/changeLogs",
    validator: validate_DfareportingChangeLogsList_579754,
    base: "/dfareporting/v2.7", url: url_DfareportingChangeLogsList_579755,
    schemes: {Scheme.Https})
type
  Call_DfareportingChangeLogsGet_579778 = ref object of OpenApiRestCall_578364
proc url_DfareportingChangeLogsGet_579780(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/changeLogs/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingChangeLogsGet_579779(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one change log by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Change log ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579781 = path.getOrDefault("profileId")
  valid_579781 = validateParameter(valid_579781, JString, required = true,
                                 default = nil)
  if valid_579781 != nil:
    section.add "profileId", valid_579781
  var valid_579782 = path.getOrDefault("id")
  valid_579782 = validateParameter(valid_579782, JString, required = true,
                                 default = nil)
  if valid_579782 != nil:
    section.add "id", valid_579782
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579783 = query.getOrDefault("key")
  valid_579783 = validateParameter(valid_579783, JString, required = false,
                                 default = nil)
  if valid_579783 != nil:
    section.add "key", valid_579783
  var valid_579784 = query.getOrDefault("prettyPrint")
  valid_579784 = validateParameter(valid_579784, JBool, required = false,
                                 default = newJBool(true))
  if valid_579784 != nil:
    section.add "prettyPrint", valid_579784
  var valid_579785 = query.getOrDefault("oauth_token")
  valid_579785 = validateParameter(valid_579785, JString, required = false,
                                 default = nil)
  if valid_579785 != nil:
    section.add "oauth_token", valid_579785
  var valid_579786 = query.getOrDefault("alt")
  valid_579786 = validateParameter(valid_579786, JString, required = false,
                                 default = newJString("json"))
  if valid_579786 != nil:
    section.add "alt", valid_579786
  var valid_579787 = query.getOrDefault("userIp")
  valid_579787 = validateParameter(valid_579787, JString, required = false,
                                 default = nil)
  if valid_579787 != nil:
    section.add "userIp", valid_579787
  var valid_579788 = query.getOrDefault("quotaUser")
  valid_579788 = validateParameter(valid_579788, JString, required = false,
                                 default = nil)
  if valid_579788 != nil:
    section.add "quotaUser", valid_579788
  var valid_579789 = query.getOrDefault("fields")
  valid_579789 = validateParameter(valid_579789, JString, required = false,
                                 default = nil)
  if valid_579789 != nil:
    section.add "fields", valid_579789
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579790: Call_DfareportingChangeLogsGet_579778; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one change log by ID.
  ## 
  let valid = call_579790.validator(path, query, header, formData, body)
  let scheme = call_579790.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579790.url(scheme.get, call_579790.host, call_579790.base,
                         call_579790.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579790, url, valid)

proc call*(call_579791: Call_DfareportingChangeLogsGet_579778; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingChangeLogsGet
  ## Gets one change log by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Change log ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579792 = newJObject()
  var query_579793 = newJObject()
  add(query_579793, "key", newJString(key))
  add(query_579793, "prettyPrint", newJBool(prettyPrint))
  add(query_579793, "oauth_token", newJString(oauthToken))
  add(path_579792, "profileId", newJString(profileId))
  add(path_579792, "id", newJString(id))
  add(query_579793, "alt", newJString(alt))
  add(query_579793, "userIp", newJString(userIp))
  add(query_579793, "quotaUser", newJString(quotaUser))
  add(query_579793, "fields", newJString(fields))
  result = call_579791.call(path_579792, query_579793, nil, nil, nil)

var dfareportingChangeLogsGet* = Call_DfareportingChangeLogsGet_579778(
    name: "dfareportingChangeLogsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/changeLogs/{id}",
    validator: validate_DfareportingChangeLogsGet_579779,
    base: "/dfareporting/v2.7", url: url_DfareportingChangeLogsGet_579780,
    schemes: {Scheme.Https})
type
  Call_DfareportingCitiesList_579794 = ref object of OpenApiRestCall_578364
proc url_DfareportingCitiesList_579796(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/cities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCitiesList_579795(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of cities, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579797 = path.getOrDefault("profileId")
  valid_579797 = validateParameter(valid_579797, JString, required = true,
                                 default = nil)
  if valid_579797 != nil:
    section.add "profileId", valid_579797
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   countryDartIds: JArray
  ##                 : Select only cities from these countries.
  ##   namePrefix: JString
  ##             : Select only cities with names starting with this prefix.
  ##   regionDartIds: JArray
  ##                : Select only cities from these regions.
  ##   dartIds: JArray
  ##          : Select only cities with these DART IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579798 = query.getOrDefault("key")
  valid_579798 = validateParameter(valid_579798, JString, required = false,
                                 default = nil)
  if valid_579798 != nil:
    section.add "key", valid_579798
  var valid_579799 = query.getOrDefault("prettyPrint")
  valid_579799 = validateParameter(valid_579799, JBool, required = false,
                                 default = newJBool(true))
  if valid_579799 != nil:
    section.add "prettyPrint", valid_579799
  var valid_579800 = query.getOrDefault("oauth_token")
  valid_579800 = validateParameter(valid_579800, JString, required = false,
                                 default = nil)
  if valid_579800 != nil:
    section.add "oauth_token", valid_579800
  var valid_579801 = query.getOrDefault("alt")
  valid_579801 = validateParameter(valid_579801, JString, required = false,
                                 default = newJString("json"))
  if valid_579801 != nil:
    section.add "alt", valid_579801
  var valid_579802 = query.getOrDefault("userIp")
  valid_579802 = validateParameter(valid_579802, JString, required = false,
                                 default = nil)
  if valid_579802 != nil:
    section.add "userIp", valid_579802
  var valid_579803 = query.getOrDefault("quotaUser")
  valid_579803 = validateParameter(valid_579803, JString, required = false,
                                 default = nil)
  if valid_579803 != nil:
    section.add "quotaUser", valid_579803
  var valid_579804 = query.getOrDefault("countryDartIds")
  valid_579804 = validateParameter(valid_579804, JArray, required = false,
                                 default = nil)
  if valid_579804 != nil:
    section.add "countryDartIds", valid_579804
  var valid_579805 = query.getOrDefault("namePrefix")
  valid_579805 = validateParameter(valid_579805, JString, required = false,
                                 default = nil)
  if valid_579805 != nil:
    section.add "namePrefix", valid_579805
  var valid_579806 = query.getOrDefault("regionDartIds")
  valid_579806 = validateParameter(valid_579806, JArray, required = false,
                                 default = nil)
  if valid_579806 != nil:
    section.add "regionDartIds", valid_579806
  var valid_579807 = query.getOrDefault("dartIds")
  valid_579807 = validateParameter(valid_579807, JArray, required = false,
                                 default = nil)
  if valid_579807 != nil:
    section.add "dartIds", valid_579807
  var valid_579808 = query.getOrDefault("fields")
  valid_579808 = validateParameter(valid_579808, JString, required = false,
                                 default = nil)
  if valid_579808 != nil:
    section.add "fields", valid_579808
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579809: Call_DfareportingCitiesList_579794; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of cities, possibly filtered.
  ## 
  let valid = call_579809.validator(path, query, header, formData, body)
  let scheme = call_579809.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579809.url(scheme.get, call_579809.host, call_579809.base,
                         call_579809.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579809, url, valid)

proc call*(call_579810: Call_DfareportingCitiesList_579794; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          countryDartIds: JsonNode = nil; namePrefix: string = "";
          regionDartIds: JsonNode = nil; dartIds: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingCitiesList
  ## Retrieves a list of cities, possibly filtered.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   countryDartIds: JArray
  ##                 : Select only cities from these countries.
  ##   namePrefix: string
  ##             : Select only cities with names starting with this prefix.
  ##   regionDartIds: JArray
  ##                : Select only cities from these regions.
  ##   dartIds: JArray
  ##          : Select only cities with these DART IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579811 = newJObject()
  var query_579812 = newJObject()
  add(query_579812, "key", newJString(key))
  add(query_579812, "prettyPrint", newJBool(prettyPrint))
  add(query_579812, "oauth_token", newJString(oauthToken))
  add(path_579811, "profileId", newJString(profileId))
  add(query_579812, "alt", newJString(alt))
  add(query_579812, "userIp", newJString(userIp))
  add(query_579812, "quotaUser", newJString(quotaUser))
  if countryDartIds != nil:
    query_579812.add "countryDartIds", countryDartIds
  add(query_579812, "namePrefix", newJString(namePrefix))
  if regionDartIds != nil:
    query_579812.add "regionDartIds", regionDartIds
  if dartIds != nil:
    query_579812.add "dartIds", dartIds
  add(query_579812, "fields", newJString(fields))
  result = call_579810.call(path_579811, query_579812, nil, nil, nil)

var dfareportingCitiesList* = Call_DfareportingCitiesList_579794(
    name: "dfareportingCitiesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/cities",
    validator: validate_DfareportingCitiesList_579795, base: "/dfareporting/v2.7",
    url: url_DfareportingCitiesList_579796, schemes: {Scheme.Https})
type
  Call_DfareportingConnectionTypesList_579813 = ref object of OpenApiRestCall_578364
proc url_DfareportingConnectionTypesList_579815(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/connectionTypes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingConnectionTypesList_579814(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of connection types.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579816 = path.getOrDefault("profileId")
  valid_579816 = validateParameter(valid_579816, JString, required = true,
                                 default = nil)
  if valid_579816 != nil:
    section.add "profileId", valid_579816
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579817 = query.getOrDefault("key")
  valid_579817 = validateParameter(valid_579817, JString, required = false,
                                 default = nil)
  if valid_579817 != nil:
    section.add "key", valid_579817
  var valid_579818 = query.getOrDefault("prettyPrint")
  valid_579818 = validateParameter(valid_579818, JBool, required = false,
                                 default = newJBool(true))
  if valid_579818 != nil:
    section.add "prettyPrint", valid_579818
  var valid_579819 = query.getOrDefault("oauth_token")
  valid_579819 = validateParameter(valid_579819, JString, required = false,
                                 default = nil)
  if valid_579819 != nil:
    section.add "oauth_token", valid_579819
  var valid_579820 = query.getOrDefault("alt")
  valid_579820 = validateParameter(valid_579820, JString, required = false,
                                 default = newJString("json"))
  if valid_579820 != nil:
    section.add "alt", valid_579820
  var valid_579821 = query.getOrDefault("userIp")
  valid_579821 = validateParameter(valid_579821, JString, required = false,
                                 default = nil)
  if valid_579821 != nil:
    section.add "userIp", valid_579821
  var valid_579822 = query.getOrDefault("quotaUser")
  valid_579822 = validateParameter(valid_579822, JString, required = false,
                                 default = nil)
  if valid_579822 != nil:
    section.add "quotaUser", valid_579822
  var valid_579823 = query.getOrDefault("fields")
  valid_579823 = validateParameter(valid_579823, JString, required = false,
                                 default = nil)
  if valid_579823 != nil:
    section.add "fields", valid_579823
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579824: Call_DfareportingConnectionTypesList_579813;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of connection types.
  ## 
  let valid = call_579824.validator(path, query, header, formData, body)
  let scheme = call_579824.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579824.url(scheme.get, call_579824.host, call_579824.base,
                         call_579824.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579824, url, valid)

proc call*(call_579825: Call_DfareportingConnectionTypesList_579813;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingConnectionTypesList
  ## Retrieves a list of connection types.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579826 = newJObject()
  var query_579827 = newJObject()
  add(query_579827, "key", newJString(key))
  add(query_579827, "prettyPrint", newJBool(prettyPrint))
  add(query_579827, "oauth_token", newJString(oauthToken))
  add(path_579826, "profileId", newJString(profileId))
  add(query_579827, "alt", newJString(alt))
  add(query_579827, "userIp", newJString(userIp))
  add(query_579827, "quotaUser", newJString(quotaUser))
  add(query_579827, "fields", newJString(fields))
  result = call_579825.call(path_579826, query_579827, nil, nil, nil)

var dfareportingConnectionTypesList* = Call_DfareportingConnectionTypesList_579813(
    name: "dfareportingConnectionTypesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/connectionTypes",
    validator: validate_DfareportingConnectionTypesList_579814,
    base: "/dfareporting/v2.7", url: url_DfareportingConnectionTypesList_579815,
    schemes: {Scheme.Https})
type
  Call_DfareportingConnectionTypesGet_579828 = ref object of OpenApiRestCall_578364
proc url_DfareportingConnectionTypesGet_579830(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/connectionTypes/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingConnectionTypesGet_579829(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one connection type by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Connection type ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579831 = path.getOrDefault("profileId")
  valid_579831 = validateParameter(valid_579831, JString, required = true,
                                 default = nil)
  if valid_579831 != nil:
    section.add "profileId", valid_579831
  var valid_579832 = path.getOrDefault("id")
  valid_579832 = validateParameter(valid_579832, JString, required = true,
                                 default = nil)
  if valid_579832 != nil:
    section.add "id", valid_579832
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579833 = query.getOrDefault("key")
  valid_579833 = validateParameter(valid_579833, JString, required = false,
                                 default = nil)
  if valid_579833 != nil:
    section.add "key", valid_579833
  var valid_579834 = query.getOrDefault("prettyPrint")
  valid_579834 = validateParameter(valid_579834, JBool, required = false,
                                 default = newJBool(true))
  if valid_579834 != nil:
    section.add "prettyPrint", valid_579834
  var valid_579835 = query.getOrDefault("oauth_token")
  valid_579835 = validateParameter(valid_579835, JString, required = false,
                                 default = nil)
  if valid_579835 != nil:
    section.add "oauth_token", valid_579835
  var valid_579836 = query.getOrDefault("alt")
  valid_579836 = validateParameter(valid_579836, JString, required = false,
                                 default = newJString("json"))
  if valid_579836 != nil:
    section.add "alt", valid_579836
  var valid_579837 = query.getOrDefault("userIp")
  valid_579837 = validateParameter(valid_579837, JString, required = false,
                                 default = nil)
  if valid_579837 != nil:
    section.add "userIp", valid_579837
  var valid_579838 = query.getOrDefault("quotaUser")
  valid_579838 = validateParameter(valid_579838, JString, required = false,
                                 default = nil)
  if valid_579838 != nil:
    section.add "quotaUser", valid_579838
  var valid_579839 = query.getOrDefault("fields")
  valid_579839 = validateParameter(valid_579839, JString, required = false,
                                 default = nil)
  if valid_579839 != nil:
    section.add "fields", valid_579839
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579840: Call_DfareportingConnectionTypesGet_579828; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one connection type by ID.
  ## 
  let valid = call_579840.validator(path, query, header, formData, body)
  let scheme = call_579840.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579840.url(scheme.get, call_579840.host, call_579840.base,
                         call_579840.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579840, url, valid)

proc call*(call_579841: Call_DfareportingConnectionTypesGet_579828;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingConnectionTypesGet
  ## Gets one connection type by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Connection type ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579842 = newJObject()
  var query_579843 = newJObject()
  add(query_579843, "key", newJString(key))
  add(query_579843, "prettyPrint", newJBool(prettyPrint))
  add(query_579843, "oauth_token", newJString(oauthToken))
  add(path_579842, "profileId", newJString(profileId))
  add(path_579842, "id", newJString(id))
  add(query_579843, "alt", newJString(alt))
  add(query_579843, "userIp", newJString(userIp))
  add(query_579843, "quotaUser", newJString(quotaUser))
  add(query_579843, "fields", newJString(fields))
  result = call_579841.call(path_579842, query_579843, nil, nil, nil)

var dfareportingConnectionTypesGet* = Call_DfareportingConnectionTypesGet_579828(
    name: "dfareportingConnectionTypesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/connectionTypes/{id}",
    validator: validate_DfareportingConnectionTypesGet_579829,
    base: "/dfareporting/v2.7", url: url_DfareportingConnectionTypesGet_579830,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesUpdate_579865 = ref object of OpenApiRestCall_578364
proc url_DfareportingContentCategoriesUpdate_579867(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesUpdate_579866(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing content category.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579868 = path.getOrDefault("profileId")
  valid_579868 = validateParameter(valid_579868, JString, required = true,
                                 default = nil)
  if valid_579868 != nil:
    section.add "profileId", valid_579868
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579869 = query.getOrDefault("key")
  valid_579869 = validateParameter(valid_579869, JString, required = false,
                                 default = nil)
  if valid_579869 != nil:
    section.add "key", valid_579869
  var valid_579870 = query.getOrDefault("prettyPrint")
  valid_579870 = validateParameter(valid_579870, JBool, required = false,
                                 default = newJBool(true))
  if valid_579870 != nil:
    section.add "prettyPrint", valid_579870
  var valid_579871 = query.getOrDefault("oauth_token")
  valid_579871 = validateParameter(valid_579871, JString, required = false,
                                 default = nil)
  if valid_579871 != nil:
    section.add "oauth_token", valid_579871
  var valid_579872 = query.getOrDefault("alt")
  valid_579872 = validateParameter(valid_579872, JString, required = false,
                                 default = newJString("json"))
  if valid_579872 != nil:
    section.add "alt", valid_579872
  var valid_579873 = query.getOrDefault("userIp")
  valid_579873 = validateParameter(valid_579873, JString, required = false,
                                 default = nil)
  if valid_579873 != nil:
    section.add "userIp", valid_579873
  var valid_579874 = query.getOrDefault("quotaUser")
  valid_579874 = validateParameter(valid_579874, JString, required = false,
                                 default = nil)
  if valid_579874 != nil:
    section.add "quotaUser", valid_579874
  var valid_579875 = query.getOrDefault("fields")
  valid_579875 = validateParameter(valid_579875, JString, required = false,
                                 default = nil)
  if valid_579875 != nil:
    section.add "fields", valid_579875
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579877: Call_DfareportingContentCategoriesUpdate_579865;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing content category.
  ## 
  let valid = call_579877.validator(path, query, header, formData, body)
  let scheme = call_579877.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579877.url(scheme.get, call_579877.host, call_579877.base,
                         call_579877.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579877, url, valid)

proc call*(call_579878: Call_DfareportingContentCategoriesUpdate_579865;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingContentCategoriesUpdate
  ## Updates an existing content category.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579879 = newJObject()
  var query_579880 = newJObject()
  var body_579881 = newJObject()
  add(query_579880, "key", newJString(key))
  add(query_579880, "prettyPrint", newJBool(prettyPrint))
  add(query_579880, "oauth_token", newJString(oauthToken))
  add(path_579879, "profileId", newJString(profileId))
  add(query_579880, "alt", newJString(alt))
  add(query_579880, "userIp", newJString(userIp))
  add(query_579880, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_579881 = body
  add(query_579880, "fields", newJString(fields))
  result = call_579878.call(path_579879, query_579880, nil, nil, body_579881)

var dfareportingContentCategoriesUpdate* = Call_DfareportingContentCategoriesUpdate_579865(
    name: "dfareportingContentCategoriesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesUpdate_579866,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesUpdate_579867,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesInsert_579882 = ref object of OpenApiRestCall_578364
proc url_DfareportingContentCategoriesInsert_579884(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesInsert_579883(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new content category.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579885 = path.getOrDefault("profileId")
  valid_579885 = validateParameter(valid_579885, JString, required = true,
                                 default = nil)
  if valid_579885 != nil:
    section.add "profileId", valid_579885
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579886 = query.getOrDefault("key")
  valid_579886 = validateParameter(valid_579886, JString, required = false,
                                 default = nil)
  if valid_579886 != nil:
    section.add "key", valid_579886
  var valid_579887 = query.getOrDefault("prettyPrint")
  valid_579887 = validateParameter(valid_579887, JBool, required = false,
                                 default = newJBool(true))
  if valid_579887 != nil:
    section.add "prettyPrint", valid_579887
  var valid_579888 = query.getOrDefault("oauth_token")
  valid_579888 = validateParameter(valid_579888, JString, required = false,
                                 default = nil)
  if valid_579888 != nil:
    section.add "oauth_token", valid_579888
  var valid_579889 = query.getOrDefault("alt")
  valid_579889 = validateParameter(valid_579889, JString, required = false,
                                 default = newJString("json"))
  if valid_579889 != nil:
    section.add "alt", valid_579889
  var valid_579890 = query.getOrDefault("userIp")
  valid_579890 = validateParameter(valid_579890, JString, required = false,
                                 default = nil)
  if valid_579890 != nil:
    section.add "userIp", valid_579890
  var valid_579891 = query.getOrDefault("quotaUser")
  valid_579891 = validateParameter(valid_579891, JString, required = false,
                                 default = nil)
  if valid_579891 != nil:
    section.add "quotaUser", valid_579891
  var valid_579892 = query.getOrDefault("fields")
  valid_579892 = validateParameter(valid_579892, JString, required = false,
                                 default = nil)
  if valid_579892 != nil:
    section.add "fields", valid_579892
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579894: Call_DfareportingContentCategoriesInsert_579882;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new content category.
  ## 
  let valid = call_579894.validator(path, query, header, formData, body)
  let scheme = call_579894.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579894.url(scheme.get, call_579894.host, call_579894.base,
                         call_579894.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579894, url, valid)

proc call*(call_579895: Call_DfareportingContentCategoriesInsert_579882;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingContentCategoriesInsert
  ## Inserts a new content category.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579896 = newJObject()
  var query_579897 = newJObject()
  var body_579898 = newJObject()
  add(query_579897, "key", newJString(key))
  add(query_579897, "prettyPrint", newJBool(prettyPrint))
  add(query_579897, "oauth_token", newJString(oauthToken))
  add(path_579896, "profileId", newJString(profileId))
  add(query_579897, "alt", newJString(alt))
  add(query_579897, "userIp", newJString(userIp))
  add(query_579897, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_579898 = body
  add(query_579897, "fields", newJString(fields))
  result = call_579895.call(path_579896, query_579897, nil, nil, body_579898)

var dfareportingContentCategoriesInsert* = Call_DfareportingContentCategoriesInsert_579882(
    name: "dfareportingContentCategoriesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesInsert_579883,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesInsert_579884,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesList_579844 = ref object of OpenApiRestCall_578364
proc url_DfareportingContentCategoriesList_579846(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesList_579845(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of content categories, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579847 = path.getOrDefault("profileId")
  valid_579847 = validateParameter(valid_579847, JString, required = true,
                                 default = nil)
  if valid_579847 != nil:
    section.add "profileId", valid_579847
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "contentcategory*2015" will return objects with names like "contentcategory June 2015", "contentcategory April 2015", or simply "contentcategory 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "contentcategory" will match objects with name "my contentcategory", "contentcategory 2015", or simply "contentcategory".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only content categories with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_579848 = query.getOrDefault("key")
  valid_579848 = validateParameter(valid_579848, JString, required = false,
                                 default = nil)
  if valid_579848 != nil:
    section.add "key", valid_579848
  var valid_579849 = query.getOrDefault("prettyPrint")
  valid_579849 = validateParameter(valid_579849, JBool, required = false,
                                 default = newJBool(true))
  if valid_579849 != nil:
    section.add "prettyPrint", valid_579849
  var valid_579850 = query.getOrDefault("oauth_token")
  valid_579850 = validateParameter(valid_579850, JString, required = false,
                                 default = nil)
  if valid_579850 != nil:
    section.add "oauth_token", valid_579850
  var valid_579851 = query.getOrDefault("sortField")
  valid_579851 = validateParameter(valid_579851, JString, required = false,
                                 default = newJString("ID"))
  if valid_579851 != nil:
    section.add "sortField", valid_579851
  var valid_579852 = query.getOrDefault("alt")
  valid_579852 = validateParameter(valid_579852, JString, required = false,
                                 default = newJString("json"))
  if valid_579852 != nil:
    section.add "alt", valid_579852
  var valid_579853 = query.getOrDefault("userIp")
  valid_579853 = validateParameter(valid_579853, JString, required = false,
                                 default = nil)
  if valid_579853 != nil:
    section.add "userIp", valid_579853
  var valid_579854 = query.getOrDefault("quotaUser")
  valid_579854 = validateParameter(valid_579854, JString, required = false,
                                 default = nil)
  if valid_579854 != nil:
    section.add "quotaUser", valid_579854
  var valid_579855 = query.getOrDefault("pageToken")
  valid_579855 = validateParameter(valid_579855, JString, required = false,
                                 default = nil)
  if valid_579855 != nil:
    section.add "pageToken", valid_579855
  var valid_579856 = query.getOrDefault("searchString")
  valid_579856 = validateParameter(valid_579856, JString, required = false,
                                 default = nil)
  if valid_579856 != nil:
    section.add "searchString", valid_579856
  var valid_579857 = query.getOrDefault("sortOrder")
  valid_579857 = validateParameter(valid_579857, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_579857 != nil:
    section.add "sortOrder", valid_579857
  var valid_579858 = query.getOrDefault("ids")
  valid_579858 = validateParameter(valid_579858, JArray, required = false,
                                 default = nil)
  if valid_579858 != nil:
    section.add "ids", valid_579858
  var valid_579859 = query.getOrDefault("fields")
  valid_579859 = validateParameter(valid_579859, JString, required = false,
                                 default = nil)
  if valid_579859 != nil:
    section.add "fields", valid_579859
  var valid_579860 = query.getOrDefault("maxResults")
  valid_579860 = validateParameter(valid_579860, JInt, required = false,
                                 default = newJInt(1000))
  if valid_579860 != nil:
    section.add "maxResults", valid_579860
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579861: Call_DfareportingContentCategoriesList_579844;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of content categories, possibly filtered. This method supports paging.
  ## 
  let valid = call_579861.validator(path, query, header, formData, body)
  let scheme = call_579861.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579861.url(scheme.get, call_579861.host, call_579861.base,
                         call_579861.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579861, url, valid)

proc call*(call_579862: Call_DfareportingContentCategoriesList_579844;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; sortField: string = "ID"; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; pageToken: string = "";
          searchString: string = ""; sortOrder: string = "ASCENDING";
          ids: JsonNode = nil; fields: string = ""; maxResults: int = 1000): Recallable =
  ## dfareportingContentCategoriesList
  ## Retrieves a list of content categories, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "contentcategory*2015" will return objects with names like "contentcategory June 2015", "contentcategory April 2015", or simply "contentcategory 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "contentcategory" will match objects with name "my contentcategory", "contentcategory 2015", or simply "contentcategory".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only content categories with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_579863 = newJObject()
  var query_579864 = newJObject()
  add(query_579864, "key", newJString(key))
  add(query_579864, "prettyPrint", newJBool(prettyPrint))
  add(query_579864, "oauth_token", newJString(oauthToken))
  add(path_579863, "profileId", newJString(profileId))
  add(query_579864, "sortField", newJString(sortField))
  add(query_579864, "alt", newJString(alt))
  add(query_579864, "userIp", newJString(userIp))
  add(query_579864, "quotaUser", newJString(quotaUser))
  add(query_579864, "pageToken", newJString(pageToken))
  add(query_579864, "searchString", newJString(searchString))
  add(query_579864, "sortOrder", newJString(sortOrder))
  if ids != nil:
    query_579864.add "ids", ids
  add(query_579864, "fields", newJString(fields))
  add(query_579864, "maxResults", newJInt(maxResults))
  result = call_579862.call(path_579863, query_579864, nil, nil, nil)

var dfareportingContentCategoriesList* = Call_DfareportingContentCategoriesList_579844(
    name: "dfareportingContentCategoriesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesList_579845,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesList_579846,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesPatch_579899 = ref object of OpenApiRestCall_578364
proc url_DfareportingContentCategoriesPatch_579901(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesPatch_579900(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing content category. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579902 = path.getOrDefault("profileId")
  valid_579902 = validateParameter(valid_579902, JString, required = true,
                                 default = nil)
  if valid_579902 != nil:
    section.add "profileId", valid_579902
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Content category ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579903 = query.getOrDefault("key")
  valid_579903 = validateParameter(valid_579903, JString, required = false,
                                 default = nil)
  if valid_579903 != nil:
    section.add "key", valid_579903
  var valid_579904 = query.getOrDefault("prettyPrint")
  valid_579904 = validateParameter(valid_579904, JBool, required = false,
                                 default = newJBool(true))
  if valid_579904 != nil:
    section.add "prettyPrint", valid_579904
  var valid_579905 = query.getOrDefault("oauth_token")
  valid_579905 = validateParameter(valid_579905, JString, required = false,
                                 default = nil)
  if valid_579905 != nil:
    section.add "oauth_token", valid_579905
  var valid_579906 = query.getOrDefault("alt")
  valid_579906 = validateParameter(valid_579906, JString, required = false,
                                 default = newJString("json"))
  if valid_579906 != nil:
    section.add "alt", valid_579906
  var valid_579907 = query.getOrDefault("userIp")
  valid_579907 = validateParameter(valid_579907, JString, required = false,
                                 default = nil)
  if valid_579907 != nil:
    section.add "userIp", valid_579907
  var valid_579908 = query.getOrDefault("quotaUser")
  valid_579908 = validateParameter(valid_579908, JString, required = false,
                                 default = nil)
  if valid_579908 != nil:
    section.add "quotaUser", valid_579908
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_579909 = query.getOrDefault("id")
  valid_579909 = validateParameter(valid_579909, JString, required = true,
                                 default = nil)
  if valid_579909 != nil:
    section.add "id", valid_579909
  var valid_579910 = query.getOrDefault("fields")
  valid_579910 = validateParameter(valid_579910, JString, required = false,
                                 default = nil)
  if valid_579910 != nil:
    section.add "fields", valid_579910
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579912: Call_DfareportingContentCategoriesPatch_579899;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing content category. This method supports patch semantics.
  ## 
  let valid = call_579912.validator(path, query, header, formData, body)
  let scheme = call_579912.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579912.url(scheme.get, call_579912.host, call_579912.base,
                         call_579912.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579912, url, valid)

proc call*(call_579913: Call_DfareportingContentCategoriesPatch_579899;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingContentCategoriesPatch
  ## Updates an existing content category. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Content category ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579914 = newJObject()
  var query_579915 = newJObject()
  var body_579916 = newJObject()
  add(query_579915, "key", newJString(key))
  add(query_579915, "prettyPrint", newJBool(prettyPrint))
  add(query_579915, "oauth_token", newJString(oauthToken))
  add(path_579914, "profileId", newJString(profileId))
  add(query_579915, "alt", newJString(alt))
  add(query_579915, "userIp", newJString(userIp))
  add(query_579915, "quotaUser", newJString(quotaUser))
  add(query_579915, "id", newJString(id))
  if body != nil:
    body_579916 = body
  add(query_579915, "fields", newJString(fields))
  result = call_579913.call(path_579914, query_579915, nil, nil, body_579916)

var dfareportingContentCategoriesPatch* = Call_DfareportingContentCategoriesPatch_579899(
    name: "dfareportingContentCategoriesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesPatch_579900,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesPatch_579901,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesGet_579917 = ref object of OpenApiRestCall_578364
proc url_DfareportingContentCategoriesGet_579919(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesGet_579918(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one content category by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Content category ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579920 = path.getOrDefault("profileId")
  valid_579920 = validateParameter(valid_579920, JString, required = true,
                                 default = nil)
  if valid_579920 != nil:
    section.add "profileId", valid_579920
  var valid_579921 = path.getOrDefault("id")
  valid_579921 = validateParameter(valid_579921, JString, required = true,
                                 default = nil)
  if valid_579921 != nil:
    section.add "id", valid_579921
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579922 = query.getOrDefault("key")
  valid_579922 = validateParameter(valid_579922, JString, required = false,
                                 default = nil)
  if valid_579922 != nil:
    section.add "key", valid_579922
  var valid_579923 = query.getOrDefault("prettyPrint")
  valid_579923 = validateParameter(valid_579923, JBool, required = false,
                                 default = newJBool(true))
  if valid_579923 != nil:
    section.add "prettyPrint", valid_579923
  var valid_579924 = query.getOrDefault("oauth_token")
  valid_579924 = validateParameter(valid_579924, JString, required = false,
                                 default = nil)
  if valid_579924 != nil:
    section.add "oauth_token", valid_579924
  var valid_579925 = query.getOrDefault("alt")
  valid_579925 = validateParameter(valid_579925, JString, required = false,
                                 default = newJString("json"))
  if valid_579925 != nil:
    section.add "alt", valid_579925
  var valid_579926 = query.getOrDefault("userIp")
  valid_579926 = validateParameter(valid_579926, JString, required = false,
                                 default = nil)
  if valid_579926 != nil:
    section.add "userIp", valid_579926
  var valid_579927 = query.getOrDefault("quotaUser")
  valid_579927 = validateParameter(valid_579927, JString, required = false,
                                 default = nil)
  if valid_579927 != nil:
    section.add "quotaUser", valid_579927
  var valid_579928 = query.getOrDefault("fields")
  valid_579928 = validateParameter(valid_579928, JString, required = false,
                                 default = nil)
  if valid_579928 != nil:
    section.add "fields", valid_579928
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579929: Call_DfareportingContentCategoriesGet_579917;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one content category by ID.
  ## 
  let valid = call_579929.validator(path, query, header, formData, body)
  let scheme = call_579929.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579929.url(scheme.get, call_579929.host, call_579929.base,
                         call_579929.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579929, url, valid)

proc call*(call_579930: Call_DfareportingContentCategoriesGet_579917;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingContentCategoriesGet
  ## Gets one content category by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Content category ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579931 = newJObject()
  var query_579932 = newJObject()
  add(query_579932, "key", newJString(key))
  add(query_579932, "prettyPrint", newJBool(prettyPrint))
  add(query_579932, "oauth_token", newJString(oauthToken))
  add(path_579931, "profileId", newJString(profileId))
  add(path_579931, "id", newJString(id))
  add(query_579932, "alt", newJString(alt))
  add(query_579932, "userIp", newJString(userIp))
  add(query_579932, "quotaUser", newJString(quotaUser))
  add(query_579932, "fields", newJString(fields))
  result = call_579930.call(path_579931, query_579932, nil, nil, nil)

var dfareportingContentCategoriesGet* = Call_DfareportingContentCategoriesGet_579917(
    name: "dfareportingContentCategoriesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories/{id}",
    validator: validate_DfareportingContentCategoriesGet_579918,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesGet_579919,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesDelete_579933 = ref object of OpenApiRestCall_578364
proc url_DfareportingContentCategoriesDelete_579935(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesDelete_579934(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing content category.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Content category ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579936 = path.getOrDefault("profileId")
  valid_579936 = validateParameter(valid_579936, JString, required = true,
                                 default = nil)
  if valid_579936 != nil:
    section.add "profileId", valid_579936
  var valid_579937 = path.getOrDefault("id")
  valid_579937 = validateParameter(valid_579937, JString, required = true,
                                 default = nil)
  if valid_579937 != nil:
    section.add "id", valid_579937
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579938 = query.getOrDefault("key")
  valid_579938 = validateParameter(valid_579938, JString, required = false,
                                 default = nil)
  if valid_579938 != nil:
    section.add "key", valid_579938
  var valid_579939 = query.getOrDefault("prettyPrint")
  valid_579939 = validateParameter(valid_579939, JBool, required = false,
                                 default = newJBool(true))
  if valid_579939 != nil:
    section.add "prettyPrint", valid_579939
  var valid_579940 = query.getOrDefault("oauth_token")
  valid_579940 = validateParameter(valid_579940, JString, required = false,
                                 default = nil)
  if valid_579940 != nil:
    section.add "oauth_token", valid_579940
  var valid_579941 = query.getOrDefault("alt")
  valid_579941 = validateParameter(valid_579941, JString, required = false,
                                 default = newJString("json"))
  if valid_579941 != nil:
    section.add "alt", valid_579941
  var valid_579942 = query.getOrDefault("userIp")
  valid_579942 = validateParameter(valid_579942, JString, required = false,
                                 default = nil)
  if valid_579942 != nil:
    section.add "userIp", valid_579942
  var valid_579943 = query.getOrDefault("quotaUser")
  valid_579943 = validateParameter(valid_579943, JString, required = false,
                                 default = nil)
  if valid_579943 != nil:
    section.add "quotaUser", valid_579943
  var valid_579944 = query.getOrDefault("fields")
  valid_579944 = validateParameter(valid_579944, JString, required = false,
                                 default = nil)
  if valid_579944 != nil:
    section.add "fields", valid_579944
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579945: Call_DfareportingContentCategoriesDelete_579933;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing content category.
  ## 
  let valid = call_579945.validator(path, query, header, formData, body)
  let scheme = call_579945.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579945.url(scheme.get, call_579945.host, call_579945.base,
                         call_579945.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579945, url, valid)

proc call*(call_579946: Call_DfareportingContentCategoriesDelete_579933;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingContentCategoriesDelete
  ## Deletes an existing content category.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Content category ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579947 = newJObject()
  var query_579948 = newJObject()
  add(query_579948, "key", newJString(key))
  add(query_579948, "prettyPrint", newJBool(prettyPrint))
  add(query_579948, "oauth_token", newJString(oauthToken))
  add(path_579947, "profileId", newJString(profileId))
  add(path_579947, "id", newJString(id))
  add(query_579948, "alt", newJString(alt))
  add(query_579948, "userIp", newJString(userIp))
  add(query_579948, "quotaUser", newJString(quotaUser))
  add(query_579948, "fields", newJString(fields))
  result = call_579946.call(path_579947, query_579948, nil, nil, nil)

var dfareportingContentCategoriesDelete* = Call_DfareportingContentCategoriesDelete_579933(
    name: "dfareportingContentCategoriesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories/{id}",
    validator: validate_DfareportingContentCategoriesDelete_579934,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesDelete_579935,
    schemes: {Scheme.Https})
type
  Call_DfareportingConversionsBatchinsert_579949 = ref object of OpenApiRestCall_578364
proc url_DfareportingConversionsBatchinsert_579951(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/conversions/batchinsert")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingConversionsBatchinsert_579950(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts conversions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579952 = path.getOrDefault("profileId")
  valid_579952 = validateParameter(valid_579952, JString, required = true,
                                 default = nil)
  if valid_579952 != nil:
    section.add "profileId", valid_579952
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579953 = query.getOrDefault("key")
  valid_579953 = validateParameter(valid_579953, JString, required = false,
                                 default = nil)
  if valid_579953 != nil:
    section.add "key", valid_579953
  var valid_579954 = query.getOrDefault("prettyPrint")
  valid_579954 = validateParameter(valid_579954, JBool, required = false,
                                 default = newJBool(true))
  if valid_579954 != nil:
    section.add "prettyPrint", valid_579954
  var valid_579955 = query.getOrDefault("oauth_token")
  valid_579955 = validateParameter(valid_579955, JString, required = false,
                                 default = nil)
  if valid_579955 != nil:
    section.add "oauth_token", valid_579955
  var valid_579956 = query.getOrDefault("alt")
  valid_579956 = validateParameter(valid_579956, JString, required = false,
                                 default = newJString("json"))
  if valid_579956 != nil:
    section.add "alt", valid_579956
  var valid_579957 = query.getOrDefault("userIp")
  valid_579957 = validateParameter(valid_579957, JString, required = false,
                                 default = nil)
  if valid_579957 != nil:
    section.add "userIp", valid_579957
  var valid_579958 = query.getOrDefault("quotaUser")
  valid_579958 = validateParameter(valid_579958, JString, required = false,
                                 default = nil)
  if valid_579958 != nil:
    section.add "quotaUser", valid_579958
  var valid_579959 = query.getOrDefault("fields")
  valid_579959 = validateParameter(valid_579959, JString, required = false,
                                 default = nil)
  if valid_579959 != nil:
    section.add "fields", valid_579959
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579961: Call_DfareportingConversionsBatchinsert_579949;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts conversions.
  ## 
  let valid = call_579961.validator(path, query, header, formData, body)
  let scheme = call_579961.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579961.url(scheme.get, call_579961.host, call_579961.base,
                         call_579961.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579961, url, valid)

proc call*(call_579962: Call_DfareportingConversionsBatchinsert_579949;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingConversionsBatchinsert
  ## Inserts conversions.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579963 = newJObject()
  var query_579964 = newJObject()
  var body_579965 = newJObject()
  add(query_579964, "key", newJString(key))
  add(query_579964, "prettyPrint", newJBool(prettyPrint))
  add(query_579964, "oauth_token", newJString(oauthToken))
  add(path_579963, "profileId", newJString(profileId))
  add(query_579964, "alt", newJString(alt))
  add(query_579964, "userIp", newJString(userIp))
  add(query_579964, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_579965 = body
  add(query_579964, "fields", newJString(fields))
  result = call_579962.call(path_579963, query_579964, nil, nil, body_579965)

var dfareportingConversionsBatchinsert* = Call_DfareportingConversionsBatchinsert_579949(
    name: "dfareportingConversionsBatchinsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/conversions/batchinsert",
    validator: validate_DfareportingConversionsBatchinsert_579950,
    base: "/dfareporting/v2.7", url: url_DfareportingConversionsBatchinsert_579951,
    schemes: {Scheme.Https})
type
  Call_DfareportingCountriesList_579966 = ref object of OpenApiRestCall_578364
proc url_DfareportingCountriesList_579968(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/countries")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCountriesList_579967(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of countries.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579969 = path.getOrDefault("profileId")
  valid_579969 = validateParameter(valid_579969, JString, required = true,
                                 default = nil)
  if valid_579969 != nil:
    section.add "profileId", valid_579969
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579970 = query.getOrDefault("key")
  valid_579970 = validateParameter(valid_579970, JString, required = false,
                                 default = nil)
  if valid_579970 != nil:
    section.add "key", valid_579970
  var valid_579971 = query.getOrDefault("prettyPrint")
  valid_579971 = validateParameter(valid_579971, JBool, required = false,
                                 default = newJBool(true))
  if valid_579971 != nil:
    section.add "prettyPrint", valid_579971
  var valid_579972 = query.getOrDefault("oauth_token")
  valid_579972 = validateParameter(valid_579972, JString, required = false,
                                 default = nil)
  if valid_579972 != nil:
    section.add "oauth_token", valid_579972
  var valid_579973 = query.getOrDefault("alt")
  valid_579973 = validateParameter(valid_579973, JString, required = false,
                                 default = newJString("json"))
  if valid_579973 != nil:
    section.add "alt", valid_579973
  var valid_579974 = query.getOrDefault("userIp")
  valid_579974 = validateParameter(valid_579974, JString, required = false,
                                 default = nil)
  if valid_579974 != nil:
    section.add "userIp", valid_579974
  var valid_579975 = query.getOrDefault("quotaUser")
  valid_579975 = validateParameter(valid_579975, JString, required = false,
                                 default = nil)
  if valid_579975 != nil:
    section.add "quotaUser", valid_579975
  var valid_579976 = query.getOrDefault("fields")
  valid_579976 = validateParameter(valid_579976, JString, required = false,
                                 default = nil)
  if valid_579976 != nil:
    section.add "fields", valid_579976
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579977: Call_DfareportingCountriesList_579966; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of countries.
  ## 
  let valid = call_579977.validator(path, query, header, formData, body)
  let scheme = call_579977.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579977.url(scheme.get, call_579977.host, call_579977.base,
                         call_579977.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579977, url, valid)

proc call*(call_579978: Call_DfareportingCountriesList_579966; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingCountriesList
  ## Retrieves a list of countries.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579979 = newJObject()
  var query_579980 = newJObject()
  add(query_579980, "key", newJString(key))
  add(query_579980, "prettyPrint", newJBool(prettyPrint))
  add(query_579980, "oauth_token", newJString(oauthToken))
  add(path_579979, "profileId", newJString(profileId))
  add(query_579980, "alt", newJString(alt))
  add(query_579980, "userIp", newJString(userIp))
  add(query_579980, "quotaUser", newJString(quotaUser))
  add(query_579980, "fields", newJString(fields))
  result = call_579978.call(path_579979, query_579980, nil, nil, nil)

var dfareportingCountriesList* = Call_DfareportingCountriesList_579966(
    name: "dfareportingCountriesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/countries",
    validator: validate_DfareportingCountriesList_579967,
    base: "/dfareporting/v2.7", url: url_DfareportingCountriesList_579968,
    schemes: {Scheme.Https})
type
  Call_DfareportingCountriesGet_579981 = ref object of OpenApiRestCall_578364
proc url_DfareportingCountriesGet_579983(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "dartId" in path, "`dartId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/countries/"),
               (kind: VariableSegment, value: "dartId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCountriesGet_579982(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one country by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   dartId: JString (required)
  ##         : Country DART ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_579984 = path.getOrDefault("profileId")
  valid_579984 = validateParameter(valid_579984, JString, required = true,
                                 default = nil)
  if valid_579984 != nil:
    section.add "profileId", valid_579984
  var valid_579985 = path.getOrDefault("dartId")
  valid_579985 = validateParameter(valid_579985, JString, required = true,
                                 default = nil)
  if valid_579985 != nil:
    section.add "dartId", valid_579985
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_579986 = query.getOrDefault("key")
  valid_579986 = validateParameter(valid_579986, JString, required = false,
                                 default = nil)
  if valid_579986 != nil:
    section.add "key", valid_579986
  var valid_579987 = query.getOrDefault("prettyPrint")
  valid_579987 = validateParameter(valid_579987, JBool, required = false,
                                 default = newJBool(true))
  if valid_579987 != nil:
    section.add "prettyPrint", valid_579987
  var valid_579988 = query.getOrDefault("oauth_token")
  valid_579988 = validateParameter(valid_579988, JString, required = false,
                                 default = nil)
  if valid_579988 != nil:
    section.add "oauth_token", valid_579988
  var valid_579989 = query.getOrDefault("alt")
  valid_579989 = validateParameter(valid_579989, JString, required = false,
                                 default = newJString("json"))
  if valid_579989 != nil:
    section.add "alt", valid_579989
  var valid_579990 = query.getOrDefault("userIp")
  valid_579990 = validateParameter(valid_579990, JString, required = false,
                                 default = nil)
  if valid_579990 != nil:
    section.add "userIp", valid_579990
  var valid_579991 = query.getOrDefault("quotaUser")
  valid_579991 = validateParameter(valid_579991, JString, required = false,
                                 default = nil)
  if valid_579991 != nil:
    section.add "quotaUser", valid_579991
  var valid_579992 = query.getOrDefault("fields")
  valid_579992 = validateParameter(valid_579992, JString, required = false,
                                 default = nil)
  if valid_579992 != nil:
    section.add "fields", valid_579992
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579993: Call_DfareportingCountriesGet_579981; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one country by ID.
  ## 
  let valid = call_579993.validator(path, query, header, formData, body)
  let scheme = call_579993.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579993.url(scheme.get, call_579993.host, call_579993.base,
                         call_579993.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579993, url, valid)

proc call*(call_579994: Call_DfareportingCountriesGet_579981; profileId: string;
          dartId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingCountriesGet
  ## Gets one country by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   dartId: string (required)
  ##         : Country DART ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_579995 = newJObject()
  var query_579996 = newJObject()
  add(query_579996, "key", newJString(key))
  add(query_579996, "prettyPrint", newJBool(prettyPrint))
  add(query_579996, "oauth_token", newJString(oauthToken))
  add(path_579995, "profileId", newJString(profileId))
  add(query_579996, "alt", newJString(alt))
  add(query_579996, "userIp", newJString(userIp))
  add(query_579996, "quotaUser", newJString(quotaUser))
  add(path_579995, "dartId", newJString(dartId))
  add(query_579996, "fields", newJString(fields))
  result = call_579994.call(path_579995, query_579996, nil, nil, nil)

var dfareportingCountriesGet* = Call_DfareportingCountriesGet_579981(
    name: "dfareportingCountriesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/countries/{dartId}",
    validator: validate_DfareportingCountriesGet_579982,
    base: "/dfareporting/v2.7", url: url_DfareportingCountriesGet_579983,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeAssetsInsert_579997 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeAssetsInsert_579999(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "advertiserId" in path, "`advertiserId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeAssets/"),
               (kind: VariableSegment, value: "advertiserId"),
               (kind: ConstantSegment, value: "/creativeAssets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeAssetsInsert_579998(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative asset.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   advertiserId: JString (required)
  ##               : Advertiser ID of this creative. This is a required field.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580000 = path.getOrDefault("profileId")
  valid_580000 = validateParameter(valid_580000, JString, required = true,
                                 default = nil)
  if valid_580000 != nil:
    section.add "profileId", valid_580000
  var valid_580001 = path.getOrDefault("advertiserId")
  valid_580001 = validateParameter(valid_580001, JString, required = true,
                                 default = nil)
  if valid_580001 != nil:
    section.add "advertiserId", valid_580001
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580002 = query.getOrDefault("key")
  valid_580002 = validateParameter(valid_580002, JString, required = false,
                                 default = nil)
  if valid_580002 != nil:
    section.add "key", valid_580002
  var valid_580003 = query.getOrDefault("prettyPrint")
  valid_580003 = validateParameter(valid_580003, JBool, required = false,
                                 default = newJBool(true))
  if valid_580003 != nil:
    section.add "prettyPrint", valid_580003
  var valid_580004 = query.getOrDefault("oauth_token")
  valid_580004 = validateParameter(valid_580004, JString, required = false,
                                 default = nil)
  if valid_580004 != nil:
    section.add "oauth_token", valid_580004
  var valid_580005 = query.getOrDefault("alt")
  valid_580005 = validateParameter(valid_580005, JString, required = false,
                                 default = newJString("json"))
  if valid_580005 != nil:
    section.add "alt", valid_580005
  var valid_580006 = query.getOrDefault("userIp")
  valid_580006 = validateParameter(valid_580006, JString, required = false,
                                 default = nil)
  if valid_580006 != nil:
    section.add "userIp", valid_580006
  var valid_580007 = query.getOrDefault("quotaUser")
  valid_580007 = validateParameter(valid_580007, JString, required = false,
                                 default = nil)
  if valid_580007 != nil:
    section.add "quotaUser", valid_580007
  var valid_580008 = query.getOrDefault("fields")
  valid_580008 = validateParameter(valid_580008, JString, required = false,
                                 default = nil)
  if valid_580008 != nil:
    section.add "fields", valid_580008
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580010: Call_DfareportingCreativeAssetsInsert_579997;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative asset.
  ## 
  let valid = call_580010.validator(path, query, header, formData, body)
  let scheme = call_580010.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580010.url(scheme.get, call_580010.host, call_580010.base,
                         call_580010.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580010, url, valid)

proc call*(call_580011: Call_DfareportingCreativeAssetsInsert_579997;
          profileId: string; advertiserId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; body: JsonNode = nil;
          fields: string = ""): Recallable =
  ## dfareportingCreativeAssetsInsert
  ## Inserts a new creative asset.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   advertiserId: string (required)
  ##               : Advertiser ID of this creative. This is a required field.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580012 = newJObject()
  var query_580013 = newJObject()
  var body_580014 = newJObject()
  add(query_580013, "key", newJString(key))
  add(query_580013, "prettyPrint", newJBool(prettyPrint))
  add(query_580013, "oauth_token", newJString(oauthToken))
  add(path_580012, "profileId", newJString(profileId))
  add(query_580013, "alt", newJString(alt))
  add(query_580013, "userIp", newJString(userIp))
  add(query_580013, "quotaUser", newJString(quotaUser))
  add(path_580012, "advertiserId", newJString(advertiserId))
  if body != nil:
    body_580014 = body
  add(query_580013, "fields", newJString(fields))
  result = call_580011.call(path_580012, query_580013, nil, nil, body_580014)

var dfareportingCreativeAssetsInsert* = Call_DfareportingCreativeAssetsInsert_579997(
    name: "dfareportingCreativeAssetsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeAssets/{advertiserId}/creativeAssets",
    validator: validate_DfareportingCreativeAssetsInsert_579998,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeAssetsInsert_579999,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsUpdate_580037 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeFieldsUpdate_580039(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsUpdate_580038(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580040 = path.getOrDefault("profileId")
  valid_580040 = validateParameter(valid_580040, JString, required = true,
                                 default = nil)
  if valid_580040 != nil:
    section.add "profileId", valid_580040
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580041 = query.getOrDefault("key")
  valid_580041 = validateParameter(valid_580041, JString, required = false,
                                 default = nil)
  if valid_580041 != nil:
    section.add "key", valid_580041
  var valid_580042 = query.getOrDefault("prettyPrint")
  valid_580042 = validateParameter(valid_580042, JBool, required = false,
                                 default = newJBool(true))
  if valid_580042 != nil:
    section.add "prettyPrint", valid_580042
  var valid_580043 = query.getOrDefault("oauth_token")
  valid_580043 = validateParameter(valid_580043, JString, required = false,
                                 default = nil)
  if valid_580043 != nil:
    section.add "oauth_token", valid_580043
  var valid_580044 = query.getOrDefault("alt")
  valid_580044 = validateParameter(valid_580044, JString, required = false,
                                 default = newJString("json"))
  if valid_580044 != nil:
    section.add "alt", valid_580044
  var valid_580045 = query.getOrDefault("userIp")
  valid_580045 = validateParameter(valid_580045, JString, required = false,
                                 default = nil)
  if valid_580045 != nil:
    section.add "userIp", valid_580045
  var valid_580046 = query.getOrDefault("quotaUser")
  valid_580046 = validateParameter(valid_580046, JString, required = false,
                                 default = nil)
  if valid_580046 != nil:
    section.add "quotaUser", valid_580046
  var valid_580047 = query.getOrDefault("fields")
  valid_580047 = validateParameter(valid_580047, JString, required = false,
                                 default = nil)
  if valid_580047 != nil:
    section.add "fields", valid_580047
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580049: Call_DfareportingCreativeFieldsUpdate_580037;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field.
  ## 
  let valid = call_580049.validator(path, query, header, formData, body)
  let scheme = call_580049.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580049.url(scheme.get, call_580049.host, call_580049.base,
                         call_580049.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580049, url, valid)

proc call*(call_580050: Call_DfareportingCreativeFieldsUpdate_580037;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingCreativeFieldsUpdate
  ## Updates an existing creative field.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580051 = newJObject()
  var query_580052 = newJObject()
  var body_580053 = newJObject()
  add(query_580052, "key", newJString(key))
  add(query_580052, "prettyPrint", newJBool(prettyPrint))
  add(query_580052, "oauth_token", newJString(oauthToken))
  add(path_580051, "profileId", newJString(profileId))
  add(query_580052, "alt", newJString(alt))
  add(query_580052, "userIp", newJString(userIp))
  add(query_580052, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580053 = body
  add(query_580052, "fields", newJString(fields))
  result = call_580050.call(path_580051, query_580052, nil, nil, body_580053)

var dfareportingCreativeFieldsUpdate* = Call_DfareportingCreativeFieldsUpdate_580037(
    name: "dfareportingCreativeFieldsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsUpdate_580038,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsUpdate_580039,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsInsert_580054 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeFieldsInsert_580056(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsInsert_580055(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative field.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580057 = path.getOrDefault("profileId")
  valid_580057 = validateParameter(valid_580057, JString, required = true,
                                 default = nil)
  if valid_580057 != nil:
    section.add "profileId", valid_580057
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580058 = query.getOrDefault("key")
  valid_580058 = validateParameter(valid_580058, JString, required = false,
                                 default = nil)
  if valid_580058 != nil:
    section.add "key", valid_580058
  var valid_580059 = query.getOrDefault("prettyPrint")
  valid_580059 = validateParameter(valid_580059, JBool, required = false,
                                 default = newJBool(true))
  if valid_580059 != nil:
    section.add "prettyPrint", valid_580059
  var valid_580060 = query.getOrDefault("oauth_token")
  valid_580060 = validateParameter(valid_580060, JString, required = false,
                                 default = nil)
  if valid_580060 != nil:
    section.add "oauth_token", valid_580060
  var valid_580061 = query.getOrDefault("alt")
  valid_580061 = validateParameter(valid_580061, JString, required = false,
                                 default = newJString("json"))
  if valid_580061 != nil:
    section.add "alt", valid_580061
  var valid_580062 = query.getOrDefault("userIp")
  valid_580062 = validateParameter(valid_580062, JString, required = false,
                                 default = nil)
  if valid_580062 != nil:
    section.add "userIp", valid_580062
  var valid_580063 = query.getOrDefault("quotaUser")
  valid_580063 = validateParameter(valid_580063, JString, required = false,
                                 default = nil)
  if valid_580063 != nil:
    section.add "quotaUser", valid_580063
  var valid_580064 = query.getOrDefault("fields")
  valid_580064 = validateParameter(valid_580064, JString, required = false,
                                 default = nil)
  if valid_580064 != nil:
    section.add "fields", valid_580064
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580066: Call_DfareportingCreativeFieldsInsert_580054;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative field.
  ## 
  let valid = call_580066.validator(path, query, header, formData, body)
  let scheme = call_580066.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580066.url(scheme.get, call_580066.host, call_580066.base,
                         call_580066.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580066, url, valid)

proc call*(call_580067: Call_DfareportingCreativeFieldsInsert_580054;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingCreativeFieldsInsert
  ## Inserts a new creative field.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580068 = newJObject()
  var query_580069 = newJObject()
  var body_580070 = newJObject()
  add(query_580069, "key", newJString(key))
  add(query_580069, "prettyPrint", newJBool(prettyPrint))
  add(query_580069, "oauth_token", newJString(oauthToken))
  add(path_580068, "profileId", newJString(profileId))
  add(query_580069, "alt", newJString(alt))
  add(query_580069, "userIp", newJString(userIp))
  add(query_580069, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580070 = body
  add(query_580069, "fields", newJString(fields))
  result = call_580067.call(path_580068, query_580069, nil, nil, body_580070)

var dfareportingCreativeFieldsInsert* = Call_DfareportingCreativeFieldsInsert_580054(
    name: "dfareportingCreativeFieldsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsInsert_580055,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsInsert_580056,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsList_580015 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeFieldsList_580017(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsList_580016(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creative fields, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580018 = path.getOrDefault("profileId")
  valid_580018 = validateParameter(valid_580018, JString, required = true,
                                 default = nil)
  if valid_580018 != nil:
    section.add "profileId", valid_580018
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   advertiserIds: JArray
  ##                : Select only creative fields that belong to these advertisers.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for creative fields by name or ID. Wildcards (*) are allowed. For example, "creativefield*2015" will return creative fields with names like "creativefield June 2015", "creativefield April 2015", or simply "creativefield 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativefield" will match creative fields with the name "my creativefield", "creativefield 2015", or simply "creativefield".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only creative fields with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_580019 = query.getOrDefault("key")
  valid_580019 = validateParameter(valid_580019, JString, required = false,
                                 default = nil)
  if valid_580019 != nil:
    section.add "key", valid_580019
  var valid_580020 = query.getOrDefault("prettyPrint")
  valid_580020 = validateParameter(valid_580020, JBool, required = false,
                                 default = newJBool(true))
  if valid_580020 != nil:
    section.add "prettyPrint", valid_580020
  var valid_580021 = query.getOrDefault("oauth_token")
  valid_580021 = validateParameter(valid_580021, JString, required = false,
                                 default = nil)
  if valid_580021 != nil:
    section.add "oauth_token", valid_580021
  var valid_580022 = query.getOrDefault("sortField")
  valid_580022 = validateParameter(valid_580022, JString, required = false,
                                 default = newJString("ID"))
  if valid_580022 != nil:
    section.add "sortField", valid_580022
  var valid_580023 = query.getOrDefault("advertiserIds")
  valid_580023 = validateParameter(valid_580023, JArray, required = false,
                                 default = nil)
  if valid_580023 != nil:
    section.add "advertiserIds", valid_580023
  var valid_580024 = query.getOrDefault("alt")
  valid_580024 = validateParameter(valid_580024, JString, required = false,
                                 default = newJString("json"))
  if valid_580024 != nil:
    section.add "alt", valid_580024
  var valid_580025 = query.getOrDefault("userIp")
  valid_580025 = validateParameter(valid_580025, JString, required = false,
                                 default = nil)
  if valid_580025 != nil:
    section.add "userIp", valid_580025
  var valid_580026 = query.getOrDefault("quotaUser")
  valid_580026 = validateParameter(valid_580026, JString, required = false,
                                 default = nil)
  if valid_580026 != nil:
    section.add "quotaUser", valid_580026
  var valid_580027 = query.getOrDefault("pageToken")
  valid_580027 = validateParameter(valid_580027, JString, required = false,
                                 default = nil)
  if valid_580027 != nil:
    section.add "pageToken", valid_580027
  var valid_580028 = query.getOrDefault("searchString")
  valid_580028 = validateParameter(valid_580028, JString, required = false,
                                 default = nil)
  if valid_580028 != nil:
    section.add "searchString", valid_580028
  var valid_580029 = query.getOrDefault("sortOrder")
  valid_580029 = validateParameter(valid_580029, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580029 != nil:
    section.add "sortOrder", valid_580029
  var valid_580030 = query.getOrDefault("ids")
  valid_580030 = validateParameter(valid_580030, JArray, required = false,
                                 default = nil)
  if valid_580030 != nil:
    section.add "ids", valid_580030
  var valid_580031 = query.getOrDefault("fields")
  valid_580031 = validateParameter(valid_580031, JString, required = false,
                                 default = nil)
  if valid_580031 != nil:
    section.add "fields", valid_580031
  var valid_580032 = query.getOrDefault("maxResults")
  valid_580032 = validateParameter(valid_580032, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580032 != nil:
    section.add "maxResults", valid_580032
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580033: Call_DfareportingCreativeFieldsList_580015; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of creative fields, possibly filtered. This method supports paging.
  ## 
  let valid = call_580033.validator(path, query, header, formData, body)
  let scheme = call_580033.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580033.url(scheme.get, call_580033.host, call_580033.base,
                         call_580033.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580033, url, valid)

proc call*(call_580034: Call_DfareportingCreativeFieldsList_580015;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; sortField: string = "ID";
          advertiserIds: JsonNode = nil; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; pageToken: string = ""; searchString: string = "";
          sortOrder: string = "ASCENDING"; ids: JsonNode = nil; fields: string = "";
          maxResults: int = 1000): Recallable =
  ## dfareportingCreativeFieldsList
  ## Retrieves a list of creative fields, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   advertiserIds: JArray
  ##                : Select only creative fields that belong to these advertisers.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for creative fields by name or ID. Wildcards (*) are allowed. For example, "creativefield*2015" will return creative fields with names like "creativefield June 2015", "creativefield April 2015", or simply "creativefield 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativefield" will match creative fields with the name "my creativefield", "creativefield 2015", or simply "creativefield".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only creative fields with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_580035 = newJObject()
  var query_580036 = newJObject()
  add(query_580036, "key", newJString(key))
  add(query_580036, "prettyPrint", newJBool(prettyPrint))
  add(query_580036, "oauth_token", newJString(oauthToken))
  add(path_580035, "profileId", newJString(profileId))
  add(query_580036, "sortField", newJString(sortField))
  if advertiserIds != nil:
    query_580036.add "advertiserIds", advertiserIds
  add(query_580036, "alt", newJString(alt))
  add(query_580036, "userIp", newJString(userIp))
  add(query_580036, "quotaUser", newJString(quotaUser))
  add(query_580036, "pageToken", newJString(pageToken))
  add(query_580036, "searchString", newJString(searchString))
  add(query_580036, "sortOrder", newJString(sortOrder))
  if ids != nil:
    query_580036.add "ids", ids
  add(query_580036, "fields", newJString(fields))
  add(query_580036, "maxResults", newJInt(maxResults))
  result = call_580034.call(path_580035, query_580036, nil, nil, nil)

var dfareportingCreativeFieldsList* = Call_DfareportingCreativeFieldsList_580015(
    name: "dfareportingCreativeFieldsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsList_580016,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsList_580017,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsPatch_580071 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeFieldsPatch_580073(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsPatch_580072(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580074 = path.getOrDefault("profileId")
  valid_580074 = validateParameter(valid_580074, JString, required = true,
                                 default = nil)
  if valid_580074 != nil:
    section.add "profileId", valid_580074
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative Field ID
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580075 = query.getOrDefault("key")
  valid_580075 = validateParameter(valid_580075, JString, required = false,
                                 default = nil)
  if valid_580075 != nil:
    section.add "key", valid_580075
  var valid_580076 = query.getOrDefault("prettyPrint")
  valid_580076 = validateParameter(valid_580076, JBool, required = false,
                                 default = newJBool(true))
  if valid_580076 != nil:
    section.add "prettyPrint", valid_580076
  var valid_580077 = query.getOrDefault("oauth_token")
  valid_580077 = validateParameter(valid_580077, JString, required = false,
                                 default = nil)
  if valid_580077 != nil:
    section.add "oauth_token", valid_580077
  var valid_580078 = query.getOrDefault("alt")
  valid_580078 = validateParameter(valid_580078, JString, required = false,
                                 default = newJString("json"))
  if valid_580078 != nil:
    section.add "alt", valid_580078
  var valid_580079 = query.getOrDefault("userIp")
  valid_580079 = validateParameter(valid_580079, JString, required = false,
                                 default = nil)
  if valid_580079 != nil:
    section.add "userIp", valid_580079
  var valid_580080 = query.getOrDefault("quotaUser")
  valid_580080 = validateParameter(valid_580080, JString, required = false,
                                 default = nil)
  if valid_580080 != nil:
    section.add "quotaUser", valid_580080
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580081 = query.getOrDefault("id")
  valid_580081 = validateParameter(valid_580081, JString, required = true,
                                 default = nil)
  if valid_580081 != nil:
    section.add "id", valid_580081
  var valid_580082 = query.getOrDefault("fields")
  valid_580082 = validateParameter(valid_580082, JString, required = false,
                                 default = nil)
  if valid_580082 != nil:
    section.add "fields", valid_580082
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580084: Call_DfareportingCreativeFieldsPatch_580071;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field. This method supports patch semantics.
  ## 
  let valid = call_580084.validator(path, query, header, formData, body)
  let scheme = call_580084.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580084.url(scheme.get, call_580084.host, call_580084.base,
                         call_580084.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580084, url, valid)

proc call*(call_580085: Call_DfareportingCreativeFieldsPatch_580071;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingCreativeFieldsPatch
  ## Updates an existing creative field. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative Field ID
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580086 = newJObject()
  var query_580087 = newJObject()
  var body_580088 = newJObject()
  add(query_580087, "key", newJString(key))
  add(query_580087, "prettyPrint", newJBool(prettyPrint))
  add(query_580087, "oauth_token", newJString(oauthToken))
  add(path_580086, "profileId", newJString(profileId))
  add(query_580087, "alt", newJString(alt))
  add(query_580087, "userIp", newJString(userIp))
  add(query_580087, "quotaUser", newJString(quotaUser))
  add(query_580087, "id", newJString(id))
  if body != nil:
    body_580088 = body
  add(query_580087, "fields", newJString(fields))
  result = call_580085.call(path_580086, query_580087, nil, nil, body_580088)

var dfareportingCreativeFieldsPatch* = Call_DfareportingCreativeFieldsPatch_580071(
    name: "dfareportingCreativeFieldsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsPatch_580072,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsPatch_580073,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesUpdate_580111 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeFieldValuesUpdate_580113(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesUpdate_580112(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field value.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580114 = path.getOrDefault("profileId")
  valid_580114 = validateParameter(valid_580114, JString, required = true,
                                 default = nil)
  if valid_580114 != nil:
    section.add "profileId", valid_580114
  var valid_580115 = path.getOrDefault("creativeFieldId")
  valid_580115 = validateParameter(valid_580115, JString, required = true,
                                 default = nil)
  if valid_580115 != nil:
    section.add "creativeFieldId", valid_580115
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580116 = query.getOrDefault("key")
  valid_580116 = validateParameter(valid_580116, JString, required = false,
                                 default = nil)
  if valid_580116 != nil:
    section.add "key", valid_580116
  var valid_580117 = query.getOrDefault("prettyPrint")
  valid_580117 = validateParameter(valid_580117, JBool, required = false,
                                 default = newJBool(true))
  if valid_580117 != nil:
    section.add "prettyPrint", valid_580117
  var valid_580118 = query.getOrDefault("oauth_token")
  valid_580118 = validateParameter(valid_580118, JString, required = false,
                                 default = nil)
  if valid_580118 != nil:
    section.add "oauth_token", valid_580118
  var valid_580119 = query.getOrDefault("alt")
  valid_580119 = validateParameter(valid_580119, JString, required = false,
                                 default = newJString("json"))
  if valid_580119 != nil:
    section.add "alt", valid_580119
  var valid_580120 = query.getOrDefault("userIp")
  valid_580120 = validateParameter(valid_580120, JString, required = false,
                                 default = nil)
  if valid_580120 != nil:
    section.add "userIp", valid_580120
  var valid_580121 = query.getOrDefault("quotaUser")
  valid_580121 = validateParameter(valid_580121, JString, required = false,
                                 default = nil)
  if valid_580121 != nil:
    section.add "quotaUser", valid_580121
  var valid_580122 = query.getOrDefault("fields")
  valid_580122 = validateParameter(valid_580122, JString, required = false,
                                 default = nil)
  if valid_580122 != nil:
    section.add "fields", valid_580122
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580124: Call_DfareportingCreativeFieldValuesUpdate_580111;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field value.
  ## 
  let valid = call_580124.validator(path, query, header, formData, body)
  let scheme = call_580124.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580124.url(scheme.get, call_580124.host, call_580124.base,
                         call_580124.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580124, url, valid)

proc call*(call_580125: Call_DfareportingCreativeFieldValuesUpdate_580111;
          profileId: string; creativeFieldId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; body: JsonNode = nil;
          fields: string = ""): Recallable =
  ## dfareportingCreativeFieldValuesUpdate
  ## Updates an existing creative field value.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580126 = newJObject()
  var query_580127 = newJObject()
  var body_580128 = newJObject()
  add(query_580127, "key", newJString(key))
  add(query_580127, "prettyPrint", newJBool(prettyPrint))
  add(query_580127, "oauth_token", newJString(oauthToken))
  add(path_580126, "profileId", newJString(profileId))
  add(query_580127, "alt", newJString(alt))
  add(query_580127, "userIp", newJString(userIp))
  add(query_580127, "quotaUser", newJString(quotaUser))
  add(path_580126, "creativeFieldId", newJString(creativeFieldId))
  if body != nil:
    body_580128 = body
  add(query_580127, "fields", newJString(fields))
  result = call_580125.call(path_580126, query_580127, nil, nil, body_580128)

var dfareportingCreativeFieldValuesUpdate* = Call_DfareportingCreativeFieldValuesUpdate_580111(
    name: "dfareportingCreativeFieldValuesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesUpdate_580112,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesUpdate_580113,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesInsert_580129 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeFieldValuesInsert_580131(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesInsert_580130(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative field value.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580132 = path.getOrDefault("profileId")
  valid_580132 = validateParameter(valid_580132, JString, required = true,
                                 default = nil)
  if valid_580132 != nil:
    section.add "profileId", valid_580132
  var valid_580133 = path.getOrDefault("creativeFieldId")
  valid_580133 = validateParameter(valid_580133, JString, required = true,
                                 default = nil)
  if valid_580133 != nil:
    section.add "creativeFieldId", valid_580133
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580134 = query.getOrDefault("key")
  valid_580134 = validateParameter(valid_580134, JString, required = false,
                                 default = nil)
  if valid_580134 != nil:
    section.add "key", valid_580134
  var valid_580135 = query.getOrDefault("prettyPrint")
  valid_580135 = validateParameter(valid_580135, JBool, required = false,
                                 default = newJBool(true))
  if valid_580135 != nil:
    section.add "prettyPrint", valid_580135
  var valid_580136 = query.getOrDefault("oauth_token")
  valid_580136 = validateParameter(valid_580136, JString, required = false,
                                 default = nil)
  if valid_580136 != nil:
    section.add "oauth_token", valid_580136
  var valid_580137 = query.getOrDefault("alt")
  valid_580137 = validateParameter(valid_580137, JString, required = false,
                                 default = newJString("json"))
  if valid_580137 != nil:
    section.add "alt", valid_580137
  var valid_580138 = query.getOrDefault("userIp")
  valid_580138 = validateParameter(valid_580138, JString, required = false,
                                 default = nil)
  if valid_580138 != nil:
    section.add "userIp", valid_580138
  var valid_580139 = query.getOrDefault("quotaUser")
  valid_580139 = validateParameter(valid_580139, JString, required = false,
                                 default = nil)
  if valid_580139 != nil:
    section.add "quotaUser", valid_580139
  var valid_580140 = query.getOrDefault("fields")
  valid_580140 = validateParameter(valid_580140, JString, required = false,
                                 default = nil)
  if valid_580140 != nil:
    section.add "fields", valid_580140
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580142: Call_DfareportingCreativeFieldValuesInsert_580129;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative field value.
  ## 
  let valid = call_580142.validator(path, query, header, formData, body)
  let scheme = call_580142.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580142.url(scheme.get, call_580142.host, call_580142.base,
                         call_580142.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580142, url, valid)

proc call*(call_580143: Call_DfareportingCreativeFieldValuesInsert_580129;
          profileId: string; creativeFieldId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; body: JsonNode = nil;
          fields: string = ""): Recallable =
  ## dfareportingCreativeFieldValuesInsert
  ## Inserts a new creative field value.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580144 = newJObject()
  var query_580145 = newJObject()
  var body_580146 = newJObject()
  add(query_580145, "key", newJString(key))
  add(query_580145, "prettyPrint", newJBool(prettyPrint))
  add(query_580145, "oauth_token", newJString(oauthToken))
  add(path_580144, "profileId", newJString(profileId))
  add(query_580145, "alt", newJString(alt))
  add(query_580145, "userIp", newJString(userIp))
  add(query_580145, "quotaUser", newJString(quotaUser))
  add(path_580144, "creativeFieldId", newJString(creativeFieldId))
  if body != nil:
    body_580146 = body
  add(query_580145, "fields", newJString(fields))
  result = call_580143.call(path_580144, query_580145, nil, nil, body_580146)

var dfareportingCreativeFieldValuesInsert* = Call_DfareportingCreativeFieldValuesInsert_580129(
    name: "dfareportingCreativeFieldValuesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesInsert_580130,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesInsert_580131,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesList_580089 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeFieldValuesList_580091(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesList_580090(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creative field values, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580092 = path.getOrDefault("profileId")
  valid_580092 = validateParameter(valid_580092, JString, required = true,
                                 default = nil)
  if valid_580092 != nil:
    section.add "profileId", valid_580092
  var valid_580093 = path.getOrDefault("creativeFieldId")
  valid_580093 = validateParameter(valid_580093, JString, required = true,
                                 default = nil)
  if valid_580093 != nil:
    section.add "creativeFieldId", valid_580093
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for creative field values by their values. Wildcards (e.g. *) are not allowed.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only creative field values with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_580094 = query.getOrDefault("key")
  valid_580094 = validateParameter(valid_580094, JString, required = false,
                                 default = nil)
  if valid_580094 != nil:
    section.add "key", valid_580094
  var valid_580095 = query.getOrDefault("prettyPrint")
  valid_580095 = validateParameter(valid_580095, JBool, required = false,
                                 default = newJBool(true))
  if valid_580095 != nil:
    section.add "prettyPrint", valid_580095
  var valid_580096 = query.getOrDefault("oauth_token")
  valid_580096 = validateParameter(valid_580096, JString, required = false,
                                 default = nil)
  if valid_580096 != nil:
    section.add "oauth_token", valid_580096
  var valid_580097 = query.getOrDefault("sortField")
  valid_580097 = validateParameter(valid_580097, JString, required = false,
                                 default = newJString("ID"))
  if valid_580097 != nil:
    section.add "sortField", valid_580097
  var valid_580098 = query.getOrDefault("alt")
  valid_580098 = validateParameter(valid_580098, JString, required = false,
                                 default = newJString("json"))
  if valid_580098 != nil:
    section.add "alt", valid_580098
  var valid_580099 = query.getOrDefault("userIp")
  valid_580099 = validateParameter(valid_580099, JString, required = false,
                                 default = nil)
  if valid_580099 != nil:
    section.add "userIp", valid_580099
  var valid_580100 = query.getOrDefault("quotaUser")
  valid_580100 = validateParameter(valid_580100, JString, required = false,
                                 default = nil)
  if valid_580100 != nil:
    section.add "quotaUser", valid_580100
  var valid_580101 = query.getOrDefault("pageToken")
  valid_580101 = validateParameter(valid_580101, JString, required = false,
                                 default = nil)
  if valid_580101 != nil:
    section.add "pageToken", valid_580101
  var valid_580102 = query.getOrDefault("searchString")
  valid_580102 = validateParameter(valid_580102, JString, required = false,
                                 default = nil)
  if valid_580102 != nil:
    section.add "searchString", valid_580102
  var valid_580103 = query.getOrDefault("sortOrder")
  valid_580103 = validateParameter(valid_580103, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580103 != nil:
    section.add "sortOrder", valid_580103
  var valid_580104 = query.getOrDefault("ids")
  valid_580104 = validateParameter(valid_580104, JArray, required = false,
                                 default = nil)
  if valid_580104 != nil:
    section.add "ids", valid_580104
  var valid_580105 = query.getOrDefault("fields")
  valid_580105 = validateParameter(valid_580105, JString, required = false,
                                 default = nil)
  if valid_580105 != nil:
    section.add "fields", valid_580105
  var valid_580106 = query.getOrDefault("maxResults")
  valid_580106 = validateParameter(valid_580106, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580106 != nil:
    section.add "maxResults", valid_580106
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580107: Call_DfareportingCreativeFieldValuesList_580089;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of creative field values, possibly filtered. This method supports paging.
  ## 
  let valid = call_580107.validator(path, query, header, formData, body)
  let scheme = call_580107.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580107.url(scheme.get, call_580107.host, call_580107.base,
                         call_580107.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580107, url, valid)

proc call*(call_580108: Call_DfareportingCreativeFieldValuesList_580089;
          profileId: string; creativeFieldId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; sortField: string = "ID";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          pageToken: string = ""; searchString: string = "";
          sortOrder: string = "ASCENDING"; ids: JsonNode = nil; fields: string = "";
          maxResults: int = 1000): Recallable =
  ## dfareportingCreativeFieldValuesList
  ## Retrieves a list of creative field values, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for creative field values by their values. Wildcards (e.g. *) are not allowed.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only creative field values with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_580109 = newJObject()
  var query_580110 = newJObject()
  add(query_580110, "key", newJString(key))
  add(query_580110, "prettyPrint", newJBool(prettyPrint))
  add(query_580110, "oauth_token", newJString(oauthToken))
  add(path_580109, "profileId", newJString(profileId))
  add(query_580110, "sortField", newJString(sortField))
  add(query_580110, "alt", newJString(alt))
  add(query_580110, "userIp", newJString(userIp))
  add(query_580110, "quotaUser", newJString(quotaUser))
  add(path_580109, "creativeFieldId", newJString(creativeFieldId))
  add(query_580110, "pageToken", newJString(pageToken))
  add(query_580110, "searchString", newJString(searchString))
  add(query_580110, "sortOrder", newJString(sortOrder))
  if ids != nil:
    query_580110.add "ids", ids
  add(query_580110, "fields", newJString(fields))
  add(query_580110, "maxResults", newJInt(maxResults))
  result = call_580108.call(path_580109, query_580110, nil, nil, nil)

var dfareportingCreativeFieldValuesList* = Call_DfareportingCreativeFieldValuesList_580089(
    name: "dfareportingCreativeFieldValuesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesList_580090,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesList_580091,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesPatch_580147 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeFieldValuesPatch_580149(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesPatch_580148(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field value. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580150 = path.getOrDefault("profileId")
  valid_580150 = validateParameter(valid_580150, JString, required = true,
                                 default = nil)
  if valid_580150 != nil:
    section.add "profileId", valid_580150
  var valid_580151 = path.getOrDefault("creativeFieldId")
  valid_580151 = validateParameter(valid_580151, JString, required = true,
                                 default = nil)
  if valid_580151 != nil:
    section.add "creativeFieldId", valid_580151
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative Field Value ID
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580152 = query.getOrDefault("key")
  valid_580152 = validateParameter(valid_580152, JString, required = false,
                                 default = nil)
  if valid_580152 != nil:
    section.add "key", valid_580152
  var valid_580153 = query.getOrDefault("prettyPrint")
  valid_580153 = validateParameter(valid_580153, JBool, required = false,
                                 default = newJBool(true))
  if valid_580153 != nil:
    section.add "prettyPrint", valid_580153
  var valid_580154 = query.getOrDefault("oauth_token")
  valid_580154 = validateParameter(valid_580154, JString, required = false,
                                 default = nil)
  if valid_580154 != nil:
    section.add "oauth_token", valid_580154
  var valid_580155 = query.getOrDefault("alt")
  valid_580155 = validateParameter(valid_580155, JString, required = false,
                                 default = newJString("json"))
  if valid_580155 != nil:
    section.add "alt", valid_580155
  var valid_580156 = query.getOrDefault("userIp")
  valid_580156 = validateParameter(valid_580156, JString, required = false,
                                 default = nil)
  if valid_580156 != nil:
    section.add "userIp", valid_580156
  var valid_580157 = query.getOrDefault("quotaUser")
  valid_580157 = validateParameter(valid_580157, JString, required = false,
                                 default = nil)
  if valid_580157 != nil:
    section.add "quotaUser", valid_580157
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580158 = query.getOrDefault("id")
  valid_580158 = validateParameter(valid_580158, JString, required = true,
                                 default = nil)
  if valid_580158 != nil:
    section.add "id", valid_580158
  var valid_580159 = query.getOrDefault("fields")
  valid_580159 = validateParameter(valid_580159, JString, required = false,
                                 default = nil)
  if valid_580159 != nil:
    section.add "fields", valid_580159
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580161: Call_DfareportingCreativeFieldValuesPatch_580147;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field value. This method supports patch semantics.
  ## 
  let valid = call_580161.validator(path, query, header, formData, body)
  let scheme = call_580161.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580161.url(scheme.get, call_580161.host, call_580161.base,
                         call_580161.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580161, url, valid)

proc call*(call_580162: Call_DfareportingCreativeFieldValuesPatch_580147;
          profileId: string; creativeFieldId: string; id: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; body: JsonNode = nil;
          fields: string = ""): Recallable =
  ## dfareportingCreativeFieldValuesPatch
  ## Updates an existing creative field value. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   id: string (required)
  ##     : Creative Field Value ID
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580163 = newJObject()
  var query_580164 = newJObject()
  var body_580165 = newJObject()
  add(query_580164, "key", newJString(key))
  add(query_580164, "prettyPrint", newJBool(prettyPrint))
  add(query_580164, "oauth_token", newJString(oauthToken))
  add(path_580163, "profileId", newJString(profileId))
  add(query_580164, "alt", newJString(alt))
  add(query_580164, "userIp", newJString(userIp))
  add(query_580164, "quotaUser", newJString(quotaUser))
  add(path_580163, "creativeFieldId", newJString(creativeFieldId))
  add(query_580164, "id", newJString(id))
  if body != nil:
    body_580165 = body
  add(query_580164, "fields", newJString(fields))
  result = call_580162.call(path_580163, query_580164, nil, nil, body_580165)

var dfareportingCreativeFieldValuesPatch* = Call_DfareportingCreativeFieldValuesPatch_580147(
    name: "dfareportingCreativeFieldValuesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesPatch_580148,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesPatch_580149,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesGet_580166 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeFieldValuesGet_580168(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesGet_580167(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative field value by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field Value ID
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580169 = path.getOrDefault("profileId")
  valid_580169 = validateParameter(valid_580169, JString, required = true,
                                 default = nil)
  if valid_580169 != nil:
    section.add "profileId", valid_580169
  var valid_580170 = path.getOrDefault("id")
  valid_580170 = validateParameter(valid_580170, JString, required = true,
                                 default = nil)
  if valid_580170 != nil:
    section.add "id", valid_580170
  var valid_580171 = path.getOrDefault("creativeFieldId")
  valid_580171 = validateParameter(valid_580171, JString, required = true,
                                 default = nil)
  if valid_580171 != nil:
    section.add "creativeFieldId", valid_580171
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580172 = query.getOrDefault("key")
  valid_580172 = validateParameter(valid_580172, JString, required = false,
                                 default = nil)
  if valid_580172 != nil:
    section.add "key", valid_580172
  var valid_580173 = query.getOrDefault("prettyPrint")
  valid_580173 = validateParameter(valid_580173, JBool, required = false,
                                 default = newJBool(true))
  if valid_580173 != nil:
    section.add "prettyPrint", valid_580173
  var valid_580174 = query.getOrDefault("oauth_token")
  valid_580174 = validateParameter(valid_580174, JString, required = false,
                                 default = nil)
  if valid_580174 != nil:
    section.add "oauth_token", valid_580174
  var valid_580175 = query.getOrDefault("alt")
  valid_580175 = validateParameter(valid_580175, JString, required = false,
                                 default = newJString("json"))
  if valid_580175 != nil:
    section.add "alt", valid_580175
  var valid_580176 = query.getOrDefault("userIp")
  valid_580176 = validateParameter(valid_580176, JString, required = false,
                                 default = nil)
  if valid_580176 != nil:
    section.add "userIp", valid_580176
  var valid_580177 = query.getOrDefault("quotaUser")
  valid_580177 = validateParameter(valid_580177, JString, required = false,
                                 default = nil)
  if valid_580177 != nil:
    section.add "quotaUser", valid_580177
  var valid_580178 = query.getOrDefault("fields")
  valid_580178 = validateParameter(valid_580178, JString, required = false,
                                 default = nil)
  if valid_580178 != nil:
    section.add "fields", valid_580178
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580179: Call_DfareportingCreativeFieldValuesGet_580166;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one creative field value by ID.
  ## 
  let valid = call_580179.validator(path, query, header, formData, body)
  let scheme = call_580179.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580179.url(scheme.get, call_580179.host, call_580179.base,
                         call_580179.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580179, url, valid)

proc call*(call_580180: Call_DfareportingCreativeFieldValuesGet_580166;
          profileId: string; id: string; creativeFieldId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingCreativeFieldValuesGet
  ## Gets one creative field value by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Creative Field Value ID
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580181 = newJObject()
  var query_580182 = newJObject()
  add(query_580182, "key", newJString(key))
  add(query_580182, "prettyPrint", newJBool(prettyPrint))
  add(query_580182, "oauth_token", newJString(oauthToken))
  add(path_580181, "profileId", newJString(profileId))
  add(path_580181, "id", newJString(id))
  add(query_580182, "alt", newJString(alt))
  add(query_580182, "userIp", newJString(userIp))
  add(query_580182, "quotaUser", newJString(quotaUser))
  add(path_580181, "creativeFieldId", newJString(creativeFieldId))
  add(query_580182, "fields", newJString(fields))
  result = call_580180.call(path_580181, query_580182, nil, nil, nil)

var dfareportingCreativeFieldValuesGet* = Call_DfareportingCreativeFieldValuesGet_580166(
    name: "dfareportingCreativeFieldValuesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues/{id}",
    validator: validate_DfareportingCreativeFieldValuesGet_580167,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesGet_580168,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesDelete_580183 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeFieldValuesDelete_580185(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesDelete_580184(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing creative field value.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field Value ID
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580186 = path.getOrDefault("profileId")
  valid_580186 = validateParameter(valid_580186, JString, required = true,
                                 default = nil)
  if valid_580186 != nil:
    section.add "profileId", valid_580186
  var valid_580187 = path.getOrDefault("id")
  valid_580187 = validateParameter(valid_580187, JString, required = true,
                                 default = nil)
  if valid_580187 != nil:
    section.add "id", valid_580187
  var valid_580188 = path.getOrDefault("creativeFieldId")
  valid_580188 = validateParameter(valid_580188, JString, required = true,
                                 default = nil)
  if valid_580188 != nil:
    section.add "creativeFieldId", valid_580188
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580189 = query.getOrDefault("key")
  valid_580189 = validateParameter(valid_580189, JString, required = false,
                                 default = nil)
  if valid_580189 != nil:
    section.add "key", valid_580189
  var valid_580190 = query.getOrDefault("prettyPrint")
  valid_580190 = validateParameter(valid_580190, JBool, required = false,
                                 default = newJBool(true))
  if valid_580190 != nil:
    section.add "prettyPrint", valid_580190
  var valid_580191 = query.getOrDefault("oauth_token")
  valid_580191 = validateParameter(valid_580191, JString, required = false,
                                 default = nil)
  if valid_580191 != nil:
    section.add "oauth_token", valid_580191
  var valid_580192 = query.getOrDefault("alt")
  valid_580192 = validateParameter(valid_580192, JString, required = false,
                                 default = newJString("json"))
  if valid_580192 != nil:
    section.add "alt", valid_580192
  var valid_580193 = query.getOrDefault("userIp")
  valid_580193 = validateParameter(valid_580193, JString, required = false,
                                 default = nil)
  if valid_580193 != nil:
    section.add "userIp", valid_580193
  var valid_580194 = query.getOrDefault("quotaUser")
  valid_580194 = validateParameter(valid_580194, JString, required = false,
                                 default = nil)
  if valid_580194 != nil:
    section.add "quotaUser", valid_580194
  var valid_580195 = query.getOrDefault("fields")
  valid_580195 = validateParameter(valid_580195, JString, required = false,
                                 default = nil)
  if valid_580195 != nil:
    section.add "fields", valid_580195
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580196: Call_DfareportingCreativeFieldValuesDelete_580183;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing creative field value.
  ## 
  let valid = call_580196.validator(path, query, header, formData, body)
  let scheme = call_580196.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580196.url(scheme.get, call_580196.host, call_580196.base,
                         call_580196.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580196, url, valid)

proc call*(call_580197: Call_DfareportingCreativeFieldValuesDelete_580183;
          profileId: string; id: string; creativeFieldId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingCreativeFieldValuesDelete
  ## Deletes an existing creative field value.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Creative Field Value ID
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580198 = newJObject()
  var query_580199 = newJObject()
  add(query_580199, "key", newJString(key))
  add(query_580199, "prettyPrint", newJBool(prettyPrint))
  add(query_580199, "oauth_token", newJString(oauthToken))
  add(path_580198, "profileId", newJString(profileId))
  add(path_580198, "id", newJString(id))
  add(query_580199, "alt", newJString(alt))
  add(query_580199, "userIp", newJString(userIp))
  add(query_580199, "quotaUser", newJString(quotaUser))
  add(path_580198, "creativeFieldId", newJString(creativeFieldId))
  add(query_580199, "fields", newJString(fields))
  result = call_580197.call(path_580198, query_580199, nil, nil, nil)

var dfareportingCreativeFieldValuesDelete* = Call_DfareportingCreativeFieldValuesDelete_580183(
    name: "dfareportingCreativeFieldValuesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues/{id}",
    validator: validate_DfareportingCreativeFieldValuesDelete_580184,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesDelete_580185,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsGet_580200 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeFieldsGet_580202(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsGet_580201(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative field by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580203 = path.getOrDefault("profileId")
  valid_580203 = validateParameter(valid_580203, JString, required = true,
                                 default = nil)
  if valid_580203 != nil:
    section.add "profileId", valid_580203
  var valid_580204 = path.getOrDefault("id")
  valid_580204 = validateParameter(valid_580204, JString, required = true,
                                 default = nil)
  if valid_580204 != nil:
    section.add "id", valid_580204
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580205 = query.getOrDefault("key")
  valid_580205 = validateParameter(valid_580205, JString, required = false,
                                 default = nil)
  if valid_580205 != nil:
    section.add "key", valid_580205
  var valid_580206 = query.getOrDefault("prettyPrint")
  valid_580206 = validateParameter(valid_580206, JBool, required = false,
                                 default = newJBool(true))
  if valid_580206 != nil:
    section.add "prettyPrint", valid_580206
  var valid_580207 = query.getOrDefault("oauth_token")
  valid_580207 = validateParameter(valid_580207, JString, required = false,
                                 default = nil)
  if valid_580207 != nil:
    section.add "oauth_token", valid_580207
  var valid_580208 = query.getOrDefault("alt")
  valid_580208 = validateParameter(valid_580208, JString, required = false,
                                 default = newJString("json"))
  if valid_580208 != nil:
    section.add "alt", valid_580208
  var valid_580209 = query.getOrDefault("userIp")
  valid_580209 = validateParameter(valid_580209, JString, required = false,
                                 default = nil)
  if valid_580209 != nil:
    section.add "userIp", valid_580209
  var valid_580210 = query.getOrDefault("quotaUser")
  valid_580210 = validateParameter(valid_580210, JString, required = false,
                                 default = nil)
  if valid_580210 != nil:
    section.add "quotaUser", valid_580210
  var valid_580211 = query.getOrDefault("fields")
  valid_580211 = validateParameter(valid_580211, JString, required = false,
                                 default = nil)
  if valid_580211 != nil:
    section.add "fields", valid_580211
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580212: Call_DfareportingCreativeFieldsGet_580200; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one creative field by ID.
  ## 
  let valid = call_580212.validator(path, query, header, formData, body)
  let scheme = call_580212.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580212.url(scheme.get, call_580212.host, call_580212.base,
                         call_580212.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580212, url, valid)

proc call*(call_580213: Call_DfareportingCreativeFieldsGet_580200;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingCreativeFieldsGet
  ## Gets one creative field by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Creative Field ID
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580214 = newJObject()
  var query_580215 = newJObject()
  add(query_580215, "key", newJString(key))
  add(query_580215, "prettyPrint", newJBool(prettyPrint))
  add(query_580215, "oauth_token", newJString(oauthToken))
  add(path_580214, "profileId", newJString(profileId))
  add(path_580214, "id", newJString(id))
  add(query_580215, "alt", newJString(alt))
  add(query_580215, "userIp", newJString(userIp))
  add(query_580215, "quotaUser", newJString(quotaUser))
  add(query_580215, "fields", newJString(fields))
  result = call_580213.call(path_580214, query_580215, nil, nil, nil)

var dfareportingCreativeFieldsGet* = Call_DfareportingCreativeFieldsGet_580200(
    name: "dfareportingCreativeFieldsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/creativeFields/{id}",
    validator: validate_DfareportingCreativeFieldsGet_580201,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsGet_580202,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsDelete_580216 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeFieldsDelete_580218(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsDelete_580217(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing creative field.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580219 = path.getOrDefault("profileId")
  valid_580219 = validateParameter(valid_580219, JString, required = true,
                                 default = nil)
  if valid_580219 != nil:
    section.add "profileId", valid_580219
  var valid_580220 = path.getOrDefault("id")
  valid_580220 = validateParameter(valid_580220, JString, required = true,
                                 default = nil)
  if valid_580220 != nil:
    section.add "id", valid_580220
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580221 = query.getOrDefault("key")
  valid_580221 = validateParameter(valid_580221, JString, required = false,
                                 default = nil)
  if valid_580221 != nil:
    section.add "key", valid_580221
  var valid_580222 = query.getOrDefault("prettyPrint")
  valid_580222 = validateParameter(valid_580222, JBool, required = false,
                                 default = newJBool(true))
  if valid_580222 != nil:
    section.add "prettyPrint", valid_580222
  var valid_580223 = query.getOrDefault("oauth_token")
  valid_580223 = validateParameter(valid_580223, JString, required = false,
                                 default = nil)
  if valid_580223 != nil:
    section.add "oauth_token", valid_580223
  var valid_580224 = query.getOrDefault("alt")
  valid_580224 = validateParameter(valid_580224, JString, required = false,
                                 default = newJString("json"))
  if valid_580224 != nil:
    section.add "alt", valid_580224
  var valid_580225 = query.getOrDefault("userIp")
  valid_580225 = validateParameter(valid_580225, JString, required = false,
                                 default = nil)
  if valid_580225 != nil:
    section.add "userIp", valid_580225
  var valid_580226 = query.getOrDefault("quotaUser")
  valid_580226 = validateParameter(valid_580226, JString, required = false,
                                 default = nil)
  if valid_580226 != nil:
    section.add "quotaUser", valid_580226
  var valid_580227 = query.getOrDefault("fields")
  valid_580227 = validateParameter(valid_580227, JString, required = false,
                                 default = nil)
  if valid_580227 != nil:
    section.add "fields", valid_580227
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580228: Call_DfareportingCreativeFieldsDelete_580216;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing creative field.
  ## 
  let valid = call_580228.validator(path, query, header, formData, body)
  let scheme = call_580228.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580228.url(scheme.get, call_580228.host, call_580228.base,
                         call_580228.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580228, url, valid)

proc call*(call_580229: Call_DfareportingCreativeFieldsDelete_580216;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingCreativeFieldsDelete
  ## Deletes an existing creative field.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Creative Field ID
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580230 = newJObject()
  var query_580231 = newJObject()
  add(query_580231, "key", newJString(key))
  add(query_580231, "prettyPrint", newJBool(prettyPrint))
  add(query_580231, "oauth_token", newJString(oauthToken))
  add(path_580230, "profileId", newJString(profileId))
  add(path_580230, "id", newJString(id))
  add(query_580231, "alt", newJString(alt))
  add(query_580231, "userIp", newJString(userIp))
  add(query_580231, "quotaUser", newJString(quotaUser))
  add(query_580231, "fields", newJString(fields))
  result = call_580229.call(path_580230, query_580231, nil, nil, nil)

var dfareportingCreativeFieldsDelete* = Call_DfareportingCreativeFieldsDelete_580216(
    name: "dfareportingCreativeFieldsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/creativeFields/{id}",
    validator: validate_DfareportingCreativeFieldsDelete_580217,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsDelete_580218,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsUpdate_580255 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeGroupsUpdate_580257(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsUpdate_580256(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580258 = path.getOrDefault("profileId")
  valid_580258 = validateParameter(valid_580258, JString, required = true,
                                 default = nil)
  if valid_580258 != nil:
    section.add "profileId", valid_580258
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580259 = query.getOrDefault("key")
  valid_580259 = validateParameter(valid_580259, JString, required = false,
                                 default = nil)
  if valid_580259 != nil:
    section.add "key", valid_580259
  var valid_580260 = query.getOrDefault("prettyPrint")
  valid_580260 = validateParameter(valid_580260, JBool, required = false,
                                 default = newJBool(true))
  if valid_580260 != nil:
    section.add "prettyPrint", valid_580260
  var valid_580261 = query.getOrDefault("oauth_token")
  valid_580261 = validateParameter(valid_580261, JString, required = false,
                                 default = nil)
  if valid_580261 != nil:
    section.add "oauth_token", valid_580261
  var valid_580262 = query.getOrDefault("alt")
  valid_580262 = validateParameter(valid_580262, JString, required = false,
                                 default = newJString("json"))
  if valid_580262 != nil:
    section.add "alt", valid_580262
  var valid_580263 = query.getOrDefault("userIp")
  valid_580263 = validateParameter(valid_580263, JString, required = false,
                                 default = nil)
  if valid_580263 != nil:
    section.add "userIp", valid_580263
  var valid_580264 = query.getOrDefault("quotaUser")
  valid_580264 = validateParameter(valid_580264, JString, required = false,
                                 default = nil)
  if valid_580264 != nil:
    section.add "quotaUser", valid_580264
  var valid_580265 = query.getOrDefault("fields")
  valid_580265 = validateParameter(valid_580265, JString, required = false,
                                 default = nil)
  if valid_580265 != nil:
    section.add "fields", valid_580265
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580267: Call_DfareportingCreativeGroupsUpdate_580255;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative group.
  ## 
  let valid = call_580267.validator(path, query, header, formData, body)
  let scheme = call_580267.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580267.url(scheme.get, call_580267.host, call_580267.base,
                         call_580267.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580267, url, valid)

proc call*(call_580268: Call_DfareportingCreativeGroupsUpdate_580255;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingCreativeGroupsUpdate
  ## Updates an existing creative group.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580269 = newJObject()
  var query_580270 = newJObject()
  var body_580271 = newJObject()
  add(query_580270, "key", newJString(key))
  add(query_580270, "prettyPrint", newJBool(prettyPrint))
  add(query_580270, "oauth_token", newJString(oauthToken))
  add(path_580269, "profileId", newJString(profileId))
  add(query_580270, "alt", newJString(alt))
  add(query_580270, "userIp", newJString(userIp))
  add(query_580270, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580271 = body
  add(query_580270, "fields", newJString(fields))
  result = call_580268.call(path_580269, query_580270, nil, nil, body_580271)

var dfareportingCreativeGroupsUpdate* = Call_DfareportingCreativeGroupsUpdate_580255(
    name: "dfareportingCreativeGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsUpdate_580256,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsUpdate_580257,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsInsert_580272 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeGroupsInsert_580274(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsInsert_580273(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580275 = path.getOrDefault("profileId")
  valid_580275 = validateParameter(valid_580275, JString, required = true,
                                 default = nil)
  if valid_580275 != nil:
    section.add "profileId", valid_580275
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580276 = query.getOrDefault("key")
  valid_580276 = validateParameter(valid_580276, JString, required = false,
                                 default = nil)
  if valid_580276 != nil:
    section.add "key", valid_580276
  var valid_580277 = query.getOrDefault("prettyPrint")
  valid_580277 = validateParameter(valid_580277, JBool, required = false,
                                 default = newJBool(true))
  if valid_580277 != nil:
    section.add "prettyPrint", valid_580277
  var valid_580278 = query.getOrDefault("oauth_token")
  valid_580278 = validateParameter(valid_580278, JString, required = false,
                                 default = nil)
  if valid_580278 != nil:
    section.add "oauth_token", valid_580278
  var valid_580279 = query.getOrDefault("alt")
  valid_580279 = validateParameter(valid_580279, JString, required = false,
                                 default = newJString("json"))
  if valid_580279 != nil:
    section.add "alt", valid_580279
  var valid_580280 = query.getOrDefault("userIp")
  valid_580280 = validateParameter(valid_580280, JString, required = false,
                                 default = nil)
  if valid_580280 != nil:
    section.add "userIp", valid_580280
  var valid_580281 = query.getOrDefault("quotaUser")
  valid_580281 = validateParameter(valid_580281, JString, required = false,
                                 default = nil)
  if valid_580281 != nil:
    section.add "quotaUser", valid_580281
  var valid_580282 = query.getOrDefault("fields")
  valid_580282 = validateParameter(valid_580282, JString, required = false,
                                 default = nil)
  if valid_580282 != nil:
    section.add "fields", valid_580282
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580284: Call_DfareportingCreativeGroupsInsert_580272;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative group.
  ## 
  let valid = call_580284.validator(path, query, header, formData, body)
  let scheme = call_580284.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580284.url(scheme.get, call_580284.host, call_580284.base,
                         call_580284.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580284, url, valid)

proc call*(call_580285: Call_DfareportingCreativeGroupsInsert_580272;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingCreativeGroupsInsert
  ## Inserts a new creative group.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580286 = newJObject()
  var query_580287 = newJObject()
  var body_580288 = newJObject()
  add(query_580287, "key", newJString(key))
  add(query_580287, "prettyPrint", newJBool(prettyPrint))
  add(query_580287, "oauth_token", newJString(oauthToken))
  add(path_580286, "profileId", newJString(profileId))
  add(query_580287, "alt", newJString(alt))
  add(query_580287, "userIp", newJString(userIp))
  add(query_580287, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580288 = body
  add(query_580287, "fields", newJString(fields))
  result = call_580285.call(path_580286, query_580287, nil, nil, body_580288)

var dfareportingCreativeGroupsInsert* = Call_DfareportingCreativeGroupsInsert_580272(
    name: "dfareportingCreativeGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsInsert_580273,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsInsert_580274,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsList_580232 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeGroupsList_580234(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsList_580233(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creative groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580235 = path.getOrDefault("profileId")
  valid_580235 = validateParameter(valid_580235, JString, required = true,
                                 default = nil)
  if valid_580235 != nil:
    section.add "profileId", valid_580235
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   advertiserIds: JArray
  ##                : Select only creative groups that belong to these advertisers.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for creative groups by name or ID. Wildcards (*) are allowed. For example, "creativegroup*2015" will return creative groups with names like "creativegroup June 2015", "creativegroup April 2015", or simply "creativegroup 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativegroup" will match creative groups with the name "my creativegroup", "creativegroup 2015", or simply "creativegroup".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only creative groups with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   groupNumber: JInt
  ##              : Select only creative groups that belong to this subgroup.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_580236 = query.getOrDefault("key")
  valid_580236 = validateParameter(valid_580236, JString, required = false,
                                 default = nil)
  if valid_580236 != nil:
    section.add "key", valid_580236
  var valid_580237 = query.getOrDefault("prettyPrint")
  valid_580237 = validateParameter(valid_580237, JBool, required = false,
                                 default = newJBool(true))
  if valid_580237 != nil:
    section.add "prettyPrint", valid_580237
  var valid_580238 = query.getOrDefault("oauth_token")
  valid_580238 = validateParameter(valid_580238, JString, required = false,
                                 default = nil)
  if valid_580238 != nil:
    section.add "oauth_token", valid_580238
  var valid_580239 = query.getOrDefault("sortField")
  valid_580239 = validateParameter(valid_580239, JString, required = false,
                                 default = newJString("ID"))
  if valid_580239 != nil:
    section.add "sortField", valid_580239
  var valid_580240 = query.getOrDefault("advertiserIds")
  valid_580240 = validateParameter(valid_580240, JArray, required = false,
                                 default = nil)
  if valid_580240 != nil:
    section.add "advertiserIds", valid_580240
  var valid_580241 = query.getOrDefault("alt")
  valid_580241 = validateParameter(valid_580241, JString, required = false,
                                 default = newJString("json"))
  if valid_580241 != nil:
    section.add "alt", valid_580241
  var valid_580242 = query.getOrDefault("userIp")
  valid_580242 = validateParameter(valid_580242, JString, required = false,
                                 default = nil)
  if valid_580242 != nil:
    section.add "userIp", valid_580242
  var valid_580243 = query.getOrDefault("quotaUser")
  valid_580243 = validateParameter(valid_580243, JString, required = false,
                                 default = nil)
  if valid_580243 != nil:
    section.add "quotaUser", valid_580243
  var valid_580244 = query.getOrDefault("pageToken")
  valid_580244 = validateParameter(valid_580244, JString, required = false,
                                 default = nil)
  if valid_580244 != nil:
    section.add "pageToken", valid_580244
  var valid_580245 = query.getOrDefault("searchString")
  valid_580245 = validateParameter(valid_580245, JString, required = false,
                                 default = nil)
  if valid_580245 != nil:
    section.add "searchString", valid_580245
  var valid_580246 = query.getOrDefault("sortOrder")
  valid_580246 = validateParameter(valid_580246, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580246 != nil:
    section.add "sortOrder", valid_580246
  var valid_580247 = query.getOrDefault("ids")
  valid_580247 = validateParameter(valid_580247, JArray, required = false,
                                 default = nil)
  if valid_580247 != nil:
    section.add "ids", valid_580247
  var valid_580248 = query.getOrDefault("fields")
  valid_580248 = validateParameter(valid_580248, JString, required = false,
                                 default = nil)
  if valid_580248 != nil:
    section.add "fields", valid_580248
  var valid_580249 = query.getOrDefault("groupNumber")
  valid_580249 = validateParameter(valid_580249, JInt, required = false, default = nil)
  if valid_580249 != nil:
    section.add "groupNumber", valid_580249
  var valid_580250 = query.getOrDefault("maxResults")
  valid_580250 = validateParameter(valid_580250, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580250 != nil:
    section.add "maxResults", valid_580250
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580251: Call_DfareportingCreativeGroupsList_580232; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of creative groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_580251.validator(path, query, header, formData, body)
  let scheme = call_580251.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580251.url(scheme.get, call_580251.host, call_580251.base,
                         call_580251.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580251, url, valid)

proc call*(call_580252: Call_DfareportingCreativeGroupsList_580232;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; sortField: string = "ID";
          advertiserIds: JsonNode = nil; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; pageToken: string = ""; searchString: string = "";
          sortOrder: string = "ASCENDING"; ids: JsonNode = nil; fields: string = "";
          groupNumber: int = 0; maxResults: int = 1000): Recallable =
  ## dfareportingCreativeGroupsList
  ## Retrieves a list of creative groups, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   advertiserIds: JArray
  ##                : Select only creative groups that belong to these advertisers.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for creative groups by name or ID. Wildcards (*) are allowed. For example, "creativegroup*2015" will return creative groups with names like "creativegroup June 2015", "creativegroup April 2015", or simply "creativegroup 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativegroup" will match creative groups with the name "my creativegroup", "creativegroup 2015", or simply "creativegroup".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only creative groups with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   groupNumber: int
  ##              : Select only creative groups that belong to this subgroup.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_580253 = newJObject()
  var query_580254 = newJObject()
  add(query_580254, "key", newJString(key))
  add(query_580254, "prettyPrint", newJBool(prettyPrint))
  add(query_580254, "oauth_token", newJString(oauthToken))
  add(path_580253, "profileId", newJString(profileId))
  add(query_580254, "sortField", newJString(sortField))
  if advertiserIds != nil:
    query_580254.add "advertiserIds", advertiserIds
  add(query_580254, "alt", newJString(alt))
  add(query_580254, "userIp", newJString(userIp))
  add(query_580254, "quotaUser", newJString(quotaUser))
  add(query_580254, "pageToken", newJString(pageToken))
  add(query_580254, "searchString", newJString(searchString))
  add(query_580254, "sortOrder", newJString(sortOrder))
  if ids != nil:
    query_580254.add "ids", ids
  add(query_580254, "fields", newJString(fields))
  add(query_580254, "groupNumber", newJInt(groupNumber))
  add(query_580254, "maxResults", newJInt(maxResults))
  result = call_580252.call(path_580253, query_580254, nil, nil, nil)

var dfareportingCreativeGroupsList* = Call_DfareportingCreativeGroupsList_580232(
    name: "dfareportingCreativeGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsList_580233,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsList_580234,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsPatch_580289 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeGroupsPatch_580291(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsPatch_580290(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580292 = path.getOrDefault("profileId")
  valid_580292 = validateParameter(valid_580292, JString, required = true,
                                 default = nil)
  if valid_580292 != nil:
    section.add "profileId", valid_580292
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative group ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580293 = query.getOrDefault("key")
  valid_580293 = validateParameter(valid_580293, JString, required = false,
                                 default = nil)
  if valid_580293 != nil:
    section.add "key", valid_580293
  var valid_580294 = query.getOrDefault("prettyPrint")
  valid_580294 = validateParameter(valid_580294, JBool, required = false,
                                 default = newJBool(true))
  if valid_580294 != nil:
    section.add "prettyPrint", valid_580294
  var valid_580295 = query.getOrDefault("oauth_token")
  valid_580295 = validateParameter(valid_580295, JString, required = false,
                                 default = nil)
  if valid_580295 != nil:
    section.add "oauth_token", valid_580295
  var valid_580296 = query.getOrDefault("alt")
  valid_580296 = validateParameter(valid_580296, JString, required = false,
                                 default = newJString("json"))
  if valid_580296 != nil:
    section.add "alt", valid_580296
  var valid_580297 = query.getOrDefault("userIp")
  valid_580297 = validateParameter(valid_580297, JString, required = false,
                                 default = nil)
  if valid_580297 != nil:
    section.add "userIp", valid_580297
  var valid_580298 = query.getOrDefault("quotaUser")
  valid_580298 = validateParameter(valid_580298, JString, required = false,
                                 default = nil)
  if valid_580298 != nil:
    section.add "quotaUser", valid_580298
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580299 = query.getOrDefault("id")
  valid_580299 = validateParameter(valid_580299, JString, required = true,
                                 default = nil)
  if valid_580299 != nil:
    section.add "id", valid_580299
  var valid_580300 = query.getOrDefault("fields")
  valid_580300 = validateParameter(valid_580300, JString, required = false,
                                 default = nil)
  if valid_580300 != nil:
    section.add "fields", valid_580300
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580302: Call_DfareportingCreativeGroupsPatch_580289;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative group. This method supports patch semantics.
  ## 
  let valid = call_580302.validator(path, query, header, formData, body)
  let scheme = call_580302.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580302.url(scheme.get, call_580302.host, call_580302.base,
                         call_580302.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580302, url, valid)

proc call*(call_580303: Call_DfareportingCreativeGroupsPatch_580289;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingCreativeGroupsPatch
  ## Updates an existing creative group. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative group ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580304 = newJObject()
  var query_580305 = newJObject()
  var body_580306 = newJObject()
  add(query_580305, "key", newJString(key))
  add(query_580305, "prettyPrint", newJBool(prettyPrint))
  add(query_580305, "oauth_token", newJString(oauthToken))
  add(path_580304, "profileId", newJString(profileId))
  add(query_580305, "alt", newJString(alt))
  add(query_580305, "userIp", newJString(userIp))
  add(query_580305, "quotaUser", newJString(quotaUser))
  add(query_580305, "id", newJString(id))
  if body != nil:
    body_580306 = body
  add(query_580305, "fields", newJString(fields))
  result = call_580303.call(path_580304, query_580305, nil, nil, body_580306)

var dfareportingCreativeGroupsPatch* = Call_DfareportingCreativeGroupsPatch_580289(
    name: "dfareportingCreativeGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsPatch_580290,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsPatch_580291,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsGet_580307 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativeGroupsGet_580309(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsGet_580308(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580310 = path.getOrDefault("profileId")
  valid_580310 = validateParameter(valid_580310, JString, required = true,
                                 default = nil)
  if valid_580310 != nil:
    section.add "profileId", valid_580310
  var valid_580311 = path.getOrDefault("id")
  valid_580311 = validateParameter(valid_580311, JString, required = true,
                                 default = nil)
  if valid_580311 != nil:
    section.add "id", valid_580311
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580312 = query.getOrDefault("key")
  valid_580312 = validateParameter(valid_580312, JString, required = false,
                                 default = nil)
  if valid_580312 != nil:
    section.add "key", valid_580312
  var valid_580313 = query.getOrDefault("prettyPrint")
  valid_580313 = validateParameter(valid_580313, JBool, required = false,
                                 default = newJBool(true))
  if valid_580313 != nil:
    section.add "prettyPrint", valid_580313
  var valid_580314 = query.getOrDefault("oauth_token")
  valid_580314 = validateParameter(valid_580314, JString, required = false,
                                 default = nil)
  if valid_580314 != nil:
    section.add "oauth_token", valid_580314
  var valid_580315 = query.getOrDefault("alt")
  valid_580315 = validateParameter(valid_580315, JString, required = false,
                                 default = newJString("json"))
  if valid_580315 != nil:
    section.add "alt", valid_580315
  var valid_580316 = query.getOrDefault("userIp")
  valid_580316 = validateParameter(valid_580316, JString, required = false,
                                 default = nil)
  if valid_580316 != nil:
    section.add "userIp", valid_580316
  var valid_580317 = query.getOrDefault("quotaUser")
  valid_580317 = validateParameter(valid_580317, JString, required = false,
                                 default = nil)
  if valid_580317 != nil:
    section.add "quotaUser", valid_580317
  var valid_580318 = query.getOrDefault("fields")
  valid_580318 = validateParameter(valid_580318, JString, required = false,
                                 default = nil)
  if valid_580318 != nil:
    section.add "fields", valid_580318
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580319: Call_DfareportingCreativeGroupsGet_580307; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one creative group by ID.
  ## 
  let valid = call_580319.validator(path, query, header, formData, body)
  let scheme = call_580319.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580319.url(scheme.get, call_580319.host, call_580319.base,
                         call_580319.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580319, url, valid)

proc call*(call_580320: Call_DfareportingCreativeGroupsGet_580307;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingCreativeGroupsGet
  ## Gets one creative group by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Creative group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580321 = newJObject()
  var query_580322 = newJObject()
  add(query_580322, "key", newJString(key))
  add(query_580322, "prettyPrint", newJBool(prettyPrint))
  add(query_580322, "oauth_token", newJString(oauthToken))
  add(path_580321, "profileId", newJString(profileId))
  add(path_580321, "id", newJString(id))
  add(query_580322, "alt", newJString(alt))
  add(query_580322, "userIp", newJString(userIp))
  add(query_580322, "quotaUser", newJString(quotaUser))
  add(query_580322, "fields", newJString(fields))
  result = call_580320.call(path_580321, query_580322, nil, nil, nil)

var dfareportingCreativeGroupsGet* = Call_DfareportingCreativeGroupsGet_580307(
    name: "dfareportingCreativeGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/creativeGroups/{id}",
    validator: validate_DfareportingCreativeGroupsGet_580308,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsGet_580309,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesUpdate_580354 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativesUpdate_580356(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesUpdate_580355(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580357 = path.getOrDefault("profileId")
  valid_580357 = validateParameter(valid_580357, JString, required = true,
                                 default = nil)
  if valid_580357 != nil:
    section.add "profileId", valid_580357
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580358 = query.getOrDefault("key")
  valid_580358 = validateParameter(valid_580358, JString, required = false,
                                 default = nil)
  if valid_580358 != nil:
    section.add "key", valid_580358
  var valid_580359 = query.getOrDefault("prettyPrint")
  valid_580359 = validateParameter(valid_580359, JBool, required = false,
                                 default = newJBool(true))
  if valid_580359 != nil:
    section.add "prettyPrint", valid_580359
  var valid_580360 = query.getOrDefault("oauth_token")
  valid_580360 = validateParameter(valid_580360, JString, required = false,
                                 default = nil)
  if valid_580360 != nil:
    section.add "oauth_token", valid_580360
  var valid_580361 = query.getOrDefault("alt")
  valid_580361 = validateParameter(valid_580361, JString, required = false,
                                 default = newJString("json"))
  if valid_580361 != nil:
    section.add "alt", valid_580361
  var valid_580362 = query.getOrDefault("userIp")
  valid_580362 = validateParameter(valid_580362, JString, required = false,
                                 default = nil)
  if valid_580362 != nil:
    section.add "userIp", valid_580362
  var valid_580363 = query.getOrDefault("quotaUser")
  valid_580363 = validateParameter(valid_580363, JString, required = false,
                                 default = nil)
  if valid_580363 != nil:
    section.add "quotaUser", valid_580363
  var valid_580364 = query.getOrDefault("fields")
  valid_580364 = validateParameter(valid_580364, JString, required = false,
                                 default = nil)
  if valid_580364 != nil:
    section.add "fields", valid_580364
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580366: Call_DfareportingCreativesUpdate_580354; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing creative.
  ## 
  let valid = call_580366.validator(path, query, header, formData, body)
  let scheme = call_580366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580366.url(scheme.get, call_580366.host, call_580366.base,
                         call_580366.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580366, url, valid)

proc call*(call_580367: Call_DfareportingCreativesUpdate_580354; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingCreativesUpdate
  ## Updates an existing creative.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580368 = newJObject()
  var query_580369 = newJObject()
  var body_580370 = newJObject()
  add(query_580369, "key", newJString(key))
  add(query_580369, "prettyPrint", newJBool(prettyPrint))
  add(query_580369, "oauth_token", newJString(oauthToken))
  add(path_580368, "profileId", newJString(profileId))
  add(query_580369, "alt", newJString(alt))
  add(query_580369, "userIp", newJString(userIp))
  add(query_580369, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580370 = body
  add(query_580369, "fields", newJString(fields))
  result = call_580367.call(path_580368, query_580369, nil, nil, body_580370)

var dfareportingCreativesUpdate* = Call_DfareportingCreativesUpdate_580354(
    name: "dfareportingCreativesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesUpdate_580355,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesUpdate_580356,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesInsert_580371 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativesInsert_580373(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesInsert_580372(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580374 = path.getOrDefault("profileId")
  valid_580374 = validateParameter(valid_580374, JString, required = true,
                                 default = nil)
  if valid_580374 != nil:
    section.add "profileId", valid_580374
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580375 = query.getOrDefault("key")
  valid_580375 = validateParameter(valid_580375, JString, required = false,
                                 default = nil)
  if valid_580375 != nil:
    section.add "key", valid_580375
  var valid_580376 = query.getOrDefault("prettyPrint")
  valid_580376 = validateParameter(valid_580376, JBool, required = false,
                                 default = newJBool(true))
  if valid_580376 != nil:
    section.add "prettyPrint", valid_580376
  var valid_580377 = query.getOrDefault("oauth_token")
  valid_580377 = validateParameter(valid_580377, JString, required = false,
                                 default = nil)
  if valid_580377 != nil:
    section.add "oauth_token", valid_580377
  var valid_580378 = query.getOrDefault("alt")
  valid_580378 = validateParameter(valid_580378, JString, required = false,
                                 default = newJString("json"))
  if valid_580378 != nil:
    section.add "alt", valid_580378
  var valid_580379 = query.getOrDefault("userIp")
  valid_580379 = validateParameter(valid_580379, JString, required = false,
                                 default = nil)
  if valid_580379 != nil:
    section.add "userIp", valid_580379
  var valid_580380 = query.getOrDefault("quotaUser")
  valid_580380 = validateParameter(valid_580380, JString, required = false,
                                 default = nil)
  if valid_580380 != nil:
    section.add "quotaUser", valid_580380
  var valid_580381 = query.getOrDefault("fields")
  valid_580381 = validateParameter(valid_580381, JString, required = false,
                                 default = nil)
  if valid_580381 != nil:
    section.add "fields", valid_580381
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580383: Call_DfareportingCreativesInsert_580371; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new creative.
  ## 
  let valid = call_580383.validator(path, query, header, formData, body)
  let scheme = call_580383.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580383.url(scheme.get, call_580383.host, call_580383.base,
                         call_580383.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580383, url, valid)

proc call*(call_580384: Call_DfareportingCreativesInsert_580371; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingCreativesInsert
  ## Inserts a new creative.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580385 = newJObject()
  var query_580386 = newJObject()
  var body_580387 = newJObject()
  add(query_580386, "key", newJString(key))
  add(query_580386, "prettyPrint", newJBool(prettyPrint))
  add(query_580386, "oauth_token", newJString(oauthToken))
  add(path_580385, "profileId", newJString(profileId))
  add(query_580386, "alt", newJString(alt))
  add(query_580386, "userIp", newJString(userIp))
  add(query_580386, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580387 = body
  add(query_580386, "fields", newJString(fields))
  result = call_580384.call(path_580385, query_580386, nil, nil, body_580387)

var dfareportingCreativesInsert* = Call_DfareportingCreativesInsert_580371(
    name: "dfareportingCreativesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesInsert_580372,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesInsert_580373,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesList_580323 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativesList_580325(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesList_580324(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creatives, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580326 = path.getOrDefault("profileId")
  valid_580326 = validateParameter(valid_580326, JString, required = true,
                                 default = nil)
  if valid_580326 != nil:
    section.add "profileId", valid_580326
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   active: JBool
  ##         : Select only active creatives. Leave blank to select active and inactive creatives.
  ##   creativeFieldIds: JArray
  ##                   : Select only creatives with these creative field IDs.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: JBool
  ##           : Select only archived creatives. Leave blank to select archived and unarchived creatives.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   campaignId: JString
  ##             : Select only creatives with this campaign ID.
  ##   types: JArray
  ##        : Select only creatives with these creative types.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "creative*2015" will return objects with names like "creative June 2015", "creative April 2015", or simply "creative 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "creative" will match objects with name "my creative", "creative 2015", or simply "creative".
  ##   sizeIds: JArray
  ##          : Select only creatives with these size IDs.
  ##   companionCreativeIds: JArray
  ##                       : Select only in-stream video creatives with these companion IDs.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   renderingIds: JArray
  ##               : Select only creatives with these rendering IDs.
  ##   advertiserId: JString
  ##               : Select only creatives with this advertiser ID.
  ##   ids: JArray
  ##      : Select only creatives with these IDs.
  ##   studioCreativeId: JString
  ##                   : Select only creatives corresponding to this Studio creative ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_580327 = query.getOrDefault("key")
  valid_580327 = validateParameter(valid_580327, JString, required = false,
                                 default = nil)
  if valid_580327 != nil:
    section.add "key", valid_580327
  var valid_580328 = query.getOrDefault("prettyPrint")
  valid_580328 = validateParameter(valid_580328, JBool, required = false,
                                 default = newJBool(true))
  if valid_580328 != nil:
    section.add "prettyPrint", valid_580328
  var valid_580329 = query.getOrDefault("oauth_token")
  valid_580329 = validateParameter(valid_580329, JString, required = false,
                                 default = nil)
  if valid_580329 != nil:
    section.add "oauth_token", valid_580329
  var valid_580330 = query.getOrDefault("active")
  valid_580330 = validateParameter(valid_580330, JBool, required = false, default = nil)
  if valid_580330 != nil:
    section.add "active", valid_580330
  var valid_580331 = query.getOrDefault("creativeFieldIds")
  valid_580331 = validateParameter(valid_580331, JArray, required = false,
                                 default = nil)
  if valid_580331 != nil:
    section.add "creativeFieldIds", valid_580331
  var valid_580332 = query.getOrDefault("sortField")
  valid_580332 = validateParameter(valid_580332, JString, required = false,
                                 default = newJString("ID"))
  if valid_580332 != nil:
    section.add "sortField", valid_580332
  var valid_580333 = query.getOrDefault("alt")
  valid_580333 = validateParameter(valid_580333, JString, required = false,
                                 default = newJString("json"))
  if valid_580333 != nil:
    section.add "alt", valid_580333
  var valid_580334 = query.getOrDefault("userIp")
  valid_580334 = validateParameter(valid_580334, JString, required = false,
                                 default = nil)
  if valid_580334 != nil:
    section.add "userIp", valid_580334
  var valid_580335 = query.getOrDefault("archived")
  valid_580335 = validateParameter(valid_580335, JBool, required = false, default = nil)
  if valid_580335 != nil:
    section.add "archived", valid_580335
  var valid_580336 = query.getOrDefault("quotaUser")
  valid_580336 = validateParameter(valid_580336, JString, required = false,
                                 default = nil)
  if valid_580336 != nil:
    section.add "quotaUser", valid_580336
  var valid_580337 = query.getOrDefault("campaignId")
  valid_580337 = validateParameter(valid_580337, JString, required = false,
                                 default = nil)
  if valid_580337 != nil:
    section.add "campaignId", valid_580337
  var valid_580338 = query.getOrDefault("types")
  valid_580338 = validateParameter(valid_580338, JArray, required = false,
                                 default = nil)
  if valid_580338 != nil:
    section.add "types", valid_580338
  var valid_580339 = query.getOrDefault("pageToken")
  valid_580339 = validateParameter(valid_580339, JString, required = false,
                                 default = nil)
  if valid_580339 != nil:
    section.add "pageToken", valid_580339
  var valid_580340 = query.getOrDefault("searchString")
  valid_580340 = validateParameter(valid_580340, JString, required = false,
                                 default = nil)
  if valid_580340 != nil:
    section.add "searchString", valid_580340
  var valid_580341 = query.getOrDefault("sizeIds")
  valid_580341 = validateParameter(valid_580341, JArray, required = false,
                                 default = nil)
  if valid_580341 != nil:
    section.add "sizeIds", valid_580341
  var valid_580342 = query.getOrDefault("companionCreativeIds")
  valid_580342 = validateParameter(valid_580342, JArray, required = false,
                                 default = nil)
  if valid_580342 != nil:
    section.add "companionCreativeIds", valid_580342
  var valid_580343 = query.getOrDefault("sortOrder")
  valid_580343 = validateParameter(valid_580343, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580343 != nil:
    section.add "sortOrder", valid_580343
  var valid_580344 = query.getOrDefault("renderingIds")
  valid_580344 = validateParameter(valid_580344, JArray, required = false,
                                 default = nil)
  if valid_580344 != nil:
    section.add "renderingIds", valid_580344
  var valid_580345 = query.getOrDefault("advertiserId")
  valid_580345 = validateParameter(valid_580345, JString, required = false,
                                 default = nil)
  if valid_580345 != nil:
    section.add "advertiserId", valid_580345
  var valid_580346 = query.getOrDefault("ids")
  valid_580346 = validateParameter(valid_580346, JArray, required = false,
                                 default = nil)
  if valid_580346 != nil:
    section.add "ids", valid_580346
  var valid_580347 = query.getOrDefault("studioCreativeId")
  valid_580347 = validateParameter(valid_580347, JString, required = false,
                                 default = nil)
  if valid_580347 != nil:
    section.add "studioCreativeId", valid_580347
  var valid_580348 = query.getOrDefault("fields")
  valid_580348 = validateParameter(valid_580348, JString, required = false,
                                 default = nil)
  if valid_580348 != nil:
    section.add "fields", valid_580348
  var valid_580349 = query.getOrDefault("maxResults")
  valid_580349 = validateParameter(valid_580349, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580349 != nil:
    section.add "maxResults", valid_580349
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580350: Call_DfareportingCreativesList_580323; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of creatives, possibly filtered. This method supports paging.
  ## 
  let valid = call_580350.validator(path, query, header, formData, body)
  let scheme = call_580350.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580350.url(scheme.get, call_580350.host, call_580350.base,
                         call_580350.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580350, url, valid)

proc call*(call_580351: Call_DfareportingCreativesList_580323; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          active: bool = false; creativeFieldIds: JsonNode = nil;
          sortField: string = "ID"; alt: string = "json"; userIp: string = "";
          archived: bool = false; quotaUser: string = ""; campaignId: string = "";
          types: JsonNode = nil; pageToken: string = ""; searchString: string = "";
          sizeIds: JsonNode = nil; companionCreativeIds: JsonNode = nil;
          sortOrder: string = "ASCENDING"; renderingIds: JsonNode = nil;
          advertiserId: string = ""; ids: JsonNode = nil; studioCreativeId: string = "";
          fields: string = ""; maxResults: int = 1000): Recallable =
  ## dfareportingCreativesList
  ## Retrieves a list of creatives, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   active: bool
  ##         : Select only active creatives. Leave blank to select active and inactive creatives.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldIds: JArray
  ##                   : Select only creatives with these creative field IDs.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: bool
  ##           : Select only archived creatives. Leave blank to select archived and unarchived creatives.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   campaignId: string
  ##             : Select only creatives with this campaign ID.
  ##   types: JArray
  ##        : Select only creatives with these creative types.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "creative*2015" will return objects with names like "creative June 2015", "creative April 2015", or simply "creative 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "creative" will match objects with name "my creative", "creative 2015", or simply "creative".
  ##   sizeIds: JArray
  ##          : Select only creatives with these size IDs.
  ##   companionCreativeIds: JArray
  ##                       : Select only in-stream video creatives with these companion IDs.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   renderingIds: JArray
  ##               : Select only creatives with these rendering IDs.
  ##   advertiserId: string
  ##               : Select only creatives with this advertiser ID.
  ##   ids: JArray
  ##      : Select only creatives with these IDs.
  ##   studioCreativeId: string
  ##                   : Select only creatives corresponding to this Studio creative ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_580352 = newJObject()
  var query_580353 = newJObject()
  add(query_580353, "key", newJString(key))
  add(query_580353, "prettyPrint", newJBool(prettyPrint))
  add(query_580353, "oauth_token", newJString(oauthToken))
  add(query_580353, "active", newJBool(active))
  add(path_580352, "profileId", newJString(profileId))
  if creativeFieldIds != nil:
    query_580353.add "creativeFieldIds", creativeFieldIds
  add(query_580353, "sortField", newJString(sortField))
  add(query_580353, "alt", newJString(alt))
  add(query_580353, "userIp", newJString(userIp))
  add(query_580353, "archived", newJBool(archived))
  add(query_580353, "quotaUser", newJString(quotaUser))
  add(query_580353, "campaignId", newJString(campaignId))
  if types != nil:
    query_580353.add "types", types
  add(query_580353, "pageToken", newJString(pageToken))
  add(query_580353, "searchString", newJString(searchString))
  if sizeIds != nil:
    query_580353.add "sizeIds", sizeIds
  if companionCreativeIds != nil:
    query_580353.add "companionCreativeIds", companionCreativeIds
  add(query_580353, "sortOrder", newJString(sortOrder))
  if renderingIds != nil:
    query_580353.add "renderingIds", renderingIds
  add(query_580353, "advertiserId", newJString(advertiserId))
  if ids != nil:
    query_580353.add "ids", ids
  add(query_580353, "studioCreativeId", newJString(studioCreativeId))
  add(query_580353, "fields", newJString(fields))
  add(query_580353, "maxResults", newJInt(maxResults))
  result = call_580351.call(path_580352, query_580353, nil, nil, nil)

var dfareportingCreativesList* = Call_DfareportingCreativesList_580323(
    name: "dfareportingCreativesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesList_580324,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesList_580325,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesPatch_580388 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativesPatch_580390(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesPatch_580389(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580391 = path.getOrDefault("profileId")
  valid_580391 = validateParameter(valid_580391, JString, required = true,
                                 default = nil)
  if valid_580391 != nil:
    section.add "profileId", valid_580391
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580392 = query.getOrDefault("key")
  valid_580392 = validateParameter(valid_580392, JString, required = false,
                                 default = nil)
  if valid_580392 != nil:
    section.add "key", valid_580392
  var valid_580393 = query.getOrDefault("prettyPrint")
  valid_580393 = validateParameter(valid_580393, JBool, required = false,
                                 default = newJBool(true))
  if valid_580393 != nil:
    section.add "prettyPrint", valid_580393
  var valid_580394 = query.getOrDefault("oauth_token")
  valid_580394 = validateParameter(valid_580394, JString, required = false,
                                 default = nil)
  if valid_580394 != nil:
    section.add "oauth_token", valid_580394
  var valid_580395 = query.getOrDefault("alt")
  valid_580395 = validateParameter(valid_580395, JString, required = false,
                                 default = newJString("json"))
  if valid_580395 != nil:
    section.add "alt", valid_580395
  var valid_580396 = query.getOrDefault("userIp")
  valid_580396 = validateParameter(valid_580396, JString, required = false,
                                 default = nil)
  if valid_580396 != nil:
    section.add "userIp", valid_580396
  var valid_580397 = query.getOrDefault("quotaUser")
  valid_580397 = validateParameter(valid_580397, JString, required = false,
                                 default = nil)
  if valid_580397 != nil:
    section.add "quotaUser", valid_580397
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580398 = query.getOrDefault("id")
  valid_580398 = validateParameter(valid_580398, JString, required = true,
                                 default = nil)
  if valid_580398 != nil:
    section.add "id", valid_580398
  var valid_580399 = query.getOrDefault("fields")
  valid_580399 = validateParameter(valid_580399, JString, required = false,
                                 default = nil)
  if valid_580399 != nil:
    section.add "fields", valid_580399
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580401: Call_DfareportingCreativesPatch_580388; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing creative. This method supports patch semantics.
  ## 
  let valid = call_580401.validator(path, query, header, formData, body)
  let scheme = call_580401.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580401.url(scheme.get, call_580401.host, call_580401.base,
                         call_580401.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580401, url, valid)

proc call*(call_580402: Call_DfareportingCreativesPatch_580388; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingCreativesPatch
  ## Updates an existing creative. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580403 = newJObject()
  var query_580404 = newJObject()
  var body_580405 = newJObject()
  add(query_580404, "key", newJString(key))
  add(query_580404, "prettyPrint", newJBool(prettyPrint))
  add(query_580404, "oauth_token", newJString(oauthToken))
  add(path_580403, "profileId", newJString(profileId))
  add(query_580404, "alt", newJString(alt))
  add(query_580404, "userIp", newJString(userIp))
  add(query_580404, "quotaUser", newJString(quotaUser))
  add(query_580404, "id", newJString(id))
  if body != nil:
    body_580405 = body
  add(query_580404, "fields", newJString(fields))
  result = call_580402.call(path_580403, query_580404, nil, nil, body_580405)

var dfareportingCreativesPatch* = Call_DfareportingCreativesPatch_580388(
    name: "dfareportingCreativesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesPatch_580389,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesPatch_580390,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesGet_580406 = ref object of OpenApiRestCall_578364
proc url_DfareportingCreativesGet_580408(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesGet_580407(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580409 = path.getOrDefault("profileId")
  valid_580409 = validateParameter(valid_580409, JString, required = true,
                                 default = nil)
  if valid_580409 != nil:
    section.add "profileId", valid_580409
  var valid_580410 = path.getOrDefault("id")
  valid_580410 = validateParameter(valid_580410, JString, required = true,
                                 default = nil)
  if valid_580410 != nil:
    section.add "id", valid_580410
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580411 = query.getOrDefault("key")
  valid_580411 = validateParameter(valid_580411, JString, required = false,
                                 default = nil)
  if valid_580411 != nil:
    section.add "key", valid_580411
  var valid_580412 = query.getOrDefault("prettyPrint")
  valid_580412 = validateParameter(valid_580412, JBool, required = false,
                                 default = newJBool(true))
  if valid_580412 != nil:
    section.add "prettyPrint", valid_580412
  var valid_580413 = query.getOrDefault("oauth_token")
  valid_580413 = validateParameter(valid_580413, JString, required = false,
                                 default = nil)
  if valid_580413 != nil:
    section.add "oauth_token", valid_580413
  var valid_580414 = query.getOrDefault("alt")
  valid_580414 = validateParameter(valid_580414, JString, required = false,
                                 default = newJString("json"))
  if valid_580414 != nil:
    section.add "alt", valid_580414
  var valid_580415 = query.getOrDefault("userIp")
  valid_580415 = validateParameter(valid_580415, JString, required = false,
                                 default = nil)
  if valid_580415 != nil:
    section.add "userIp", valid_580415
  var valid_580416 = query.getOrDefault("quotaUser")
  valid_580416 = validateParameter(valid_580416, JString, required = false,
                                 default = nil)
  if valid_580416 != nil:
    section.add "quotaUser", valid_580416
  var valid_580417 = query.getOrDefault("fields")
  valid_580417 = validateParameter(valid_580417, JString, required = false,
                                 default = nil)
  if valid_580417 != nil:
    section.add "fields", valid_580417
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580418: Call_DfareportingCreativesGet_580406; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one creative by ID.
  ## 
  let valid = call_580418.validator(path, query, header, formData, body)
  let scheme = call_580418.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580418.url(scheme.get, call_580418.host, call_580418.base,
                         call_580418.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580418, url, valid)

proc call*(call_580419: Call_DfareportingCreativesGet_580406; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingCreativesGet
  ## Gets one creative by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Creative ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580420 = newJObject()
  var query_580421 = newJObject()
  add(query_580421, "key", newJString(key))
  add(query_580421, "prettyPrint", newJBool(prettyPrint))
  add(query_580421, "oauth_token", newJString(oauthToken))
  add(path_580420, "profileId", newJString(profileId))
  add(path_580420, "id", newJString(id))
  add(query_580421, "alt", newJString(alt))
  add(query_580421, "userIp", newJString(userIp))
  add(query_580421, "quotaUser", newJString(quotaUser))
  add(query_580421, "fields", newJString(fields))
  result = call_580419.call(path_580420, query_580421, nil, nil, nil)

var dfareportingCreativesGet* = Call_DfareportingCreativesGet_580406(
    name: "dfareportingCreativesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives/{id}",
    validator: validate_DfareportingCreativesGet_580407,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesGet_580408,
    schemes: {Scheme.Https})
type
  Call_DfareportingDimensionValuesQuery_580422 = ref object of OpenApiRestCall_578364
proc url_DfareportingDimensionValuesQuery_580424(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dimensionvalues/query")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDimensionValuesQuery_580423(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves list of report dimension values for a list of filters.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580425 = path.getOrDefault("profileId")
  valid_580425 = validateParameter(valid_580425, JString, required = true,
                                 default = nil)
  if valid_580425 != nil:
    section.add "profileId", valid_580425
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_580426 = query.getOrDefault("key")
  valid_580426 = validateParameter(valid_580426, JString, required = false,
                                 default = nil)
  if valid_580426 != nil:
    section.add "key", valid_580426
  var valid_580427 = query.getOrDefault("prettyPrint")
  valid_580427 = validateParameter(valid_580427, JBool, required = false,
                                 default = newJBool(true))
  if valid_580427 != nil:
    section.add "prettyPrint", valid_580427
  var valid_580428 = query.getOrDefault("oauth_token")
  valid_580428 = validateParameter(valid_580428, JString, required = false,
                                 default = nil)
  if valid_580428 != nil:
    section.add "oauth_token", valid_580428
  var valid_580429 = query.getOrDefault("alt")
  valid_580429 = validateParameter(valid_580429, JString, required = false,
                                 default = newJString("json"))
  if valid_580429 != nil:
    section.add "alt", valid_580429
  var valid_580430 = query.getOrDefault("userIp")
  valid_580430 = validateParameter(valid_580430, JString, required = false,
                                 default = nil)
  if valid_580430 != nil:
    section.add "userIp", valid_580430
  var valid_580431 = query.getOrDefault("quotaUser")
  valid_580431 = validateParameter(valid_580431, JString, required = false,
                                 default = nil)
  if valid_580431 != nil:
    section.add "quotaUser", valid_580431
  var valid_580432 = query.getOrDefault("pageToken")
  valid_580432 = validateParameter(valid_580432, JString, required = false,
                                 default = nil)
  if valid_580432 != nil:
    section.add "pageToken", valid_580432
  var valid_580433 = query.getOrDefault("fields")
  valid_580433 = validateParameter(valid_580433, JString, required = false,
                                 default = nil)
  if valid_580433 != nil:
    section.add "fields", valid_580433
  var valid_580434 = query.getOrDefault("maxResults")
  valid_580434 = validateParameter(valid_580434, JInt, required = false,
                                 default = newJInt(100))
  if valid_580434 != nil:
    section.add "maxResults", valid_580434
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580436: Call_DfareportingDimensionValuesQuery_580422;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves list of report dimension values for a list of filters.
  ## 
  let valid = call_580436.validator(path, query, header, formData, body)
  let scheme = call_580436.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580436.url(scheme.get, call_580436.host, call_580436.base,
                         call_580436.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580436, url, valid)

proc call*(call_580437: Call_DfareportingDimensionValuesQuery_580422;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; pageToken: string = ""; body: JsonNode = nil;
          fields: string = ""; maxResults: int = 100): Recallable =
  ## dfareportingDimensionValuesQuery
  ## Retrieves list of report dimension values for a list of filters.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_580438 = newJObject()
  var query_580439 = newJObject()
  var body_580440 = newJObject()
  add(query_580439, "key", newJString(key))
  add(query_580439, "prettyPrint", newJBool(prettyPrint))
  add(query_580439, "oauth_token", newJString(oauthToken))
  add(path_580438, "profileId", newJString(profileId))
  add(query_580439, "alt", newJString(alt))
  add(query_580439, "userIp", newJString(userIp))
  add(query_580439, "quotaUser", newJString(quotaUser))
  add(query_580439, "pageToken", newJString(pageToken))
  if body != nil:
    body_580440 = body
  add(query_580439, "fields", newJString(fields))
  add(query_580439, "maxResults", newJInt(maxResults))
  result = call_580437.call(path_580438, query_580439, nil, nil, body_580440)

var dfareportingDimensionValuesQuery* = Call_DfareportingDimensionValuesQuery_580422(
    name: "dfareportingDimensionValuesQuery", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dimensionvalues/query",
    validator: validate_DfareportingDimensionValuesQuery_580423,
    base: "/dfareporting/v2.7", url: url_DfareportingDimensionValuesQuery_580424,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySiteContactsList_580441 = ref object of OpenApiRestCall_578364
proc url_DfareportingDirectorySiteContactsList_580443(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySiteContacts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySiteContactsList_580442(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of directory site contacts, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580444 = path.getOrDefault("profileId")
  valid_580444 = validateParameter(valid_580444, JString, required = true,
                                 default = nil)
  if valid_580444 != nil:
    section.add "profileId", valid_580444
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   directorySiteIds: JArray
  ##                   : Select only directory site contacts with these directory site IDs. This is a required field.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "directory site contact*2015" will return objects with names like "directory site contact June 2015", "directory site contact April 2015", or simply "directory site contact 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site contact" will match objects with name "my directory site contact", "directory site contact 2015", or simply "directory site contact".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only directory site contacts with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_580445 = query.getOrDefault("key")
  valid_580445 = validateParameter(valid_580445, JString, required = false,
                                 default = nil)
  if valid_580445 != nil:
    section.add "key", valid_580445
  var valid_580446 = query.getOrDefault("prettyPrint")
  valid_580446 = validateParameter(valid_580446, JBool, required = false,
                                 default = newJBool(true))
  if valid_580446 != nil:
    section.add "prettyPrint", valid_580446
  var valid_580447 = query.getOrDefault("oauth_token")
  valid_580447 = validateParameter(valid_580447, JString, required = false,
                                 default = nil)
  if valid_580447 != nil:
    section.add "oauth_token", valid_580447
  var valid_580448 = query.getOrDefault("sortField")
  valid_580448 = validateParameter(valid_580448, JString, required = false,
                                 default = newJString("ID"))
  if valid_580448 != nil:
    section.add "sortField", valid_580448
  var valid_580449 = query.getOrDefault("alt")
  valid_580449 = validateParameter(valid_580449, JString, required = false,
                                 default = newJString("json"))
  if valid_580449 != nil:
    section.add "alt", valid_580449
  var valid_580450 = query.getOrDefault("userIp")
  valid_580450 = validateParameter(valid_580450, JString, required = false,
                                 default = nil)
  if valid_580450 != nil:
    section.add "userIp", valid_580450
  var valid_580451 = query.getOrDefault("directorySiteIds")
  valid_580451 = validateParameter(valid_580451, JArray, required = false,
                                 default = nil)
  if valid_580451 != nil:
    section.add "directorySiteIds", valid_580451
  var valid_580452 = query.getOrDefault("quotaUser")
  valid_580452 = validateParameter(valid_580452, JString, required = false,
                                 default = nil)
  if valid_580452 != nil:
    section.add "quotaUser", valid_580452
  var valid_580453 = query.getOrDefault("pageToken")
  valid_580453 = validateParameter(valid_580453, JString, required = false,
                                 default = nil)
  if valid_580453 != nil:
    section.add "pageToken", valid_580453
  var valid_580454 = query.getOrDefault("searchString")
  valid_580454 = validateParameter(valid_580454, JString, required = false,
                                 default = nil)
  if valid_580454 != nil:
    section.add "searchString", valid_580454
  var valid_580455 = query.getOrDefault("sortOrder")
  valid_580455 = validateParameter(valid_580455, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580455 != nil:
    section.add "sortOrder", valid_580455
  var valid_580456 = query.getOrDefault("ids")
  valid_580456 = validateParameter(valid_580456, JArray, required = false,
                                 default = nil)
  if valid_580456 != nil:
    section.add "ids", valid_580456
  var valid_580457 = query.getOrDefault("fields")
  valid_580457 = validateParameter(valid_580457, JString, required = false,
                                 default = nil)
  if valid_580457 != nil:
    section.add "fields", valid_580457
  var valid_580458 = query.getOrDefault("maxResults")
  valid_580458 = validateParameter(valid_580458, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580458 != nil:
    section.add "maxResults", valid_580458
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580459: Call_DfareportingDirectorySiteContactsList_580441;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of directory site contacts, possibly filtered. This method supports paging.
  ## 
  let valid = call_580459.validator(path, query, header, formData, body)
  let scheme = call_580459.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580459.url(scheme.get, call_580459.host, call_580459.base,
                         call_580459.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580459, url, valid)

proc call*(call_580460: Call_DfareportingDirectorySiteContactsList_580441;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; sortField: string = "ID"; alt: string = "json";
          userIp: string = ""; directorySiteIds: JsonNode = nil; quotaUser: string = "";
          pageToken: string = ""; searchString: string = "";
          sortOrder: string = "ASCENDING"; ids: JsonNode = nil; fields: string = "";
          maxResults: int = 1000): Recallable =
  ## dfareportingDirectorySiteContactsList
  ## Retrieves a list of directory site contacts, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   directorySiteIds: JArray
  ##                   : Select only directory site contacts with these directory site IDs. This is a required field.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "directory site contact*2015" will return objects with names like "directory site contact June 2015", "directory site contact April 2015", or simply "directory site contact 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site contact" will match objects with name "my directory site contact", "directory site contact 2015", or simply "directory site contact".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only directory site contacts with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_580461 = newJObject()
  var query_580462 = newJObject()
  add(query_580462, "key", newJString(key))
  add(query_580462, "prettyPrint", newJBool(prettyPrint))
  add(query_580462, "oauth_token", newJString(oauthToken))
  add(path_580461, "profileId", newJString(profileId))
  add(query_580462, "sortField", newJString(sortField))
  add(query_580462, "alt", newJString(alt))
  add(query_580462, "userIp", newJString(userIp))
  if directorySiteIds != nil:
    query_580462.add "directorySiteIds", directorySiteIds
  add(query_580462, "quotaUser", newJString(quotaUser))
  add(query_580462, "pageToken", newJString(pageToken))
  add(query_580462, "searchString", newJString(searchString))
  add(query_580462, "sortOrder", newJString(sortOrder))
  if ids != nil:
    query_580462.add "ids", ids
  add(query_580462, "fields", newJString(fields))
  add(query_580462, "maxResults", newJInt(maxResults))
  result = call_580460.call(path_580461, query_580462, nil, nil, nil)

var dfareportingDirectorySiteContactsList* = Call_DfareportingDirectorySiteContactsList_580441(
    name: "dfareportingDirectorySiteContactsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/directorySiteContacts",
    validator: validate_DfareportingDirectorySiteContactsList_580442,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySiteContactsList_580443,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySiteContactsGet_580463 = ref object of OpenApiRestCall_578364
proc url_DfareportingDirectorySiteContactsGet_580465(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySiteContacts/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySiteContactsGet_580464(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one directory site contact by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Directory site contact ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580466 = path.getOrDefault("profileId")
  valid_580466 = validateParameter(valid_580466, JString, required = true,
                                 default = nil)
  if valid_580466 != nil:
    section.add "profileId", valid_580466
  var valid_580467 = path.getOrDefault("id")
  valid_580467 = validateParameter(valid_580467, JString, required = true,
                                 default = nil)
  if valid_580467 != nil:
    section.add "id", valid_580467
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580468 = query.getOrDefault("key")
  valid_580468 = validateParameter(valid_580468, JString, required = false,
                                 default = nil)
  if valid_580468 != nil:
    section.add "key", valid_580468
  var valid_580469 = query.getOrDefault("prettyPrint")
  valid_580469 = validateParameter(valid_580469, JBool, required = false,
                                 default = newJBool(true))
  if valid_580469 != nil:
    section.add "prettyPrint", valid_580469
  var valid_580470 = query.getOrDefault("oauth_token")
  valid_580470 = validateParameter(valid_580470, JString, required = false,
                                 default = nil)
  if valid_580470 != nil:
    section.add "oauth_token", valid_580470
  var valid_580471 = query.getOrDefault("alt")
  valid_580471 = validateParameter(valid_580471, JString, required = false,
                                 default = newJString("json"))
  if valid_580471 != nil:
    section.add "alt", valid_580471
  var valid_580472 = query.getOrDefault("userIp")
  valid_580472 = validateParameter(valid_580472, JString, required = false,
                                 default = nil)
  if valid_580472 != nil:
    section.add "userIp", valid_580472
  var valid_580473 = query.getOrDefault("quotaUser")
  valid_580473 = validateParameter(valid_580473, JString, required = false,
                                 default = nil)
  if valid_580473 != nil:
    section.add "quotaUser", valid_580473
  var valid_580474 = query.getOrDefault("fields")
  valid_580474 = validateParameter(valid_580474, JString, required = false,
                                 default = nil)
  if valid_580474 != nil:
    section.add "fields", valid_580474
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580475: Call_DfareportingDirectorySiteContactsGet_580463;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one directory site contact by ID.
  ## 
  let valid = call_580475.validator(path, query, header, formData, body)
  let scheme = call_580475.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580475.url(scheme.get, call_580475.host, call_580475.base,
                         call_580475.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580475, url, valid)

proc call*(call_580476: Call_DfareportingDirectorySiteContactsGet_580463;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingDirectorySiteContactsGet
  ## Gets one directory site contact by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Directory site contact ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580477 = newJObject()
  var query_580478 = newJObject()
  add(query_580478, "key", newJString(key))
  add(query_580478, "prettyPrint", newJBool(prettyPrint))
  add(query_580478, "oauth_token", newJString(oauthToken))
  add(path_580477, "profileId", newJString(profileId))
  add(path_580477, "id", newJString(id))
  add(query_580478, "alt", newJString(alt))
  add(query_580478, "userIp", newJString(userIp))
  add(query_580478, "quotaUser", newJString(quotaUser))
  add(query_580478, "fields", newJString(fields))
  result = call_580476.call(path_580477, query_580478, nil, nil, nil)

var dfareportingDirectorySiteContactsGet* = Call_DfareportingDirectorySiteContactsGet_580463(
    name: "dfareportingDirectorySiteContactsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/directorySiteContacts/{id}",
    validator: validate_DfareportingDirectorySiteContactsGet_580464,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySiteContactsGet_580465,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySitesInsert_580507 = ref object of OpenApiRestCall_578364
proc url_DfareportingDirectorySitesInsert_580509(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySitesInsert_580508(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new directory site.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580510 = path.getOrDefault("profileId")
  valid_580510 = validateParameter(valid_580510, JString, required = true,
                                 default = nil)
  if valid_580510 != nil:
    section.add "profileId", valid_580510
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580511 = query.getOrDefault("key")
  valid_580511 = validateParameter(valid_580511, JString, required = false,
                                 default = nil)
  if valid_580511 != nil:
    section.add "key", valid_580511
  var valid_580512 = query.getOrDefault("prettyPrint")
  valid_580512 = validateParameter(valid_580512, JBool, required = false,
                                 default = newJBool(true))
  if valid_580512 != nil:
    section.add "prettyPrint", valid_580512
  var valid_580513 = query.getOrDefault("oauth_token")
  valid_580513 = validateParameter(valid_580513, JString, required = false,
                                 default = nil)
  if valid_580513 != nil:
    section.add "oauth_token", valid_580513
  var valid_580514 = query.getOrDefault("alt")
  valid_580514 = validateParameter(valid_580514, JString, required = false,
                                 default = newJString("json"))
  if valid_580514 != nil:
    section.add "alt", valid_580514
  var valid_580515 = query.getOrDefault("userIp")
  valid_580515 = validateParameter(valid_580515, JString, required = false,
                                 default = nil)
  if valid_580515 != nil:
    section.add "userIp", valid_580515
  var valid_580516 = query.getOrDefault("quotaUser")
  valid_580516 = validateParameter(valid_580516, JString, required = false,
                                 default = nil)
  if valid_580516 != nil:
    section.add "quotaUser", valid_580516
  var valid_580517 = query.getOrDefault("fields")
  valid_580517 = validateParameter(valid_580517, JString, required = false,
                                 default = nil)
  if valid_580517 != nil:
    section.add "fields", valid_580517
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580519: Call_DfareportingDirectorySitesInsert_580507;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new directory site.
  ## 
  let valid = call_580519.validator(path, query, header, formData, body)
  let scheme = call_580519.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580519.url(scheme.get, call_580519.host, call_580519.base,
                         call_580519.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580519, url, valid)

proc call*(call_580520: Call_DfareportingDirectorySitesInsert_580507;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingDirectorySitesInsert
  ## Inserts a new directory site.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580521 = newJObject()
  var query_580522 = newJObject()
  var body_580523 = newJObject()
  add(query_580522, "key", newJString(key))
  add(query_580522, "prettyPrint", newJBool(prettyPrint))
  add(query_580522, "oauth_token", newJString(oauthToken))
  add(path_580521, "profileId", newJString(profileId))
  add(query_580522, "alt", newJString(alt))
  add(query_580522, "userIp", newJString(userIp))
  add(query_580522, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580523 = body
  add(query_580522, "fields", newJString(fields))
  result = call_580520.call(path_580521, query_580522, nil, nil, body_580523)

var dfareportingDirectorySitesInsert* = Call_DfareportingDirectorySitesInsert_580507(
    name: "dfareportingDirectorySitesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/directorySites",
    validator: validate_DfareportingDirectorySitesInsert_580508,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySitesInsert_580509,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySitesList_580479 = ref object of OpenApiRestCall_578364
proc url_DfareportingDirectorySitesList_580481(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySitesList_580480(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of directory sites, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580482 = path.getOrDefault("profileId")
  valid_580482 = validateParameter(valid_580482, JString, required = true,
                                 default = nil)
  if valid_580482 != nil:
    section.add "profileId", valid_580482
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsPublisherPaidPlacements: JBool
  ##                                 : Select only directory sites that accept publisher paid placements. This field can be left blank.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   active: JBool
  ##         : Select only active directory sites. Leave blank to retrieve both active and inactive directory sites.
  ##   countryId: JString
  ##            : Select only directory sites with this country ID.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   acceptsInterstitialPlacements: JBool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   dfp_network_code: JString
  ##                   : Select only directory sites with this DFP network code.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or URL. Wildcards (*) are allowed. For example, "directory site*2015" will return objects with names like "directory site June 2015", "directory site April 2015", or simply "directory site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site" will match objects with name "my directory site", "directory site 2015" or simply, "directory site".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   acceptsInStreamVideoPlacements: JBool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   ids: JArray
  ##      : Select only directory sites with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   parentId: JString
  ##           : Select only directory sites with this parent ID.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_580483 = query.getOrDefault("key")
  valid_580483 = validateParameter(valid_580483, JString, required = false,
                                 default = nil)
  if valid_580483 != nil:
    section.add "key", valid_580483
  var valid_580484 = query.getOrDefault("acceptsPublisherPaidPlacements")
  valid_580484 = validateParameter(valid_580484, JBool, required = false, default = nil)
  if valid_580484 != nil:
    section.add "acceptsPublisherPaidPlacements", valid_580484
  var valid_580485 = query.getOrDefault("prettyPrint")
  valid_580485 = validateParameter(valid_580485, JBool, required = false,
                                 default = newJBool(true))
  if valid_580485 != nil:
    section.add "prettyPrint", valid_580485
  var valid_580486 = query.getOrDefault("oauth_token")
  valid_580486 = validateParameter(valid_580486, JString, required = false,
                                 default = nil)
  if valid_580486 != nil:
    section.add "oauth_token", valid_580486
  var valid_580487 = query.getOrDefault("active")
  valid_580487 = validateParameter(valid_580487, JBool, required = false, default = nil)
  if valid_580487 != nil:
    section.add "active", valid_580487
  var valid_580488 = query.getOrDefault("countryId")
  valid_580488 = validateParameter(valid_580488, JString, required = false,
                                 default = nil)
  if valid_580488 != nil:
    section.add "countryId", valid_580488
  var valid_580489 = query.getOrDefault("sortField")
  valid_580489 = validateParameter(valid_580489, JString, required = false,
                                 default = newJString("ID"))
  if valid_580489 != nil:
    section.add "sortField", valid_580489
  var valid_580490 = query.getOrDefault("alt")
  valid_580490 = validateParameter(valid_580490, JString, required = false,
                                 default = newJString("json"))
  if valid_580490 != nil:
    section.add "alt", valid_580490
  var valid_580491 = query.getOrDefault("userIp")
  valid_580491 = validateParameter(valid_580491, JString, required = false,
                                 default = nil)
  if valid_580491 != nil:
    section.add "userIp", valid_580491
  var valid_580492 = query.getOrDefault("acceptsInterstitialPlacements")
  valid_580492 = validateParameter(valid_580492, JBool, required = false, default = nil)
  if valid_580492 != nil:
    section.add "acceptsInterstitialPlacements", valid_580492
  var valid_580493 = query.getOrDefault("quotaUser")
  valid_580493 = validateParameter(valid_580493, JString, required = false,
                                 default = nil)
  if valid_580493 != nil:
    section.add "quotaUser", valid_580493
  var valid_580494 = query.getOrDefault("dfp_network_code")
  valid_580494 = validateParameter(valid_580494, JString, required = false,
                                 default = nil)
  if valid_580494 != nil:
    section.add "dfp_network_code", valid_580494
  var valid_580495 = query.getOrDefault("pageToken")
  valid_580495 = validateParameter(valid_580495, JString, required = false,
                                 default = nil)
  if valid_580495 != nil:
    section.add "pageToken", valid_580495
  var valid_580496 = query.getOrDefault("searchString")
  valid_580496 = validateParameter(valid_580496, JString, required = false,
                                 default = nil)
  if valid_580496 != nil:
    section.add "searchString", valid_580496
  var valid_580497 = query.getOrDefault("sortOrder")
  valid_580497 = validateParameter(valid_580497, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580497 != nil:
    section.add "sortOrder", valid_580497
  var valid_580498 = query.getOrDefault("acceptsInStreamVideoPlacements")
  valid_580498 = validateParameter(valid_580498, JBool, required = false, default = nil)
  if valid_580498 != nil:
    section.add "acceptsInStreamVideoPlacements", valid_580498
  var valid_580499 = query.getOrDefault("ids")
  valid_580499 = validateParameter(valid_580499, JArray, required = false,
                                 default = nil)
  if valid_580499 != nil:
    section.add "ids", valid_580499
  var valid_580500 = query.getOrDefault("fields")
  valid_580500 = validateParameter(valid_580500, JString, required = false,
                                 default = nil)
  if valid_580500 != nil:
    section.add "fields", valid_580500
  var valid_580501 = query.getOrDefault("parentId")
  valid_580501 = validateParameter(valid_580501, JString, required = false,
                                 default = nil)
  if valid_580501 != nil:
    section.add "parentId", valid_580501
  var valid_580502 = query.getOrDefault("maxResults")
  valid_580502 = validateParameter(valid_580502, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580502 != nil:
    section.add "maxResults", valid_580502
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580503: Call_DfareportingDirectorySitesList_580479; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of directory sites, possibly filtered. This method supports paging.
  ## 
  let valid = call_580503.validator(path, query, header, formData, body)
  let scheme = call_580503.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580503.url(scheme.get, call_580503.host, call_580503.base,
                         call_580503.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580503, url, valid)

proc call*(call_580504: Call_DfareportingDirectorySitesList_580479;
          profileId: string; key: string = "";
          acceptsPublisherPaidPlacements: bool = false; prettyPrint: bool = true;
          oauthToken: string = ""; active: bool = false; countryId: string = "";
          sortField: string = "ID"; alt: string = "json"; userIp: string = "";
          acceptsInterstitialPlacements: bool = false; quotaUser: string = "";
          dfpNetworkCode: string = ""; pageToken: string = "";
          searchString: string = ""; sortOrder: string = "ASCENDING";
          acceptsInStreamVideoPlacements: bool = false; ids: JsonNode = nil;
          fields: string = ""; parentId: string = ""; maxResults: int = 1000): Recallable =
  ## dfareportingDirectorySitesList
  ## Retrieves a list of directory sites, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsPublisherPaidPlacements: bool
  ##                                 : Select only directory sites that accept publisher paid placements. This field can be left blank.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   active: bool
  ##         : Select only active directory sites. Leave blank to retrieve both active and inactive directory sites.
  ##   countryId: string
  ##            : Select only directory sites with this country ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   acceptsInterstitialPlacements: bool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   dfpNetworkCode: string
  ##                 : Select only directory sites with this DFP network code.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or URL. Wildcards (*) are allowed. For example, "directory site*2015" will return objects with names like "directory site June 2015", "directory site April 2015", or simply "directory site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site" will match objects with name "my directory site", "directory site 2015" or simply, "directory site".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   acceptsInStreamVideoPlacements: bool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   ids: JArray
  ##      : Select only directory sites with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   parentId: string
  ##           : Select only directory sites with this parent ID.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_580505 = newJObject()
  var query_580506 = newJObject()
  add(query_580506, "key", newJString(key))
  add(query_580506, "acceptsPublisherPaidPlacements",
      newJBool(acceptsPublisherPaidPlacements))
  add(query_580506, "prettyPrint", newJBool(prettyPrint))
  add(query_580506, "oauth_token", newJString(oauthToken))
  add(query_580506, "active", newJBool(active))
  add(query_580506, "countryId", newJString(countryId))
  add(path_580505, "profileId", newJString(profileId))
  add(query_580506, "sortField", newJString(sortField))
  add(query_580506, "alt", newJString(alt))
  add(query_580506, "userIp", newJString(userIp))
  add(query_580506, "acceptsInterstitialPlacements",
      newJBool(acceptsInterstitialPlacements))
  add(query_580506, "quotaUser", newJString(quotaUser))
  add(query_580506, "dfp_network_code", newJString(dfpNetworkCode))
  add(query_580506, "pageToken", newJString(pageToken))
  add(query_580506, "searchString", newJString(searchString))
  add(query_580506, "sortOrder", newJString(sortOrder))
  add(query_580506, "acceptsInStreamVideoPlacements",
      newJBool(acceptsInStreamVideoPlacements))
  if ids != nil:
    query_580506.add "ids", ids
  add(query_580506, "fields", newJString(fields))
  add(query_580506, "parentId", newJString(parentId))
  add(query_580506, "maxResults", newJInt(maxResults))
  result = call_580504.call(path_580505, query_580506, nil, nil, nil)

var dfareportingDirectorySitesList* = Call_DfareportingDirectorySitesList_580479(
    name: "dfareportingDirectorySitesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/directorySites",
    validator: validate_DfareportingDirectorySitesList_580480,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySitesList_580481,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySitesGet_580524 = ref object of OpenApiRestCall_578364
proc url_DfareportingDirectorySitesGet_580526(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySites/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySitesGet_580525(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one directory site by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Directory site ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580527 = path.getOrDefault("profileId")
  valid_580527 = validateParameter(valid_580527, JString, required = true,
                                 default = nil)
  if valid_580527 != nil:
    section.add "profileId", valid_580527
  var valid_580528 = path.getOrDefault("id")
  valid_580528 = validateParameter(valid_580528, JString, required = true,
                                 default = nil)
  if valid_580528 != nil:
    section.add "id", valid_580528
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580529 = query.getOrDefault("key")
  valid_580529 = validateParameter(valid_580529, JString, required = false,
                                 default = nil)
  if valid_580529 != nil:
    section.add "key", valid_580529
  var valid_580530 = query.getOrDefault("prettyPrint")
  valid_580530 = validateParameter(valid_580530, JBool, required = false,
                                 default = newJBool(true))
  if valid_580530 != nil:
    section.add "prettyPrint", valid_580530
  var valid_580531 = query.getOrDefault("oauth_token")
  valid_580531 = validateParameter(valid_580531, JString, required = false,
                                 default = nil)
  if valid_580531 != nil:
    section.add "oauth_token", valid_580531
  var valid_580532 = query.getOrDefault("alt")
  valid_580532 = validateParameter(valid_580532, JString, required = false,
                                 default = newJString("json"))
  if valid_580532 != nil:
    section.add "alt", valid_580532
  var valid_580533 = query.getOrDefault("userIp")
  valid_580533 = validateParameter(valid_580533, JString, required = false,
                                 default = nil)
  if valid_580533 != nil:
    section.add "userIp", valid_580533
  var valid_580534 = query.getOrDefault("quotaUser")
  valid_580534 = validateParameter(valid_580534, JString, required = false,
                                 default = nil)
  if valid_580534 != nil:
    section.add "quotaUser", valid_580534
  var valid_580535 = query.getOrDefault("fields")
  valid_580535 = validateParameter(valid_580535, JString, required = false,
                                 default = nil)
  if valid_580535 != nil:
    section.add "fields", valid_580535
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580536: Call_DfareportingDirectorySitesGet_580524; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one directory site by ID.
  ## 
  let valid = call_580536.validator(path, query, header, formData, body)
  let scheme = call_580536.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580536.url(scheme.get, call_580536.host, call_580536.base,
                         call_580536.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580536, url, valid)

proc call*(call_580537: Call_DfareportingDirectorySitesGet_580524;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingDirectorySitesGet
  ## Gets one directory site by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Directory site ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580538 = newJObject()
  var query_580539 = newJObject()
  add(query_580539, "key", newJString(key))
  add(query_580539, "prettyPrint", newJBool(prettyPrint))
  add(query_580539, "oauth_token", newJString(oauthToken))
  add(path_580538, "profileId", newJString(profileId))
  add(path_580538, "id", newJString(id))
  add(query_580539, "alt", newJString(alt))
  add(query_580539, "userIp", newJString(userIp))
  add(query_580539, "quotaUser", newJString(quotaUser))
  add(query_580539, "fields", newJString(fields))
  result = call_580537.call(path_580538, query_580539, nil, nil, nil)

var dfareportingDirectorySitesGet* = Call_DfareportingDirectorySitesGet_580524(
    name: "dfareportingDirectorySitesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/directorySites/{id}",
    validator: validate_DfareportingDirectorySitesGet_580525,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySitesGet_580526,
    schemes: {Scheme.Https})
type
  Call_DfareportingDynamicTargetingKeysInsert_580559 = ref object of OpenApiRestCall_578364
proc url_DfareportingDynamicTargetingKeysInsert_580561(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dynamicTargetingKeys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDynamicTargetingKeysInsert_580560(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new dynamic targeting key. Keys must be created at the advertiser level before being assigned to the advertiser's ads, creatives, or placements. There is a maximum of 1000 keys per advertiser, out of which a maximum of 20 keys can be assigned per ad, creative, or placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580562 = path.getOrDefault("profileId")
  valid_580562 = validateParameter(valid_580562, JString, required = true,
                                 default = nil)
  if valid_580562 != nil:
    section.add "profileId", valid_580562
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580563 = query.getOrDefault("key")
  valid_580563 = validateParameter(valid_580563, JString, required = false,
                                 default = nil)
  if valid_580563 != nil:
    section.add "key", valid_580563
  var valid_580564 = query.getOrDefault("prettyPrint")
  valid_580564 = validateParameter(valid_580564, JBool, required = false,
                                 default = newJBool(true))
  if valid_580564 != nil:
    section.add "prettyPrint", valid_580564
  var valid_580565 = query.getOrDefault("oauth_token")
  valid_580565 = validateParameter(valid_580565, JString, required = false,
                                 default = nil)
  if valid_580565 != nil:
    section.add "oauth_token", valid_580565
  var valid_580566 = query.getOrDefault("alt")
  valid_580566 = validateParameter(valid_580566, JString, required = false,
                                 default = newJString("json"))
  if valid_580566 != nil:
    section.add "alt", valid_580566
  var valid_580567 = query.getOrDefault("userIp")
  valid_580567 = validateParameter(valid_580567, JString, required = false,
                                 default = nil)
  if valid_580567 != nil:
    section.add "userIp", valid_580567
  var valid_580568 = query.getOrDefault("quotaUser")
  valid_580568 = validateParameter(valid_580568, JString, required = false,
                                 default = nil)
  if valid_580568 != nil:
    section.add "quotaUser", valid_580568
  var valid_580569 = query.getOrDefault("fields")
  valid_580569 = validateParameter(valid_580569, JString, required = false,
                                 default = nil)
  if valid_580569 != nil:
    section.add "fields", valid_580569
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580571: Call_DfareportingDynamicTargetingKeysInsert_580559;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new dynamic targeting key. Keys must be created at the advertiser level before being assigned to the advertiser's ads, creatives, or placements. There is a maximum of 1000 keys per advertiser, out of which a maximum of 20 keys can be assigned per ad, creative, or placement.
  ## 
  let valid = call_580571.validator(path, query, header, formData, body)
  let scheme = call_580571.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580571.url(scheme.get, call_580571.host, call_580571.base,
                         call_580571.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580571, url, valid)

proc call*(call_580572: Call_DfareportingDynamicTargetingKeysInsert_580559;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingDynamicTargetingKeysInsert
  ## Inserts a new dynamic targeting key. Keys must be created at the advertiser level before being assigned to the advertiser's ads, creatives, or placements. There is a maximum of 1000 keys per advertiser, out of which a maximum of 20 keys can be assigned per ad, creative, or placement.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580573 = newJObject()
  var query_580574 = newJObject()
  var body_580575 = newJObject()
  add(query_580574, "key", newJString(key))
  add(query_580574, "prettyPrint", newJBool(prettyPrint))
  add(query_580574, "oauth_token", newJString(oauthToken))
  add(path_580573, "profileId", newJString(profileId))
  add(query_580574, "alt", newJString(alt))
  add(query_580574, "userIp", newJString(userIp))
  add(query_580574, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580575 = body
  add(query_580574, "fields", newJString(fields))
  result = call_580572.call(path_580573, query_580574, nil, nil, body_580575)

var dfareportingDynamicTargetingKeysInsert* = Call_DfareportingDynamicTargetingKeysInsert_580559(
    name: "dfareportingDynamicTargetingKeysInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dynamicTargetingKeys",
    validator: validate_DfareportingDynamicTargetingKeysInsert_580560,
    base: "/dfareporting/v2.7", url: url_DfareportingDynamicTargetingKeysInsert_580561,
    schemes: {Scheme.Https})
type
  Call_DfareportingDynamicTargetingKeysList_580540 = ref object of OpenApiRestCall_578364
proc url_DfareportingDynamicTargetingKeysList_580542(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dynamicTargetingKeys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDynamicTargetingKeysList_580541(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of dynamic targeting keys.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580543 = path.getOrDefault("profileId")
  valid_580543 = validateParameter(valid_580543, JString, required = true,
                                 default = nil)
  if valid_580543 != nil:
    section.add "profileId", valid_580543
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   names: JArray
  ##        : Select only dynamic targeting keys exactly matching these names.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   objectType: JString
  ##             : Select only dynamic targeting keys with this object type.
  ##   objectId: JString
  ##           : Select only dynamic targeting keys with this object ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   advertiserId: JString
  ##               : Select only dynamic targeting keys whose object has this advertiser ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580544 = query.getOrDefault("key")
  valid_580544 = validateParameter(valid_580544, JString, required = false,
                                 default = nil)
  if valid_580544 != nil:
    section.add "key", valid_580544
  var valid_580545 = query.getOrDefault("names")
  valid_580545 = validateParameter(valid_580545, JArray, required = false,
                                 default = nil)
  if valid_580545 != nil:
    section.add "names", valid_580545
  var valid_580546 = query.getOrDefault("prettyPrint")
  valid_580546 = validateParameter(valid_580546, JBool, required = false,
                                 default = newJBool(true))
  if valid_580546 != nil:
    section.add "prettyPrint", valid_580546
  var valid_580547 = query.getOrDefault("oauth_token")
  valid_580547 = validateParameter(valid_580547, JString, required = false,
                                 default = nil)
  if valid_580547 != nil:
    section.add "oauth_token", valid_580547
  var valid_580548 = query.getOrDefault("objectType")
  valid_580548 = validateParameter(valid_580548, JString, required = false,
                                 default = newJString("OBJECT_AD"))
  if valid_580548 != nil:
    section.add "objectType", valid_580548
  var valid_580549 = query.getOrDefault("objectId")
  valid_580549 = validateParameter(valid_580549, JString, required = false,
                                 default = nil)
  if valid_580549 != nil:
    section.add "objectId", valid_580549
  var valid_580550 = query.getOrDefault("alt")
  valid_580550 = validateParameter(valid_580550, JString, required = false,
                                 default = newJString("json"))
  if valid_580550 != nil:
    section.add "alt", valid_580550
  var valid_580551 = query.getOrDefault("userIp")
  valid_580551 = validateParameter(valid_580551, JString, required = false,
                                 default = nil)
  if valid_580551 != nil:
    section.add "userIp", valid_580551
  var valid_580552 = query.getOrDefault("quotaUser")
  valid_580552 = validateParameter(valid_580552, JString, required = false,
                                 default = nil)
  if valid_580552 != nil:
    section.add "quotaUser", valid_580552
  var valid_580553 = query.getOrDefault("advertiserId")
  valid_580553 = validateParameter(valid_580553, JString, required = false,
                                 default = nil)
  if valid_580553 != nil:
    section.add "advertiserId", valid_580553
  var valid_580554 = query.getOrDefault("fields")
  valid_580554 = validateParameter(valid_580554, JString, required = false,
                                 default = nil)
  if valid_580554 != nil:
    section.add "fields", valid_580554
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580555: Call_DfareportingDynamicTargetingKeysList_580540;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of dynamic targeting keys.
  ## 
  let valid = call_580555.validator(path, query, header, formData, body)
  let scheme = call_580555.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580555.url(scheme.get, call_580555.host, call_580555.base,
                         call_580555.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580555, url, valid)

proc call*(call_580556: Call_DfareportingDynamicTargetingKeysList_580540;
          profileId: string; key: string = ""; names: JsonNode = nil;
          prettyPrint: bool = true; oauthToken: string = "";
          objectType: string = "OBJECT_AD"; objectId: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; advertiserId: string = "";
          fields: string = ""): Recallable =
  ## dfareportingDynamicTargetingKeysList
  ## Retrieves a list of dynamic targeting keys.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   names: JArray
  ##        : Select only dynamic targeting keys exactly matching these names.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   objectType: string
  ##             : Select only dynamic targeting keys with this object type.
  ##   objectId: string
  ##           : Select only dynamic targeting keys with this object ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   advertiserId: string
  ##               : Select only dynamic targeting keys whose object has this advertiser ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580557 = newJObject()
  var query_580558 = newJObject()
  add(query_580558, "key", newJString(key))
  if names != nil:
    query_580558.add "names", names
  add(query_580558, "prettyPrint", newJBool(prettyPrint))
  add(query_580558, "oauth_token", newJString(oauthToken))
  add(query_580558, "objectType", newJString(objectType))
  add(query_580558, "objectId", newJString(objectId))
  add(path_580557, "profileId", newJString(profileId))
  add(query_580558, "alt", newJString(alt))
  add(query_580558, "userIp", newJString(userIp))
  add(query_580558, "quotaUser", newJString(quotaUser))
  add(query_580558, "advertiserId", newJString(advertiserId))
  add(query_580558, "fields", newJString(fields))
  result = call_580556.call(path_580557, query_580558, nil, nil, nil)

var dfareportingDynamicTargetingKeysList* = Call_DfareportingDynamicTargetingKeysList_580540(
    name: "dfareportingDynamicTargetingKeysList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dynamicTargetingKeys",
    validator: validate_DfareportingDynamicTargetingKeysList_580541,
    base: "/dfareporting/v2.7", url: url_DfareportingDynamicTargetingKeysList_580542,
    schemes: {Scheme.Https})
type
  Call_DfareportingDynamicTargetingKeysDelete_580576 = ref object of OpenApiRestCall_578364
proc url_DfareportingDynamicTargetingKeysDelete_580578(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "objectId" in path, "`objectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dynamicTargetingKeys/"),
               (kind: VariableSegment, value: "objectId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDynamicTargetingKeysDelete_580577(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing dynamic targeting key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   objectId: JString (required)
  ##           : ID of the object of this dynamic targeting key. This is a required field.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580579 = path.getOrDefault("profileId")
  valid_580579 = validateParameter(valid_580579, JString, required = true,
                                 default = nil)
  if valid_580579 != nil:
    section.add "profileId", valid_580579
  var valid_580580 = path.getOrDefault("objectId")
  valid_580580 = validateParameter(valid_580580, JString, required = true,
                                 default = nil)
  if valid_580580 != nil:
    section.add "objectId", valid_580580
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   objectType: JString (required)
  ##             : Type of the object of this dynamic targeting key. This is a required field.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   name: JString (required)
  ##       : Name of this dynamic targeting key. This is a required field. Must be less than 256 characters long and cannot contain commas. All characters are converted to lowercase.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580581 = query.getOrDefault("key")
  valid_580581 = validateParameter(valid_580581, JString, required = false,
                                 default = nil)
  if valid_580581 != nil:
    section.add "key", valid_580581
  assert query != nil,
        "query argument is necessary due to required `objectType` field"
  var valid_580582 = query.getOrDefault("objectType")
  valid_580582 = validateParameter(valid_580582, JString, required = true,
                                 default = newJString("OBJECT_AD"))
  if valid_580582 != nil:
    section.add "objectType", valid_580582
  var valid_580583 = query.getOrDefault("prettyPrint")
  valid_580583 = validateParameter(valid_580583, JBool, required = false,
                                 default = newJBool(true))
  if valid_580583 != nil:
    section.add "prettyPrint", valid_580583
  var valid_580584 = query.getOrDefault("oauth_token")
  valid_580584 = validateParameter(valid_580584, JString, required = false,
                                 default = nil)
  if valid_580584 != nil:
    section.add "oauth_token", valid_580584
  var valid_580585 = query.getOrDefault("name")
  valid_580585 = validateParameter(valid_580585, JString, required = true,
                                 default = nil)
  if valid_580585 != nil:
    section.add "name", valid_580585
  var valid_580586 = query.getOrDefault("alt")
  valid_580586 = validateParameter(valid_580586, JString, required = false,
                                 default = newJString("json"))
  if valid_580586 != nil:
    section.add "alt", valid_580586
  var valid_580587 = query.getOrDefault("userIp")
  valid_580587 = validateParameter(valid_580587, JString, required = false,
                                 default = nil)
  if valid_580587 != nil:
    section.add "userIp", valid_580587
  var valid_580588 = query.getOrDefault("quotaUser")
  valid_580588 = validateParameter(valid_580588, JString, required = false,
                                 default = nil)
  if valid_580588 != nil:
    section.add "quotaUser", valid_580588
  var valid_580589 = query.getOrDefault("fields")
  valid_580589 = validateParameter(valid_580589, JString, required = false,
                                 default = nil)
  if valid_580589 != nil:
    section.add "fields", valid_580589
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580590: Call_DfareportingDynamicTargetingKeysDelete_580576;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing dynamic targeting key.
  ## 
  let valid = call_580590.validator(path, query, header, formData, body)
  let scheme = call_580590.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580590.url(scheme.get, call_580590.host, call_580590.base,
                         call_580590.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580590, url, valid)

proc call*(call_580591: Call_DfareportingDynamicTargetingKeysDelete_580576;
          name: string; profileId: string; objectId: string; key: string = "";
          objectType: string = "OBJECT_AD"; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingDynamicTargetingKeysDelete
  ## Deletes an existing dynamic targeting key.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   objectType: string (required)
  ##             : Type of the object of this dynamic targeting key. This is a required field.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   name: string (required)
  ##       : Name of this dynamic targeting key. This is a required field. Must be less than 256 characters long and cannot contain commas. All characters are converted to lowercase.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   objectId: string (required)
  ##           : ID of the object of this dynamic targeting key. This is a required field.
  var path_580592 = newJObject()
  var query_580593 = newJObject()
  add(query_580593, "key", newJString(key))
  add(query_580593, "objectType", newJString(objectType))
  add(query_580593, "prettyPrint", newJBool(prettyPrint))
  add(query_580593, "oauth_token", newJString(oauthToken))
  add(query_580593, "name", newJString(name))
  add(path_580592, "profileId", newJString(profileId))
  add(query_580593, "alt", newJString(alt))
  add(query_580593, "userIp", newJString(userIp))
  add(query_580593, "quotaUser", newJString(quotaUser))
  add(query_580593, "fields", newJString(fields))
  add(path_580592, "objectId", newJString(objectId))
  result = call_580591.call(path_580592, query_580593, nil, nil, nil)

var dfareportingDynamicTargetingKeysDelete* = Call_DfareportingDynamicTargetingKeysDelete_580576(
    name: "dfareportingDynamicTargetingKeysDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dynamicTargetingKeys/{objectId}",
    validator: validate_DfareportingDynamicTargetingKeysDelete_580577,
    base: "/dfareporting/v2.7", url: url_DfareportingDynamicTargetingKeysDelete_580578,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsUpdate_580619 = ref object of OpenApiRestCall_578364
proc url_DfareportingEventTagsUpdate_580621(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsUpdate_580620(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing event tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580622 = path.getOrDefault("profileId")
  valid_580622 = validateParameter(valid_580622, JString, required = true,
                                 default = nil)
  if valid_580622 != nil:
    section.add "profileId", valid_580622
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580623 = query.getOrDefault("key")
  valid_580623 = validateParameter(valid_580623, JString, required = false,
                                 default = nil)
  if valid_580623 != nil:
    section.add "key", valid_580623
  var valid_580624 = query.getOrDefault("prettyPrint")
  valid_580624 = validateParameter(valid_580624, JBool, required = false,
                                 default = newJBool(true))
  if valid_580624 != nil:
    section.add "prettyPrint", valid_580624
  var valid_580625 = query.getOrDefault("oauth_token")
  valid_580625 = validateParameter(valid_580625, JString, required = false,
                                 default = nil)
  if valid_580625 != nil:
    section.add "oauth_token", valid_580625
  var valid_580626 = query.getOrDefault("alt")
  valid_580626 = validateParameter(valid_580626, JString, required = false,
                                 default = newJString("json"))
  if valid_580626 != nil:
    section.add "alt", valid_580626
  var valid_580627 = query.getOrDefault("userIp")
  valid_580627 = validateParameter(valid_580627, JString, required = false,
                                 default = nil)
  if valid_580627 != nil:
    section.add "userIp", valid_580627
  var valid_580628 = query.getOrDefault("quotaUser")
  valid_580628 = validateParameter(valid_580628, JString, required = false,
                                 default = nil)
  if valid_580628 != nil:
    section.add "quotaUser", valid_580628
  var valid_580629 = query.getOrDefault("fields")
  valid_580629 = validateParameter(valid_580629, JString, required = false,
                                 default = nil)
  if valid_580629 != nil:
    section.add "fields", valid_580629
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580631: Call_DfareportingEventTagsUpdate_580619; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing event tag.
  ## 
  let valid = call_580631.validator(path, query, header, formData, body)
  let scheme = call_580631.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580631.url(scheme.get, call_580631.host, call_580631.base,
                         call_580631.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580631, url, valid)

proc call*(call_580632: Call_DfareportingEventTagsUpdate_580619; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingEventTagsUpdate
  ## Updates an existing event tag.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580633 = newJObject()
  var query_580634 = newJObject()
  var body_580635 = newJObject()
  add(query_580634, "key", newJString(key))
  add(query_580634, "prettyPrint", newJBool(prettyPrint))
  add(query_580634, "oauth_token", newJString(oauthToken))
  add(path_580633, "profileId", newJString(profileId))
  add(query_580634, "alt", newJString(alt))
  add(query_580634, "userIp", newJString(userIp))
  add(query_580634, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580635 = body
  add(query_580634, "fields", newJString(fields))
  result = call_580632.call(path_580633, query_580634, nil, nil, body_580635)

var dfareportingEventTagsUpdate* = Call_DfareportingEventTagsUpdate_580619(
    name: "dfareportingEventTagsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsUpdate_580620,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsUpdate_580621,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsInsert_580636 = ref object of OpenApiRestCall_578364
proc url_DfareportingEventTagsInsert_580638(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsInsert_580637(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new event tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580639 = path.getOrDefault("profileId")
  valid_580639 = validateParameter(valid_580639, JString, required = true,
                                 default = nil)
  if valid_580639 != nil:
    section.add "profileId", valid_580639
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580640 = query.getOrDefault("key")
  valid_580640 = validateParameter(valid_580640, JString, required = false,
                                 default = nil)
  if valid_580640 != nil:
    section.add "key", valid_580640
  var valid_580641 = query.getOrDefault("prettyPrint")
  valid_580641 = validateParameter(valid_580641, JBool, required = false,
                                 default = newJBool(true))
  if valid_580641 != nil:
    section.add "prettyPrint", valid_580641
  var valid_580642 = query.getOrDefault("oauth_token")
  valid_580642 = validateParameter(valid_580642, JString, required = false,
                                 default = nil)
  if valid_580642 != nil:
    section.add "oauth_token", valid_580642
  var valid_580643 = query.getOrDefault("alt")
  valid_580643 = validateParameter(valid_580643, JString, required = false,
                                 default = newJString("json"))
  if valid_580643 != nil:
    section.add "alt", valid_580643
  var valid_580644 = query.getOrDefault("userIp")
  valid_580644 = validateParameter(valid_580644, JString, required = false,
                                 default = nil)
  if valid_580644 != nil:
    section.add "userIp", valid_580644
  var valid_580645 = query.getOrDefault("quotaUser")
  valid_580645 = validateParameter(valid_580645, JString, required = false,
                                 default = nil)
  if valid_580645 != nil:
    section.add "quotaUser", valid_580645
  var valid_580646 = query.getOrDefault("fields")
  valid_580646 = validateParameter(valid_580646, JString, required = false,
                                 default = nil)
  if valid_580646 != nil:
    section.add "fields", valid_580646
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580648: Call_DfareportingEventTagsInsert_580636; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new event tag.
  ## 
  let valid = call_580648.validator(path, query, header, formData, body)
  let scheme = call_580648.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580648.url(scheme.get, call_580648.host, call_580648.base,
                         call_580648.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580648, url, valid)

proc call*(call_580649: Call_DfareportingEventTagsInsert_580636; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingEventTagsInsert
  ## Inserts a new event tag.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580650 = newJObject()
  var query_580651 = newJObject()
  var body_580652 = newJObject()
  add(query_580651, "key", newJString(key))
  add(query_580651, "prettyPrint", newJBool(prettyPrint))
  add(query_580651, "oauth_token", newJString(oauthToken))
  add(path_580650, "profileId", newJString(profileId))
  add(query_580651, "alt", newJString(alt))
  add(query_580651, "userIp", newJString(userIp))
  add(query_580651, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580652 = body
  add(query_580651, "fields", newJString(fields))
  result = call_580649.call(path_580650, query_580651, nil, nil, body_580652)

var dfareportingEventTagsInsert* = Call_DfareportingEventTagsInsert_580636(
    name: "dfareportingEventTagsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsInsert_580637,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsInsert_580638,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsList_580594 = ref object of OpenApiRestCall_578364
proc url_DfareportingEventTagsList_580596(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsList_580595(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of event tags, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580597 = path.getOrDefault("profileId")
  valid_580597 = validateParameter(valid_580597, JString, required = true,
                                 default = nil)
  if valid_580597 != nil:
    section.add "profileId", valid_580597
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   adId: JString
  ##       : Select only event tags that belong to this ad.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   definitionsOnly: JBool
  ##                  : Examine only the specified campaign or advertiser's event tags for matching selector criteria. When set to false, the parent advertiser and parent campaign of the specified ad or campaign is examined as well. In addition, when set to false, the status field is examined as well, along with the enabledByDefault field. This parameter can not be set to true when adId is specified as ads do not define their own even tags.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   campaignId: JString
  ##             : Select only event tags that belong to this campaign.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "eventtag*2015" will return objects with names like "eventtag June 2015", "eventtag April 2015", or simply "eventtag 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "eventtag" will match objects with name "my eventtag", "eventtag 2015", or simply "eventtag".
  ##   eventTagTypes: JArray
  ##                : Select only event tags with the specified event tag types. Event tag types can be used to specify whether to use a third-party pixel, a third-party JavaScript URL, or a third-party click-through URL for either impression or click tracking.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   advertiserId: JString
  ##               : Select only event tags that belong to this advertiser.
  ##   enabled: JBool
  ##          : Select only enabled event tags. What is considered enabled or disabled depends on the definitionsOnly parameter. When definitionsOnly is set to true, only the specified advertiser or campaign's event tags' enabledByDefault field is examined. When definitionsOnly is set to false, the specified ad or specified campaign's parent advertiser's or parent campaign's event tags' enabledByDefault and status fields are examined as well.
  ##   ids: JArray
  ##      : Select only event tags with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580598 = query.getOrDefault("key")
  valid_580598 = validateParameter(valid_580598, JString, required = false,
                                 default = nil)
  if valid_580598 != nil:
    section.add "key", valid_580598
  var valid_580599 = query.getOrDefault("prettyPrint")
  valid_580599 = validateParameter(valid_580599, JBool, required = false,
                                 default = newJBool(true))
  if valid_580599 != nil:
    section.add "prettyPrint", valid_580599
  var valid_580600 = query.getOrDefault("oauth_token")
  valid_580600 = validateParameter(valid_580600, JString, required = false,
                                 default = nil)
  if valid_580600 != nil:
    section.add "oauth_token", valid_580600
  var valid_580601 = query.getOrDefault("adId")
  valid_580601 = validateParameter(valid_580601, JString, required = false,
                                 default = nil)
  if valid_580601 != nil:
    section.add "adId", valid_580601
  var valid_580602 = query.getOrDefault("sortField")
  valid_580602 = validateParameter(valid_580602, JString, required = false,
                                 default = newJString("ID"))
  if valid_580602 != nil:
    section.add "sortField", valid_580602
  var valid_580603 = query.getOrDefault("alt")
  valid_580603 = validateParameter(valid_580603, JString, required = false,
                                 default = newJString("json"))
  if valid_580603 != nil:
    section.add "alt", valid_580603
  var valid_580604 = query.getOrDefault("userIp")
  valid_580604 = validateParameter(valid_580604, JString, required = false,
                                 default = nil)
  if valid_580604 != nil:
    section.add "userIp", valid_580604
  var valid_580605 = query.getOrDefault("definitionsOnly")
  valid_580605 = validateParameter(valid_580605, JBool, required = false, default = nil)
  if valid_580605 != nil:
    section.add "definitionsOnly", valid_580605
  var valid_580606 = query.getOrDefault("quotaUser")
  valid_580606 = validateParameter(valid_580606, JString, required = false,
                                 default = nil)
  if valid_580606 != nil:
    section.add "quotaUser", valid_580606
  var valid_580607 = query.getOrDefault("campaignId")
  valid_580607 = validateParameter(valid_580607, JString, required = false,
                                 default = nil)
  if valid_580607 != nil:
    section.add "campaignId", valid_580607
  var valid_580608 = query.getOrDefault("searchString")
  valid_580608 = validateParameter(valid_580608, JString, required = false,
                                 default = nil)
  if valid_580608 != nil:
    section.add "searchString", valid_580608
  var valid_580609 = query.getOrDefault("eventTagTypes")
  valid_580609 = validateParameter(valid_580609, JArray, required = false,
                                 default = nil)
  if valid_580609 != nil:
    section.add "eventTagTypes", valid_580609
  var valid_580610 = query.getOrDefault("sortOrder")
  valid_580610 = validateParameter(valid_580610, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580610 != nil:
    section.add "sortOrder", valid_580610
  var valid_580611 = query.getOrDefault("advertiserId")
  valid_580611 = validateParameter(valid_580611, JString, required = false,
                                 default = nil)
  if valid_580611 != nil:
    section.add "advertiserId", valid_580611
  var valid_580612 = query.getOrDefault("enabled")
  valid_580612 = validateParameter(valid_580612, JBool, required = false, default = nil)
  if valid_580612 != nil:
    section.add "enabled", valid_580612
  var valid_580613 = query.getOrDefault("ids")
  valid_580613 = validateParameter(valid_580613, JArray, required = false,
                                 default = nil)
  if valid_580613 != nil:
    section.add "ids", valid_580613
  var valid_580614 = query.getOrDefault("fields")
  valid_580614 = validateParameter(valid_580614, JString, required = false,
                                 default = nil)
  if valid_580614 != nil:
    section.add "fields", valid_580614
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580615: Call_DfareportingEventTagsList_580594; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of event tags, possibly filtered.
  ## 
  let valid = call_580615.validator(path, query, header, formData, body)
  let scheme = call_580615.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580615.url(scheme.get, call_580615.host, call_580615.base,
                         call_580615.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580615, url, valid)

proc call*(call_580616: Call_DfareportingEventTagsList_580594; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          adId: string = ""; sortField: string = "ID"; alt: string = "json";
          userIp: string = ""; definitionsOnly: bool = false; quotaUser: string = "";
          campaignId: string = ""; searchString: string = "";
          eventTagTypes: JsonNode = nil; sortOrder: string = "ASCENDING";
          advertiserId: string = ""; enabled: bool = false; ids: JsonNode = nil;
          fields: string = ""): Recallable =
  ## dfareportingEventTagsList
  ## Retrieves a list of event tags, possibly filtered.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   adId: string
  ##       : Select only event tags that belong to this ad.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   definitionsOnly: bool
  ##                  : Examine only the specified campaign or advertiser's event tags for matching selector criteria. When set to false, the parent advertiser and parent campaign of the specified ad or campaign is examined as well. In addition, when set to false, the status field is examined as well, along with the enabledByDefault field. This parameter can not be set to true when adId is specified as ads do not define their own even tags.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   campaignId: string
  ##             : Select only event tags that belong to this campaign.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "eventtag*2015" will return objects with names like "eventtag June 2015", "eventtag April 2015", or simply "eventtag 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "eventtag" will match objects with name "my eventtag", "eventtag 2015", or simply "eventtag".
  ##   eventTagTypes: JArray
  ##                : Select only event tags with the specified event tag types. Event tag types can be used to specify whether to use a third-party pixel, a third-party JavaScript URL, or a third-party click-through URL for either impression or click tracking.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   advertiserId: string
  ##               : Select only event tags that belong to this advertiser.
  ##   enabled: bool
  ##          : Select only enabled event tags. What is considered enabled or disabled depends on the definitionsOnly parameter. When definitionsOnly is set to true, only the specified advertiser or campaign's event tags' enabledByDefault field is examined. When definitionsOnly is set to false, the specified ad or specified campaign's parent advertiser's or parent campaign's event tags' enabledByDefault and status fields are examined as well.
  ##   ids: JArray
  ##      : Select only event tags with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580617 = newJObject()
  var query_580618 = newJObject()
  add(query_580618, "key", newJString(key))
  add(query_580618, "prettyPrint", newJBool(prettyPrint))
  add(query_580618, "oauth_token", newJString(oauthToken))
  add(path_580617, "profileId", newJString(profileId))
  add(query_580618, "adId", newJString(adId))
  add(query_580618, "sortField", newJString(sortField))
  add(query_580618, "alt", newJString(alt))
  add(query_580618, "userIp", newJString(userIp))
  add(query_580618, "definitionsOnly", newJBool(definitionsOnly))
  add(query_580618, "quotaUser", newJString(quotaUser))
  add(query_580618, "campaignId", newJString(campaignId))
  add(query_580618, "searchString", newJString(searchString))
  if eventTagTypes != nil:
    query_580618.add "eventTagTypes", eventTagTypes
  add(query_580618, "sortOrder", newJString(sortOrder))
  add(query_580618, "advertiserId", newJString(advertiserId))
  add(query_580618, "enabled", newJBool(enabled))
  if ids != nil:
    query_580618.add "ids", ids
  add(query_580618, "fields", newJString(fields))
  result = call_580616.call(path_580617, query_580618, nil, nil, nil)

var dfareportingEventTagsList* = Call_DfareportingEventTagsList_580594(
    name: "dfareportingEventTagsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsList_580595,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsList_580596,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsPatch_580653 = ref object of OpenApiRestCall_578364
proc url_DfareportingEventTagsPatch_580655(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsPatch_580654(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing event tag. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580656 = path.getOrDefault("profileId")
  valid_580656 = validateParameter(valid_580656, JString, required = true,
                                 default = nil)
  if valid_580656 != nil:
    section.add "profileId", valid_580656
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Event tag ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580657 = query.getOrDefault("key")
  valid_580657 = validateParameter(valid_580657, JString, required = false,
                                 default = nil)
  if valid_580657 != nil:
    section.add "key", valid_580657
  var valid_580658 = query.getOrDefault("prettyPrint")
  valid_580658 = validateParameter(valid_580658, JBool, required = false,
                                 default = newJBool(true))
  if valid_580658 != nil:
    section.add "prettyPrint", valid_580658
  var valid_580659 = query.getOrDefault("oauth_token")
  valid_580659 = validateParameter(valid_580659, JString, required = false,
                                 default = nil)
  if valid_580659 != nil:
    section.add "oauth_token", valid_580659
  var valid_580660 = query.getOrDefault("alt")
  valid_580660 = validateParameter(valid_580660, JString, required = false,
                                 default = newJString("json"))
  if valid_580660 != nil:
    section.add "alt", valid_580660
  var valid_580661 = query.getOrDefault("userIp")
  valid_580661 = validateParameter(valid_580661, JString, required = false,
                                 default = nil)
  if valid_580661 != nil:
    section.add "userIp", valid_580661
  var valid_580662 = query.getOrDefault("quotaUser")
  valid_580662 = validateParameter(valid_580662, JString, required = false,
                                 default = nil)
  if valid_580662 != nil:
    section.add "quotaUser", valid_580662
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580663 = query.getOrDefault("id")
  valid_580663 = validateParameter(valid_580663, JString, required = true,
                                 default = nil)
  if valid_580663 != nil:
    section.add "id", valid_580663
  var valid_580664 = query.getOrDefault("fields")
  valid_580664 = validateParameter(valid_580664, JString, required = false,
                                 default = nil)
  if valid_580664 != nil:
    section.add "fields", valid_580664
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580666: Call_DfareportingEventTagsPatch_580653; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing event tag. This method supports patch semantics.
  ## 
  let valid = call_580666.validator(path, query, header, formData, body)
  let scheme = call_580666.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580666.url(scheme.get, call_580666.host, call_580666.base,
                         call_580666.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580666, url, valid)

proc call*(call_580667: Call_DfareportingEventTagsPatch_580653; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingEventTagsPatch
  ## Updates an existing event tag. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Event tag ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580668 = newJObject()
  var query_580669 = newJObject()
  var body_580670 = newJObject()
  add(query_580669, "key", newJString(key))
  add(query_580669, "prettyPrint", newJBool(prettyPrint))
  add(query_580669, "oauth_token", newJString(oauthToken))
  add(path_580668, "profileId", newJString(profileId))
  add(query_580669, "alt", newJString(alt))
  add(query_580669, "userIp", newJString(userIp))
  add(query_580669, "quotaUser", newJString(quotaUser))
  add(query_580669, "id", newJString(id))
  if body != nil:
    body_580670 = body
  add(query_580669, "fields", newJString(fields))
  result = call_580667.call(path_580668, query_580669, nil, nil, body_580670)

var dfareportingEventTagsPatch* = Call_DfareportingEventTagsPatch_580653(
    name: "dfareportingEventTagsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsPatch_580654,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsPatch_580655,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsGet_580671 = ref object of OpenApiRestCall_578364
proc url_DfareportingEventTagsGet_580673(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsGet_580672(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one event tag by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Event tag ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580674 = path.getOrDefault("profileId")
  valid_580674 = validateParameter(valid_580674, JString, required = true,
                                 default = nil)
  if valid_580674 != nil:
    section.add "profileId", valid_580674
  var valid_580675 = path.getOrDefault("id")
  valid_580675 = validateParameter(valid_580675, JString, required = true,
                                 default = nil)
  if valid_580675 != nil:
    section.add "id", valid_580675
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580676 = query.getOrDefault("key")
  valid_580676 = validateParameter(valid_580676, JString, required = false,
                                 default = nil)
  if valid_580676 != nil:
    section.add "key", valid_580676
  var valid_580677 = query.getOrDefault("prettyPrint")
  valid_580677 = validateParameter(valid_580677, JBool, required = false,
                                 default = newJBool(true))
  if valid_580677 != nil:
    section.add "prettyPrint", valid_580677
  var valid_580678 = query.getOrDefault("oauth_token")
  valid_580678 = validateParameter(valid_580678, JString, required = false,
                                 default = nil)
  if valid_580678 != nil:
    section.add "oauth_token", valid_580678
  var valid_580679 = query.getOrDefault("alt")
  valid_580679 = validateParameter(valid_580679, JString, required = false,
                                 default = newJString("json"))
  if valid_580679 != nil:
    section.add "alt", valid_580679
  var valid_580680 = query.getOrDefault("userIp")
  valid_580680 = validateParameter(valid_580680, JString, required = false,
                                 default = nil)
  if valid_580680 != nil:
    section.add "userIp", valid_580680
  var valid_580681 = query.getOrDefault("quotaUser")
  valid_580681 = validateParameter(valid_580681, JString, required = false,
                                 default = nil)
  if valid_580681 != nil:
    section.add "quotaUser", valid_580681
  var valid_580682 = query.getOrDefault("fields")
  valid_580682 = validateParameter(valid_580682, JString, required = false,
                                 default = nil)
  if valid_580682 != nil:
    section.add "fields", valid_580682
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580683: Call_DfareportingEventTagsGet_580671; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one event tag by ID.
  ## 
  let valid = call_580683.validator(path, query, header, formData, body)
  let scheme = call_580683.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580683.url(scheme.get, call_580683.host, call_580683.base,
                         call_580683.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580683, url, valid)

proc call*(call_580684: Call_DfareportingEventTagsGet_580671; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingEventTagsGet
  ## Gets one event tag by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Event tag ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580685 = newJObject()
  var query_580686 = newJObject()
  add(query_580686, "key", newJString(key))
  add(query_580686, "prettyPrint", newJBool(prettyPrint))
  add(query_580686, "oauth_token", newJString(oauthToken))
  add(path_580685, "profileId", newJString(profileId))
  add(path_580685, "id", newJString(id))
  add(query_580686, "alt", newJString(alt))
  add(query_580686, "userIp", newJString(userIp))
  add(query_580686, "quotaUser", newJString(quotaUser))
  add(query_580686, "fields", newJString(fields))
  result = call_580684.call(path_580685, query_580686, nil, nil, nil)

var dfareportingEventTagsGet* = Call_DfareportingEventTagsGet_580671(
    name: "dfareportingEventTagsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags/{id}",
    validator: validate_DfareportingEventTagsGet_580672,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsGet_580673,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsDelete_580687 = ref object of OpenApiRestCall_578364
proc url_DfareportingEventTagsDelete_580689(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsDelete_580688(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing event tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Event tag ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580690 = path.getOrDefault("profileId")
  valid_580690 = validateParameter(valid_580690, JString, required = true,
                                 default = nil)
  if valid_580690 != nil:
    section.add "profileId", valid_580690
  var valid_580691 = path.getOrDefault("id")
  valid_580691 = validateParameter(valid_580691, JString, required = true,
                                 default = nil)
  if valid_580691 != nil:
    section.add "id", valid_580691
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580692 = query.getOrDefault("key")
  valid_580692 = validateParameter(valid_580692, JString, required = false,
                                 default = nil)
  if valid_580692 != nil:
    section.add "key", valid_580692
  var valid_580693 = query.getOrDefault("prettyPrint")
  valid_580693 = validateParameter(valid_580693, JBool, required = false,
                                 default = newJBool(true))
  if valid_580693 != nil:
    section.add "prettyPrint", valid_580693
  var valid_580694 = query.getOrDefault("oauth_token")
  valid_580694 = validateParameter(valid_580694, JString, required = false,
                                 default = nil)
  if valid_580694 != nil:
    section.add "oauth_token", valid_580694
  var valid_580695 = query.getOrDefault("alt")
  valid_580695 = validateParameter(valid_580695, JString, required = false,
                                 default = newJString("json"))
  if valid_580695 != nil:
    section.add "alt", valid_580695
  var valid_580696 = query.getOrDefault("userIp")
  valid_580696 = validateParameter(valid_580696, JString, required = false,
                                 default = nil)
  if valid_580696 != nil:
    section.add "userIp", valid_580696
  var valid_580697 = query.getOrDefault("quotaUser")
  valid_580697 = validateParameter(valid_580697, JString, required = false,
                                 default = nil)
  if valid_580697 != nil:
    section.add "quotaUser", valid_580697
  var valid_580698 = query.getOrDefault("fields")
  valid_580698 = validateParameter(valid_580698, JString, required = false,
                                 default = nil)
  if valid_580698 != nil:
    section.add "fields", valid_580698
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580699: Call_DfareportingEventTagsDelete_580687; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing event tag.
  ## 
  let valid = call_580699.validator(path, query, header, formData, body)
  let scheme = call_580699.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580699.url(scheme.get, call_580699.host, call_580699.base,
                         call_580699.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580699, url, valid)

proc call*(call_580700: Call_DfareportingEventTagsDelete_580687; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingEventTagsDelete
  ## Deletes an existing event tag.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Event tag ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580701 = newJObject()
  var query_580702 = newJObject()
  add(query_580702, "key", newJString(key))
  add(query_580702, "prettyPrint", newJBool(prettyPrint))
  add(query_580702, "oauth_token", newJString(oauthToken))
  add(path_580701, "profileId", newJString(profileId))
  add(path_580701, "id", newJString(id))
  add(query_580702, "alt", newJString(alt))
  add(query_580702, "userIp", newJString(userIp))
  add(query_580702, "quotaUser", newJString(quotaUser))
  add(query_580702, "fields", newJString(fields))
  result = call_580700.call(path_580701, query_580702, nil, nil, nil)

var dfareportingEventTagsDelete* = Call_DfareportingEventTagsDelete_580687(
    name: "dfareportingEventTagsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags/{id}",
    validator: validate_DfareportingEventTagsDelete_580688,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsDelete_580689,
    schemes: {Scheme.Https})
type
  Call_DfareportingFilesList_580703 = ref object of OpenApiRestCall_578364
proc url_DfareportingFilesList_580705(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFilesList_580704(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists files for a user profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580706 = path.getOrDefault("profileId")
  valid_580706 = validateParameter(valid_580706, JString, required = true,
                                 default = nil)
  if valid_580706 != nil:
    section.add "profileId", valid_580706
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   scope: JString
  ##        : The scope that defines which results are returned.
  ##   sortField: JString
  ##            : The field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_580707 = query.getOrDefault("key")
  valid_580707 = validateParameter(valid_580707, JString, required = false,
                                 default = nil)
  if valid_580707 != nil:
    section.add "key", valid_580707
  var valid_580708 = query.getOrDefault("prettyPrint")
  valid_580708 = validateParameter(valid_580708, JBool, required = false,
                                 default = newJBool(true))
  if valid_580708 != nil:
    section.add "prettyPrint", valid_580708
  var valid_580709 = query.getOrDefault("oauth_token")
  valid_580709 = validateParameter(valid_580709, JString, required = false,
                                 default = nil)
  if valid_580709 != nil:
    section.add "oauth_token", valid_580709
  var valid_580710 = query.getOrDefault("scope")
  valid_580710 = validateParameter(valid_580710, JString, required = false,
                                 default = newJString("MINE"))
  if valid_580710 != nil:
    section.add "scope", valid_580710
  var valid_580711 = query.getOrDefault("sortField")
  valid_580711 = validateParameter(valid_580711, JString, required = false,
                                 default = newJString("LAST_MODIFIED_TIME"))
  if valid_580711 != nil:
    section.add "sortField", valid_580711
  var valid_580712 = query.getOrDefault("alt")
  valid_580712 = validateParameter(valid_580712, JString, required = false,
                                 default = newJString("json"))
  if valid_580712 != nil:
    section.add "alt", valid_580712
  var valid_580713 = query.getOrDefault("userIp")
  valid_580713 = validateParameter(valid_580713, JString, required = false,
                                 default = nil)
  if valid_580713 != nil:
    section.add "userIp", valid_580713
  var valid_580714 = query.getOrDefault("quotaUser")
  valid_580714 = validateParameter(valid_580714, JString, required = false,
                                 default = nil)
  if valid_580714 != nil:
    section.add "quotaUser", valid_580714
  var valid_580715 = query.getOrDefault("pageToken")
  valid_580715 = validateParameter(valid_580715, JString, required = false,
                                 default = nil)
  if valid_580715 != nil:
    section.add "pageToken", valid_580715
  var valid_580716 = query.getOrDefault("sortOrder")
  valid_580716 = validateParameter(valid_580716, JString, required = false,
                                 default = newJString("DESCENDING"))
  if valid_580716 != nil:
    section.add "sortOrder", valid_580716
  var valid_580717 = query.getOrDefault("fields")
  valid_580717 = validateParameter(valid_580717, JString, required = false,
                                 default = nil)
  if valid_580717 != nil:
    section.add "fields", valid_580717
  var valid_580718 = query.getOrDefault("maxResults")
  valid_580718 = validateParameter(valid_580718, JInt, required = false,
                                 default = newJInt(10))
  if valid_580718 != nil:
    section.add "maxResults", valid_580718
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580719: Call_DfareportingFilesList_580703; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists files for a user profile.
  ## 
  let valid = call_580719.validator(path, query, header, formData, body)
  let scheme = call_580719.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580719.url(scheme.get, call_580719.host, call_580719.base,
                         call_580719.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580719, url, valid)

proc call*(call_580720: Call_DfareportingFilesList_580703; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          scope: string = "MINE"; sortField: string = "LAST_MODIFIED_TIME";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          pageToken: string = ""; sortOrder: string = "DESCENDING"; fields: string = "";
          maxResults: int = 10): Recallable =
  ## dfareportingFilesList
  ## Lists files for a user profile.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   scope: string
  ##        : The scope that defines which results are returned.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   sortField: string
  ##            : The field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_580721 = newJObject()
  var query_580722 = newJObject()
  add(query_580722, "key", newJString(key))
  add(query_580722, "prettyPrint", newJBool(prettyPrint))
  add(query_580722, "oauth_token", newJString(oauthToken))
  add(query_580722, "scope", newJString(scope))
  add(path_580721, "profileId", newJString(profileId))
  add(query_580722, "sortField", newJString(sortField))
  add(query_580722, "alt", newJString(alt))
  add(query_580722, "userIp", newJString(userIp))
  add(query_580722, "quotaUser", newJString(quotaUser))
  add(query_580722, "pageToken", newJString(pageToken))
  add(query_580722, "sortOrder", newJString(sortOrder))
  add(query_580722, "fields", newJString(fields))
  add(query_580722, "maxResults", newJInt(maxResults))
  result = call_580720.call(path_580721, query_580722, nil, nil, nil)

var dfareportingFilesList* = Call_DfareportingFilesList_580703(
    name: "dfareportingFilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/files",
    validator: validate_DfareportingFilesList_580704, base: "/dfareporting/v2.7",
    url: url_DfareportingFilesList_580705, schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesUpdate_580751 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightActivitiesUpdate_580753(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesUpdate_580752(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580754 = path.getOrDefault("profileId")
  valid_580754 = validateParameter(valid_580754, JString, required = true,
                                 default = nil)
  if valid_580754 != nil:
    section.add "profileId", valid_580754
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580755 = query.getOrDefault("key")
  valid_580755 = validateParameter(valid_580755, JString, required = false,
                                 default = nil)
  if valid_580755 != nil:
    section.add "key", valid_580755
  var valid_580756 = query.getOrDefault("prettyPrint")
  valid_580756 = validateParameter(valid_580756, JBool, required = false,
                                 default = newJBool(true))
  if valid_580756 != nil:
    section.add "prettyPrint", valid_580756
  var valid_580757 = query.getOrDefault("oauth_token")
  valid_580757 = validateParameter(valid_580757, JString, required = false,
                                 default = nil)
  if valid_580757 != nil:
    section.add "oauth_token", valid_580757
  var valid_580758 = query.getOrDefault("alt")
  valid_580758 = validateParameter(valid_580758, JString, required = false,
                                 default = newJString("json"))
  if valid_580758 != nil:
    section.add "alt", valid_580758
  var valid_580759 = query.getOrDefault("userIp")
  valid_580759 = validateParameter(valid_580759, JString, required = false,
                                 default = nil)
  if valid_580759 != nil:
    section.add "userIp", valid_580759
  var valid_580760 = query.getOrDefault("quotaUser")
  valid_580760 = validateParameter(valid_580760, JString, required = false,
                                 default = nil)
  if valid_580760 != nil:
    section.add "quotaUser", valid_580760
  var valid_580761 = query.getOrDefault("fields")
  valid_580761 = validateParameter(valid_580761, JString, required = false,
                                 default = nil)
  if valid_580761 != nil:
    section.add "fields", valid_580761
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580763: Call_DfareportingFloodlightActivitiesUpdate_580751;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity.
  ## 
  let valid = call_580763.validator(path, query, header, formData, body)
  let scheme = call_580763.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580763.url(scheme.get, call_580763.host, call_580763.base,
                         call_580763.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580763, url, valid)

proc call*(call_580764: Call_DfareportingFloodlightActivitiesUpdate_580751;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingFloodlightActivitiesUpdate
  ## Updates an existing floodlight activity.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580765 = newJObject()
  var query_580766 = newJObject()
  var body_580767 = newJObject()
  add(query_580766, "key", newJString(key))
  add(query_580766, "prettyPrint", newJBool(prettyPrint))
  add(query_580766, "oauth_token", newJString(oauthToken))
  add(path_580765, "profileId", newJString(profileId))
  add(query_580766, "alt", newJString(alt))
  add(query_580766, "userIp", newJString(userIp))
  add(query_580766, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580767 = body
  add(query_580766, "fields", newJString(fields))
  result = call_580764.call(path_580765, query_580766, nil, nil, body_580767)

var dfareportingFloodlightActivitiesUpdate* = Call_DfareportingFloodlightActivitiesUpdate_580751(
    name: "dfareportingFloodlightActivitiesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesUpdate_580752,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesUpdate_580753,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesInsert_580768 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightActivitiesInsert_580770(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesInsert_580769(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580771 = path.getOrDefault("profileId")
  valid_580771 = validateParameter(valid_580771, JString, required = true,
                                 default = nil)
  if valid_580771 != nil:
    section.add "profileId", valid_580771
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580772 = query.getOrDefault("key")
  valid_580772 = validateParameter(valid_580772, JString, required = false,
                                 default = nil)
  if valid_580772 != nil:
    section.add "key", valid_580772
  var valid_580773 = query.getOrDefault("prettyPrint")
  valid_580773 = validateParameter(valid_580773, JBool, required = false,
                                 default = newJBool(true))
  if valid_580773 != nil:
    section.add "prettyPrint", valid_580773
  var valid_580774 = query.getOrDefault("oauth_token")
  valid_580774 = validateParameter(valid_580774, JString, required = false,
                                 default = nil)
  if valid_580774 != nil:
    section.add "oauth_token", valid_580774
  var valid_580775 = query.getOrDefault("alt")
  valid_580775 = validateParameter(valid_580775, JString, required = false,
                                 default = newJString("json"))
  if valid_580775 != nil:
    section.add "alt", valid_580775
  var valid_580776 = query.getOrDefault("userIp")
  valid_580776 = validateParameter(valid_580776, JString, required = false,
                                 default = nil)
  if valid_580776 != nil:
    section.add "userIp", valid_580776
  var valid_580777 = query.getOrDefault("quotaUser")
  valid_580777 = validateParameter(valid_580777, JString, required = false,
                                 default = nil)
  if valid_580777 != nil:
    section.add "quotaUser", valid_580777
  var valid_580778 = query.getOrDefault("fields")
  valid_580778 = validateParameter(valid_580778, JString, required = false,
                                 default = nil)
  if valid_580778 != nil:
    section.add "fields", valid_580778
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580780: Call_DfareportingFloodlightActivitiesInsert_580768;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new floodlight activity.
  ## 
  let valid = call_580780.validator(path, query, header, formData, body)
  let scheme = call_580780.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580780.url(scheme.get, call_580780.host, call_580780.base,
                         call_580780.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580780, url, valid)

proc call*(call_580781: Call_DfareportingFloodlightActivitiesInsert_580768;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingFloodlightActivitiesInsert
  ## Inserts a new floodlight activity.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580782 = newJObject()
  var query_580783 = newJObject()
  var body_580784 = newJObject()
  add(query_580783, "key", newJString(key))
  add(query_580783, "prettyPrint", newJBool(prettyPrint))
  add(query_580783, "oauth_token", newJString(oauthToken))
  add(path_580782, "profileId", newJString(profileId))
  add(query_580783, "alt", newJString(alt))
  add(query_580783, "userIp", newJString(userIp))
  add(query_580783, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580784 = body
  add(query_580783, "fields", newJString(fields))
  result = call_580781.call(path_580782, query_580783, nil, nil, body_580784)

var dfareportingFloodlightActivitiesInsert* = Call_DfareportingFloodlightActivitiesInsert_580768(
    name: "dfareportingFloodlightActivitiesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesInsert_580769,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesInsert_580770,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesList_580723 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightActivitiesList_580725(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesList_580724(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of floodlight activities, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580726 = path.getOrDefault("profileId")
  valid_580726 = validateParameter(valid_580726, JString, required = true,
                                 default = nil)
  if valid_580726 != nil:
    section.add "profileId", valid_580726
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   floodlightActivityGroupName: JString
  ##                              : Select only floodlight activities with the specified floodlight activity group name.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   floodlightActivityGroupType: JString
  ##                              : Select only floodlight activities with the specified floodlight activity group type.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   floodlightActivityGroupIds: JArray
  ##                             : Select only floodlight activities with the specified floodlight activity group IDs.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivity*2015" will return objects with names like "floodlightactivity June 2015", "floodlightactivity April 2015", or simply "floodlightactivity 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivity" will match objects with name "my floodlightactivity activity", "floodlightactivity 2015", or simply "floodlightactivity".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   floodlightConfigurationId: JString
  ##                            : Select only floodlight activities for the specified floodlight configuration ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   advertiserId: JString
  ##               : Select only floodlight activities for the specified advertiser ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   tagString: JString
  ##            : Select only floodlight activities with the specified tag string.
  ##   floodlightActivityGroupTagString: JString
  ##                                   : Select only floodlight activities with the specified floodlight activity group tag string.
  ##   ids: JArray
  ##      : Select only floodlight activities with the specified IDs. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_580727 = query.getOrDefault("key")
  valid_580727 = validateParameter(valid_580727, JString, required = false,
                                 default = nil)
  if valid_580727 != nil:
    section.add "key", valid_580727
  var valid_580728 = query.getOrDefault("prettyPrint")
  valid_580728 = validateParameter(valid_580728, JBool, required = false,
                                 default = newJBool(true))
  if valid_580728 != nil:
    section.add "prettyPrint", valid_580728
  var valid_580729 = query.getOrDefault("oauth_token")
  valid_580729 = validateParameter(valid_580729, JString, required = false,
                                 default = nil)
  if valid_580729 != nil:
    section.add "oauth_token", valid_580729
  var valid_580730 = query.getOrDefault("floodlightActivityGroupName")
  valid_580730 = validateParameter(valid_580730, JString, required = false,
                                 default = nil)
  if valid_580730 != nil:
    section.add "floodlightActivityGroupName", valid_580730
  var valid_580731 = query.getOrDefault("sortField")
  valid_580731 = validateParameter(valid_580731, JString, required = false,
                                 default = newJString("ID"))
  if valid_580731 != nil:
    section.add "sortField", valid_580731
  var valid_580732 = query.getOrDefault("floodlightActivityGroupType")
  valid_580732 = validateParameter(valid_580732, JString, required = false,
                                 default = newJString("COUNTER"))
  if valid_580732 != nil:
    section.add "floodlightActivityGroupType", valid_580732
  var valid_580733 = query.getOrDefault("alt")
  valid_580733 = validateParameter(valid_580733, JString, required = false,
                                 default = newJString("json"))
  if valid_580733 != nil:
    section.add "alt", valid_580733
  var valid_580734 = query.getOrDefault("userIp")
  valid_580734 = validateParameter(valid_580734, JString, required = false,
                                 default = nil)
  if valid_580734 != nil:
    section.add "userIp", valid_580734
  var valid_580735 = query.getOrDefault("quotaUser")
  valid_580735 = validateParameter(valid_580735, JString, required = false,
                                 default = nil)
  if valid_580735 != nil:
    section.add "quotaUser", valid_580735
  var valid_580736 = query.getOrDefault("floodlightActivityGroupIds")
  valid_580736 = validateParameter(valid_580736, JArray, required = false,
                                 default = nil)
  if valid_580736 != nil:
    section.add "floodlightActivityGroupIds", valid_580736
  var valid_580737 = query.getOrDefault("pageToken")
  valid_580737 = validateParameter(valid_580737, JString, required = false,
                                 default = nil)
  if valid_580737 != nil:
    section.add "pageToken", valid_580737
  var valid_580738 = query.getOrDefault("searchString")
  valid_580738 = validateParameter(valid_580738, JString, required = false,
                                 default = nil)
  if valid_580738 != nil:
    section.add "searchString", valid_580738
  var valid_580739 = query.getOrDefault("sortOrder")
  valid_580739 = validateParameter(valid_580739, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580739 != nil:
    section.add "sortOrder", valid_580739
  var valid_580740 = query.getOrDefault("floodlightConfigurationId")
  valid_580740 = validateParameter(valid_580740, JString, required = false,
                                 default = nil)
  if valid_580740 != nil:
    section.add "floodlightConfigurationId", valid_580740
  var valid_580741 = query.getOrDefault("advertiserId")
  valid_580741 = validateParameter(valid_580741, JString, required = false,
                                 default = nil)
  if valid_580741 != nil:
    section.add "advertiserId", valid_580741
  var valid_580742 = query.getOrDefault("tagString")
  valid_580742 = validateParameter(valid_580742, JString, required = false,
                                 default = nil)
  if valid_580742 != nil:
    section.add "tagString", valid_580742
  var valid_580743 = query.getOrDefault("floodlightActivityGroupTagString")
  valid_580743 = validateParameter(valid_580743, JString, required = false,
                                 default = nil)
  if valid_580743 != nil:
    section.add "floodlightActivityGroupTagString", valid_580743
  var valid_580744 = query.getOrDefault("ids")
  valid_580744 = validateParameter(valid_580744, JArray, required = false,
                                 default = nil)
  if valid_580744 != nil:
    section.add "ids", valid_580744
  var valid_580745 = query.getOrDefault("fields")
  valid_580745 = validateParameter(valid_580745, JString, required = false,
                                 default = nil)
  if valid_580745 != nil:
    section.add "fields", valid_580745
  var valid_580746 = query.getOrDefault("maxResults")
  valid_580746 = validateParameter(valid_580746, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580746 != nil:
    section.add "maxResults", valid_580746
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580747: Call_DfareportingFloodlightActivitiesList_580723;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of floodlight activities, possibly filtered. This method supports paging.
  ## 
  let valid = call_580747.validator(path, query, header, formData, body)
  let scheme = call_580747.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580747.url(scheme.get, call_580747.host, call_580747.base,
                         call_580747.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580747, url, valid)

proc call*(call_580748: Call_DfareportingFloodlightActivitiesList_580723;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; floodlightActivityGroupName: string = "";
          sortField: string = "ID"; floodlightActivityGroupType: string = "COUNTER";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          floodlightActivityGroupIds: JsonNode = nil; pageToken: string = "";
          searchString: string = ""; sortOrder: string = "ASCENDING";
          floodlightConfigurationId: string = ""; advertiserId: string = "";
          tagString: string = ""; floodlightActivityGroupTagString: string = "";
          ids: JsonNode = nil; fields: string = ""; maxResults: int = 1000): Recallable =
  ## dfareportingFloodlightActivitiesList
  ## Retrieves a list of floodlight activities, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   floodlightActivityGroupName: string
  ##                              : Select only floodlight activities with the specified floodlight activity group name.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   floodlightActivityGroupType: string
  ##                              : Select only floodlight activities with the specified floodlight activity group type.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   floodlightActivityGroupIds: JArray
  ##                             : Select only floodlight activities with the specified floodlight activity group IDs.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivity*2015" will return objects with names like "floodlightactivity June 2015", "floodlightactivity April 2015", or simply "floodlightactivity 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivity" will match objects with name "my floodlightactivity activity", "floodlightactivity 2015", or simply "floodlightactivity".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   floodlightConfigurationId: string
  ##                            : Select only floodlight activities for the specified floodlight configuration ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   advertiserId: string
  ##               : Select only floodlight activities for the specified advertiser ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   tagString: string
  ##            : Select only floodlight activities with the specified tag string.
  ##   floodlightActivityGroupTagString: string
  ##                                   : Select only floodlight activities with the specified floodlight activity group tag string.
  ##   ids: JArray
  ##      : Select only floodlight activities with the specified IDs. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_580749 = newJObject()
  var query_580750 = newJObject()
  add(query_580750, "key", newJString(key))
  add(query_580750, "prettyPrint", newJBool(prettyPrint))
  add(query_580750, "oauth_token", newJString(oauthToken))
  add(query_580750, "floodlightActivityGroupName",
      newJString(floodlightActivityGroupName))
  add(path_580749, "profileId", newJString(profileId))
  add(query_580750, "sortField", newJString(sortField))
  add(query_580750, "floodlightActivityGroupType",
      newJString(floodlightActivityGroupType))
  add(query_580750, "alt", newJString(alt))
  add(query_580750, "userIp", newJString(userIp))
  add(query_580750, "quotaUser", newJString(quotaUser))
  if floodlightActivityGroupIds != nil:
    query_580750.add "floodlightActivityGroupIds", floodlightActivityGroupIds
  add(query_580750, "pageToken", newJString(pageToken))
  add(query_580750, "searchString", newJString(searchString))
  add(query_580750, "sortOrder", newJString(sortOrder))
  add(query_580750, "floodlightConfigurationId",
      newJString(floodlightConfigurationId))
  add(query_580750, "advertiserId", newJString(advertiserId))
  add(query_580750, "tagString", newJString(tagString))
  add(query_580750, "floodlightActivityGroupTagString",
      newJString(floodlightActivityGroupTagString))
  if ids != nil:
    query_580750.add "ids", ids
  add(query_580750, "fields", newJString(fields))
  add(query_580750, "maxResults", newJInt(maxResults))
  result = call_580748.call(path_580749, query_580750, nil, nil, nil)

var dfareportingFloodlightActivitiesList* = Call_DfareportingFloodlightActivitiesList_580723(
    name: "dfareportingFloodlightActivitiesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesList_580724,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesList_580725,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesPatch_580785 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightActivitiesPatch_580787(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesPatch_580786(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580788 = path.getOrDefault("profileId")
  valid_580788 = validateParameter(valid_580788, JString, required = true,
                                 default = nil)
  if valid_580788 != nil:
    section.add "profileId", valid_580788
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Floodlight activity ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580789 = query.getOrDefault("key")
  valid_580789 = validateParameter(valid_580789, JString, required = false,
                                 default = nil)
  if valid_580789 != nil:
    section.add "key", valid_580789
  var valid_580790 = query.getOrDefault("prettyPrint")
  valid_580790 = validateParameter(valid_580790, JBool, required = false,
                                 default = newJBool(true))
  if valid_580790 != nil:
    section.add "prettyPrint", valid_580790
  var valid_580791 = query.getOrDefault("oauth_token")
  valid_580791 = validateParameter(valid_580791, JString, required = false,
                                 default = nil)
  if valid_580791 != nil:
    section.add "oauth_token", valid_580791
  var valid_580792 = query.getOrDefault("alt")
  valid_580792 = validateParameter(valid_580792, JString, required = false,
                                 default = newJString("json"))
  if valid_580792 != nil:
    section.add "alt", valid_580792
  var valid_580793 = query.getOrDefault("userIp")
  valid_580793 = validateParameter(valid_580793, JString, required = false,
                                 default = nil)
  if valid_580793 != nil:
    section.add "userIp", valid_580793
  var valid_580794 = query.getOrDefault("quotaUser")
  valid_580794 = validateParameter(valid_580794, JString, required = false,
                                 default = nil)
  if valid_580794 != nil:
    section.add "quotaUser", valid_580794
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580795 = query.getOrDefault("id")
  valid_580795 = validateParameter(valid_580795, JString, required = true,
                                 default = nil)
  if valid_580795 != nil:
    section.add "id", valid_580795
  var valid_580796 = query.getOrDefault("fields")
  valid_580796 = validateParameter(valid_580796, JString, required = false,
                                 default = nil)
  if valid_580796 != nil:
    section.add "fields", valid_580796
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580798: Call_DfareportingFloodlightActivitiesPatch_580785;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity. This method supports patch semantics.
  ## 
  let valid = call_580798.validator(path, query, header, formData, body)
  let scheme = call_580798.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580798.url(scheme.get, call_580798.host, call_580798.base,
                         call_580798.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580798, url, valid)

proc call*(call_580799: Call_DfareportingFloodlightActivitiesPatch_580785;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingFloodlightActivitiesPatch
  ## Updates an existing floodlight activity. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Floodlight activity ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580800 = newJObject()
  var query_580801 = newJObject()
  var body_580802 = newJObject()
  add(query_580801, "key", newJString(key))
  add(query_580801, "prettyPrint", newJBool(prettyPrint))
  add(query_580801, "oauth_token", newJString(oauthToken))
  add(path_580800, "profileId", newJString(profileId))
  add(query_580801, "alt", newJString(alt))
  add(query_580801, "userIp", newJString(userIp))
  add(query_580801, "quotaUser", newJString(quotaUser))
  add(query_580801, "id", newJString(id))
  if body != nil:
    body_580802 = body
  add(query_580801, "fields", newJString(fields))
  result = call_580799.call(path_580800, query_580801, nil, nil, body_580802)

var dfareportingFloodlightActivitiesPatch* = Call_DfareportingFloodlightActivitiesPatch_580785(
    name: "dfareportingFloodlightActivitiesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesPatch_580786,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesPatch_580787,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesGeneratetag_580803 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightActivitiesGeneratetag_580805(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"), (kind: ConstantSegment,
        value: "/floodlightActivities/generatetag")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesGeneratetag_580804(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Generates a tag for a floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580806 = path.getOrDefault("profileId")
  valid_580806 = validateParameter(valid_580806, JString, required = true,
                                 default = nil)
  if valid_580806 != nil:
    section.add "profileId", valid_580806
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   floodlightActivityId: JString
  ##                       : Floodlight activity ID for which we want to generate a tag.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580807 = query.getOrDefault("key")
  valid_580807 = validateParameter(valid_580807, JString, required = false,
                                 default = nil)
  if valid_580807 != nil:
    section.add "key", valid_580807
  var valid_580808 = query.getOrDefault("prettyPrint")
  valid_580808 = validateParameter(valid_580808, JBool, required = false,
                                 default = newJBool(true))
  if valid_580808 != nil:
    section.add "prettyPrint", valid_580808
  var valid_580809 = query.getOrDefault("oauth_token")
  valid_580809 = validateParameter(valid_580809, JString, required = false,
                                 default = nil)
  if valid_580809 != nil:
    section.add "oauth_token", valid_580809
  var valid_580810 = query.getOrDefault("floodlightActivityId")
  valid_580810 = validateParameter(valid_580810, JString, required = false,
                                 default = nil)
  if valid_580810 != nil:
    section.add "floodlightActivityId", valid_580810
  var valid_580811 = query.getOrDefault("alt")
  valid_580811 = validateParameter(valid_580811, JString, required = false,
                                 default = newJString("json"))
  if valid_580811 != nil:
    section.add "alt", valid_580811
  var valid_580812 = query.getOrDefault("userIp")
  valid_580812 = validateParameter(valid_580812, JString, required = false,
                                 default = nil)
  if valid_580812 != nil:
    section.add "userIp", valid_580812
  var valid_580813 = query.getOrDefault("quotaUser")
  valid_580813 = validateParameter(valid_580813, JString, required = false,
                                 default = nil)
  if valid_580813 != nil:
    section.add "quotaUser", valid_580813
  var valid_580814 = query.getOrDefault("fields")
  valid_580814 = validateParameter(valid_580814, JString, required = false,
                                 default = nil)
  if valid_580814 != nil:
    section.add "fields", valid_580814
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580815: Call_DfareportingFloodlightActivitiesGeneratetag_580803;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Generates a tag for a floodlight activity.
  ## 
  let valid = call_580815.validator(path, query, header, formData, body)
  let scheme = call_580815.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580815.url(scheme.get, call_580815.host, call_580815.base,
                         call_580815.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580815, url, valid)

proc call*(call_580816: Call_DfareportingFloodlightActivitiesGeneratetag_580803;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; floodlightActivityId: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingFloodlightActivitiesGeneratetag
  ## Generates a tag for a floodlight activity.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   floodlightActivityId: string
  ##                       : Floodlight activity ID for which we want to generate a tag.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580817 = newJObject()
  var query_580818 = newJObject()
  add(query_580818, "key", newJString(key))
  add(query_580818, "prettyPrint", newJBool(prettyPrint))
  add(query_580818, "oauth_token", newJString(oauthToken))
  add(query_580818, "floodlightActivityId", newJString(floodlightActivityId))
  add(path_580817, "profileId", newJString(profileId))
  add(query_580818, "alt", newJString(alt))
  add(query_580818, "userIp", newJString(userIp))
  add(query_580818, "quotaUser", newJString(quotaUser))
  add(query_580818, "fields", newJString(fields))
  result = call_580816.call(path_580817, query_580818, nil, nil, nil)

var dfareportingFloodlightActivitiesGeneratetag* = Call_DfareportingFloodlightActivitiesGeneratetag_580803(
    name: "dfareportingFloodlightActivitiesGeneratetag",
    meth: HttpMethod.HttpPost, host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities/generatetag",
    validator: validate_DfareportingFloodlightActivitiesGeneratetag_580804,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivitiesGeneratetag_580805,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesGet_580819 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightActivitiesGet_580821(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesGet_580820(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one floodlight activity by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight activity ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580822 = path.getOrDefault("profileId")
  valid_580822 = validateParameter(valid_580822, JString, required = true,
                                 default = nil)
  if valid_580822 != nil:
    section.add "profileId", valid_580822
  var valid_580823 = path.getOrDefault("id")
  valid_580823 = validateParameter(valid_580823, JString, required = true,
                                 default = nil)
  if valid_580823 != nil:
    section.add "id", valid_580823
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580824 = query.getOrDefault("key")
  valid_580824 = validateParameter(valid_580824, JString, required = false,
                                 default = nil)
  if valid_580824 != nil:
    section.add "key", valid_580824
  var valid_580825 = query.getOrDefault("prettyPrint")
  valid_580825 = validateParameter(valid_580825, JBool, required = false,
                                 default = newJBool(true))
  if valid_580825 != nil:
    section.add "prettyPrint", valid_580825
  var valid_580826 = query.getOrDefault("oauth_token")
  valid_580826 = validateParameter(valid_580826, JString, required = false,
                                 default = nil)
  if valid_580826 != nil:
    section.add "oauth_token", valid_580826
  var valid_580827 = query.getOrDefault("alt")
  valid_580827 = validateParameter(valid_580827, JString, required = false,
                                 default = newJString("json"))
  if valid_580827 != nil:
    section.add "alt", valid_580827
  var valid_580828 = query.getOrDefault("userIp")
  valid_580828 = validateParameter(valid_580828, JString, required = false,
                                 default = nil)
  if valid_580828 != nil:
    section.add "userIp", valid_580828
  var valid_580829 = query.getOrDefault("quotaUser")
  valid_580829 = validateParameter(valid_580829, JString, required = false,
                                 default = nil)
  if valid_580829 != nil:
    section.add "quotaUser", valid_580829
  var valid_580830 = query.getOrDefault("fields")
  valid_580830 = validateParameter(valid_580830, JString, required = false,
                                 default = nil)
  if valid_580830 != nil:
    section.add "fields", valid_580830
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580831: Call_DfareportingFloodlightActivitiesGet_580819;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one floodlight activity by ID.
  ## 
  let valid = call_580831.validator(path, query, header, formData, body)
  let scheme = call_580831.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580831.url(scheme.get, call_580831.host, call_580831.base,
                         call_580831.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580831, url, valid)

proc call*(call_580832: Call_DfareportingFloodlightActivitiesGet_580819;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingFloodlightActivitiesGet
  ## Gets one floodlight activity by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Floodlight activity ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580833 = newJObject()
  var query_580834 = newJObject()
  add(query_580834, "key", newJString(key))
  add(query_580834, "prettyPrint", newJBool(prettyPrint))
  add(query_580834, "oauth_token", newJString(oauthToken))
  add(path_580833, "profileId", newJString(profileId))
  add(path_580833, "id", newJString(id))
  add(query_580834, "alt", newJString(alt))
  add(query_580834, "userIp", newJString(userIp))
  add(query_580834, "quotaUser", newJString(quotaUser))
  add(query_580834, "fields", newJString(fields))
  result = call_580832.call(path_580833, query_580834, nil, nil, nil)

var dfareportingFloodlightActivitiesGet* = Call_DfareportingFloodlightActivitiesGet_580819(
    name: "dfareportingFloodlightActivitiesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities/{id}",
    validator: validate_DfareportingFloodlightActivitiesGet_580820,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesGet_580821,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesDelete_580835 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightActivitiesDelete_580837(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesDelete_580836(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight activity ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580838 = path.getOrDefault("profileId")
  valid_580838 = validateParameter(valid_580838, JString, required = true,
                                 default = nil)
  if valid_580838 != nil:
    section.add "profileId", valid_580838
  var valid_580839 = path.getOrDefault("id")
  valid_580839 = validateParameter(valid_580839, JString, required = true,
                                 default = nil)
  if valid_580839 != nil:
    section.add "id", valid_580839
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580840 = query.getOrDefault("key")
  valid_580840 = validateParameter(valid_580840, JString, required = false,
                                 default = nil)
  if valid_580840 != nil:
    section.add "key", valid_580840
  var valid_580841 = query.getOrDefault("prettyPrint")
  valid_580841 = validateParameter(valid_580841, JBool, required = false,
                                 default = newJBool(true))
  if valid_580841 != nil:
    section.add "prettyPrint", valid_580841
  var valid_580842 = query.getOrDefault("oauth_token")
  valid_580842 = validateParameter(valid_580842, JString, required = false,
                                 default = nil)
  if valid_580842 != nil:
    section.add "oauth_token", valid_580842
  var valid_580843 = query.getOrDefault("alt")
  valid_580843 = validateParameter(valid_580843, JString, required = false,
                                 default = newJString("json"))
  if valid_580843 != nil:
    section.add "alt", valid_580843
  var valid_580844 = query.getOrDefault("userIp")
  valid_580844 = validateParameter(valid_580844, JString, required = false,
                                 default = nil)
  if valid_580844 != nil:
    section.add "userIp", valid_580844
  var valid_580845 = query.getOrDefault("quotaUser")
  valid_580845 = validateParameter(valid_580845, JString, required = false,
                                 default = nil)
  if valid_580845 != nil:
    section.add "quotaUser", valid_580845
  var valid_580846 = query.getOrDefault("fields")
  valid_580846 = validateParameter(valid_580846, JString, required = false,
                                 default = nil)
  if valid_580846 != nil:
    section.add "fields", valid_580846
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580847: Call_DfareportingFloodlightActivitiesDelete_580835;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing floodlight activity.
  ## 
  let valid = call_580847.validator(path, query, header, formData, body)
  let scheme = call_580847.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580847.url(scheme.get, call_580847.host, call_580847.base,
                         call_580847.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580847, url, valid)

proc call*(call_580848: Call_DfareportingFloodlightActivitiesDelete_580835;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingFloodlightActivitiesDelete
  ## Deletes an existing floodlight activity.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Floodlight activity ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580849 = newJObject()
  var query_580850 = newJObject()
  add(query_580850, "key", newJString(key))
  add(query_580850, "prettyPrint", newJBool(prettyPrint))
  add(query_580850, "oauth_token", newJString(oauthToken))
  add(path_580849, "profileId", newJString(profileId))
  add(path_580849, "id", newJString(id))
  add(query_580850, "alt", newJString(alt))
  add(query_580850, "userIp", newJString(userIp))
  add(query_580850, "quotaUser", newJString(quotaUser))
  add(query_580850, "fields", newJString(fields))
  result = call_580848.call(path_580849, query_580850, nil, nil, nil)

var dfareportingFloodlightActivitiesDelete* = Call_DfareportingFloodlightActivitiesDelete_580835(
    name: "dfareportingFloodlightActivitiesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities/{id}",
    validator: validate_DfareportingFloodlightActivitiesDelete_580836,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesDelete_580837,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsUpdate_580875 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightActivityGroupsUpdate_580877(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsUpdate_580876(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580878 = path.getOrDefault("profileId")
  valid_580878 = validateParameter(valid_580878, JString, required = true,
                                 default = nil)
  if valid_580878 != nil:
    section.add "profileId", valid_580878
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580879 = query.getOrDefault("key")
  valid_580879 = validateParameter(valid_580879, JString, required = false,
                                 default = nil)
  if valid_580879 != nil:
    section.add "key", valid_580879
  var valid_580880 = query.getOrDefault("prettyPrint")
  valid_580880 = validateParameter(valid_580880, JBool, required = false,
                                 default = newJBool(true))
  if valid_580880 != nil:
    section.add "prettyPrint", valid_580880
  var valid_580881 = query.getOrDefault("oauth_token")
  valid_580881 = validateParameter(valid_580881, JString, required = false,
                                 default = nil)
  if valid_580881 != nil:
    section.add "oauth_token", valid_580881
  var valid_580882 = query.getOrDefault("alt")
  valid_580882 = validateParameter(valid_580882, JString, required = false,
                                 default = newJString("json"))
  if valid_580882 != nil:
    section.add "alt", valid_580882
  var valid_580883 = query.getOrDefault("userIp")
  valid_580883 = validateParameter(valid_580883, JString, required = false,
                                 default = nil)
  if valid_580883 != nil:
    section.add "userIp", valid_580883
  var valid_580884 = query.getOrDefault("quotaUser")
  valid_580884 = validateParameter(valid_580884, JString, required = false,
                                 default = nil)
  if valid_580884 != nil:
    section.add "quotaUser", valid_580884
  var valid_580885 = query.getOrDefault("fields")
  valid_580885 = validateParameter(valid_580885, JString, required = false,
                                 default = nil)
  if valid_580885 != nil:
    section.add "fields", valid_580885
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580887: Call_DfareportingFloodlightActivityGroupsUpdate_580875;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity group.
  ## 
  let valid = call_580887.validator(path, query, header, formData, body)
  let scheme = call_580887.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580887.url(scheme.get, call_580887.host, call_580887.base,
                         call_580887.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580887, url, valid)

proc call*(call_580888: Call_DfareportingFloodlightActivityGroupsUpdate_580875;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingFloodlightActivityGroupsUpdate
  ## Updates an existing floodlight activity group.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580889 = newJObject()
  var query_580890 = newJObject()
  var body_580891 = newJObject()
  add(query_580890, "key", newJString(key))
  add(query_580890, "prettyPrint", newJBool(prettyPrint))
  add(query_580890, "oauth_token", newJString(oauthToken))
  add(path_580889, "profileId", newJString(profileId))
  add(query_580890, "alt", newJString(alt))
  add(query_580890, "userIp", newJString(userIp))
  add(query_580890, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580891 = body
  add(query_580890, "fields", newJString(fields))
  result = call_580888.call(path_580889, query_580890, nil, nil, body_580891)

var dfareportingFloodlightActivityGroupsUpdate* = Call_DfareportingFloodlightActivityGroupsUpdate_580875(
    name: "dfareportingFloodlightActivityGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsUpdate_580876,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivityGroupsUpdate_580877,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsInsert_580892 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightActivityGroupsInsert_580894(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsInsert_580893(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new floodlight activity group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580895 = path.getOrDefault("profileId")
  valid_580895 = validateParameter(valid_580895, JString, required = true,
                                 default = nil)
  if valid_580895 != nil:
    section.add "profileId", valid_580895
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580896 = query.getOrDefault("key")
  valid_580896 = validateParameter(valid_580896, JString, required = false,
                                 default = nil)
  if valid_580896 != nil:
    section.add "key", valid_580896
  var valid_580897 = query.getOrDefault("prettyPrint")
  valid_580897 = validateParameter(valid_580897, JBool, required = false,
                                 default = newJBool(true))
  if valid_580897 != nil:
    section.add "prettyPrint", valid_580897
  var valid_580898 = query.getOrDefault("oauth_token")
  valid_580898 = validateParameter(valid_580898, JString, required = false,
                                 default = nil)
  if valid_580898 != nil:
    section.add "oauth_token", valid_580898
  var valid_580899 = query.getOrDefault("alt")
  valid_580899 = validateParameter(valid_580899, JString, required = false,
                                 default = newJString("json"))
  if valid_580899 != nil:
    section.add "alt", valid_580899
  var valid_580900 = query.getOrDefault("userIp")
  valid_580900 = validateParameter(valid_580900, JString, required = false,
                                 default = nil)
  if valid_580900 != nil:
    section.add "userIp", valid_580900
  var valid_580901 = query.getOrDefault("quotaUser")
  valid_580901 = validateParameter(valid_580901, JString, required = false,
                                 default = nil)
  if valid_580901 != nil:
    section.add "quotaUser", valid_580901
  var valid_580902 = query.getOrDefault("fields")
  valid_580902 = validateParameter(valid_580902, JString, required = false,
                                 default = nil)
  if valid_580902 != nil:
    section.add "fields", valid_580902
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580904: Call_DfareportingFloodlightActivityGroupsInsert_580892;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new floodlight activity group.
  ## 
  let valid = call_580904.validator(path, query, header, formData, body)
  let scheme = call_580904.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580904.url(scheme.get, call_580904.host, call_580904.base,
                         call_580904.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580904, url, valid)

proc call*(call_580905: Call_DfareportingFloodlightActivityGroupsInsert_580892;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingFloodlightActivityGroupsInsert
  ## Inserts a new floodlight activity group.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580906 = newJObject()
  var query_580907 = newJObject()
  var body_580908 = newJObject()
  add(query_580907, "key", newJString(key))
  add(query_580907, "prettyPrint", newJBool(prettyPrint))
  add(query_580907, "oauth_token", newJString(oauthToken))
  add(path_580906, "profileId", newJString(profileId))
  add(query_580907, "alt", newJString(alt))
  add(query_580907, "userIp", newJString(userIp))
  add(query_580907, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580908 = body
  add(query_580907, "fields", newJString(fields))
  result = call_580905.call(path_580906, query_580907, nil, nil, body_580908)

var dfareportingFloodlightActivityGroupsInsert* = Call_DfareportingFloodlightActivityGroupsInsert_580892(
    name: "dfareportingFloodlightActivityGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsInsert_580893,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivityGroupsInsert_580894,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsList_580851 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightActivityGroupsList_580853(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsList_580852(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of floodlight activity groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580854 = path.getOrDefault("profileId")
  valid_580854 = validateParameter(valid_580854, JString, required = true,
                                 default = nil)
  if valid_580854 != nil:
    section.add "profileId", valid_580854
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   type: JString
  ##       : Select only floodlight activity groups with the specified floodlight activity group type.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivitygroup*2015" will return objects with names like "floodlightactivitygroup June 2015", "floodlightactivitygroup April 2015", or simply "floodlightactivitygroup 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivitygroup" will match objects with name "my floodlightactivitygroup activity", "floodlightactivitygroup 2015", or simply "floodlightactivitygroup".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   floodlightConfigurationId: JString
  ##                            : Select only floodlight activity groups with the specified floodlight configuration ID. Must specify either advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   advertiserId: JString
  ##               : Select only floodlight activity groups with the specified advertiser ID. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   ids: JArray
  ##      : Select only floodlight activity groups with the specified IDs. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_580855 = query.getOrDefault("key")
  valid_580855 = validateParameter(valid_580855, JString, required = false,
                                 default = nil)
  if valid_580855 != nil:
    section.add "key", valid_580855
  var valid_580856 = query.getOrDefault("prettyPrint")
  valid_580856 = validateParameter(valid_580856, JBool, required = false,
                                 default = newJBool(true))
  if valid_580856 != nil:
    section.add "prettyPrint", valid_580856
  var valid_580857 = query.getOrDefault("oauth_token")
  valid_580857 = validateParameter(valid_580857, JString, required = false,
                                 default = nil)
  if valid_580857 != nil:
    section.add "oauth_token", valid_580857
  var valid_580858 = query.getOrDefault("sortField")
  valid_580858 = validateParameter(valid_580858, JString, required = false,
                                 default = newJString("ID"))
  if valid_580858 != nil:
    section.add "sortField", valid_580858
  var valid_580859 = query.getOrDefault("alt")
  valid_580859 = validateParameter(valid_580859, JString, required = false,
                                 default = newJString("json"))
  if valid_580859 != nil:
    section.add "alt", valid_580859
  var valid_580860 = query.getOrDefault("userIp")
  valid_580860 = validateParameter(valid_580860, JString, required = false,
                                 default = nil)
  if valid_580860 != nil:
    section.add "userIp", valid_580860
  var valid_580861 = query.getOrDefault("quotaUser")
  valid_580861 = validateParameter(valid_580861, JString, required = false,
                                 default = nil)
  if valid_580861 != nil:
    section.add "quotaUser", valid_580861
  var valid_580862 = query.getOrDefault("type")
  valid_580862 = validateParameter(valid_580862, JString, required = false,
                                 default = newJString("COUNTER"))
  if valid_580862 != nil:
    section.add "type", valid_580862
  var valid_580863 = query.getOrDefault("pageToken")
  valid_580863 = validateParameter(valid_580863, JString, required = false,
                                 default = nil)
  if valid_580863 != nil:
    section.add "pageToken", valid_580863
  var valid_580864 = query.getOrDefault("searchString")
  valid_580864 = validateParameter(valid_580864, JString, required = false,
                                 default = nil)
  if valid_580864 != nil:
    section.add "searchString", valid_580864
  var valid_580865 = query.getOrDefault("sortOrder")
  valid_580865 = validateParameter(valid_580865, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580865 != nil:
    section.add "sortOrder", valid_580865
  var valid_580866 = query.getOrDefault("floodlightConfigurationId")
  valid_580866 = validateParameter(valid_580866, JString, required = false,
                                 default = nil)
  if valid_580866 != nil:
    section.add "floodlightConfigurationId", valid_580866
  var valid_580867 = query.getOrDefault("advertiserId")
  valid_580867 = validateParameter(valid_580867, JString, required = false,
                                 default = nil)
  if valid_580867 != nil:
    section.add "advertiserId", valid_580867
  var valid_580868 = query.getOrDefault("ids")
  valid_580868 = validateParameter(valid_580868, JArray, required = false,
                                 default = nil)
  if valid_580868 != nil:
    section.add "ids", valid_580868
  var valid_580869 = query.getOrDefault("fields")
  valid_580869 = validateParameter(valid_580869, JString, required = false,
                                 default = nil)
  if valid_580869 != nil:
    section.add "fields", valid_580869
  var valid_580870 = query.getOrDefault("maxResults")
  valid_580870 = validateParameter(valid_580870, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580870 != nil:
    section.add "maxResults", valid_580870
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580871: Call_DfareportingFloodlightActivityGroupsList_580851;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of floodlight activity groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_580871.validator(path, query, header, formData, body)
  let scheme = call_580871.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580871.url(scheme.get, call_580871.host, call_580871.base,
                         call_580871.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580871, url, valid)

proc call*(call_580872: Call_DfareportingFloodlightActivityGroupsList_580851;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; sortField: string = "ID"; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; `type`: string = "COUNTER";
          pageToken: string = ""; searchString: string = "";
          sortOrder: string = "ASCENDING"; floodlightConfigurationId: string = "";
          advertiserId: string = ""; ids: JsonNode = nil; fields: string = "";
          maxResults: int = 1000): Recallable =
  ## dfareportingFloodlightActivityGroupsList
  ## Retrieves a list of floodlight activity groups, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   type: string
  ##       : Select only floodlight activity groups with the specified floodlight activity group type.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivitygroup*2015" will return objects with names like "floodlightactivitygroup June 2015", "floodlightactivitygroup April 2015", or simply "floodlightactivitygroup 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivitygroup" will match objects with name "my floodlightactivitygroup activity", "floodlightactivitygroup 2015", or simply "floodlightactivitygroup".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   floodlightConfigurationId: string
  ##                            : Select only floodlight activity groups with the specified floodlight configuration ID. Must specify either advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   advertiserId: string
  ##               : Select only floodlight activity groups with the specified advertiser ID. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   ids: JArray
  ##      : Select only floodlight activity groups with the specified IDs. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_580873 = newJObject()
  var query_580874 = newJObject()
  add(query_580874, "key", newJString(key))
  add(query_580874, "prettyPrint", newJBool(prettyPrint))
  add(query_580874, "oauth_token", newJString(oauthToken))
  add(path_580873, "profileId", newJString(profileId))
  add(query_580874, "sortField", newJString(sortField))
  add(query_580874, "alt", newJString(alt))
  add(query_580874, "userIp", newJString(userIp))
  add(query_580874, "quotaUser", newJString(quotaUser))
  add(query_580874, "type", newJString(`type`))
  add(query_580874, "pageToken", newJString(pageToken))
  add(query_580874, "searchString", newJString(searchString))
  add(query_580874, "sortOrder", newJString(sortOrder))
  add(query_580874, "floodlightConfigurationId",
      newJString(floodlightConfigurationId))
  add(query_580874, "advertiserId", newJString(advertiserId))
  if ids != nil:
    query_580874.add "ids", ids
  add(query_580874, "fields", newJString(fields))
  add(query_580874, "maxResults", newJInt(maxResults))
  result = call_580872.call(path_580873, query_580874, nil, nil, nil)

var dfareportingFloodlightActivityGroupsList* = Call_DfareportingFloodlightActivityGroupsList_580851(
    name: "dfareportingFloodlightActivityGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsList_580852,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivityGroupsList_580853,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsPatch_580909 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightActivityGroupsPatch_580911(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsPatch_580910(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580912 = path.getOrDefault("profileId")
  valid_580912 = validateParameter(valid_580912, JString, required = true,
                                 default = nil)
  if valid_580912 != nil:
    section.add "profileId", valid_580912
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Floodlight activity Group ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580913 = query.getOrDefault("key")
  valid_580913 = validateParameter(valid_580913, JString, required = false,
                                 default = nil)
  if valid_580913 != nil:
    section.add "key", valid_580913
  var valid_580914 = query.getOrDefault("prettyPrint")
  valid_580914 = validateParameter(valid_580914, JBool, required = false,
                                 default = newJBool(true))
  if valid_580914 != nil:
    section.add "prettyPrint", valid_580914
  var valid_580915 = query.getOrDefault("oauth_token")
  valid_580915 = validateParameter(valid_580915, JString, required = false,
                                 default = nil)
  if valid_580915 != nil:
    section.add "oauth_token", valid_580915
  var valid_580916 = query.getOrDefault("alt")
  valid_580916 = validateParameter(valid_580916, JString, required = false,
                                 default = newJString("json"))
  if valid_580916 != nil:
    section.add "alt", valid_580916
  var valid_580917 = query.getOrDefault("userIp")
  valid_580917 = validateParameter(valid_580917, JString, required = false,
                                 default = nil)
  if valid_580917 != nil:
    section.add "userIp", valid_580917
  var valid_580918 = query.getOrDefault("quotaUser")
  valid_580918 = validateParameter(valid_580918, JString, required = false,
                                 default = nil)
  if valid_580918 != nil:
    section.add "quotaUser", valid_580918
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580919 = query.getOrDefault("id")
  valid_580919 = validateParameter(valid_580919, JString, required = true,
                                 default = nil)
  if valid_580919 != nil:
    section.add "id", valid_580919
  var valid_580920 = query.getOrDefault("fields")
  valid_580920 = validateParameter(valid_580920, JString, required = false,
                                 default = nil)
  if valid_580920 != nil:
    section.add "fields", valid_580920
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580922: Call_DfareportingFloodlightActivityGroupsPatch_580909;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity group. This method supports patch semantics.
  ## 
  let valid = call_580922.validator(path, query, header, formData, body)
  let scheme = call_580922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580922.url(scheme.get, call_580922.host, call_580922.base,
                         call_580922.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580922, url, valid)

proc call*(call_580923: Call_DfareportingFloodlightActivityGroupsPatch_580909;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingFloodlightActivityGroupsPatch
  ## Updates an existing floodlight activity group. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Floodlight activity Group ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580924 = newJObject()
  var query_580925 = newJObject()
  var body_580926 = newJObject()
  add(query_580925, "key", newJString(key))
  add(query_580925, "prettyPrint", newJBool(prettyPrint))
  add(query_580925, "oauth_token", newJString(oauthToken))
  add(path_580924, "profileId", newJString(profileId))
  add(query_580925, "alt", newJString(alt))
  add(query_580925, "userIp", newJString(userIp))
  add(query_580925, "quotaUser", newJString(quotaUser))
  add(query_580925, "id", newJString(id))
  if body != nil:
    body_580926 = body
  add(query_580925, "fields", newJString(fields))
  result = call_580923.call(path_580924, query_580925, nil, nil, body_580926)

var dfareportingFloodlightActivityGroupsPatch* = Call_DfareportingFloodlightActivityGroupsPatch_580909(
    name: "dfareportingFloodlightActivityGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsPatch_580910,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivityGroupsPatch_580911,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsGet_580927 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightActivityGroupsGet_580929(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsGet_580928(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one floodlight activity group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight activity Group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580930 = path.getOrDefault("profileId")
  valid_580930 = validateParameter(valid_580930, JString, required = true,
                                 default = nil)
  if valid_580930 != nil:
    section.add "profileId", valid_580930
  var valid_580931 = path.getOrDefault("id")
  valid_580931 = validateParameter(valid_580931, JString, required = true,
                                 default = nil)
  if valid_580931 != nil:
    section.add "id", valid_580931
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580932 = query.getOrDefault("key")
  valid_580932 = validateParameter(valid_580932, JString, required = false,
                                 default = nil)
  if valid_580932 != nil:
    section.add "key", valid_580932
  var valid_580933 = query.getOrDefault("prettyPrint")
  valid_580933 = validateParameter(valid_580933, JBool, required = false,
                                 default = newJBool(true))
  if valid_580933 != nil:
    section.add "prettyPrint", valid_580933
  var valid_580934 = query.getOrDefault("oauth_token")
  valid_580934 = validateParameter(valid_580934, JString, required = false,
                                 default = nil)
  if valid_580934 != nil:
    section.add "oauth_token", valid_580934
  var valid_580935 = query.getOrDefault("alt")
  valid_580935 = validateParameter(valid_580935, JString, required = false,
                                 default = newJString("json"))
  if valid_580935 != nil:
    section.add "alt", valid_580935
  var valid_580936 = query.getOrDefault("userIp")
  valid_580936 = validateParameter(valid_580936, JString, required = false,
                                 default = nil)
  if valid_580936 != nil:
    section.add "userIp", valid_580936
  var valid_580937 = query.getOrDefault("quotaUser")
  valid_580937 = validateParameter(valid_580937, JString, required = false,
                                 default = nil)
  if valid_580937 != nil:
    section.add "quotaUser", valid_580937
  var valid_580938 = query.getOrDefault("fields")
  valid_580938 = validateParameter(valid_580938, JString, required = false,
                                 default = nil)
  if valid_580938 != nil:
    section.add "fields", valid_580938
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580939: Call_DfareportingFloodlightActivityGroupsGet_580927;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one floodlight activity group by ID.
  ## 
  let valid = call_580939.validator(path, query, header, formData, body)
  let scheme = call_580939.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580939.url(scheme.get, call_580939.host, call_580939.base,
                         call_580939.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580939, url, valid)

proc call*(call_580940: Call_DfareportingFloodlightActivityGroupsGet_580927;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingFloodlightActivityGroupsGet
  ## Gets one floodlight activity group by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Floodlight activity Group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580941 = newJObject()
  var query_580942 = newJObject()
  add(query_580942, "key", newJString(key))
  add(query_580942, "prettyPrint", newJBool(prettyPrint))
  add(query_580942, "oauth_token", newJString(oauthToken))
  add(path_580941, "profileId", newJString(profileId))
  add(path_580941, "id", newJString(id))
  add(query_580942, "alt", newJString(alt))
  add(query_580942, "userIp", newJString(userIp))
  add(query_580942, "quotaUser", newJString(quotaUser))
  add(query_580942, "fields", newJString(fields))
  result = call_580940.call(path_580941, query_580942, nil, nil, nil)

var dfareportingFloodlightActivityGroupsGet* = Call_DfareportingFloodlightActivityGroupsGet_580927(
    name: "dfareportingFloodlightActivityGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups/{id}",
    validator: validate_DfareportingFloodlightActivityGroupsGet_580928,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivityGroupsGet_580929,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsUpdate_580959 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightConfigurationsUpdate_580961(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsUpdate_580960(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580962 = path.getOrDefault("profileId")
  valid_580962 = validateParameter(valid_580962, JString, required = true,
                                 default = nil)
  if valid_580962 != nil:
    section.add "profileId", valid_580962
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580963 = query.getOrDefault("key")
  valid_580963 = validateParameter(valid_580963, JString, required = false,
                                 default = nil)
  if valid_580963 != nil:
    section.add "key", valid_580963
  var valid_580964 = query.getOrDefault("prettyPrint")
  valid_580964 = validateParameter(valid_580964, JBool, required = false,
                                 default = newJBool(true))
  if valid_580964 != nil:
    section.add "prettyPrint", valid_580964
  var valid_580965 = query.getOrDefault("oauth_token")
  valid_580965 = validateParameter(valid_580965, JString, required = false,
                                 default = nil)
  if valid_580965 != nil:
    section.add "oauth_token", valid_580965
  var valid_580966 = query.getOrDefault("alt")
  valid_580966 = validateParameter(valid_580966, JString, required = false,
                                 default = newJString("json"))
  if valid_580966 != nil:
    section.add "alt", valid_580966
  var valid_580967 = query.getOrDefault("userIp")
  valid_580967 = validateParameter(valid_580967, JString, required = false,
                                 default = nil)
  if valid_580967 != nil:
    section.add "userIp", valid_580967
  var valid_580968 = query.getOrDefault("quotaUser")
  valid_580968 = validateParameter(valid_580968, JString, required = false,
                                 default = nil)
  if valid_580968 != nil:
    section.add "quotaUser", valid_580968
  var valid_580969 = query.getOrDefault("fields")
  valid_580969 = validateParameter(valid_580969, JString, required = false,
                                 default = nil)
  if valid_580969 != nil:
    section.add "fields", valid_580969
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580971: Call_DfareportingFloodlightConfigurationsUpdate_580959;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight configuration.
  ## 
  let valid = call_580971.validator(path, query, header, formData, body)
  let scheme = call_580971.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580971.url(scheme.get, call_580971.host, call_580971.base,
                         call_580971.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580971, url, valid)

proc call*(call_580972: Call_DfareportingFloodlightConfigurationsUpdate_580959;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingFloodlightConfigurationsUpdate
  ## Updates an existing floodlight configuration.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580973 = newJObject()
  var query_580974 = newJObject()
  var body_580975 = newJObject()
  add(query_580974, "key", newJString(key))
  add(query_580974, "prettyPrint", newJBool(prettyPrint))
  add(query_580974, "oauth_token", newJString(oauthToken))
  add(path_580973, "profileId", newJString(profileId))
  add(query_580974, "alt", newJString(alt))
  add(query_580974, "userIp", newJString(userIp))
  add(query_580974, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_580975 = body
  add(query_580974, "fields", newJString(fields))
  result = call_580972.call(path_580973, query_580974, nil, nil, body_580975)

var dfareportingFloodlightConfigurationsUpdate* = Call_DfareportingFloodlightConfigurationsUpdate_580959(
    name: "dfareportingFloodlightConfigurationsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations",
    validator: validate_DfareportingFloodlightConfigurationsUpdate_580960,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightConfigurationsUpdate_580961,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsList_580943 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightConfigurationsList_580945(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsList_580944(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of floodlight configurations, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580946 = path.getOrDefault("profileId")
  valid_580946 = validateParameter(valid_580946, JString, required = true,
                                 default = nil)
  if valid_580946 != nil:
    section.add "profileId", valid_580946
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   ids: JArray
  ##      : Set of IDs of floodlight configurations to retrieve. Required field; otherwise an empty list will be returned.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580947 = query.getOrDefault("key")
  valid_580947 = validateParameter(valid_580947, JString, required = false,
                                 default = nil)
  if valid_580947 != nil:
    section.add "key", valid_580947
  var valid_580948 = query.getOrDefault("prettyPrint")
  valid_580948 = validateParameter(valid_580948, JBool, required = false,
                                 default = newJBool(true))
  if valid_580948 != nil:
    section.add "prettyPrint", valid_580948
  var valid_580949 = query.getOrDefault("oauth_token")
  valid_580949 = validateParameter(valid_580949, JString, required = false,
                                 default = nil)
  if valid_580949 != nil:
    section.add "oauth_token", valid_580949
  var valid_580950 = query.getOrDefault("alt")
  valid_580950 = validateParameter(valid_580950, JString, required = false,
                                 default = newJString("json"))
  if valid_580950 != nil:
    section.add "alt", valid_580950
  var valid_580951 = query.getOrDefault("userIp")
  valid_580951 = validateParameter(valid_580951, JString, required = false,
                                 default = nil)
  if valid_580951 != nil:
    section.add "userIp", valid_580951
  var valid_580952 = query.getOrDefault("quotaUser")
  valid_580952 = validateParameter(valid_580952, JString, required = false,
                                 default = nil)
  if valid_580952 != nil:
    section.add "quotaUser", valid_580952
  var valid_580953 = query.getOrDefault("ids")
  valid_580953 = validateParameter(valid_580953, JArray, required = false,
                                 default = nil)
  if valid_580953 != nil:
    section.add "ids", valid_580953
  var valid_580954 = query.getOrDefault("fields")
  valid_580954 = validateParameter(valid_580954, JString, required = false,
                                 default = nil)
  if valid_580954 != nil:
    section.add "fields", valid_580954
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580955: Call_DfareportingFloodlightConfigurationsList_580943;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of floodlight configurations, possibly filtered.
  ## 
  let valid = call_580955.validator(path, query, header, formData, body)
  let scheme = call_580955.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580955.url(scheme.get, call_580955.host, call_580955.base,
                         call_580955.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580955, url, valid)

proc call*(call_580956: Call_DfareportingFloodlightConfigurationsList_580943;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; ids: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingFloodlightConfigurationsList
  ## Retrieves a list of floodlight configurations, possibly filtered.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   ids: JArray
  ##      : Set of IDs of floodlight configurations to retrieve. Required field; otherwise an empty list will be returned.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580957 = newJObject()
  var query_580958 = newJObject()
  add(query_580958, "key", newJString(key))
  add(query_580958, "prettyPrint", newJBool(prettyPrint))
  add(query_580958, "oauth_token", newJString(oauthToken))
  add(path_580957, "profileId", newJString(profileId))
  add(query_580958, "alt", newJString(alt))
  add(query_580958, "userIp", newJString(userIp))
  add(query_580958, "quotaUser", newJString(quotaUser))
  if ids != nil:
    query_580958.add "ids", ids
  add(query_580958, "fields", newJString(fields))
  result = call_580956.call(path_580957, query_580958, nil, nil, nil)

var dfareportingFloodlightConfigurationsList* = Call_DfareportingFloodlightConfigurationsList_580943(
    name: "dfareportingFloodlightConfigurationsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations",
    validator: validate_DfareportingFloodlightConfigurationsList_580944,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightConfigurationsList_580945,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsPatch_580976 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightConfigurationsPatch_580978(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsPatch_580977(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight configuration. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580979 = path.getOrDefault("profileId")
  valid_580979 = validateParameter(valid_580979, JString, required = true,
                                 default = nil)
  if valid_580979 != nil:
    section.add "profileId", valid_580979
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Floodlight configuration ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580980 = query.getOrDefault("key")
  valid_580980 = validateParameter(valid_580980, JString, required = false,
                                 default = nil)
  if valid_580980 != nil:
    section.add "key", valid_580980
  var valid_580981 = query.getOrDefault("prettyPrint")
  valid_580981 = validateParameter(valid_580981, JBool, required = false,
                                 default = newJBool(true))
  if valid_580981 != nil:
    section.add "prettyPrint", valid_580981
  var valid_580982 = query.getOrDefault("oauth_token")
  valid_580982 = validateParameter(valid_580982, JString, required = false,
                                 default = nil)
  if valid_580982 != nil:
    section.add "oauth_token", valid_580982
  var valid_580983 = query.getOrDefault("alt")
  valid_580983 = validateParameter(valid_580983, JString, required = false,
                                 default = newJString("json"))
  if valid_580983 != nil:
    section.add "alt", valid_580983
  var valid_580984 = query.getOrDefault("userIp")
  valid_580984 = validateParameter(valid_580984, JString, required = false,
                                 default = nil)
  if valid_580984 != nil:
    section.add "userIp", valid_580984
  var valid_580985 = query.getOrDefault("quotaUser")
  valid_580985 = validateParameter(valid_580985, JString, required = false,
                                 default = nil)
  if valid_580985 != nil:
    section.add "quotaUser", valid_580985
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580986 = query.getOrDefault("id")
  valid_580986 = validateParameter(valid_580986, JString, required = true,
                                 default = nil)
  if valid_580986 != nil:
    section.add "id", valid_580986
  var valid_580987 = query.getOrDefault("fields")
  valid_580987 = validateParameter(valid_580987, JString, required = false,
                                 default = nil)
  if valid_580987 != nil:
    section.add "fields", valid_580987
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580989: Call_DfareportingFloodlightConfigurationsPatch_580976;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight configuration. This method supports patch semantics.
  ## 
  let valid = call_580989.validator(path, query, header, formData, body)
  let scheme = call_580989.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580989.url(scheme.get, call_580989.host, call_580989.base,
                         call_580989.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580989, url, valid)

proc call*(call_580990: Call_DfareportingFloodlightConfigurationsPatch_580976;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingFloodlightConfigurationsPatch
  ## Updates an existing floodlight configuration. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Floodlight configuration ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_580991 = newJObject()
  var query_580992 = newJObject()
  var body_580993 = newJObject()
  add(query_580992, "key", newJString(key))
  add(query_580992, "prettyPrint", newJBool(prettyPrint))
  add(query_580992, "oauth_token", newJString(oauthToken))
  add(path_580991, "profileId", newJString(profileId))
  add(query_580992, "alt", newJString(alt))
  add(query_580992, "userIp", newJString(userIp))
  add(query_580992, "quotaUser", newJString(quotaUser))
  add(query_580992, "id", newJString(id))
  if body != nil:
    body_580993 = body
  add(query_580992, "fields", newJString(fields))
  result = call_580990.call(path_580991, query_580992, nil, nil, body_580993)

var dfareportingFloodlightConfigurationsPatch* = Call_DfareportingFloodlightConfigurationsPatch_580976(
    name: "dfareportingFloodlightConfigurationsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations",
    validator: validate_DfareportingFloodlightConfigurationsPatch_580977,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightConfigurationsPatch_580978,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsGet_580994 = ref object of OpenApiRestCall_578364
proc url_DfareportingFloodlightConfigurationsGet_580996(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsGet_580995(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one floodlight configuration by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight configuration ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580997 = path.getOrDefault("profileId")
  valid_580997 = validateParameter(valid_580997, JString, required = true,
                                 default = nil)
  if valid_580997 != nil:
    section.add "profileId", valid_580997
  var valid_580998 = path.getOrDefault("id")
  valid_580998 = validateParameter(valid_580998, JString, required = true,
                                 default = nil)
  if valid_580998 != nil:
    section.add "id", valid_580998
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_580999 = query.getOrDefault("key")
  valid_580999 = validateParameter(valid_580999, JString, required = false,
                                 default = nil)
  if valid_580999 != nil:
    section.add "key", valid_580999
  var valid_581000 = query.getOrDefault("prettyPrint")
  valid_581000 = validateParameter(valid_581000, JBool, required = false,
                                 default = newJBool(true))
  if valid_581000 != nil:
    section.add "prettyPrint", valid_581000
  var valid_581001 = query.getOrDefault("oauth_token")
  valid_581001 = validateParameter(valid_581001, JString, required = false,
                                 default = nil)
  if valid_581001 != nil:
    section.add "oauth_token", valid_581001
  var valid_581002 = query.getOrDefault("alt")
  valid_581002 = validateParameter(valid_581002, JString, required = false,
                                 default = newJString("json"))
  if valid_581002 != nil:
    section.add "alt", valid_581002
  var valid_581003 = query.getOrDefault("userIp")
  valid_581003 = validateParameter(valid_581003, JString, required = false,
                                 default = nil)
  if valid_581003 != nil:
    section.add "userIp", valid_581003
  var valid_581004 = query.getOrDefault("quotaUser")
  valid_581004 = validateParameter(valid_581004, JString, required = false,
                                 default = nil)
  if valid_581004 != nil:
    section.add "quotaUser", valid_581004
  var valid_581005 = query.getOrDefault("fields")
  valid_581005 = validateParameter(valid_581005, JString, required = false,
                                 default = nil)
  if valid_581005 != nil:
    section.add "fields", valid_581005
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581006: Call_DfareportingFloodlightConfigurationsGet_580994;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one floodlight configuration by ID.
  ## 
  let valid = call_581006.validator(path, query, header, formData, body)
  let scheme = call_581006.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581006.url(scheme.get, call_581006.host, call_581006.base,
                         call_581006.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581006, url, valid)

proc call*(call_581007: Call_DfareportingFloodlightConfigurationsGet_580994;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingFloodlightConfigurationsGet
  ## Gets one floodlight configuration by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Floodlight configuration ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581008 = newJObject()
  var query_581009 = newJObject()
  add(query_581009, "key", newJString(key))
  add(query_581009, "prettyPrint", newJBool(prettyPrint))
  add(query_581009, "oauth_token", newJString(oauthToken))
  add(path_581008, "profileId", newJString(profileId))
  add(path_581008, "id", newJString(id))
  add(query_581009, "alt", newJString(alt))
  add(query_581009, "userIp", newJString(userIp))
  add(query_581009, "quotaUser", newJString(quotaUser))
  add(query_581009, "fields", newJString(fields))
  result = call_581007.call(path_581008, query_581009, nil, nil, nil)

var dfareportingFloodlightConfigurationsGet* = Call_DfareportingFloodlightConfigurationsGet_580994(
    name: "dfareportingFloodlightConfigurationsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations/{id}",
    validator: validate_DfareportingFloodlightConfigurationsGet_580995,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightConfigurationsGet_580996,
    schemes: {Scheme.Https})
type
  Call_DfareportingLanguagesList_581010 = ref object of OpenApiRestCall_578364
proc url_DfareportingLanguagesList_581012(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/languages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLanguagesList_581011(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of languages.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581013 = path.getOrDefault("profileId")
  valid_581013 = validateParameter(valid_581013, JString, required = true,
                                 default = nil)
  if valid_581013 != nil:
    section.add "profileId", valid_581013
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581014 = query.getOrDefault("key")
  valid_581014 = validateParameter(valid_581014, JString, required = false,
                                 default = nil)
  if valid_581014 != nil:
    section.add "key", valid_581014
  var valid_581015 = query.getOrDefault("prettyPrint")
  valid_581015 = validateParameter(valid_581015, JBool, required = false,
                                 default = newJBool(true))
  if valid_581015 != nil:
    section.add "prettyPrint", valid_581015
  var valid_581016 = query.getOrDefault("oauth_token")
  valid_581016 = validateParameter(valid_581016, JString, required = false,
                                 default = nil)
  if valid_581016 != nil:
    section.add "oauth_token", valid_581016
  var valid_581017 = query.getOrDefault("alt")
  valid_581017 = validateParameter(valid_581017, JString, required = false,
                                 default = newJString("json"))
  if valid_581017 != nil:
    section.add "alt", valid_581017
  var valid_581018 = query.getOrDefault("userIp")
  valid_581018 = validateParameter(valid_581018, JString, required = false,
                                 default = nil)
  if valid_581018 != nil:
    section.add "userIp", valid_581018
  var valid_581019 = query.getOrDefault("quotaUser")
  valid_581019 = validateParameter(valid_581019, JString, required = false,
                                 default = nil)
  if valid_581019 != nil:
    section.add "quotaUser", valid_581019
  var valid_581020 = query.getOrDefault("fields")
  valid_581020 = validateParameter(valid_581020, JString, required = false,
                                 default = nil)
  if valid_581020 != nil:
    section.add "fields", valid_581020
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581021: Call_DfareportingLanguagesList_581010; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of languages.
  ## 
  let valid = call_581021.validator(path, query, header, formData, body)
  let scheme = call_581021.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581021.url(scheme.get, call_581021.host, call_581021.base,
                         call_581021.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581021, url, valid)

proc call*(call_581022: Call_DfareportingLanguagesList_581010; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingLanguagesList
  ## Retrieves a list of languages.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581023 = newJObject()
  var query_581024 = newJObject()
  add(query_581024, "key", newJString(key))
  add(query_581024, "prettyPrint", newJBool(prettyPrint))
  add(query_581024, "oauth_token", newJString(oauthToken))
  add(path_581023, "profileId", newJString(profileId))
  add(query_581024, "alt", newJString(alt))
  add(query_581024, "userIp", newJString(userIp))
  add(query_581024, "quotaUser", newJString(quotaUser))
  add(query_581024, "fields", newJString(fields))
  result = call_581022.call(path_581023, query_581024, nil, nil, nil)

var dfareportingLanguagesList* = Call_DfareportingLanguagesList_581010(
    name: "dfareportingLanguagesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/languages",
    validator: validate_DfareportingLanguagesList_581011,
    base: "/dfareporting/v2.7", url: url_DfareportingLanguagesList_581012,
    schemes: {Scheme.Https})
type
  Call_DfareportingMetrosList_581025 = ref object of OpenApiRestCall_578364
proc url_DfareportingMetrosList_581027(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/metros")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingMetrosList_581026(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of metros.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581028 = path.getOrDefault("profileId")
  valid_581028 = validateParameter(valid_581028, JString, required = true,
                                 default = nil)
  if valid_581028 != nil:
    section.add "profileId", valid_581028
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581029 = query.getOrDefault("key")
  valid_581029 = validateParameter(valid_581029, JString, required = false,
                                 default = nil)
  if valid_581029 != nil:
    section.add "key", valid_581029
  var valid_581030 = query.getOrDefault("prettyPrint")
  valid_581030 = validateParameter(valid_581030, JBool, required = false,
                                 default = newJBool(true))
  if valid_581030 != nil:
    section.add "prettyPrint", valid_581030
  var valid_581031 = query.getOrDefault("oauth_token")
  valid_581031 = validateParameter(valid_581031, JString, required = false,
                                 default = nil)
  if valid_581031 != nil:
    section.add "oauth_token", valid_581031
  var valid_581032 = query.getOrDefault("alt")
  valid_581032 = validateParameter(valid_581032, JString, required = false,
                                 default = newJString("json"))
  if valid_581032 != nil:
    section.add "alt", valid_581032
  var valid_581033 = query.getOrDefault("userIp")
  valid_581033 = validateParameter(valid_581033, JString, required = false,
                                 default = nil)
  if valid_581033 != nil:
    section.add "userIp", valid_581033
  var valid_581034 = query.getOrDefault("quotaUser")
  valid_581034 = validateParameter(valid_581034, JString, required = false,
                                 default = nil)
  if valid_581034 != nil:
    section.add "quotaUser", valid_581034
  var valid_581035 = query.getOrDefault("fields")
  valid_581035 = validateParameter(valid_581035, JString, required = false,
                                 default = nil)
  if valid_581035 != nil:
    section.add "fields", valid_581035
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581036: Call_DfareportingMetrosList_581025; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of metros.
  ## 
  let valid = call_581036.validator(path, query, header, formData, body)
  let scheme = call_581036.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581036.url(scheme.get, call_581036.host, call_581036.base,
                         call_581036.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581036, url, valid)

proc call*(call_581037: Call_DfareportingMetrosList_581025; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingMetrosList
  ## Retrieves a list of metros.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581038 = newJObject()
  var query_581039 = newJObject()
  add(query_581039, "key", newJString(key))
  add(query_581039, "prettyPrint", newJBool(prettyPrint))
  add(query_581039, "oauth_token", newJString(oauthToken))
  add(path_581038, "profileId", newJString(profileId))
  add(query_581039, "alt", newJString(alt))
  add(query_581039, "userIp", newJString(userIp))
  add(query_581039, "quotaUser", newJString(quotaUser))
  add(query_581039, "fields", newJString(fields))
  result = call_581037.call(path_581038, query_581039, nil, nil, nil)

var dfareportingMetrosList* = Call_DfareportingMetrosList_581025(
    name: "dfareportingMetrosList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/metros",
    validator: validate_DfareportingMetrosList_581026, base: "/dfareporting/v2.7",
    url: url_DfareportingMetrosList_581027, schemes: {Scheme.Https})
type
  Call_DfareportingMobileCarriersList_581040 = ref object of OpenApiRestCall_578364
proc url_DfareportingMobileCarriersList_581042(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/mobileCarriers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingMobileCarriersList_581041(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of mobile carriers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581043 = path.getOrDefault("profileId")
  valid_581043 = validateParameter(valid_581043, JString, required = true,
                                 default = nil)
  if valid_581043 != nil:
    section.add "profileId", valid_581043
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581044 = query.getOrDefault("key")
  valid_581044 = validateParameter(valid_581044, JString, required = false,
                                 default = nil)
  if valid_581044 != nil:
    section.add "key", valid_581044
  var valid_581045 = query.getOrDefault("prettyPrint")
  valid_581045 = validateParameter(valid_581045, JBool, required = false,
                                 default = newJBool(true))
  if valid_581045 != nil:
    section.add "prettyPrint", valid_581045
  var valid_581046 = query.getOrDefault("oauth_token")
  valid_581046 = validateParameter(valid_581046, JString, required = false,
                                 default = nil)
  if valid_581046 != nil:
    section.add "oauth_token", valid_581046
  var valid_581047 = query.getOrDefault("alt")
  valid_581047 = validateParameter(valid_581047, JString, required = false,
                                 default = newJString("json"))
  if valid_581047 != nil:
    section.add "alt", valid_581047
  var valid_581048 = query.getOrDefault("userIp")
  valid_581048 = validateParameter(valid_581048, JString, required = false,
                                 default = nil)
  if valid_581048 != nil:
    section.add "userIp", valid_581048
  var valid_581049 = query.getOrDefault("quotaUser")
  valid_581049 = validateParameter(valid_581049, JString, required = false,
                                 default = nil)
  if valid_581049 != nil:
    section.add "quotaUser", valid_581049
  var valid_581050 = query.getOrDefault("fields")
  valid_581050 = validateParameter(valid_581050, JString, required = false,
                                 default = nil)
  if valid_581050 != nil:
    section.add "fields", valid_581050
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581051: Call_DfareportingMobileCarriersList_581040; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of mobile carriers.
  ## 
  let valid = call_581051.validator(path, query, header, formData, body)
  let scheme = call_581051.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581051.url(scheme.get, call_581051.host, call_581051.base,
                         call_581051.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581051, url, valid)

proc call*(call_581052: Call_DfareportingMobileCarriersList_581040;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingMobileCarriersList
  ## Retrieves a list of mobile carriers.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581053 = newJObject()
  var query_581054 = newJObject()
  add(query_581054, "key", newJString(key))
  add(query_581054, "prettyPrint", newJBool(prettyPrint))
  add(query_581054, "oauth_token", newJString(oauthToken))
  add(path_581053, "profileId", newJString(profileId))
  add(query_581054, "alt", newJString(alt))
  add(query_581054, "userIp", newJString(userIp))
  add(query_581054, "quotaUser", newJString(quotaUser))
  add(query_581054, "fields", newJString(fields))
  result = call_581052.call(path_581053, query_581054, nil, nil, nil)

var dfareportingMobileCarriersList* = Call_DfareportingMobileCarriersList_581040(
    name: "dfareportingMobileCarriersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/mobileCarriers",
    validator: validate_DfareportingMobileCarriersList_581041,
    base: "/dfareporting/v2.7", url: url_DfareportingMobileCarriersList_581042,
    schemes: {Scheme.Https})
type
  Call_DfareportingMobileCarriersGet_581055 = ref object of OpenApiRestCall_578364
proc url_DfareportingMobileCarriersGet_581057(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/mobileCarriers/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingMobileCarriersGet_581056(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one mobile carrier by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Mobile carrier ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581058 = path.getOrDefault("profileId")
  valid_581058 = validateParameter(valid_581058, JString, required = true,
                                 default = nil)
  if valid_581058 != nil:
    section.add "profileId", valid_581058
  var valid_581059 = path.getOrDefault("id")
  valid_581059 = validateParameter(valid_581059, JString, required = true,
                                 default = nil)
  if valid_581059 != nil:
    section.add "id", valid_581059
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581060 = query.getOrDefault("key")
  valid_581060 = validateParameter(valid_581060, JString, required = false,
                                 default = nil)
  if valid_581060 != nil:
    section.add "key", valid_581060
  var valid_581061 = query.getOrDefault("prettyPrint")
  valid_581061 = validateParameter(valid_581061, JBool, required = false,
                                 default = newJBool(true))
  if valid_581061 != nil:
    section.add "prettyPrint", valid_581061
  var valid_581062 = query.getOrDefault("oauth_token")
  valid_581062 = validateParameter(valid_581062, JString, required = false,
                                 default = nil)
  if valid_581062 != nil:
    section.add "oauth_token", valid_581062
  var valid_581063 = query.getOrDefault("alt")
  valid_581063 = validateParameter(valid_581063, JString, required = false,
                                 default = newJString("json"))
  if valid_581063 != nil:
    section.add "alt", valid_581063
  var valid_581064 = query.getOrDefault("userIp")
  valid_581064 = validateParameter(valid_581064, JString, required = false,
                                 default = nil)
  if valid_581064 != nil:
    section.add "userIp", valid_581064
  var valid_581065 = query.getOrDefault("quotaUser")
  valid_581065 = validateParameter(valid_581065, JString, required = false,
                                 default = nil)
  if valid_581065 != nil:
    section.add "quotaUser", valid_581065
  var valid_581066 = query.getOrDefault("fields")
  valid_581066 = validateParameter(valid_581066, JString, required = false,
                                 default = nil)
  if valid_581066 != nil:
    section.add "fields", valid_581066
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581067: Call_DfareportingMobileCarriersGet_581055; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one mobile carrier by ID.
  ## 
  let valid = call_581067.validator(path, query, header, formData, body)
  let scheme = call_581067.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581067.url(scheme.get, call_581067.host, call_581067.base,
                         call_581067.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581067, url, valid)

proc call*(call_581068: Call_DfareportingMobileCarriersGet_581055;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingMobileCarriersGet
  ## Gets one mobile carrier by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Mobile carrier ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581069 = newJObject()
  var query_581070 = newJObject()
  add(query_581070, "key", newJString(key))
  add(query_581070, "prettyPrint", newJBool(prettyPrint))
  add(query_581070, "oauth_token", newJString(oauthToken))
  add(path_581069, "profileId", newJString(profileId))
  add(path_581069, "id", newJString(id))
  add(query_581070, "alt", newJString(alt))
  add(query_581070, "userIp", newJString(userIp))
  add(query_581070, "quotaUser", newJString(quotaUser))
  add(query_581070, "fields", newJString(fields))
  result = call_581068.call(path_581069, query_581070, nil, nil, nil)

var dfareportingMobileCarriersGet* = Call_DfareportingMobileCarriersGet_581055(
    name: "dfareportingMobileCarriersGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/mobileCarriers/{id}",
    validator: validate_DfareportingMobileCarriersGet_581056,
    base: "/dfareporting/v2.7", url: url_DfareportingMobileCarriersGet_581057,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemVersionsList_581071 = ref object of OpenApiRestCall_578364
proc url_DfareportingOperatingSystemVersionsList_581073(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystemVersions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemVersionsList_581072(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of operating system versions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581074 = path.getOrDefault("profileId")
  valid_581074 = validateParameter(valid_581074, JString, required = true,
                                 default = nil)
  if valid_581074 != nil:
    section.add "profileId", valid_581074
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581075 = query.getOrDefault("key")
  valid_581075 = validateParameter(valid_581075, JString, required = false,
                                 default = nil)
  if valid_581075 != nil:
    section.add "key", valid_581075
  var valid_581076 = query.getOrDefault("prettyPrint")
  valid_581076 = validateParameter(valid_581076, JBool, required = false,
                                 default = newJBool(true))
  if valid_581076 != nil:
    section.add "prettyPrint", valid_581076
  var valid_581077 = query.getOrDefault("oauth_token")
  valid_581077 = validateParameter(valid_581077, JString, required = false,
                                 default = nil)
  if valid_581077 != nil:
    section.add "oauth_token", valid_581077
  var valid_581078 = query.getOrDefault("alt")
  valid_581078 = validateParameter(valid_581078, JString, required = false,
                                 default = newJString("json"))
  if valid_581078 != nil:
    section.add "alt", valid_581078
  var valid_581079 = query.getOrDefault("userIp")
  valid_581079 = validateParameter(valid_581079, JString, required = false,
                                 default = nil)
  if valid_581079 != nil:
    section.add "userIp", valid_581079
  var valid_581080 = query.getOrDefault("quotaUser")
  valid_581080 = validateParameter(valid_581080, JString, required = false,
                                 default = nil)
  if valid_581080 != nil:
    section.add "quotaUser", valid_581080
  var valid_581081 = query.getOrDefault("fields")
  valid_581081 = validateParameter(valid_581081, JString, required = false,
                                 default = nil)
  if valid_581081 != nil:
    section.add "fields", valid_581081
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581082: Call_DfareportingOperatingSystemVersionsList_581071;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of operating system versions.
  ## 
  let valid = call_581082.validator(path, query, header, formData, body)
  let scheme = call_581082.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581082.url(scheme.get, call_581082.host, call_581082.base,
                         call_581082.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581082, url, valid)

proc call*(call_581083: Call_DfareportingOperatingSystemVersionsList_581071;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingOperatingSystemVersionsList
  ## Retrieves a list of operating system versions.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581084 = newJObject()
  var query_581085 = newJObject()
  add(query_581085, "key", newJString(key))
  add(query_581085, "prettyPrint", newJBool(prettyPrint))
  add(query_581085, "oauth_token", newJString(oauthToken))
  add(path_581084, "profileId", newJString(profileId))
  add(query_581085, "alt", newJString(alt))
  add(query_581085, "userIp", newJString(userIp))
  add(query_581085, "quotaUser", newJString(quotaUser))
  add(query_581085, "fields", newJString(fields))
  result = call_581083.call(path_581084, query_581085, nil, nil, nil)

var dfareportingOperatingSystemVersionsList* = Call_DfareportingOperatingSystemVersionsList_581071(
    name: "dfareportingOperatingSystemVersionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystemVersions",
    validator: validate_DfareportingOperatingSystemVersionsList_581072,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemVersionsList_581073,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemVersionsGet_581086 = ref object of OpenApiRestCall_578364
proc url_DfareportingOperatingSystemVersionsGet_581088(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystemVersions/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemVersionsGet_581087(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one operating system version by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Operating system version ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581089 = path.getOrDefault("profileId")
  valid_581089 = validateParameter(valid_581089, JString, required = true,
                                 default = nil)
  if valid_581089 != nil:
    section.add "profileId", valid_581089
  var valid_581090 = path.getOrDefault("id")
  valid_581090 = validateParameter(valid_581090, JString, required = true,
                                 default = nil)
  if valid_581090 != nil:
    section.add "id", valid_581090
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581091 = query.getOrDefault("key")
  valid_581091 = validateParameter(valid_581091, JString, required = false,
                                 default = nil)
  if valid_581091 != nil:
    section.add "key", valid_581091
  var valid_581092 = query.getOrDefault("prettyPrint")
  valid_581092 = validateParameter(valid_581092, JBool, required = false,
                                 default = newJBool(true))
  if valid_581092 != nil:
    section.add "prettyPrint", valid_581092
  var valid_581093 = query.getOrDefault("oauth_token")
  valid_581093 = validateParameter(valid_581093, JString, required = false,
                                 default = nil)
  if valid_581093 != nil:
    section.add "oauth_token", valid_581093
  var valid_581094 = query.getOrDefault("alt")
  valid_581094 = validateParameter(valid_581094, JString, required = false,
                                 default = newJString("json"))
  if valid_581094 != nil:
    section.add "alt", valid_581094
  var valid_581095 = query.getOrDefault("userIp")
  valid_581095 = validateParameter(valid_581095, JString, required = false,
                                 default = nil)
  if valid_581095 != nil:
    section.add "userIp", valid_581095
  var valid_581096 = query.getOrDefault("quotaUser")
  valid_581096 = validateParameter(valid_581096, JString, required = false,
                                 default = nil)
  if valid_581096 != nil:
    section.add "quotaUser", valid_581096
  var valid_581097 = query.getOrDefault("fields")
  valid_581097 = validateParameter(valid_581097, JString, required = false,
                                 default = nil)
  if valid_581097 != nil:
    section.add "fields", valid_581097
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581098: Call_DfareportingOperatingSystemVersionsGet_581086;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one operating system version by ID.
  ## 
  let valid = call_581098.validator(path, query, header, formData, body)
  let scheme = call_581098.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581098.url(scheme.get, call_581098.host, call_581098.base,
                         call_581098.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581098, url, valid)

proc call*(call_581099: Call_DfareportingOperatingSystemVersionsGet_581086;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingOperatingSystemVersionsGet
  ## Gets one operating system version by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Operating system version ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581100 = newJObject()
  var query_581101 = newJObject()
  add(query_581101, "key", newJString(key))
  add(query_581101, "prettyPrint", newJBool(prettyPrint))
  add(query_581101, "oauth_token", newJString(oauthToken))
  add(path_581100, "profileId", newJString(profileId))
  add(path_581100, "id", newJString(id))
  add(query_581101, "alt", newJString(alt))
  add(query_581101, "userIp", newJString(userIp))
  add(query_581101, "quotaUser", newJString(quotaUser))
  add(query_581101, "fields", newJString(fields))
  result = call_581099.call(path_581100, query_581101, nil, nil, nil)

var dfareportingOperatingSystemVersionsGet* = Call_DfareportingOperatingSystemVersionsGet_581086(
    name: "dfareportingOperatingSystemVersionsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystemVersions/{id}",
    validator: validate_DfareportingOperatingSystemVersionsGet_581087,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemVersionsGet_581088,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemsList_581102 = ref object of OpenApiRestCall_578364
proc url_DfareportingOperatingSystemsList_581104(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystems")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemsList_581103(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of operating systems.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581105 = path.getOrDefault("profileId")
  valid_581105 = validateParameter(valid_581105, JString, required = true,
                                 default = nil)
  if valid_581105 != nil:
    section.add "profileId", valid_581105
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581106 = query.getOrDefault("key")
  valid_581106 = validateParameter(valid_581106, JString, required = false,
                                 default = nil)
  if valid_581106 != nil:
    section.add "key", valid_581106
  var valid_581107 = query.getOrDefault("prettyPrint")
  valid_581107 = validateParameter(valid_581107, JBool, required = false,
                                 default = newJBool(true))
  if valid_581107 != nil:
    section.add "prettyPrint", valid_581107
  var valid_581108 = query.getOrDefault("oauth_token")
  valid_581108 = validateParameter(valid_581108, JString, required = false,
                                 default = nil)
  if valid_581108 != nil:
    section.add "oauth_token", valid_581108
  var valid_581109 = query.getOrDefault("alt")
  valid_581109 = validateParameter(valid_581109, JString, required = false,
                                 default = newJString("json"))
  if valid_581109 != nil:
    section.add "alt", valid_581109
  var valid_581110 = query.getOrDefault("userIp")
  valid_581110 = validateParameter(valid_581110, JString, required = false,
                                 default = nil)
  if valid_581110 != nil:
    section.add "userIp", valid_581110
  var valid_581111 = query.getOrDefault("quotaUser")
  valid_581111 = validateParameter(valid_581111, JString, required = false,
                                 default = nil)
  if valid_581111 != nil:
    section.add "quotaUser", valid_581111
  var valid_581112 = query.getOrDefault("fields")
  valid_581112 = validateParameter(valid_581112, JString, required = false,
                                 default = nil)
  if valid_581112 != nil:
    section.add "fields", valid_581112
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581113: Call_DfareportingOperatingSystemsList_581102;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of operating systems.
  ## 
  let valid = call_581113.validator(path, query, header, formData, body)
  let scheme = call_581113.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581113.url(scheme.get, call_581113.host, call_581113.base,
                         call_581113.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581113, url, valid)

proc call*(call_581114: Call_DfareportingOperatingSystemsList_581102;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingOperatingSystemsList
  ## Retrieves a list of operating systems.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581115 = newJObject()
  var query_581116 = newJObject()
  add(query_581116, "key", newJString(key))
  add(query_581116, "prettyPrint", newJBool(prettyPrint))
  add(query_581116, "oauth_token", newJString(oauthToken))
  add(path_581115, "profileId", newJString(profileId))
  add(query_581116, "alt", newJString(alt))
  add(query_581116, "userIp", newJString(userIp))
  add(query_581116, "quotaUser", newJString(quotaUser))
  add(query_581116, "fields", newJString(fields))
  result = call_581114.call(path_581115, query_581116, nil, nil, nil)

var dfareportingOperatingSystemsList* = Call_DfareportingOperatingSystemsList_581102(
    name: "dfareportingOperatingSystemsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystems",
    validator: validate_DfareportingOperatingSystemsList_581103,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemsList_581104,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemsGet_581117 = ref object of OpenApiRestCall_578364
proc url_DfareportingOperatingSystemsGet_581119(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "dartId" in path, "`dartId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystems/"),
               (kind: VariableSegment, value: "dartId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemsGet_581118(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one operating system by DART ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   dartId: JString (required)
  ##         : Operating system DART ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581120 = path.getOrDefault("profileId")
  valid_581120 = validateParameter(valid_581120, JString, required = true,
                                 default = nil)
  if valid_581120 != nil:
    section.add "profileId", valid_581120
  var valid_581121 = path.getOrDefault("dartId")
  valid_581121 = validateParameter(valid_581121, JString, required = true,
                                 default = nil)
  if valid_581121 != nil:
    section.add "dartId", valid_581121
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581122 = query.getOrDefault("key")
  valid_581122 = validateParameter(valid_581122, JString, required = false,
                                 default = nil)
  if valid_581122 != nil:
    section.add "key", valid_581122
  var valid_581123 = query.getOrDefault("prettyPrint")
  valid_581123 = validateParameter(valid_581123, JBool, required = false,
                                 default = newJBool(true))
  if valid_581123 != nil:
    section.add "prettyPrint", valid_581123
  var valid_581124 = query.getOrDefault("oauth_token")
  valid_581124 = validateParameter(valid_581124, JString, required = false,
                                 default = nil)
  if valid_581124 != nil:
    section.add "oauth_token", valid_581124
  var valid_581125 = query.getOrDefault("alt")
  valid_581125 = validateParameter(valid_581125, JString, required = false,
                                 default = newJString("json"))
  if valid_581125 != nil:
    section.add "alt", valid_581125
  var valid_581126 = query.getOrDefault("userIp")
  valid_581126 = validateParameter(valid_581126, JString, required = false,
                                 default = nil)
  if valid_581126 != nil:
    section.add "userIp", valid_581126
  var valid_581127 = query.getOrDefault("quotaUser")
  valid_581127 = validateParameter(valid_581127, JString, required = false,
                                 default = nil)
  if valid_581127 != nil:
    section.add "quotaUser", valid_581127
  var valid_581128 = query.getOrDefault("fields")
  valid_581128 = validateParameter(valid_581128, JString, required = false,
                                 default = nil)
  if valid_581128 != nil:
    section.add "fields", valid_581128
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581129: Call_DfareportingOperatingSystemsGet_581117;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one operating system by DART ID.
  ## 
  let valid = call_581129.validator(path, query, header, formData, body)
  let scheme = call_581129.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581129.url(scheme.get, call_581129.host, call_581129.base,
                         call_581129.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581129, url, valid)

proc call*(call_581130: Call_DfareportingOperatingSystemsGet_581117;
          profileId: string; dartId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingOperatingSystemsGet
  ## Gets one operating system by DART ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   dartId: string (required)
  ##         : Operating system DART ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581131 = newJObject()
  var query_581132 = newJObject()
  add(query_581132, "key", newJString(key))
  add(query_581132, "prettyPrint", newJBool(prettyPrint))
  add(query_581132, "oauth_token", newJString(oauthToken))
  add(path_581131, "profileId", newJString(profileId))
  add(query_581132, "alt", newJString(alt))
  add(query_581132, "userIp", newJString(userIp))
  add(query_581132, "quotaUser", newJString(quotaUser))
  add(path_581131, "dartId", newJString(dartId))
  add(query_581132, "fields", newJString(fields))
  result = call_581130.call(path_581131, query_581132, nil, nil, nil)

var dfareportingOperatingSystemsGet* = Call_DfareportingOperatingSystemsGet_581117(
    name: "dfareportingOperatingSystemsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystems/{dartId}",
    validator: validate_DfareportingOperatingSystemsGet_581118,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemsGet_581119,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsUpdate_581167 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementGroupsUpdate_581169(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsUpdate_581168(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581170 = path.getOrDefault("profileId")
  valid_581170 = validateParameter(valid_581170, JString, required = true,
                                 default = nil)
  if valid_581170 != nil:
    section.add "profileId", valid_581170
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581171 = query.getOrDefault("key")
  valid_581171 = validateParameter(valid_581171, JString, required = false,
                                 default = nil)
  if valid_581171 != nil:
    section.add "key", valid_581171
  var valid_581172 = query.getOrDefault("prettyPrint")
  valid_581172 = validateParameter(valid_581172, JBool, required = false,
                                 default = newJBool(true))
  if valid_581172 != nil:
    section.add "prettyPrint", valid_581172
  var valid_581173 = query.getOrDefault("oauth_token")
  valid_581173 = validateParameter(valid_581173, JString, required = false,
                                 default = nil)
  if valid_581173 != nil:
    section.add "oauth_token", valid_581173
  var valid_581174 = query.getOrDefault("alt")
  valid_581174 = validateParameter(valid_581174, JString, required = false,
                                 default = newJString("json"))
  if valid_581174 != nil:
    section.add "alt", valid_581174
  var valid_581175 = query.getOrDefault("userIp")
  valid_581175 = validateParameter(valid_581175, JString, required = false,
                                 default = nil)
  if valid_581175 != nil:
    section.add "userIp", valid_581175
  var valid_581176 = query.getOrDefault("quotaUser")
  valid_581176 = validateParameter(valid_581176, JString, required = false,
                                 default = nil)
  if valid_581176 != nil:
    section.add "quotaUser", valid_581176
  var valid_581177 = query.getOrDefault("fields")
  valid_581177 = validateParameter(valid_581177, JString, required = false,
                                 default = nil)
  if valid_581177 != nil:
    section.add "fields", valid_581177
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581179: Call_DfareportingPlacementGroupsUpdate_581167;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement group.
  ## 
  let valid = call_581179.validator(path, query, header, formData, body)
  let scheme = call_581179.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581179.url(scheme.get, call_581179.host, call_581179.base,
                         call_581179.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581179, url, valid)

proc call*(call_581180: Call_DfareportingPlacementGroupsUpdate_581167;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingPlacementGroupsUpdate
  ## Updates an existing placement group.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581181 = newJObject()
  var query_581182 = newJObject()
  var body_581183 = newJObject()
  add(query_581182, "key", newJString(key))
  add(query_581182, "prettyPrint", newJBool(prettyPrint))
  add(query_581182, "oauth_token", newJString(oauthToken))
  add(path_581181, "profileId", newJString(profileId))
  add(query_581182, "alt", newJString(alt))
  add(query_581182, "userIp", newJString(userIp))
  add(query_581182, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_581183 = body
  add(query_581182, "fields", newJString(fields))
  result = call_581180.call(path_581181, query_581182, nil, nil, body_581183)

var dfareportingPlacementGroupsUpdate* = Call_DfareportingPlacementGroupsUpdate_581167(
    name: "dfareportingPlacementGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsUpdate_581168,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsUpdate_581169,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsInsert_581184 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementGroupsInsert_581186(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsInsert_581185(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new placement group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581187 = path.getOrDefault("profileId")
  valid_581187 = validateParameter(valid_581187, JString, required = true,
                                 default = nil)
  if valid_581187 != nil:
    section.add "profileId", valid_581187
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581188 = query.getOrDefault("key")
  valid_581188 = validateParameter(valid_581188, JString, required = false,
                                 default = nil)
  if valid_581188 != nil:
    section.add "key", valid_581188
  var valid_581189 = query.getOrDefault("prettyPrint")
  valid_581189 = validateParameter(valid_581189, JBool, required = false,
                                 default = newJBool(true))
  if valid_581189 != nil:
    section.add "prettyPrint", valid_581189
  var valid_581190 = query.getOrDefault("oauth_token")
  valid_581190 = validateParameter(valid_581190, JString, required = false,
                                 default = nil)
  if valid_581190 != nil:
    section.add "oauth_token", valid_581190
  var valid_581191 = query.getOrDefault("alt")
  valid_581191 = validateParameter(valid_581191, JString, required = false,
                                 default = newJString("json"))
  if valid_581191 != nil:
    section.add "alt", valid_581191
  var valid_581192 = query.getOrDefault("userIp")
  valid_581192 = validateParameter(valid_581192, JString, required = false,
                                 default = nil)
  if valid_581192 != nil:
    section.add "userIp", valid_581192
  var valid_581193 = query.getOrDefault("quotaUser")
  valid_581193 = validateParameter(valid_581193, JString, required = false,
                                 default = nil)
  if valid_581193 != nil:
    section.add "quotaUser", valid_581193
  var valid_581194 = query.getOrDefault("fields")
  valid_581194 = validateParameter(valid_581194, JString, required = false,
                                 default = nil)
  if valid_581194 != nil:
    section.add "fields", valid_581194
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581196: Call_DfareportingPlacementGroupsInsert_581184;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new placement group.
  ## 
  let valid = call_581196.validator(path, query, header, formData, body)
  let scheme = call_581196.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581196.url(scheme.get, call_581196.host, call_581196.base,
                         call_581196.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581196, url, valid)

proc call*(call_581197: Call_DfareportingPlacementGroupsInsert_581184;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingPlacementGroupsInsert
  ## Inserts a new placement group.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581198 = newJObject()
  var query_581199 = newJObject()
  var body_581200 = newJObject()
  add(query_581199, "key", newJString(key))
  add(query_581199, "prettyPrint", newJBool(prettyPrint))
  add(query_581199, "oauth_token", newJString(oauthToken))
  add(path_581198, "profileId", newJString(profileId))
  add(query_581199, "alt", newJString(alt))
  add(query_581199, "userIp", newJString(userIp))
  add(query_581199, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_581200 = body
  add(query_581199, "fields", newJString(fields))
  result = call_581197.call(path_581198, query_581199, nil, nil, body_581200)

var dfareportingPlacementGroupsInsert* = Call_DfareportingPlacementGroupsInsert_581184(
    name: "dfareportingPlacementGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsInsert_581185,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsInsert_581186,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsList_581133 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementGroupsList_581135(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsList_581134(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of placement groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581136 = path.getOrDefault("profileId")
  valid_581136 = validateParameter(valid_581136, JString, required = true,
                                 default = nil)
  if valid_581136 != nil:
    section.add "profileId", valid_581136
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   maxStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   placementStrategyIds: JArray
  ##                       : Select only placement groups that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placement groups with these pricing types.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placement groups that are associated with these content categories.
  ##   advertiserIds: JArray
  ##                : Select only placement groups that belong to these advertisers.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: JBool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   directorySiteIds: JArray
  ##                   : Select only placement groups that are associated with these directory sites.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   minStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   searchString: JString
  ##               : Allows searching for placement groups by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placement groups with names like "placement group June 2015", "placement group May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementgroup" will match placement groups with name "my placementgroup", "placementgroup 2015", or simply "placementgroup".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   siteIds: JArray
  ##          : Select only placement groups that are associated with these sites.
  ##   maxEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   campaignIds: JArray
  ##              : Select only placement groups that belong to these campaigns.
  ##   placementGroupType: JString
  ##                     : Select only placement groups belonging with this group type. A package is a simple group of placements that acts as a single pricing point for a group of tags. A roadblock is a group of placements that not only acts as a single pricing point but also assumes that all the tags in it will be served at the same time. A roadblock requires one of its assigned placements to be marked as primary for reporting.
  ##   ids: JArray
  ##      : Select only placement groups with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   minEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  section = newJObject()
  var valid_581137 = query.getOrDefault("key")
  valid_581137 = validateParameter(valid_581137, JString, required = false,
                                 default = nil)
  if valid_581137 != nil:
    section.add "key", valid_581137
  var valid_581138 = query.getOrDefault("maxStartDate")
  valid_581138 = validateParameter(valid_581138, JString, required = false,
                                 default = nil)
  if valid_581138 != nil:
    section.add "maxStartDate", valid_581138
  var valid_581139 = query.getOrDefault("prettyPrint")
  valid_581139 = validateParameter(valid_581139, JBool, required = false,
                                 default = newJBool(true))
  if valid_581139 != nil:
    section.add "prettyPrint", valid_581139
  var valid_581140 = query.getOrDefault("oauth_token")
  valid_581140 = validateParameter(valid_581140, JString, required = false,
                                 default = nil)
  if valid_581140 != nil:
    section.add "oauth_token", valid_581140
  var valid_581141 = query.getOrDefault("placementStrategyIds")
  valid_581141 = validateParameter(valid_581141, JArray, required = false,
                                 default = nil)
  if valid_581141 != nil:
    section.add "placementStrategyIds", valid_581141
  var valid_581142 = query.getOrDefault("pricingTypes")
  valid_581142 = validateParameter(valid_581142, JArray, required = false,
                                 default = nil)
  if valid_581142 != nil:
    section.add "pricingTypes", valid_581142
  var valid_581143 = query.getOrDefault("sortField")
  valid_581143 = validateParameter(valid_581143, JString, required = false,
                                 default = newJString("ID"))
  if valid_581143 != nil:
    section.add "sortField", valid_581143
  var valid_581144 = query.getOrDefault("contentCategoryIds")
  valid_581144 = validateParameter(valid_581144, JArray, required = false,
                                 default = nil)
  if valid_581144 != nil:
    section.add "contentCategoryIds", valid_581144
  var valid_581145 = query.getOrDefault("advertiserIds")
  valid_581145 = validateParameter(valid_581145, JArray, required = false,
                                 default = nil)
  if valid_581145 != nil:
    section.add "advertiserIds", valid_581145
  var valid_581146 = query.getOrDefault("alt")
  valid_581146 = validateParameter(valid_581146, JString, required = false,
                                 default = newJString("json"))
  if valid_581146 != nil:
    section.add "alt", valid_581146
  var valid_581147 = query.getOrDefault("userIp")
  valid_581147 = validateParameter(valid_581147, JString, required = false,
                                 default = nil)
  if valid_581147 != nil:
    section.add "userIp", valid_581147
  var valid_581148 = query.getOrDefault("archived")
  valid_581148 = validateParameter(valid_581148, JBool, required = false, default = nil)
  if valid_581148 != nil:
    section.add "archived", valid_581148
  var valid_581149 = query.getOrDefault("quotaUser")
  valid_581149 = validateParameter(valid_581149, JString, required = false,
                                 default = nil)
  if valid_581149 != nil:
    section.add "quotaUser", valid_581149
  var valid_581150 = query.getOrDefault("directorySiteIds")
  valid_581150 = validateParameter(valid_581150, JArray, required = false,
                                 default = nil)
  if valid_581150 != nil:
    section.add "directorySiteIds", valid_581150
  var valid_581151 = query.getOrDefault("pageToken")
  valid_581151 = validateParameter(valid_581151, JString, required = false,
                                 default = nil)
  if valid_581151 != nil:
    section.add "pageToken", valid_581151
  var valid_581152 = query.getOrDefault("minStartDate")
  valid_581152 = validateParameter(valid_581152, JString, required = false,
                                 default = nil)
  if valid_581152 != nil:
    section.add "minStartDate", valid_581152
  var valid_581153 = query.getOrDefault("searchString")
  valid_581153 = validateParameter(valid_581153, JString, required = false,
                                 default = nil)
  if valid_581153 != nil:
    section.add "searchString", valid_581153
  var valid_581154 = query.getOrDefault("sortOrder")
  valid_581154 = validateParameter(valid_581154, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581154 != nil:
    section.add "sortOrder", valid_581154
  var valid_581155 = query.getOrDefault("siteIds")
  valid_581155 = validateParameter(valid_581155, JArray, required = false,
                                 default = nil)
  if valid_581155 != nil:
    section.add "siteIds", valid_581155
  var valid_581156 = query.getOrDefault("maxEndDate")
  valid_581156 = validateParameter(valid_581156, JString, required = false,
                                 default = nil)
  if valid_581156 != nil:
    section.add "maxEndDate", valid_581156
  var valid_581157 = query.getOrDefault("campaignIds")
  valid_581157 = validateParameter(valid_581157, JArray, required = false,
                                 default = nil)
  if valid_581157 != nil:
    section.add "campaignIds", valid_581157
  var valid_581158 = query.getOrDefault("placementGroupType")
  valid_581158 = validateParameter(valid_581158, JString, required = false,
                                 default = newJString("PLACEMENT_PACKAGE"))
  if valid_581158 != nil:
    section.add "placementGroupType", valid_581158
  var valid_581159 = query.getOrDefault("ids")
  valid_581159 = validateParameter(valid_581159, JArray, required = false,
                                 default = nil)
  if valid_581159 != nil:
    section.add "ids", valid_581159
  var valid_581160 = query.getOrDefault("fields")
  valid_581160 = validateParameter(valid_581160, JString, required = false,
                                 default = nil)
  if valid_581160 != nil:
    section.add "fields", valid_581160
  var valid_581161 = query.getOrDefault("maxResults")
  valid_581161 = validateParameter(valid_581161, JInt, required = false,
                                 default = newJInt(800))
  if valid_581161 != nil:
    section.add "maxResults", valid_581161
  var valid_581162 = query.getOrDefault("minEndDate")
  valid_581162 = validateParameter(valid_581162, JString, required = false,
                                 default = nil)
  if valid_581162 != nil:
    section.add "minEndDate", valid_581162
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581163: Call_DfareportingPlacementGroupsList_581133;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of placement groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_581163.validator(path, query, header, formData, body)
  let scheme = call_581163.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581163.url(scheme.get, call_581163.host, call_581163.base,
                         call_581163.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581163, url, valid)

proc call*(call_581164: Call_DfareportingPlacementGroupsList_581133;
          profileId: string; key: string = ""; maxStartDate: string = "";
          prettyPrint: bool = true; oauthToken: string = "";
          placementStrategyIds: JsonNode = nil; pricingTypes: JsonNode = nil;
          sortField: string = "ID"; contentCategoryIds: JsonNode = nil;
          advertiserIds: JsonNode = nil; alt: string = "json"; userIp: string = "";
          archived: bool = false; quotaUser: string = "";
          directorySiteIds: JsonNode = nil; pageToken: string = "";
          minStartDate: string = ""; searchString: string = "";
          sortOrder: string = "ASCENDING"; siteIds: JsonNode = nil;
          maxEndDate: string = ""; campaignIds: JsonNode = nil;
          placementGroupType: string = "PLACEMENT_PACKAGE"; ids: JsonNode = nil;
          fields: string = ""; maxResults: int = 800; minEndDate: string = ""): Recallable =
  ## dfareportingPlacementGroupsList
  ## Retrieves a list of placement groups, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   maxStartDate: string
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   placementStrategyIds: JArray
  ##                       : Select only placement groups that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placement groups with these pricing types.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placement groups that are associated with these content categories.
  ##   advertiserIds: JArray
  ##                : Select only placement groups that belong to these advertisers.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: bool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   directorySiteIds: JArray
  ##                   : Select only placement groups that are associated with these directory sites.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   minStartDate: string
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   searchString: string
  ##               : Allows searching for placement groups by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placement groups with names like "placement group June 2015", "placement group May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementgroup" will match placement groups with name "my placementgroup", "placementgroup 2015", or simply "placementgroup".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   siteIds: JArray
  ##          : Select only placement groups that are associated with these sites.
  ##   maxEndDate: string
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   campaignIds: JArray
  ##              : Select only placement groups that belong to these campaigns.
  ##   placementGroupType: string
  ##                     : Select only placement groups belonging with this group type. A package is a simple group of placements that acts as a single pricing point for a group of tags. A roadblock is a group of placements that not only acts as a single pricing point but also assumes that all the tags in it will be served at the same time. A roadblock requires one of its assigned placements to be marked as primary for reporting.
  ##   ids: JArray
  ##      : Select only placement groups with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   minEndDate: string
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  var path_581165 = newJObject()
  var query_581166 = newJObject()
  add(query_581166, "key", newJString(key))
  add(query_581166, "maxStartDate", newJString(maxStartDate))
  add(query_581166, "prettyPrint", newJBool(prettyPrint))
  add(query_581166, "oauth_token", newJString(oauthToken))
  if placementStrategyIds != nil:
    query_581166.add "placementStrategyIds", placementStrategyIds
  if pricingTypes != nil:
    query_581166.add "pricingTypes", pricingTypes
  add(path_581165, "profileId", newJString(profileId))
  add(query_581166, "sortField", newJString(sortField))
  if contentCategoryIds != nil:
    query_581166.add "contentCategoryIds", contentCategoryIds
  if advertiserIds != nil:
    query_581166.add "advertiserIds", advertiserIds
  add(query_581166, "alt", newJString(alt))
  add(query_581166, "userIp", newJString(userIp))
  add(query_581166, "archived", newJBool(archived))
  add(query_581166, "quotaUser", newJString(quotaUser))
  if directorySiteIds != nil:
    query_581166.add "directorySiteIds", directorySiteIds
  add(query_581166, "pageToken", newJString(pageToken))
  add(query_581166, "minStartDate", newJString(minStartDate))
  add(query_581166, "searchString", newJString(searchString))
  add(query_581166, "sortOrder", newJString(sortOrder))
  if siteIds != nil:
    query_581166.add "siteIds", siteIds
  add(query_581166, "maxEndDate", newJString(maxEndDate))
  if campaignIds != nil:
    query_581166.add "campaignIds", campaignIds
  add(query_581166, "placementGroupType", newJString(placementGroupType))
  if ids != nil:
    query_581166.add "ids", ids
  add(query_581166, "fields", newJString(fields))
  add(query_581166, "maxResults", newJInt(maxResults))
  add(query_581166, "minEndDate", newJString(minEndDate))
  result = call_581164.call(path_581165, query_581166, nil, nil, nil)

var dfareportingPlacementGroupsList* = Call_DfareportingPlacementGroupsList_581133(
    name: "dfareportingPlacementGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsList_581134,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsList_581135,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsPatch_581201 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementGroupsPatch_581203(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsPatch_581202(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581204 = path.getOrDefault("profileId")
  valid_581204 = validateParameter(valid_581204, JString, required = true,
                                 default = nil)
  if valid_581204 != nil:
    section.add "profileId", valid_581204
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Placement group ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581205 = query.getOrDefault("key")
  valid_581205 = validateParameter(valid_581205, JString, required = false,
                                 default = nil)
  if valid_581205 != nil:
    section.add "key", valid_581205
  var valid_581206 = query.getOrDefault("prettyPrint")
  valid_581206 = validateParameter(valid_581206, JBool, required = false,
                                 default = newJBool(true))
  if valid_581206 != nil:
    section.add "prettyPrint", valid_581206
  var valid_581207 = query.getOrDefault("oauth_token")
  valid_581207 = validateParameter(valid_581207, JString, required = false,
                                 default = nil)
  if valid_581207 != nil:
    section.add "oauth_token", valid_581207
  var valid_581208 = query.getOrDefault("alt")
  valid_581208 = validateParameter(valid_581208, JString, required = false,
                                 default = newJString("json"))
  if valid_581208 != nil:
    section.add "alt", valid_581208
  var valid_581209 = query.getOrDefault("userIp")
  valid_581209 = validateParameter(valid_581209, JString, required = false,
                                 default = nil)
  if valid_581209 != nil:
    section.add "userIp", valid_581209
  var valid_581210 = query.getOrDefault("quotaUser")
  valid_581210 = validateParameter(valid_581210, JString, required = false,
                                 default = nil)
  if valid_581210 != nil:
    section.add "quotaUser", valid_581210
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_581211 = query.getOrDefault("id")
  valid_581211 = validateParameter(valid_581211, JString, required = true,
                                 default = nil)
  if valid_581211 != nil:
    section.add "id", valid_581211
  var valid_581212 = query.getOrDefault("fields")
  valid_581212 = validateParameter(valid_581212, JString, required = false,
                                 default = nil)
  if valid_581212 != nil:
    section.add "fields", valid_581212
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581214: Call_DfareportingPlacementGroupsPatch_581201;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement group. This method supports patch semantics.
  ## 
  let valid = call_581214.validator(path, query, header, formData, body)
  let scheme = call_581214.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581214.url(scheme.get, call_581214.host, call_581214.base,
                         call_581214.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581214, url, valid)

proc call*(call_581215: Call_DfareportingPlacementGroupsPatch_581201;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingPlacementGroupsPatch
  ## Updates an existing placement group. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Placement group ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581216 = newJObject()
  var query_581217 = newJObject()
  var body_581218 = newJObject()
  add(query_581217, "key", newJString(key))
  add(query_581217, "prettyPrint", newJBool(prettyPrint))
  add(query_581217, "oauth_token", newJString(oauthToken))
  add(path_581216, "profileId", newJString(profileId))
  add(query_581217, "alt", newJString(alt))
  add(query_581217, "userIp", newJString(userIp))
  add(query_581217, "quotaUser", newJString(quotaUser))
  add(query_581217, "id", newJString(id))
  if body != nil:
    body_581218 = body
  add(query_581217, "fields", newJString(fields))
  result = call_581215.call(path_581216, query_581217, nil, nil, body_581218)

var dfareportingPlacementGroupsPatch* = Call_DfareportingPlacementGroupsPatch_581201(
    name: "dfareportingPlacementGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsPatch_581202,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsPatch_581203,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsGet_581219 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementGroupsGet_581221(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsGet_581220(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one placement group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581222 = path.getOrDefault("profileId")
  valid_581222 = validateParameter(valid_581222, JString, required = true,
                                 default = nil)
  if valid_581222 != nil:
    section.add "profileId", valid_581222
  var valid_581223 = path.getOrDefault("id")
  valid_581223 = validateParameter(valid_581223, JString, required = true,
                                 default = nil)
  if valid_581223 != nil:
    section.add "id", valid_581223
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581224 = query.getOrDefault("key")
  valid_581224 = validateParameter(valid_581224, JString, required = false,
                                 default = nil)
  if valid_581224 != nil:
    section.add "key", valid_581224
  var valid_581225 = query.getOrDefault("prettyPrint")
  valid_581225 = validateParameter(valid_581225, JBool, required = false,
                                 default = newJBool(true))
  if valid_581225 != nil:
    section.add "prettyPrint", valid_581225
  var valid_581226 = query.getOrDefault("oauth_token")
  valid_581226 = validateParameter(valid_581226, JString, required = false,
                                 default = nil)
  if valid_581226 != nil:
    section.add "oauth_token", valid_581226
  var valid_581227 = query.getOrDefault("alt")
  valid_581227 = validateParameter(valid_581227, JString, required = false,
                                 default = newJString("json"))
  if valid_581227 != nil:
    section.add "alt", valid_581227
  var valid_581228 = query.getOrDefault("userIp")
  valid_581228 = validateParameter(valid_581228, JString, required = false,
                                 default = nil)
  if valid_581228 != nil:
    section.add "userIp", valid_581228
  var valid_581229 = query.getOrDefault("quotaUser")
  valid_581229 = validateParameter(valid_581229, JString, required = false,
                                 default = nil)
  if valid_581229 != nil:
    section.add "quotaUser", valid_581229
  var valid_581230 = query.getOrDefault("fields")
  valid_581230 = validateParameter(valid_581230, JString, required = false,
                                 default = nil)
  if valid_581230 != nil:
    section.add "fields", valid_581230
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581231: Call_DfareportingPlacementGroupsGet_581219; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one placement group by ID.
  ## 
  let valid = call_581231.validator(path, query, header, formData, body)
  let scheme = call_581231.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581231.url(scheme.get, call_581231.host, call_581231.base,
                         call_581231.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581231, url, valid)

proc call*(call_581232: Call_DfareportingPlacementGroupsGet_581219;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingPlacementGroupsGet
  ## Gets one placement group by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Placement group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581233 = newJObject()
  var query_581234 = newJObject()
  add(query_581234, "key", newJString(key))
  add(query_581234, "prettyPrint", newJBool(prettyPrint))
  add(query_581234, "oauth_token", newJString(oauthToken))
  add(path_581233, "profileId", newJString(profileId))
  add(path_581233, "id", newJString(id))
  add(query_581234, "alt", newJString(alt))
  add(query_581234, "userIp", newJString(userIp))
  add(query_581234, "quotaUser", newJString(quotaUser))
  add(query_581234, "fields", newJString(fields))
  result = call_581232.call(path_581233, query_581234, nil, nil, nil)

var dfareportingPlacementGroupsGet* = Call_DfareportingPlacementGroupsGet_581219(
    name: "dfareportingPlacementGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups/{id}",
    validator: validate_DfareportingPlacementGroupsGet_581220,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsGet_581221,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesUpdate_581256 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementStrategiesUpdate_581258(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesUpdate_581257(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement strategy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581259 = path.getOrDefault("profileId")
  valid_581259 = validateParameter(valid_581259, JString, required = true,
                                 default = nil)
  if valid_581259 != nil:
    section.add "profileId", valid_581259
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581260 = query.getOrDefault("key")
  valid_581260 = validateParameter(valid_581260, JString, required = false,
                                 default = nil)
  if valid_581260 != nil:
    section.add "key", valid_581260
  var valid_581261 = query.getOrDefault("prettyPrint")
  valid_581261 = validateParameter(valid_581261, JBool, required = false,
                                 default = newJBool(true))
  if valid_581261 != nil:
    section.add "prettyPrint", valid_581261
  var valid_581262 = query.getOrDefault("oauth_token")
  valid_581262 = validateParameter(valid_581262, JString, required = false,
                                 default = nil)
  if valid_581262 != nil:
    section.add "oauth_token", valid_581262
  var valid_581263 = query.getOrDefault("alt")
  valid_581263 = validateParameter(valid_581263, JString, required = false,
                                 default = newJString("json"))
  if valid_581263 != nil:
    section.add "alt", valid_581263
  var valid_581264 = query.getOrDefault("userIp")
  valid_581264 = validateParameter(valid_581264, JString, required = false,
                                 default = nil)
  if valid_581264 != nil:
    section.add "userIp", valid_581264
  var valid_581265 = query.getOrDefault("quotaUser")
  valid_581265 = validateParameter(valid_581265, JString, required = false,
                                 default = nil)
  if valid_581265 != nil:
    section.add "quotaUser", valid_581265
  var valid_581266 = query.getOrDefault("fields")
  valid_581266 = validateParameter(valid_581266, JString, required = false,
                                 default = nil)
  if valid_581266 != nil:
    section.add "fields", valid_581266
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581268: Call_DfareportingPlacementStrategiesUpdate_581256;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement strategy.
  ## 
  let valid = call_581268.validator(path, query, header, formData, body)
  let scheme = call_581268.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581268.url(scheme.get, call_581268.host, call_581268.base,
                         call_581268.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581268, url, valid)

proc call*(call_581269: Call_DfareportingPlacementStrategiesUpdate_581256;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingPlacementStrategiesUpdate
  ## Updates an existing placement strategy.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581270 = newJObject()
  var query_581271 = newJObject()
  var body_581272 = newJObject()
  add(query_581271, "key", newJString(key))
  add(query_581271, "prettyPrint", newJBool(prettyPrint))
  add(query_581271, "oauth_token", newJString(oauthToken))
  add(path_581270, "profileId", newJString(profileId))
  add(query_581271, "alt", newJString(alt))
  add(query_581271, "userIp", newJString(userIp))
  add(query_581271, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_581272 = body
  add(query_581271, "fields", newJString(fields))
  result = call_581269.call(path_581270, query_581271, nil, nil, body_581272)

var dfareportingPlacementStrategiesUpdate* = Call_DfareportingPlacementStrategiesUpdate_581256(
    name: "dfareportingPlacementStrategiesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesUpdate_581257,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesUpdate_581258,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesInsert_581273 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementStrategiesInsert_581275(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesInsert_581274(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new placement strategy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581276 = path.getOrDefault("profileId")
  valid_581276 = validateParameter(valid_581276, JString, required = true,
                                 default = nil)
  if valid_581276 != nil:
    section.add "profileId", valid_581276
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581277 = query.getOrDefault("key")
  valid_581277 = validateParameter(valid_581277, JString, required = false,
                                 default = nil)
  if valid_581277 != nil:
    section.add "key", valid_581277
  var valid_581278 = query.getOrDefault("prettyPrint")
  valid_581278 = validateParameter(valid_581278, JBool, required = false,
                                 default = newJBool(true))
  if valid_581278 != nil:
    section.add "prettyPrint", valid_581278
  var valid_581279 = query.getOrDefault("oauth_token")
  valid_581279 = validateParameter(valid_581279, JString, required = false,
                                 default = nil)
  if valid_581279 != nil:
    section.add "oauth_token", valid_581279
  var valid_581280 = query.getOrDefault("alt")
  valid_581280 = validateParameter(valid_581280, JString, required = false,
                                 default = newJString("json"))
  if valid_581280 != nil:
    section.add "alt", valid_581280
  var valid_581281 = query.getOrDefault("userIp")
  valid_581281 = validateParameter(valid_581281, JString, required = false,
                                 default = nil)
  if valid_581281 != nil:
    section.add "userIp", valid_581281
  var valid_581282 = query.getOrDefault("quotaUser")
  valid_581282 = validateParameter(valid_581282, JString, required = false,
                                 default = nil)
  if valid_581282 != nil:
    section.add "quotaUser", valid_581282
  var valid_581283 = query.getOrDefault("fields")
  valid_581283 = validateParameter(valid_581283, JString, required = false,
                                 default = nil)
  if valid_581283 != nil:
    section.add "fields", valid_581283
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581285: Call_DfareportingPlacementStrategiesInsert_581273;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new placement strategy.
  ## 
  let valid = call_581285.validator(path, query, header, formData, body)
  let scheme = call_581285.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581285.url(scheme.get, call_581285.host, call_581285.base,
                         call_581285.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581285, url, valid)

proc call*(call_581286: Call_DfareportingPlacementStrategiesInsert_581273;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingPlacementStrategiesInsert
  ## Inserts a new placement strategy.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581287 = newJObject()
  var query_581288 = newJObject()
  var body_581289 = newJObject()
  add(query_581288, "key", newJString(key))
  add(query_581288, "prettyPrint", newJBool(prettyPrint))
  add(query_581288, "oauth_token", newJString(oauthToken))
  add(path_581287, "profileId", newJString(profileId))
  add(query_581288, "alt", newJString(alt))
  add(query_581288, "userIp", newJString(userIp))
  add(query_581288, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_581289 = body
  add(query_581288, "fields", newJString(fields))
  result = call_581286.call(path_581287, query_581288, nil, nil, body_581289)

var dfareportingPlacementStrategiesInsert* = Call_DfareportingPlacementStrategiesInsert_581273(
    name: "dfareportingPlacementStrategiesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesInsert_581274,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesInsert_581275,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesList_581235 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementStrategiesList_581237(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesList_581236(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of placement strategies, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581238 = path.getOrDefault("profileId")
  valid_581238 = validateParameter(valid_581238, JString, required = true,
                                 default = nil)
  if valid_581238 != nil:
    section.add "profileId", valid_581238
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "placementstrategy*2015" will return objects with names like "placementstrategy June 2015", "placementstrategy April 2015", or simply "placementstrategy 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementstrategy" will match objects with name "my placementstrategy", "placementstrategy 2015", or simply "placementstrategy".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only placement strategies with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_581239 = query.getOrDefault("key")
  valid_581239 = validateParameter(valid_581239, JString, required = false,
                                 default = nil)
  if valid_581239 != nil:
    section.add "key", valid_581239
  var valid_581240 = query.getOrDefault("prettyPrint")
  valid_581240 = validateParameter(valid_581240, JBool, required = false,
                                 default = newJBool(true))
  if valid_581240 != nil:
    section.add "prettyPrint", valid_581240
  var valid_581241 = query.getOrDefault("oauth_token")
  valid_581241 = validateParameter(valid_581241, JString, required = false,
                                 default = nil)
  if valid_581241 != nil:
    section.add "oauth_token", valid_581241
  var valid_581242 = query.getOrDefault("sortField")
  valid_581242 = validateParameter(valid_581242, JString, required = false,
                                 default = newJString("ID"))
  if valid_581242 != nil:
    section.add "sortField", valid_581242
  var valid_581243 = query.getOrDefault("alt")
  valid_581243 = validateParameter(valid_581243, JString, required = false,
                                 default = newJString("json"))
  if valid_581243 != nil:
    section.add "alt", valid_581243
  var valid_581244 = query.getOrDefault("userIp")
  valid_581244 = validateParameter(valid_581244, JString, required = false,
                                 default = nil)
  if valid_581244 != nil:
    section.add "userIp", valid_581244
  var valid_581245 = query.getOrDefault("quotaUser")
  valid_581245 = validateParameter(valid_581245, JString, required = false,
                                 default = nil)
  if valid_581245 != nil:
    section.add "quotaUser", valid_581245
  var valid_581246 = query.getOrDefault("pageToken")
  valid_581246 = validateParameter(valid_581246, JString, required = false,
                                 default = nil)
  if valid_581246 != nil:
    section.add "pageToken", valid_581246
  var valid_581247 = query.getOrDefault("searchString")
  valid_581247 = validateParameter(valid_581247, JString, required = false,
                                 default = nil)
  if valid_581247 != nil:
    section.add "searchString", valid_581247
  var valid_581248 = query.getOrDefault("sortOrder")
  valid_581248 = validateParameter(valid_581248, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581248 != nil:
    section.add "sortOrder", valid_581248
  var valid_581249 = query.getOrDefault("ids")
  valid_581249 = validateParameter(valid_581249, JArray, required = false,
                                 default = nil)
  if valid_581249 != nil:
    section.add "ids", valid_581249
  var valid_581250 = query.getOrDefault("fields")
  valid_581250 = validateParameter(valid_581250, JString, required = false,
                                 default = nil)
  if valid_581250 != nil:
    section.add "fields", valid_581250
  var valid_581251 = query.getOrDefault("maxResults")
  valid_581251 = validateParameter(valid_581251, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581251 != nil:
    section.add "maxResults", valid_581251
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581252: Call_DfareportingPlacementStrategiesList_581235;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of placement strategies, possibly filtered. This method supports paging.
  ## 
  let valid = call_581252.validator(path, query, header, formData, body)
  let scheme = call_581252.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581252.url(scheme.get, call_581252.host, call_581252.base,
                         call_581252.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581252, url, valid)

proc call*(call_581253: Call_DfareportingPlacementStrategiesList_581235;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; sortField: string = "ID"; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; pageToken: string = "";
          searchString: string = ""; sortOrder: string = "ASCENDING";
          ids: JsonNode = nil; fields: string = ""; maxResults: int = 1000): Recallable =
  ## dfareportingPlacementStrategiesList
  ## Retrieves a list of placement strategies, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "placementstrategy*2015" will return objects with names like "placementstrategy June 2015", "placementstrategy April 2015", or simply "placementstrategy 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementstrategy" will match objects with name "my placementstrategy", "placementstrategy 2015", or simply "placementstrategy".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only placement strategies with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_581254 = newJObject()
  var query_581255 = newJObject()
  add(query_581255, "key", newJString(key))
  add(query_581255, "prettyPrint", newJBool(prettyPrint))
  add(query_581255, "oauth_token", newJString(oauthToken))
  add(path_581254, "profileId", newJString(profileId))
  add(query_581255, "sortField", newJString(sortField))
  add(query_581255, "alt", newJString(alt))
  add(query_581255, "userIp", newJString(userIp))
  add(query_581255, "quotaUser", newJString(quotaUser))
  add(query_581255, "pageToken", newJString(pageToken))
  add(query_581255, "searchString", newJString(searchString))
  add(query_581255, "sortOrder", newJString(sortOrder))
  if ids != nil:
    query_581255.add "ids", ids
  add(query_581255, "fields", newJString(fields))
  add(query_581255, "maxResults", newJInt(maxResults))
  result = call_581253.call(path_581254, query_581255, nil, nil, nil)

var dfareportingPlacementStrategiesList* = Call_DfareportingPlacementStrategiesList_581235(
    name: "dfareportingPlacementStrategiesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesList_581236,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesList_581237,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesPatch_581290 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementStrategiesPatch_581292(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesPatch_581291(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement strategy. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581293 = path.getOrDefault("profileId")
  valid_581293 = validateParameter(valid_581293, JString, required = true,
                                 default = nil)
  if valid_581293 != nil:
    section.add "profileId", valid_581293
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Placement strategy ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581294 = query.getOrDefault("key")
  valid_581294 = validateParameter(valid_581294, JString, required = false,
                                 default = nil)
  if valid_581294 != nil:
    section.add "key", valid_581294
  var valid_581295 = query.getOrDefault("prettyPrint")
  valid_581295 = validateParameter(valid_581295, JBool, required = false,
                                 default = newJBool(true))
  if valid_581295 != nil:
    section.add "prettyPrint", valid_581295
  var valid_581296 = query.getOrDefault("oauth_token")
  valid_581296 = validateParameter(valid_581296, JString, required = false,
                                 default = nil)
  if valid_581296 != nil:
    section.add "oauth_token", valid_581296
  var valid_581297 = query.getOrDefault("alt")
  valid_581297 = validateParameter(valid_581297, JString, required = false,
                                 default = newJString("json"))
  if valid_581297 != nil:
    section.add "alt", valid_581297
  var valid_581298 = query.getOrDefault("userIp")
  valid_581298 = validateParameter(valid_581298, JString, required = false,
                                 default = nil)
  if valid_581298 != nil:
    section.add "userIp", valid_581298
  var valid_581299 = query.getOrDefault("quotaUser")
  valid_581299 = validateParameter(valid_581299, JString, required = false,
                                 default = nil)
  if valid_581299 != nil:
    section.add "quotaUser", valid_581299
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_581300 = query.getOrDefault("id")
  valid_581300 = validateParameter(valid_581300, JString, required = true,
                                 default = nil)
  if valid_581300 != nil:
    section.add "id", valid_581300
  var valid_581301 = query.getOrDefault("fields")
  valid_581301 = validateParameter(valid_581301, JString, required = false,
                                 default = nil)
  if valid_581301 != nil:
    section.add "fields", valid_581301
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581303: Call_DfareportingPlacementStrategiesPatch_581290;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement strategy. This method supports patch semantics.
  ## 
  let valid = call_581303.validator(path, query, header, formData, body)
  let scheme = call_581303.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581303.url(scheme.get, call_581303.host, call_581303.base,
                         call_581303.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581303, url, valid)

proc call*(call_581304: Call_DfareportingPlacementStrategiesPatch_581290;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingPlacementStrategiesPatch
  ## Updates an existing placement strategy. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Placement strategy ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581305 = newJObject()
  var query_581306 = newJObject()
  var body_581307 = newJObject()
  add(query_581306, "key", newJString(key))
  add(query_581306, "prettyPrint", newJBool(prettyPrint))
  add(query_581306, "oauth_token", newJString(oauthToken))
  add(path_581305, "profileId", newJString(profileId))
  add(query_581306, "alt", newJString(alt))
  add(query_581306, "userIp", newJString(userIp))
  add(query_581306, "quotaUser", newJString(quotaUser))
  add(query_581306, "id", newJString(id))
  if body != nil:
    body_581307 = body
  add(query_581306, "fields", newJString(fields))
  result = call_581304.call(path_581305, query_581306, nil, nil, body_581307)

var dfareportingPlacementStrategiesPatch* = Call_DfareportingPlacementStrategiesPatch_581290(
    name: "dfareportingPlacementStrategiesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesPatch_581291,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesPatch_581292,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesGet_581308 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementStrategiesGet_581310(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesGet_581309(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one placement strategy by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement strategy ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581311 = path.getOrDefault("profileId")
  valid_581311 = validateParameter(valid_581311, JString, required = true,
                                 default = nil)
  if valid_581311 != nil:
    section.add "profileId", valid_581311
  var valid_581312 = path.getOrDefault("id")
  valid_581312 = validateParameter(valid_581312, JString, required = true,
                                 default = nil)
  if valid_581312 != nil:
    section.add "id", valid_581312
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581313 = query.getOrDefault("key")
  valid_581313 = validateParameter(valid_581313, JString, required = false,
                                 default = nil)
  if valid_581313 != nil:
    section.add "key", valid_581313
  var valid_581314 = query.getOrDefault("prettyPrint")
  valid_581314 = validateParameter(valid_581314, JBool, required = false,
                                 default = newJBool(true))
  if valid_581314 != nil:
    section.add "prettyPrint", valid_581314
  var valid_581315 = query.getOrDefault("oauth_token")
  valid_581315 = validateParameter(valid_581315, JString, required = false,
                                 default = nil)
  if valid_581315 != nil:
    section.add "oauth_token", valid_581315
  var valid_581316 = query.getOrDefault("alt")
  valid_581316 = validateParameter(valid_581316, JString, required = false,
                                 default = newJString("json"))
  if valid_581316 != nil:
    section.add "alt", valid_581316
  var valid_581317 = query.getOrDefault("userIp")
  valid_581317 = validateParameter(valid_581317, JString, required = false,
                                 default = nil)
  if valid_581317 != nil:
    section.add "userIp", valid_581317
  var valid_581318 = query.getOrDefault("quotaUser")
  valid_581318 = validateParameter(valid_581318, JString, required = false,
                                 default = nil)
  if valid_581318 != nil:
    section.add "quotaUser", valid_581318
  var valid_581319 = query.getOrDefault("fields")
  valid_581319 = validateParameter(valid_581319, JString, required = false,
                                 default = nil)
  if valid_581319 != nil:
    section.add "fields", valid_581319
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581320: Call_DfareportingPlacementStrategiesGet_581308;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one placement strategy by ID.
  ## 
  let valid = call_581320.validator(path, query, header, formData, body)
  let scheme = call_581320.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581320.url(scheme.get, call_581320.host, call_581320.base,
                         call_581320.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581320, url, valid)

proc call*(call_581321: Call_DfareportingPlacementStrategiesGet_581308;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingPlacementStrategiesGet
  ## Gets one placement strategy by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Placement strategy ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581322 = newJObject()
  var query_581323 = newJObject()
  add(query_581323, "key", newJString(key))
  add(query_581323, "prettyPrint", newJBool(prettyPrint))
  add(query_581323, "oauth_token", newJString(oauthToken))
  add(path_581322, "profileId", newJString(profileId))
  add(path_581322, "id", newJString(id))
  add(query_581323, "alt", newJString(alt))
  add(query_581323, "userIp", newJString(userIp))
  add(query_581323, "quotaUser", newJString(quotaUser))
  add(query_581323, "fields", newJString(fields))
  result = call_581321.call(path_581322, query_581323, nil, nil, nil)

var dfareportingPlacementStrategiesGet* = Call_DfareportingPlacementStrategiesGet_581308(
    name: "dfareportingPlacementStrategiesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies/{id}",
    validator: validate_DfareportingPlacementStrategiesGet_581309,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesGet_581310,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesDelete_581324 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementStrategiesDelete_581326(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesDelete_581325(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing placement strategy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement strategy ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581327 = path.getOrDefault("profileId")
  valid_581327 = validateParameter(valid_581327, JString, required = true,
                                 default = nil)
  if valid_581327 != nil:
    section.add "profileId", valid_581327
  var valid_581328 = path.getOrDefault("id")
  valid_581328 = validateParameter(valid_581328, JString, required = true,
                                 default = nil)
  if valid_581328 != nil:
    section.add "id", valid_581328
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581329 = query.getOrDefault("key")
  valid_581329 = validateParameter(valid_581329, JString, required = false,
                                 default = nil)
  if valid_581329 != nil:
    section.add "key", valid_581329
  var valid_581330 = query.getOrDefault("prettyPrint")
  valid_581330 = validateParameter(valid_581330, JBool, required = false,
                                 default = newJBool(true))
  if valid_581330 != nil:
    section.add "prettyPrint", valid_581330
  var valid_581331 = query.getOrDefault("oauth_token")
  valid_581331 = validateParameter(valid_581331, JString, required = false,
                                 default = nil)
  if valid_581331 != nil:
    section.add "oauth_token", valid_581331
  var valid_581332 = query.getOrDefault("alt")
  valid_581332 = validateParameter(valid_581332, JString, required = false,
                                 default = newJString("json"))
  if valid_581332 != nil:
    section.add "alt", valid_581332
  var valid_581333 = query.getOrDefault("userIp")
  valid_581333 = validateParameter(valid_581333, JString, required = false,
                                 default = nil)
  if valid_581333 != nil:
    section.add "userIp", valid_581333
  var valid_581334 = query.getOrDefault("quotaUser")
  valid_581334 = validateParameter(valid_581334, JString, required = false,
                                 default = nil)
  if valid_581334 != nil:
    section.add "quotaUser", valid_581334
  var valid_581335 = query.getOrDefault("fields")
  valid_581335 = validateParameter(valid_581335, JString, required = false,
                                 default = nil)
  if valid_581335 != nil:
    section.add "fields", valid_581335
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581336: Call_DfareportingPlacementStrategiesDelete_581324;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing placement strategy.
  ## 
  let valid = call_581336.validator(path, query, header, formData, body)
  let scheme = call_581336.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581336.url(scheme.get, call_581336.host, call_581336.base,
                         call_581336.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581336, url, valid)

proc call*(call_581337: Call_DfareportingPlacementStrategiesDelete_581324;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingPlacementStrategiesDelete
  ## Deletes an existing placement strategy.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Placement strategy ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581338 = newJObject()
  var query_581339 = newJObject()
  add(query_581339, "key", newJString(key))
  add(query_581339, "prettyPrint", newJBool(prettyPrint))
  add(query_581339, "oauth_token", newJString(oauthToken))
  add(path_581338, "profileId", newJString(profileId))
  add(path_581338, "id", newJString(id))
  add(query_581339, "alt", newJString(alt))
  add(query_581339, "userIp", newJString(userIp))
  add(query_581339, "quotaUser", newJString(quotaUser))
  add(query_581339, "fields", newJString(fields))
  result = call_581337.call(path_581338, query_581339, nil, nil, nil)

var dfareportingPlacementStrategiesDelete* = Call_DfareportingPlacementStrategiesDelete_581324(
    name: "dfareportingPlacementStrategiesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies/{id}",
    validator: validate_DfareportingPlacementStrategiesDelete_581325,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesDelete_581326,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsUpdate_581377 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementsUpdate_581379(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsUpdate_581378(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581380 = path.getOrDefault("profileId")
  valid_581380 = validateParameter(valid_581380, JString, required = true,
                                 default = nil)
  if valid_581380 != nil:
    section.add "profileId", valid_581380
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581381 = query.getOrDefault("key")
  valid_581381 = validateParameter(valid_581381, JString, required = false,
                                 default = nil)
  if valid_581381 != nil:
    section.add "key", valid_581381
  var valid_581382 = query.getOrDefault("prettyPrint")
  valid_581382 = validateParameter(valid_581382, JBool, required = false,
                                 default = newJBool(true))
  if valid_581382 != nil:
    section.add "prettyPrint", valid_581382
  var valid_581383 = query.getOrDefault("oauth_token")
  valid_581383 = validateParameter(valid_581383, JString, required = false,
                                 default = nil)
  if valid_581383 != nil:
    section.add "oauth_token", valid_581383
  var valid_581384 = query.getOrDefault("alt")
  valid_581384 = validateParameter(valid_581384, JString, required = false,
                                 default = newJString("json"))
  if valid_581384 != nil:
    section.add "alt", valid_581384
  var valid_581385 = query.getOrDefault("userIp")
  valid_581385 = validateParameter(valid_581385, JString, required = false,
                                 default = nil)
  if valid_581385 != nil:
    section.add "userIp", valid_581385
  var valid_581386 = query.getOrDefault("quotaUser")
  valid_581386 = validateParameter(valid_581386, JString, required = false,
                                 default = nil)
  if valid_581386 != nil:
    section.add "quotaUser", valid_581386
  var valid_581387 = query.getOrDefault("fields")
  valid_581387 = validateParameter(valid_581387, JString, required = false,
                                 default = nil)
  if valid_581387 != nil:
    section.add "fields", valid_581387
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581389: Call_DfareportingPlacementsUpdate_581377; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing placement.
  ## 
  let valid = call_581389.validator(path, query, header, formData, body)
  let scheme = call_581389.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581389.url(scheme.get, call_581389.host, call_581389.base,
                         call_581389.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581389, url, valid)

proc call*(call_581390: Call_DfareportingPlacementsUpdate_581377;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingPlacementsUpdate
  ## Updates an existing placement.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581391 = newJObject()
  var query_581392 = newJObject()
  var body_581393 = newJObject()
  add(query_581392, "key", newJString(key))
  add(query_581392, "prettyPrint", newJBool(prettyPrint))
  add(query_581392, "oauth_token", newJString(oauthToken))
  add(path_581391, "profileId", newJString(profileId))
  add(query_581392, "alt", newJString(alt))
  add(query_581392, "userIp", newJString(userIp))
  add(query_581392, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_581393 = body
  add(query_581392, "fields", newJString(fields))
  result = call_581390.call(path_581391, query_581392, nil, nil, body_581393)

var dfareportingPlacementsUpdate* = Call_DfareportingPlacementsUpdate_581377(
    name: "dfareportingPlacementsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsUpdate_581378,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsUpdate_581379,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsInsert_581394 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementsInsert_581396(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsInsert_581395(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581397 = path.getOrDefault("profileId")
  valid_581397 = validateParameter(valid_581397, JString, required = true,
                                 default = nil)
  if valid_581397 != nil:
    section.add "profileId", valid_581397
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581398 = query.getOrDefault("key")
  valid_581398 = validateParameter(valid_581398, JString, required = false,
                                 default = nil)
  if valid_581398 != nil:
    section.add "key", valid_581398
  var valid_581399 = query.getOrDefault("prettyPrint")
  valid_581399 = validateParameter(valid_581399, JBool, required = false,
                                 default = newJBool(true))
  if valid_581399 != nil:
    section.add "prettyPrint", valid_581399
  var valid_581400 = query.getOrDefault("oauth_token")
  valid_581400 = validateParameter(valid_581400, JString, required = false,
                                 default = nil)
  if valid_581400 != nil:
    section.add "oauth_token", valid_581400
  var valid_581401 = query.getOrDefault("alt")
  valid_581401 = validateParameter(valid_581401, JString, required = false,
                                 default = newJString("json"))
  if valid_581401 != nil:
    section.add "alt", valid_581401
  var valid_581402 = query.getOrDefault("userIp")
  valid_581402 = validateParameter(valid_581402, JString, required = false,
                                 default = nil)
  if valid_581402 != nil:
    section.add "userIp", valid_581402
  var valid_581403 = query.getOrDefault("quotaUser")
  valid_581403 = validateParameter(valid_581403, JString, required = false,
                                 default = nil)
  if valid_581403 != nil:
    section.add "quotaUser", valid_581403
  var valid_581404 = query.getOrDefault("fields")
  valid_581404 = validateParameter(valid_581404, JString, required = false,
                                 default = nil)
  if valid_581404 != nil:
    section.add "fields", valid_581404
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581406: Call_DfareportingPlacementsInsert_581394; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new placement.
  ## 
  let valid = call_581406.validator(path, query, header, formData, body)
  let scheme = call_581406.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581406.url(scheme.get, call_581406.host, call_581406.base,
                         call_581406.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581406, url, valid)

proc call*(call_581407: Call_DfareportingPlacementsInsert_581394;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingPlacementsInsert
  ## Inserts a new placement.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581408 = newJObject()
  var query_581409 = newJObject()
  var body_581410 = newJObject()
  add(query_581409, "key", newJString(key))
  add(query_581409, "prettyPrint", newJBool(prettyPrint))
  add(query_581409, "oauth_token", newJString(oauthToken))
  add(path_581408, "profileId", newJString(profileId))
  add(query_581409, "alt", newJString(alt))
  add(query_581409, "userIp", newJString(userIp))
  add(query_581409, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_581410 = body
  add(query_581409, "fields", newJString(fields))
  result = call_581407.call(path_581408, query_581409, nil, nil, body_581410)

var dfareportingPlacementsInsert* = Call_DfareportingPlacementsInsert_581394(
    name: "dfareportingPlacementsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsInsert_581395,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsInsert_581396,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsList_581340 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementsList_581342(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsList_581341(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of placements, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581343 = path.getOrDefault("profileId")
  valid_581343 = validateParameter(valid_581343, JString, required = true,
                                 default = nil)
  if valid_581343 != nil:
    section.add "profileId", valid_581343
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   maxStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   placementStrategyIds: JArray
  ##                       : Select only placements that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placements with these pricing types.
  ##   paymentSource: JString
  ##                : Select only placements with this payment source.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placements that are associated with these content categories.
  ##   advertiserIds: JArray
  ##                : Select only placements that belong to these advertisers.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: JBool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   directorySiteIds: JArray
  ##                   : Select only placements that are associated with these directory sites.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   minStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   searchString: JString
  ##               : Allows searching for placements by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placements with names like "placement June 2015", "placement May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placement" will match placements with name "my placement", "placement 2015", or simply "placement".
  ##   sizeIds: JArray
  ##          : Select only placements that are associated with these sizes.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   siteIds: JArray
  ##          : Select only placements that are associated with these sites.
  ##   maxEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   compatibilities: JArray
  ##                  : Select only placements that are associated with these compatibilities. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering in in-stream video ads developed with the VAST standard.
  ##   campaignIds: JArray
  ##              : Select only placements that belong to these campaigns.
  ##   ids: JArray
  ##      : Select only placements with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   groupIds: JArray
  ##           : Select only placements that belong to these placement groups.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   minEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  section = newJObject()
  var valid_581344 = query.getOrDefault("key")
  valid_581344 = validateParameter(valid_581344, JString, required = false,
                                 default = nil)
  if valid_581344 != nil:
    section.add "key", valid_581344
  var valid_581345 = query.getOrDefault("maxStartDate")
  valid_581345 = validateParameter(valid_581345, JString, required = false,
                                 default = nil)
  if valid_581345 != nil:
    section.add "maxStartDate", valid_581345
  var valid_581346 = query.getOrDefault("prettyPrint")
  valid_581346 = validateParameter(valid_581346, JBool, required = false,
                                 default = newJBool(true))
  if valid_581346 != nil:
    section.add "prettyPrint", valid_581346
  var valid_581347 = query.getOrDefault("oauth_token")
  valid_581347 = validateParameter(valid_581347, JString, required = false,
                                 default = nil)
  if valid_581347 != nil:
    section.add "oauth_token", valid_581347
  var valid_581348 = query.getOrDefault("placementStrategyIds")
  valid_581348 = validateParameter(valid_581348, JArray, required = false,
                                 default = nil)
  if valid_581348 != nil:
    section.add "placementStrategyIds", valid_581348
  var valid_581349 = query.getOrDefault("pricingTypes")
  valid_581349 = validateParameter(valid_581349, JArray, required = false,
                                 default = nil)
  if valid_581349 != nil:
    section.add "pricingTypes", valid_581349
  var valid_581350 = query.getOrDefault("paymentSource")
  valid_581350 = validateParameter(valid_581350, JString, required = false,
                                 default = newJString("PLACEMENT_AGENCY_PAID"))
  if valid_581350 != nil:
    section.add "paymentSource", valid_581350
  var valid_581351 = query.getOrDefault("sortField")
  valid_581351 = validateParameter(valid_581351, JString, required = false,
                                 default = newJString("ID"))
  if valid_581351 != nil:
    section.add "sortField", valid_581351
  var valid_581352 = query.getOrDefault("contentCategoryIds")
  valid_581352 = validateParameter(valid_581352, JArray, required = false,
                                 default = nil)
  if valid_581352 != nil:
    section.add "contentCategoryIds", valid_581352
  var valid_581353 = query.getOrDefault("advertiserIds")
  valid_581353 = validateParameter(valid_581353, JArray, required = false,
                                 default = nil)
  if valid_581353 != nil:
    section.add "advertiserIds", valid_581353
  var valid_581354 = query.getOrDefault("alt")
  valid_581354 = validateParameter(valid_581354, JString, required = false,
                                 default = newJString("json"))
  if valid_581354 != nil:
    section.add "alt", valid_581354
  var valid_581355 = query.getOrDefault("userIp")
  valid_581355 = validateParameter(valid_581355, JString, required = false,
                                 default = nil)
  if valid_581355 != nil:
    section.add "userIp", valid_581355
  var valid_581356 = query.getOrDefault("archived")
  valid_581356 = validateParameter(valid_581356, JBool, required = false, default = nil)
  if valid_581356 != nil:
    section.add "archived", valid_581356
  var valid_581357 = query.getOrDefault("quotaUser")
  valid_581357 = validateParameter(valid_581357, JString, required = false,
                                 default = nil)
  if valid_581357 != nil:
    section.add "quotaUser", valid_581357
  var valid_581358 = query.getOrDefault("directorySiteIds")
  valid_581358 = validateParameter(valid_581358, JArray, required = false,
                                 default = nil)
  if valid_581358 != nil:
    section.add "directorySiteIds", valid_581358
  var valid_581359 = query.getOrDefault("pageToken")
  valid_581359 = validateParameter(valid_581359, JString, required = false,
                                 default = nil)
  if valid_581359 != nil:
    section.add "pageToken", valid_581359
  var valid_581360 = query.getOrDefault("minStartDate")
  valid_581360 = validateParameter(valid_581360, JString, required = false,
                                 default = nil)
  if valid_581360 != nil:
    section.add "minStartDate", valid_581360
  var valid_581361 = query.getOrDefault("searchString")
  valid_581361 = validateParameter(valid_581361, JString, required = false,
                                 default = nil)
  if valid_581361 != nil:
    section.add "searchString", valid_581361
  var valid_581362 = query.getOrDefault("sizeIds")
  valid_581362 = validateParameter(valid_581362, JArray, required = false,
                                 default = nil)
  if valid_581362 != nil:
    section.add "sizeIds", valid_581362
  var valid_581363 = query.getOrDefault("sortOrder")
  valid_581363 = validateParameter(valid_581363, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581363 != nil:
    section.add "sortOrder", valid_581363
  var valid_581364 = query.getOrDefault("siteIds")
  valid_581364 = validateParameter(valid_581364, JArray, required = false,
                                 default = nil)
  if valid_581364 != nil:
    section.add "siteIds", valid_581364
  var valid_581365 = query.getOrDefault("maxEndDate")
  valid_581365 = validateParameter(valid_581365, JString, required = false,
                                 default = nil)
  if valid_581365 != nil:
    section.add "maxEndDate", valid_581365
  var valid_581366 = query.getOrDefault("compatibilities")
  valid_581366 = validateParameter(valid_581366, JArray, required = false,
                                 default = nil)
  if valid_581366 != nil:
    section.add "compatibilities", valid_581366
  var valid_581367 = query.getOrDefault("campaignIds")
  valid_581367 = validateParameter(valid_581367, JArray, required = false,
                                 default = nil)
  if valid_581367 != nil:
    section.add "campaignIds", valid_581367
  var valid_581368 = query.getOrDefault("ids")
  valid_581368 = validateParameter(valid_581368, JArray, required = false,
                                 default = nil)
  if valid_581368 != nil:
    section.add "ids", valid_581368
  var valid_581369 = query.getOrDefault("fields")
  valid_581369 = validateParameter(valid_581369, JString, required = false,
                                 default = nil)
  if valid_581369 != nil:
    section.add "fields", valid_581369
  var valid_581370 = query.getOrDefault("groupIds")
  valid_581370 = validateParameter(valid_581370, JArray, required = false,
                                 default = nil)
  if valid_581370 != nil:
    section.add "groupIds", valid_581370
  var valid_581371 = query.getOrDefault("maxResults")
  valid_581371 = validateParameter(valid_581371, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581371 != nil:
    section.add "maxResults", valid_581371
  var valid_581372 = query.getOrDefault("minEndDate")
  valid_581372 = validateParameter(valid_581372, JString, required = false,
                                 default = nil)
  if valid_581372 != nil:
    section.add "minEndDate", valid_581372
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581373: Call_DfareportingPlacementsList_581340; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of placements, possibly filtered. This method supports paging.
  ## 
  let valid = call_581373.validator(path, query, header, formData, body)
  let scheme = call_581373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581373.url(scheme.get, call_581373.host, call_581373.base,
                         call_581373.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581373, url, valid)

proc call*(call_581374: Call_DfareportingPlacementsList_581340; profileId: string;
          key: string = ""; maxStartDate: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; placementStrategyIds: JsonNode = nil;
          pricingTypes: JsonNode = nil;
          paymentSource: string = "PLACEMENT_AGENCY_PAID"; sortField: string = "ID";
          contentCategoryIds: JsonNode = nil; advertiserIds: JsonNode = nil;
          alt: string = "json"; userIp: string = ""; archived: bool = false;
          quotaUser: string = ""; directorySiteIds: JsonNode = nil;
          pageToken: string = ""; minStartDate: string = ""; searchString: string = "";
          sizeIds: JsonNode = nil; sortOrder: string = "ASCENDING";
          siteIds: JsonNode = nil; maxEndDate: string = "";
          compatibilities: JsonNode = nil; campaignIds: JsonNode = nil;
          ids: JsonNode = nil; fields: string = ""; groupIds: JsonNode = nil;
          maxResults: int = 1000; minEndDate: string = ""): Recallable =
  ## dfareportingPlacementsList
  ## Retrieves a list of placements, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   maxStartDate: string
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   placementStrategyIds: JArray
  ##                       : Select only placements that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placements with these pricing types.
  ##   paymentSource: string
  ##                : Select only placements with this payment source.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placements that are associated with these content categories.
  ##   advertiserIds: JArray
  ##                : Select only placements that belong to these advertisers.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: bool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   directorySiteIds: JArray
  ##                   : Select only placements that are associated with these directory sites.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   minStartDate: string
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   searchString: string
  ##               : Allows searching for placements by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placements with names like "placement June 2015", "placement May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placement" will match placements with name "my placement", "placement 2015", or simply "placement".
  ##   sizeIds: JArray
  ##          : Select only placements that are associated with these sizes.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   siteIds: JArray
  ##          : Select only placements that are associated with these sites.
  ##   maxEndDate: string
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   compatibilities: JArray
  ##                  : Select only placements that are associated with these compatibilities. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering in in-stream video ads developed with the VAST standard.
  ##   campaignIds: JArray
  ##              : Select only placements that belong to these campaigns.
  ##   ids: JArray
  ##      : Select only placements with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   groupIds: JArray
  ##           : Select only placements that belong to these placement groups.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   minEndDate: string
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  var path_581375 = newJObject()
  var query_581376 = newJObject()
  add(query_581376, "key", newJString(key))
  add(query_581376, "maxStartDate", newJString(maxStartDate))
  add(query_581376, "prettyPrint", newJBool(prettyPrint))
  add(query_581376, "oauth_token", newJString(oauthToken))
  if placementStrategyIds != nil:
    query_581376.add "placementStrategyIds", placementStrategyIds
  if pricingTypes != nil:
    query_581376.add "pricingTypes", pricingTypes
  add(query_581376, "paymentSource", newJString(paymentSource))
  add(path_581375, "profileId", newJString(profileId))
  add(query_581376, "sortField", newJString(sortField))
  if contentCategoryIds != nil:
    query_581376.add "contentCategoryIds", contentCategoryIds
  if advertiserIds != nil:
    query_581376.add "advertiserIds", advertiserIds
  add(query_581376, "alt", newJString(alt))
  add(query_581376, "userIp", newJString(userIp))
  add(query_581376, "archived", newJBool(archived))
  add(query_581376, "quotaUser", newJString(quotaUser))
  if directorySiteIds != nil:
    query_581376.add "directorySiteIds", directorySiteIds
  add(query_581376, "pageToken", newJString(pageToken))
  add(query_581376, "minStartDate", newJString(minStartDate))
  add(query_581376, "searchString", newJString(searchString))
  if sizeIds != nil:
    query_581376.add "sizeIds", sizeIds
  add(query_581376, "sortOrder", newJString(sortOrder))
  if siteIds != nil:
    query_581376.add "siteIds", siteIds
  add(query_581376, "maxEndDate", newJString(maxEndDate))
  if compatibilities != nil:
    query_581376.add "compatibilities", compatibilities
  if campaignIds != nil:
    query_581376.add "campaignIds", campaignIds
  if ids != nil:
    query_581376.add "ids", ids
  add(query_581376, "fields", newJString(fields))
  if groupIds != nil:
    query_581376.add "groupIds", groupIds
  add(query_581376, "maxResults", newJInt(maxResults))
  add(query_581376, "minEndDate", newJString(minEndDate))
  result = call_581374.call(path_581375, query_581376, nil, nil, nil)

var dfareportingPlacementsList* = Call_DfareportingPlacementsList_581340(
    name: "dfareportingPlacementsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsList_581341,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsList_581342,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsPatch_581411 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementsPatch_581413(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsPatch_581412(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581414 = path.getOrDefault("profileId")
  valid_581414 = validateParameter(valid_581414, JString, required = true,
                                 default = nil)
  if valid_581414 != nil:
    section.add "profileId", valid_581414
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Placement ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581415 = query.getOrDefault("key")
  valid_581415 = validateParameter(valid_581415, JString, required = false,
                                 default = nil)
  if valid_581415 != nil:
    section.add "key", valid_581415
  var valid_581416 = query.getOrDefault("prettyPrint")
  valid_581416 = validateParameter(valid_581416, JBool, required = false,
                                 default = newJBool(true))
  if valid_581416 != nil:
    section.add "prettyPrint", valid_581416
  var valid_581417 = query.getOrDefault("oauth_token")
  valid_581417 = validateParameter(valid_581417, JString, required = false,
                                 default = nil)
  if valid_581417 != nil:
    section.add "oauth_token", valid_581417
  var valid_581418 = query.getOrDefault("alt")
  valid_581418 = validateParameter(valid_581418, JString, required = false,
                                 default = newJString("json"))
  if valid_581418 != nil:
    section.add "alt", valid_581418
  var valid_581419 = query.getOrDefault("userIp")
  valid_581419 = validateParameter(valid_581419, JString, required = false,
                                 default = nil)
  if valid_581419 != nil:
    section.add "userIp", valid_581419
  var valid_581420 = query.getOrDefault("quotaUser")
  valid_581420 = validateParameter(valid_581420, JString, required = false,
                                 default = nil)
  if valid_581420 != nil:
    section.add "quotaUser", valid_581420
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_581421 = query.getOrDefault("id")
  valid_581421 = validateParameter(valid_581421, JString, required = true,
                                 default = nil)
  if valid_581421 != nil:
    section.add "id", valid_581421
  var valid_581422 = query.getOrDefault("fields")
  valid_581422 = validateParameter(valid_581422, JString, required = false,
                                 default = nil)
  if valid_581422 != nil:
    section.add "fields", valid_581422
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581424: Call_DfareportingPlacementsPatch_581411; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing placement. This method supports patch semantics.
  ## 
  let valid = call_581424.validator(path, query, header, formData, body)
  let scheme = call_581424.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581424.url(scheme.get, call_581424.host, call_581424.base,
                         call_581424.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581424, url, valid)

proc call*(call_581425: Call_DfareportingPlacementsPatch_581411; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingPlacementsPatch
  ## Updates an existing placement. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Placement ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581426 = newJObject()
  var query_581427 = newJObject()
  var body_581428 = newJObject()
  add(query_581427, "key", newJString(key))
  add(query_581427, "prettyPrint", newJBool(prettyPrint))
  add(query_581427, "oauth_token", newJString(oauthToken))
  add(path_581426, "profileId", newJString(profileId))
  add(query_581427, "alt", newJString(alt))
  add(query_581427, "userIp", newJString(userIp))
  add(query_581427, "quotaUser", newJString(quotaUser))
  add(query_581427, "id", newJString(id))
  if body != nil:
    body_581428 = body
  add(query_581427, "fields", newJString(fields))
  result = call_581425.call(path_581426, query_581427, nil, nil, body_581428)

var dfareportingPlacementsPatch* = Call_DfareportingPlacementsPatch_581411(
    name: "dfareportingPlacementsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsPatch_581412,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsPatch_581413,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsGeneratetags_581429 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementsGeneratetags_581431(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements/generatetags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsGeneratetags_581430(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Generates tags for a placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581432 = path.getOrDefault("profileId")
  valid_581432 = validateParameter(valid_581432, JString, required = true,
                                 default = nil)
  if valid_581432 != nil:
    section.add "profileId", valid_581432
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   campaignId: JString
  ##             : Generate placements belonging to this campaign. This is a required field.
  ##   placementIds: JArray
  ##               : Generate tags for these placements.
  ##   tagFormats: JArray
  ##             : Tag formats to generate for these placements.
  ## 
  ## Note: PLACEMENT_TAG_STANDARD can only be generated for 1x1 placements.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581433 = query.getOrDefault("key")
  valid_581433 = validateParameter(valid_581433, JString, required = false,
                                 default = nil)
  if valid_581433 != nil:
    section.add "key", valid_581433
  var valid_581434 = query.getOrDefault("prettyPrint")
  valid_581434 = validateParameter(valid_581434, JBool, required = false,
                                 default = newJBool(true))
  if valid_581434 != nil:
    section.add "prettyPrint", valid_581434
  var valid_581435 = query.getOrDefault("oauth_token")
  valid_581435 = validateParameter(valid_581435, JString, required = false,
                                 default = nil)
  if valid_581435 != nil:
    section.add "oauth_token", valid_581435
  var valid_581436 = query.getOrDefault("alt")
  valid_581436 = validateParameter(valid_581436, JString, required = false,
                                 default = newJString("json"))
  if valid_581436 != nil:
    section.add "alt", valid_581436
  var valid_581437 = query.getOrDefault("userIp")
  valid_581437 = validateParameter(valid_581437, JString, required = false,
                                 default = nil)
  if valid_581437 != nil:
    section.add "userIp", valid_581437
  var valid_581438 = query.getOrDefault("quotaUser")
  valid_581438 = validateParameter(valid_581438, JString, required = false,
                                 default = nil)
  if valid_581438 != nil:
    section.add "quotaUser", valid_581438
  var valid_581439 = query.getOrDefault("campaignId")
  valid_581439 = validateParameter(valid_581439, JString, required = false,
                                 default = nil)
  if valid_581439 != nil:
    section.add "campaignId", valid_581439
  var valid_581440 = query.getOrDefault("placementIds")
  valid_581440 = validateParameter(valid_581440, JArray, required = false,
                                 default = nil)
  if valid_581440 != nil:
    section.add "placementIds", valid_581440
  var valid_581441 = query.getOrDefault("tagFormats")
  valid_581441 = validateParameter(valid_581441, JArray, required = false,
                                 default = nil)
  if valid_581441 != nil:
    section.add "tagFormats", valid_581441
  var valid_581442 = query.getOrDefault("fields")
  valid_581442 = validateParameter(valid_581442, JString, required = false,
                                 default = nil)
  if valid_581442 != nil:
    section.add "fields", valid_581442
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581443: Call_DfareportingPlacementsGeneratetags_581429;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Generates tags for a placement.
  ## 
  let valid = call_581443.validator(path, query, header, formData, body)
  let scheme = call_581443.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581443.url(scheme.get, call_581443.host, call_581443.base,
                         call_581443.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581443, url, valid)

proc call*(call_581444: Call_DfareportingPlacementsGeneratetags_581429;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; campaignId: string = ""; placementIds: JsonNode = nil;
          tagFormats: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingPlacementsGeneratetags
  ## Generates tags for a placement.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   campaignId: string
  ##             : Generate placements belonging to this campaign. This is a required field.
  ##   placementIds: JArray
  ##               : Generate tags for these placements.
  ##   tagFormats: JArray
  ##             : Tag formats to generate for these placements.
  ## 
  ## Note: PLACEMENT_TAG_STANDARD can only be generated for 1x1 placements.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581445 = newJObject()
  var query_581446 = newJObject()
  add(query_581446, "key", newJString(key))
  add(query_581446, "prettyPrint", newJBool(prettyPrint))
  add(query_581446, "oauth_token", newJString(oauthToken))
  add(path_581445, "profileId", newJString(profileId))
  add(query_581446, "alt", newJString(alt))
  add(query_581446, "userIp", newJString(userIp))
  add(query_581446, "quotaUser", newJString(quotaUser))
  add(query_581446, "campaignId", newJString(campaignId))
  if placementIds != nil:
    query_581446.add "placementIds", placementIds
  if tagFormats != nil:
    query_581446.add "tagFormats", tagFormats
  add(query_581446, "fields", newJString(fields))
  result = call_581444.call(path_581445, query_581446, nil, nil, nil)

var dfareportingPlacementsGeneratetags* = Call_DfareportingPlacementsGeneratetags_581429(
    name: "dfareportingPlacementsGeneratetags", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placements/generatetags",
    validator: validate_DfareportingPlacementsGeneratetags_581430,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsGeneratetags_581431,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsGet_581447 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlacementsGet_581449(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsGet_581448(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one placement by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581450 = path.getOrDefault("profileId")
  valid_581450 = validateParameter(valid_581450, JString, required = true,
                                 default = nil)
  if valid_581450 != nil:
    section.add "profileId", valid_581450
  var valid_581451 = path.getOrDefault("id")
  valid_581451 = validateParameter(valid_581451, JString, required = true,
                                 default = nil)
  if valid_581451 != nil:
    section.add "id", valid_581451
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581452 = query.getOrDefault("key")
  valid_581452 = validateParameter(valid_581452, JString, required = false,
                                 default = nil)
  if valid_581452 != nil:
    section.add "key", valid_581452
  var valid_581453 = query.getOrDefault("prettyPrint")
  valid_581453 = validateParameter(valid_581453, JBool, required = false,
                                 default = newJBool(true))
  if valid_581453 != nil:
    section.add "prettyPrint", valid_581453
  var valid_581454 = query.getOrDefault("oauth_token")
  valid_581454 = validateParameter(valid_581454, JString, required = false,
                                 default = nil)
  if valid_581454 != nil:
    section.add "oauth_token", valid_581454
  var valid_581455 = query.getOrDefault("alt")
  valid_581455 = validateParameter(valid_581455, JString, required = false,
                                 default = newJString("json"))
  if valid_581455 != nil:
    section.add "alt", valid_581455
  var valid_581456 = query.getOrDefault("userIp")
  valid_581456 = validateParameter(valid_581456, JString, required = false,
                                 default = nil)
  if valid_581456 != nil:
    section.add "userIp", valid_581456
  var valid_581457 = query.getOrDefault("quotaUser")
  valid_581457 = validateParameter(valid_581457, JString, required = false,
                                 default = nil)
  if valid_581457 != nil:
    section.add "quotaUser", valid_581457
  var valid_581458 = query.getOrDefault("fields")
  valid_581458 = validateParameter(valid_581458, JString, required = false,
                                 default = nil)
  if valid_581458 != nil:
    section.add "fields", valid_581458
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581459: Call_DfareportingPlacementsGet_581447; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one placement by ID.
  ## 
  let valid = call_581459.validator(path, query, header, formData, body)
  let scheme = call_581459.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581459.url(scheme.get, call_581459.host, call_581459.base,
                         call_581459.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581459, url, valid)

proc call*(call_581460: Call_DfareportingPlacementsGet_581447; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingPlacementsGet
  ## Gets one placement by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Placement ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581461 = newJObject()
  var query_581462 = newJObject()
  add(query_581462, "key", newJString(key))
  add(query_581462, "prettyPrint", newJBool(prettyPrint))
  add(query_581462, "oauth_token", newJString(oauthToken))
  add(path_581461, "profileId", newJString(profileId))
  add(path_581461, "id", newJString(id))
  add(query_581462, "alt", newJString(alt))
  add(query_581462, "userIp", newJString(userIp))
  add(query_581462, "quotaUser", newJString(quotaUser))
  add(query_581462, "fields", newJString(fields))
  result = call_581460.call(path_581461, query_581462, nil, nil, nil)

var dfareportingPlacementsGet* = Call_DfareportingPlacementsGet_581447(
    name: "dfareportingPlacementsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placements/{id}",
    validator: validate_DfareportingPlacementsGet_581448,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsGet_581449,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlatformTypesList_581463 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlatformTypesList_581465(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/platformTypes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlatformTypesList_581464(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of platform types.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581466 = path.getOrDefault("profileId")
  valid_581466 = validateParameter(valid_581466, JString, required = true,
                                 default = nil)
  if valid_581466 != nil:
    section.add "profileId", valid_581466
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581467 = query.getOrDefault("key")
  valid_581467 = validateParameter(valid_581467, JString, required = false,
                                 default = nil)
  if valid_581467 != nil:
    section.add "key", valid_581467
  var valid_581468 = query.getOrDefault("prettyPrint")
  valid_581468 = validateParameter(valid_581468, JBool, required = false,
                                 default = newJBool(true))
  if valid_581468 != nil:
    section.add "prettyPrint", valid_581468
  var valid_581469 = query.getOrDefault("oauth_token")
  valid_581469 = validateParameter(valid_581469, JString, required = false,
                                 default = nil)
  if valid_581469 != nil:
    section.add "oauth_token", valid_581469
  var valid_581470 = query.getOrDefault("alt")
  valid_581470 = validateParameter(valid_581470, JString, required = false,
                                 default = newJString("json"))
  if valid_581470 != nil:
    section.add "alt", valid_581470
  var valid_581471 = query.getOrDefault("userIp")
  valid_581471 = validateParameter(valid_581471, JString, required = false,
                                 default = nil)
  if valid_581471 != nil:
    section.add "userIp", valid_581471
  var valid_581472 = query.getOrDefault("quotaUser")
  valid_581472 = validateParameter(valid_581472, JString, required = false,
                                 default = nil)
  if valid_581472 != nil:
    section.add "quotaUser", valid_581472
  var valid_581473 = query.getOrDefault("fields")
  valid_581473 = validateParameter(valid_581473, JString, required = false,
                                 default = nil)
  if valid_581473 != nil:
    section.add "fields", valid_581473
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581474: Call_DfareportingPlatformTypesList_581463; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of platform types.
  ## 
  let valid = call_581474.validator(path, query, header, formData, body)
  let scheme = call_581474.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581474.url(scheme.get, call_581474.host, call_581474.base,
                         call_581474.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581474, url, valid)

proc call*(call_581475: Call_DfareportingPlatformTypesList_581463;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingPlatformTypesList
  ## Retrieves a list of platform types.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581476 = newJObject()
  var query_581477 = newJObject()
  add(query_581477, "key", newJString(key))
  add(query_581477, "prettyPrint", newJBool(prettyPrint))
  add(query_581477, "oauth_token", newJString(oauthToken))
  add(path_581476, "profileId", newJString(profileId))
  add(query_581477, "alt", newJString(alt))
  add(query_581477, "userIp", newJString(userIp))
  add(query_581477, "quotaUser", newJString(quotaUser))
  add(query_581477, "fields", newJString(fields))
  result = call_581475.call(path_581476, query_581477, nil, nil, nil)

var dfareportingPlatformTypesList* = Call_DfareportingPlatformTypesList_581463(
    name: "dfareportingPlatformTypesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/platformTypes",
    validator: validate_DfareportingPlatformTypesList_581464,
    base: "/dfareporting/v2.7", url: url_DfareportingPlatformTypesList_581465,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlatformTypesGet_581478 = ref object of OpenApiRestCall_578364
proc url_DfareportingPlatformTypesGet_581480(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/platformTypes/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlatformTypesGet_581479(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one platform type by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Platform type ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581481 = path.getOrDefault("profileId")
  valid_581481 = validateParameter(valid_581481, JString, required = true,
                                 default = nil)
  if valid_581481 != nil:
    section.add "profileId", valid_581481
  var valid_581482 = path.getOrDefault("id")
  valid_581482 = validateParameter(valid_581482, JString, required = true,
                                 default = nil)
  if valid_581482 != nil:
    section.add "id", valid_581482
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581483 = query.getOrDefault("key")
  valid_581483 = validateParameter(valid_581483, JString, required = false,
                                 default = nil)
  if valid_581483 != nil:
    section.add "key", valid_581483
  var valid_581484 = query.getOrDefault("prettyPrint")
  valid_581484 = validateParameter(valid_581484, JBool, required = false,
                                 default = newJBool(true))
  if valid_581484 != nil:
    section.add "prettyPrint", valid_581484
  var valid_581485 = query.getOrDefault("oauth_token")
  valid_581485 = validateParameter(valid_581485, JString, required = false,
                                 default = nil)
  if valid_581485 != nil:
    section.add "oauth_token", valid_581485
  var valid_581486 = query.getOrDefault("alt")
  valid_581486 = validateParameter(valid_581486, JString, required = false,
                                 default = newJString("json"))
  if valid_581486 != nil:
    section.add "alt", valid_581486
  var valid_581487 = query.getOrDefault("userIp")
  valid_581487 = validateParameter(valid_581487, JString, required = false,
                                 default = nil)
  if valid_581487 != nil:
    section.add "userIp", valid_581487
  var valid_581488 = query.getOrDefault("quotaUser")
  valid_581488 = validateParameter(valid_581488, JString, required = false,
                                 default = nil)
  if valid_581488 != nil:
    section.add "quotaUser", valid_581488
  var valid_581489 = query.getOrDefault("fields")
  valid_581489 = validateParameter(valid_581489, JString, required = false,
                                 default = nil)
  if valid_581489 != nil:
    section.add "fields", valid_581489
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581490: Call_DfareportingPlatformTypesGet_581478; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one platform type by ID.
  ## 
  let valid = call_581490.validator(path, query, header, formData, body)
  let scheme = call_581490.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581490.url(scheme.get, call_581490.host, call_581490.base,
                         call_581490.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581490, url, valid)

proc call*(call_581491: Call_DfareportingPlatformTypesGet_581478;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingPlatformTypesGet
  ## Gets one platform type by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Platform type ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581492 = newJObject()
  var query_581493 = newJObject()
  add(query_581493, "key", newJString(key))
  add(query_581493, "prettyPrint", newJBool(prettyPrint))
  add(query_581493, "oauth_token", newJString(oauthToken))
  add(path_581492, "profileId", newJString(profileId))
  add(path_581492, "id", newJString(id))
  add(query_581493, "alt", newJString(alt))
  add(query_581493, "userIp", newJString(userIp))
  add(query_581493, "quotaUser", newJString(quotaUser))
  add(query_581493, "fields", newJString(fields))
  result = call_581491.call(path_581492, query_581493, nil, nil, nil)

var dfareportingPlatformTypesGet* = Call_DfareportingPlatformTypesGet_581478(
    name: "dfareportingPlatformTypesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/platformTypes/{id}",
    validator: validate_DfareportingPlatformTypesGet_581479,
    base: "/dfareporting/v2.7", url: url_DfareportingPlatformTypesGet_581480,
    schemes: {Scheme.Https})
type
  Call_DfareportingPostalCodesList_581494 = ref object of OpenApiRestCall_578364
proc url_DfareportingPostalCodesList_581496(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/postalCodes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPostalCodesList_581495(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of postal codes.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581497 = path.getOrDefault("profileId")
  valid_581497 = validateParameter(valid_581497, JString, required = true,
                                 default = nil)
  if valid_581497 != nil:
    section.add "profileId", valid_581497
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581498 = query.getOrDefault("key")
  valid_581498 = validateParameter(valid_581498, JString, required = false,
                                 default = nil)
  if valid_581498 != nil:
    section.add "key", valid_581498
  var valid_581499 = query.getOrDefault("prettyPrint")
  valid_581499 = validateParameter(valid_581499, JBool, required = false,
                                 default = newJBool(true))
  if valid_581499 != nil:
    section.add "prettyPrint", valid_581499
  var valid_581500 = query.getOrDefault("oauth_token")
  valid_581500 = validateParameter(valid_581500, JString, required = false,
                                 default = nil)
  if valid_581500 != nil:
    section.add "oauth_token", valid_581500
  var valid_581501 = query.getOrDefault("alt")
  valid_581501 = validateParameter(valid_581501, JString, required = false,
                                 default = newJString("json"))
  if valid_581501 != nil:
    section.add "alt", valid_581501
  var valid_581502 = query.getOrDefault("userIp")
  valid_581502 = validateParameter(valid_581502, JString, required = false,
                                 default = nil)
  if valid_581502 != nil:
    section.add "userIp", valid_581502
  var valid_581503 = query.getOrDefault("quotaUser")
  valid_581503 = validateParameter(valid_581503, JString, required = false,
                                 default = nil)
  if valid_581503 != nil:
    section.add "quotaUser", valid_581503
  var valid_581504 = query.getOrDefault("fields")
  valid_581504 = validateParameter(valid_581504, JString, required = false,
                                 default = nil)
  if valid_581504 != nil:
    section.add "fields", valid_581504
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581505: Call_DfareportingPostalCodesList_581494; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of postal codes.
  ## 
  let valid = call_581505.validator(path, query, header, formData, body)
  let scheme = call_581505.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581505.url(scheme.get, call_581505.host, call_581505.base,
                         call_581505.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581505, url, valid)

proc call*(call_581506: Call_DfareportingPostalCodesList_581494; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingPostalCodesList
  ## Retrieves a list of postal codes.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581507 = newJObject()
  var query_581508 = newJObject()
  add(query_581508, "key", newJString(key))
  add(query_581508, "prettyPrint", newJBool(prettyPrint))
  add(query_581508, "oauth_token", newJString(oauthToken))
  add(path_581507, "profileId", newJString(profileId))
  add(query_581508, "alt", newJString(alt))
  add(query_581508, "userIp", newJString(userIp))
  add(query_581508, "quotaUser", newJString(quotaUser))
  add(query_581508, "fields", newJString(fields))
  result = call_581506.call(path_581507, query_581508, nil, nil, nil)

var dfareportingPostalCodesList* = Call_DfareportingPostalCodesList_581494(
    name: "dfareportingPostalCodesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/postalCodes",
    validator: validate_DfareportingPostalCodesList_581495,
    base: "/dfareporting/v2.7", url: url_DfareportingPostalCodesList_581496,
    schemes: {Scheme.Https})
type
  Call_DfareportingPostalCodesGet_581509 = ref object of OpenApiRestCall_578364
proc url_DfareportingPostalCodesGet_581511(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "code" in path, "`code` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/postalCodes/"),
               (kind: VariableSegment, value: "code")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPostalCodesGet_581510(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one postal code by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   code: JString (required)
  ##       : Postal code ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581512 = path.getOrDefault("profileId")
  valid_581512 = validateParameter(valid_581512, JString, required = true,
                                 default = nil)
  if valid_581512 != nil:
    section.add "profileId", valid_581512
  var valid_581513 = path.getOrDefault("code")
  valid_581513 = validateParameter(valid_581513, JString, required = true,
                                 default = nil)
  if valid_581513 != nil:
    section.add "code", valid_581513
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581514 = query.getOrDefault("key")
  valid_581514 = validateParameter(valid_581514, JString, required = false,
                                 default = nil)
  if valid_581514 != nil:
    section.add "key", valid_581514
  var valid_581515 = query.getOrDefault("prettyPrint")
  valid_581515 = validateParameter(valid_581515, JBool, required = false,
                                 default = newJBool(true))
  if valid_581515 != nil:
    section.add "prettyPrint", valid_581515
  var valid_581516 = query.getOrDefault("oauth_token")
  valid_581516 = validateParameter(valid_581516, JString, required = false,
                                 default = nil)
  if valid_581516 != nil:
    section.add "oauth_token", valid_581516
  var valid_581517 = query.getOrDefault("alt")
  valid_581517 = validateParameter(valid_581517, JString, required = false,
                                 default = newJString("json"))
  if valid_581517 != nil:
    section.add "alt", valid_581517
  var valid_581518 = query.getOrDefault("userIp")
  valid_581518 = validateParameter(valid_581518, JString, required = false,
                                 default = nil)
  if valid_581518 != nil:
    section.add "userIp", valid_581518
  var valid_581519 = query.getOrDefault("quotaUser")
  valid_581519 = validateParameter(valid_581519, JString, required = false,
                                 default = nil)
  if valid_581519 != nil:
    section.add "quotaUser", valid_581519
  var valid_581520 = query.getOrDefault("fields")
  valid_581520 = validateParameter(valid_581520, JString, required = false,
                                 default = nil)
  if valid_581520 != nil:
    section.add "fields", valid_581520
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581521: Call_DfareportingPostalCodesGet_581509; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one postal code by ID.
  ## 
  let valid = call_581521.validator(path, query, header, formData, body)
  let scheme = call_581521.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581521.url(scheme.get, call_581521.host, call_581521.base,
                         call_581521.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581521, url, valid)

proc call*(call_581522: Call_DfareportingPostalCodesGet_581509; profileId: string;
          code: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingPostalCodesGet
  ## Gets one postal code by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   code: string (required)
  ##       : Postal code ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581523 = newJObject()
  var query_581524 = newJObject()
  add(query_581524, "key", newJString(key))
  add(query_581524, "prettyPrint", newJBool(prettyPrint))
  add(query_581524, "oauth_token", newJString(oauthToken))
  add(path_581523, "profileId", newJString(profileId))
  add(query_581524, "alt", newJString(alt))
  add(query_581524, "userIp", newJString(userIp))
  add(query_581524, "quotaUser", newJString(quotaUser))
  add(path_581523, "code", newJString(code))
  add(query_581524, "fields", newJString(fields))
  result = call_581522.call(path_581523, query_581524, nil, nil, nil)

var dfareportingPostalCodesGet* = Call_DfareportingPostalCodesGet_581509(
    name: "dfareportingPostalCodesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/postalCodes/{code}",
    validator: validate_DfareportingPostalCodesGet_581510,
    base: "/dfareporting/v2.7", url: url_DfareportingPostalCodesGet_581511,
    schemes: {Scheme.Https})
type
  Call_DfareportingProjectsList_581525 = ref object of OpenApiRestCall_578364
proc url_DfareportingProjectsList_581527(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingProjectsList_581526(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of projects, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581528 = path.getOrDefault("profileId")
  valid_581528 = validateParameter(valid_581528, JString, required = true,
                                 default = nil)
  if valid_581528 != nil:
    section.add "profileId", valid_581528
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   advertiserIds: JArray
  ##                : Select only projects with these advertiser IDs.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for projects by name or ID. Wildcards (*) are allowed. For example, "project*2015" will return projects with names like "project June 2015", "project April 2015", or simply "project 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "project" will match projects with name "my project", "project 2015", or simply "project".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only projects with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_581529 = query.getOrDefault("key")
  valid_581529 = validateParameter(valid_581529, JString, required = false,
                                 default = nil)
  if valid_581529 != nil:
    section.add "key", valid_581529
  var valid_581530 = query.getOrDefault("prettyPrint")
  valid_581530 = validateParameter(valid_581530, JBool, required = false,
                                 default = newJBool(true))
  if valid_581530 != nil:
    section.add "prettyPrint", valid_581530
  var valid_581531 = query.getOrDefault("oauth_token")
  valid_581531 = validateParameter(valid_581531, JString, required = false,
                                 default = nil)
  if valid_581531 != nil:
    section.add "oauth_token", valid_581531
  var valid_581532 = query.getOrDefault("sortField")
  valid_581532 = validateParameter(valid_581532, JString, required = false,
                                 default = newJString("ID"))
  if valid_581532 != nil:
    section.add "sortField", valid_581532
  var valid_581533 = query.getOrDefault("advertiserIds")
  valid_581533 = validateParameter(valid_581533, JArray, required = false,
                                 default = nil)
  if valid_581533 != nil:
    section.add "advertiserIds", valid_581533
  var valid_581534 = query.getOrDefault("alt")
  valid_581534 = validateParameter(valid_581534, JString, required = false,
                                 default = newJString("json"))
  if valid_581534 != nil:
    section.add "alt", valid_581534
  var valid_581535 = query.getOrDefault("userIp")
  valid_581535 = validateParameter(valid_581535, JString, required = false,
                                 default = nil)
  if valid_581535 != nil:
    section.add "userIp", valid_581535
  var valid_581536 = query.getOrDefault("quotaUser")
  valid_581536 = validateParameter(valid_581536, JString, required = false,
                                 default = nil)
  if valid_581536 != nil:
    section.add "quotaUser", valid_581536
  var valid_581537 = query.getOrDefault("pageToken")
  valid_581537 = validateParameter(valid_581537, JString, required = false,
                                 default = nil)
  if valid_581537 != nil:
    section.add "pageToken", valid_581537
  var valid_581538 = query.getOrDefault("searchString")
  valid_581538 = validateParameter(valid_581538, JString, required = false,
                                 default = nil)
  if valid_581538 != nil:
    section.add "searchString", valid_581538
  var valid_581539 = query.getOrDefault("sortOrder")
  valid_581539 = validateParameter(valid_581539, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581539 != nil:
    section.add "sortOrder", valid_581539
  var valid_581540 = query.getOrDefault("ids")
  valid_581540 = validateParameter(valid_581540, JArray, required = false,
                                 default = nil)
  if valid_581540 != nil:
    section.add "ids", valid_581540
  var valid_581541 = query.getOrDefault("fields")
  valid_581541 = validateParameter(valid_581541, JString, required = false,
                                 default = nil)
  if valid_581541 != nil:
    section.add "fields", valid_581541
  var valid_581542 = query.getOrDefault("maxResults")
  valid_581542 = validateParameter(valid_581542, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581542 != nil:
    section.add "maxResults", valid_581542
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581543: Call_DfareportingProjectsList_581525; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of projects, possibly filtered. This method supports paging.
  ## 
  let valid = call_581543.validator(path, query, header, formData, body)
  let scheme = call_581543.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581543.url(scheme.get, call_581543.host, call_581543.base,
                         call_581543.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581543, url, valid)

proc call*(call_581544: Call_DfareportingProjectsList_581525; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          sortField: string = "ID"; advertiserIds: JsonNode = nil; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; pageToken: string = "";
          searchString: string = ""; sortOrder: string = "ASCENDING";
          ids: JsonNode = nil; fields: string = ""; maxResults: int = 1000): Recallable =
  ## dfareportingProjectsList
  ## Retrieves a list of projects, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   advertiserIds: JArray
  ##                : Select only projects with these advertiser IDs.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for projects by name or ID. Wildcards (*) are allowed. For example, "project*2015" will return projects with names like "project June 2015", "project April 2015", or simply "project 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "project" will match projects with name "my project", "project 2015", or simply "project".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only projects with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_581545 = newJObject()
  var query_581546 = newJObject()
  add(query_581546, "key", newJString(key))
  add(query_581546, "prettyPrint", newJBool(prettyPrint))
  add(query_581546, "oauth_token", newJString(oauthToken))
  add(path_581545, "profileId", newJString(profileId))
  add(query_581546, "sortField", newJString(sortField))
  if advertiserIds != nil:
    query_581546.add "advertiserIds", advertiserIds
  add(query_581546, "alt", newJString(alt))
  add(query_581546, "userIp", newJString(userIp))
  add(query_581546, "quotaUser", newJString(quotaUser))
  add(query_581546, "pageToken", newJString(pageToken))
  add(query_581546, "searchString", newJString(searchString))
  add(query_581546, "sortOrder", newJString(sortOrder))
  if ids != nil:
    query_581546.add "ids", ids
  add(query_581546, "fields", newJString(fields))
  add(query_581546, "maxResults", newJInt(maxResults))
  result = call_581544.call(path_581545, query_581546, nil, nil, nil)

var dfareportingProjectsList* = Call_DfareportingProjectsList_581525(
    name: "dfareportingProjectsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects",
    validator: validate_DfareportingProjectsList_581526,
    base: "/dfareporting/v2.7", url: url_DfareportingProjectsList_581527,
    schemes: {Scheme.Https})
type
  Call_DfareportingProjectsGet_581547 = ref object of OpenApiRestCall_578364
proc url_DfareportingProjectsGet_581549(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingProjectsGet_581548(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one project by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Project ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581550 = path.getOrDefault("profileId")
  valid_581550 = validateParameter(valid_581550, JString, required = true,
                                 default = nil)
  if valid_581550 != nil:
    section.add "profileId", valid_581550
  var valid_581551 = path.getOrDefault("id")
  valid_581551 = validateParameter(valid_581551, JString, required = true,
                                 default = nil)
  if valid_581551 != nil:
    section.add "id", valid_581551
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581552 = query.getOrDefault("key")
  valid_581552 = validateParameter(valid_581552, JString, required = false,
                                 default = nil)
  if valid_581552 != nil:
    section.add "key", valid_581552
  var valid_581553 = query.getOrDefault("prettyPrint")
  valid_581553 = validateParameter(valid_581553, JBool, required = false,
                                 default = newJBool(true))
  if valid_581553 != nil:
    section.add "prettyPrint", valid_581553
  var valid_581554 = query.getOrDefault("oauth_token")
  valid_581554 = validateParameter(valid_581554, JString, required = false,
                                 default = nil)
  if valid_581554 != nil:
    section.add "oauth_token", valid_581554
  var valid_581555 = query.getOrDefault("alt")
  valid_581555 = validateParameter(valid_581555, JString, required = false,
                                 default = newJString("json"))
  if valid_581555 != nil:
    section.add "alt", valid_581555
  var valid_581556 = query.getOrDefault("userIp")
  valid_581556 = validateParameter(valid_581556, JString, required = false,
                                 default = nil)
  if valid_581556 != nil:
    section.add "userIp", valid_581556
  var valid_581557 = query.getOrDefault("quotaUser")
  valid_581557 = validateParameter(valid_581557, JString, required = false,
                                 default = nil)
  if valid_581557 != nil:
    section.add "quotaUser", valid_581557
  var valid_581558 = query.getOrDefault("fields")
  valid_581558 = validateParameter(valid_581558, JString, required = false,
                                 default = nil)
  if valid_581558 != nil:
    section.add "fields", valid_581558
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581559: Call_DfareportingProjectsGet_581547; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one project by ID.
  ## 
  let valid = call_581559.validator(path, query, header, formData, body)
  let scheme = call_581559.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581559.url(scheme.get, call_581559.host, call_581559.base,
                         call_581559.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581559, url, valid)

proc call*(call_581560: Call_DfareportingProjectsGet_581547; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingProjectsGet
  ## Gets one project by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Project ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581561 = newJObject()
  var query_581562 = newJObject()
  add(query_581562, "key", newJString(key))
  add(query_581562, "prettyPrint", newJBool(prettyPrint))
  add(query_581562, "oauth_token", newJString(oauthToken))
  add(path_581561, "profileId", newJString(profileId))
  add(path_581561, "id", newJString(id))
  add(query_581562, "alt", newJString(alt))
  add(query_581562, "userIp", newJString(userIp))
  add(query_581562, "quotaUser", newJString(quotaUser))
  add(query_581562, "fields", newJString(fields))
  result = call_581560.call(path_581561, query_581562, nil, nil, nil)

var dfareportingProjectsGet* = Call_DfareportingProjectsGet_581547(
    name: "dfareportingProjectsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects/{id}",
    validator: validate_DfareportingProjectsGet_581548,
    base: "/dfareporting/v2.7", url: url_DfareportingProjectsGet_581549,
    schemes: {Scheme.Https})
type
  Call_DfareportingInventoryItemsList_581563 = ref object of OpenApiRestCall_578364
proc url_DfareportingInventoryItemsList_581565(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/inventoryItems")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingInventoryItemsList_581564(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of inventory items, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `projectId` field"
  var valid_581566 = path.getOrDefault("projectId")
  valid_581566 = validateParameter(valid_581566, JString, required = true,
                                 default = nil)
  if valid_581566 != nil:
    section.add "projectId", valid_581566
  var valid_581567 = path.getOrDefault("profileId")
  valid_581567 = validateParameter(valid_581567, JString, required = true,
                                 default = nil)
  if valid_581567 != nil:
    section.add "profileId", valid_581567
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   inPlan: JBool
  ##         : Select only inventory items that are in plan.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   orderId: JArray
  ##          : Select only inventory items that belong to specified orders.
  ##   type: JString
  ##       : Select only inventory items with this type.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   siteId: JArray
  ##         : Select only inventory items that are associated with these sites.
  ##   ids: JArray
  ##      : Select only inventory items with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_581568 = query.getOrDefault("key")
  valid_581568 = validateParameter(valid_581568, JString, required = false,
                                 default = nil)
  if valid_581568 != nil:
    section.add "key", valid_581568
  var valid_581569 = query.getOrDefault("prettyPrint")
  valid_581569 = validateParameter(valid_581569, JBool, required = false,
                                 default = newJBool(true))
  if valid_581569 != nil:
    section.add "prettyPrint", valid_581569
  var valid_581570 = query.getOrDefault("oauth_token")
  valid_581570 = validateParameter(valid_581570, JString, required = false,
                                 default = nil)
  if valid_581570 != nil:
    section.add "oauth_token", valid_581570
  var valid_581571 = query.getOrDefault("sortField")
  valid_581571 = validateParameter(valid_581571, JString, required = false,
                                 default = newJString("ID"))
  if valid_581571 != nil:
    section.add "sortField", valid_581571
  var valid_581572 = query.getOrDefault("alt")
  valid_581572 = validateParameter(valid_581572, JString, required = false,
                                 default = newJString("json"))
  if valid_581572 != nil:
    section.add "alt", valid_581572
  var valid_581573 = query.getOrDefault("userIp")
  valid_581573 = validateParameter(valid_581573, JString, required = false,
                                 default = nil)
  if valid_581573 != nil:
    section.add "userIp", valid_581573
  var valid_581574 = query.getOrDefault("inPlan")
  valid_581574 = validateParameter(valid_581574, JBool, required = false, default = nil)
  if valid_581574 != nil:
    section.add "inPlan", valid_581574
  var valid_581575 = query.getOrDefault("quotaUser")
  valid_581575 = validateParameter(valid_581575, JString, required = false,
                                 default = nil)
  if valid_581575 != nil:
    section.add "quotaUser", valid_581575
  var valid_581576 = query.getOrDefault("orderId")
  valid_581576 = validateParameter(valid_581576, JArray, required = false,
                                 default = nil)
  if valid_581576 != nil:
    section.add "orderId", valid_581576
  var valid_581577 = query.getOrDefault("type")
  valid_581577 = validateParameter(valid_581577, JString, required = false, default = newJString(
      "PLANNING_PLACEMENT_TYPE_CREDIT"))
  if valid_581577 != nil:
    section.add "type", valid_581577
  var valid_581578 = query.getOrDefault("pageToken")
  valid_581578 = validateParameter(valid_581578, JString, required = false,
                                 default = nil)
  if valid_581578 != nil:
    section.add "pageToken", valid_581578
  var valid_581579 = query.getOrDefault("sortOrder")
  valid_581579 = validateParameter(valid_581579, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581579 != nil:
    section.add "sortOrder", valid_581579
  var valid_581580 = query.getOrDefault("siteId")
  valid_581580 = validateParameter(valid_581580, JArray, required = false,
                                 default = nil)
  if valid_581580 != nil:
    section.add "siteId", valid_581580
  var valid_581581 = query.getOrDefault("ids")
  valid_581581 = validateParameter(valid_581581, JArray, required = false,
                                 default = nil)
  if valid_581581 != nil:
    section.add "ids", valid_581581
  var valid_581582 = query.getOrDefault("fields")
  valid_581582 = validateParameter(valid_581582, JString, required = false,
                                 default = nil)
  if valid_581582 != nil:
    section.add "fields", valid_581582
  var valid_581583 = query.getOrDefault("maxResults")
  valid_581583 = validateParameter(valid_581583, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581583 != nil:
    section.add "maxResults", valid_581583
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581584: Call_DfareportingInventoryItemsList_581563; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of inventory items, possibly filtered. This method supports paging.
  ## 
  let valid = call_581584.validator(path, query, header, formData, body)
  let scheme = call_581584.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581584.url(scheme.get, call_581584.host, call_581584.base,
                         call_581584.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581584, url, valid)

proc call*(call_581585: Call_DfareportingInventoryItemsList_581563;
          projectId: string; profileId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; sortField: string = "ID";
          alt: string = "json"; userIp: string = ""; inPlan: bool = false;
          quotaUser: string = ""; orderId: JsonNode = nil;
          `type`: string = "PLANNING_PLACEMENT_TYPE_CREDIT"; pageToken: string = "";
          sortOrder: string = "ASCENDING"; siteId: JsonNode = nil; ids: JsonNode = nil;
          fields: string = ""; maxResults: int = 1000): Recallable =
  ## dfareportingInventoryItemsList
  ## Retrieves a list of inventory items, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   inPlan: bool
  ##         : Select only inventory items that are in plan.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   orderId: JArray
  ##          : Select only inventory items that belong to specified orders.
  ##   type: string
  ##       : Select only inventory items with this type.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   siteId: JArray
  ##         : Select only inventory items that are associated with these sites.
  ##   ids: JArray
  ##      : Select only inventory items with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_581586 = newJObject()
  var query_581587 = newJObject()
  add(query_581587, "key", newJString(key))
  add(query_581587, "prettyPrint", newJBool(prettyPrint))
  add(query_581587, "oauth_token", newJString(oauthToken))
  add(path_581586, "projectId", newJString(projectId))
  add(path_581586, "profileId", newJString(profileId))
  add(query_581587, "sortField", newJString(sortField))
  add(query_581587, "alt", newJString(alt))
  add(query_581587, "userIp", newJString(userIp))
  add(query_581587, "inPlan", newJBool(inPlan))
  add(query_581587, "quotaUser", newJString(quotaUser))
  if orderId != nil:
    query_581587.add "orderId", orderId
  add(query_581587, "type", newJString(`type`))
  add(query_581587, "pageToken", newJString(pageToken))
  add(query_581587, "sortOrder", newJString(sortOrder))
  if siteId != nil:
    query_581587.add "siteId", siteId
  if ids != nil:
    query_581587.add "ids", ids
  add(query_581587, "fields", newJString(fields))
  add(query_581587, "maxResults", newJInt(maxResults))
  result = call_581585.call(path_581586, query_581587, nil, nil, nil)

var dfareportingInventoryItemsList* = Call_DfareportingInventoryItemsList_581563(
    name: "dfareportingInventoryItemsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/inventoryItems",
    validator: validate_DfareportingInventoryItemsList_581564,
    base: "/dfareporting/v2.7", url: url_DfareportingInventoryItemsList_581565,
    schemes: {Scheme.Https})
type
  Call_DfareportingInventoryItemsGet_581588 = ref object of OpenApiRestCall_578364
proc url_DfareportingInventoryItemsGet_581590(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/inventoryItems/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingInventoryItemsGet_581589(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one inventory item by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Inventory item ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `projectId` field"
  var valid_581591 = path.getOrDefault("projectId")
  valid_581591 = validateParameter(valid_581591, JString, required = true,
                                 default = nil)
  if valid_581591 != nil:
    section.add "projectId", valid_581591
  var valid_581592 = path.getOrDefault("profileId")
  valid_581592 = validateParameter(valid_581592, JString, required = true,
                                 default = nil)
  if valid_581592 != nil:
    section.add "profileId", valid_581592
  var valid_581593 = path.getOrDefault("id")
  valid_581593 = validateParameter(valid_581593, JString, required = true,
                                 default = nil)
  if valid_581593 != nil:
    section.add "id", valid_581593
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581594 = query.getOrDefault("key")
  valid_581594 = validateParameter(valid_581594, JString, required = false,
                                 default = nil)
  if valid_581594 != nil:
    section.add "key", valid_581594
  var valid_581595 = query.getOrDefault("prettyPrint")
  valid_581595 = validateParameter(valid_581595, JBool, required = false,
                                 default = newJBool(true))
  if valid_581595 != nil:
    section.add "prettyPrint", valid_581595
  var valid_581596 = query.getOrDefault("oauth_token")
  valid_581596 = validateParameter(valid_581596, JString, required = false,
                                 default = nil)
  if valid_581596 != nil:
    section.add "oauth_token", valid_581596
  var valid_581597 = query.getOrDefault("alt")
  valid_581597 = validateParameter(valid_581597, JString, required = false,
                                 default = newJString("json"))
  if valid_581597 != nil:
    section.add "alt", valid_581597
  var valid_581598 = query.getOrDefault("userIp")
  valid_581598 = validateParameter(valid_581598, JString, required = false,
                                 default = nil)
  if valid_581598 != nil:
    section.add "userIp", valid_581598
  var valid_581599 = query.getOrDefault("quotaUser")
  valid_581599 = validateParameter(valid_581599, JString, required = false,
                                 default = nil)
  if valid_581599 != nil:
    section.add "quotaUser", valid_581599
  var valid_581600 = query.getOrDefault("fields")
  valid_581600 = validateParameter(valid_581600, JString, required = false,
                                 default = nil)
  if valid_581600 != nil:
    section.add "fields", valid_581600
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581601: Call_DfareportingInventoryItemsGet_581588; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one inventory item by ID.
  ## 
  let valid = call_581601.validator(path, query, header, formData, body)
  let scheme = call_581601.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581601.url(scheme.get, call_581601.host, call_581601.base,
                         call_581601.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581601, url, valid)

proc call*(call_581602: Call_DfareportingInventoryItemsGet_581588;
          projectId: string; profileId: string; id: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingInventoryItemsGet
  ## Gets one inventory item by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Inventory item ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581603 = newJObject()
  var query_581604 = newJObject()
  add(query_581604, "key", newJString(key))
  add(query_581604, "prettyPrint", newJBool(prettyPrint))
  add(query_581604, "oauth_token", newJString(oauthToken))
  add(path_581603, "projectId", newJString(projectId))
  add(path_581603, "profileId", newJString(profileId))
  add(path_581603, "id", newJString(id))
  add(query_581604, "alt", newJString(alt))
  add(query_581604, "userIp", newJString(userIp))
  add(query_581604, "quotaUser", newJString(quotaUser))
  add(query_581604, "fields", newJString(fields))
  result = call_581602.call(path_581603, query_581604, nil, nil, nil)

var dfareportingInventoryItemsGet* = Call_DfareportingInventoryItemsGet_581588(
    name: "dfareportingInventoryItemsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects/{projectId}/inventoryItems/{id}",
    validator: validate_DfareportingInventoryItemsGet_581589,
    base: "/dfareporting/v2.7", url: url_DfareportingInventoryItemsGet_581590,
    schemes: {Scheme.Https})
type
  Call_DfareportingOrderDocumentsList_581605 = ref object of OpenApiRestCall_578364
proc url_DfareportingOrderDocumentsList_581607(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orderDocuments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrderDocumentsList_581606(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of order documents, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `projectId` field"
  var valid_581608 = path.getOrDefault("projectId")
  valid_581608 = validateParameter(valid_581608, JString, required = true,
                                 default = nil)
  if valid_581608 != nil:
    section.add "projectId", valid_581608
  var valid_581609 = path.getOrDefault("profileId")
  valid_581609 = validateParameter(valid_581609, JString, required = true,
                                 default = nil)
  if valid_581609 != nil:
    section.add "profileId", valid_581609
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   approved: JBool
  ##           : Select only order documents that have been approved by at least one user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   orderId: JArray
  ##          : Select only order documents for specified orders.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for order documents by name or ID. Wildcards (*) are allowed. For example, "orderdocument*2015" will return order documents with names like "orderdocument June 2015", "orderdocument April 2015", or simply "orderdocument 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "orderdocument" will match order documents with name "my orderdocument", "orderdocument 2015", or simply "orderdocument".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   siteId: JArray
  ##         : Select only order documents that are associated with these sites.
  ##   ids: JArray
  ##      : Select only order documents with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_581610 = query.getOrDefault("key")
  valid_581610 = validateParameter(valid_581610, JString, required = false,
                                 default = nil)
  if valid_581610 != nil:
    section.add "key", valid_581610
  var valid_581611 = query.getOrDefault("prettyPrint")
  valid_581611 = validateParameter(valid_581611, JBool, required = false,
                                 default = newJBool(true))
  if valid_581611 != nil:
    section.add "prettyPrint", valid_581611
  var valid_581612 = query.getOrDefault("oauth_token")
  valid_581612 = validateParameter(valid_581612, JString, required = false,
                                 default = nil)
  if valid_581612 != nil:
    section.add "oauth_token", valid_581612
  var valid_581613 = query.getOrDefault("approved")
  valid_581613 = validateParameter(valid_581613, JBool, required = false, default = nil)
  if valid_581613 != nil:
    section.add "approved", valid_581613
  var valid_581614 = query.getOrDefault("sortField")
  valid_581614 = validateParameter(valid_581614, JString, required = false,
                                 default = newJString("ID"))
  if valid_581614 != nil:
    section.add "sortField", valid_581614
  var valid_581615 = query.getOrDefault("alt")
  valid_581615 = validateParameter(valid_581615, JString, required = false,
                                 default = newJString("json"))
  if valid_581615 != nil:
    section.add "alt", valid_581615
  var valid_581616 = query.getOrDefault("userIp")
  valid_581616 = validateParameter(valid_581616, JString, required = false,
                                 default = nil)
  if valid_581616 != nil:
    section.add "userIp", valid_581616
  var valid_581617 = query.getOrDefault("quotaUser")
  valid_581617 = validateParameter(valid_581617, JString, required = false,
                                 default = nil)
  if valid_581617 != nil:
    section.add "quotaUser", valid_581617
  var valid_581618 = query.getOrDefault("orderId")
  valid_581618 = validateParameter(valid_581618, JArray, required = false,
                                 default = nil)
  if valid_581618 != nil:
    section.add "orderId", valid_581618
  var valid_581619 = query.getOrDefault("pageToken")
  valid_581619 = validateParameter(valid_581619, JString, required = false,
                                 default = nil)
  if valid_581619 != nil:
    section.add "pageToken", valid_581619
  var valid_581620 = query.getOrDefault("searchString")
  valid_581620 = validateParameter(valid_581620, JString, required = false,
                                 default = nil)
  if valid_581620 != nil:
    section.add "searchString", valid_581620
  var valid_581621 = query.getOrDefault("sortOrder")
  valid_581621 = validateParameter(valid_581621, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581621 != nil:
    section.add "sortOrder", valid_581621
  var valid_581622 = query.getOrDefault("siteId")
  valid_581622 = validateParameter(valid_581622, JArray, required = false,
                                 default = nil)
  if valid_581622 != nil:
    section.add "siteId", valid_581622
  var valid_581623 = query.getOrDefault("ids")
  valid_581623 = validateParameter(valid_581623, JArray, required = false,
                                 default = nil)
  if valid_581623 != nil:
    section.add "ids", valid_581623
  var valid_581624 = query.getOrDefault("fields")
  valid_581624 = validateParameter(valid_581624, JString, required = false,
                                 default = nil)
  if valid_581624 != nil:
    section.add "fields", valid_581624
  var valid_581625 = query.getOrDefault("maxResults")
  valid_581625 = validateParameter(valid_581625, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581625 != nil:
    section.add "maxResults", valid_581625
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581626: Call_DfareportingOrderDocumentsList_581605; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of order documents, possibly filtered. This method supports paging.
  ## 
  let valid = call_581626.validator(path, query, header, formData, body)
  let scheme = call_581626.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581626.url(scheme.get, call_581626.host, call_581626.base,
                         call_581626.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581626, url, valid)

proc call*(call_581627: Call_DfareportingOrderDocumentsList_581605;
          projectId: string; profileId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; approved: bool = false;
          sortField: string = "ID"; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; orderId: JsonNode = nil; pageToken: string = "";
          searchString: string = ""; sortOrder: string = "ASCENDING";
          siteId: JsonNode = nil; ids: JsonNode = nil; fields: string = "";
          maxResults: int = 1000): Recallable =
  ## dfareportingOrderDocumentsList
  ## Retrieves a list of order documents, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   approved: bool
  ##           : Select only order documents that have been approved by at least one user.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   orderId: JArray
  ##          : Select only order documents for specified orders.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for order documents by name or ID. Wildcards (*) are allowed. For example, "orderdocument*2015" will return order documents with names like "orderdocument June 2015", "orderdocument April 2015", or simply "orderdocument 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "orderdocument" will match order documents with name "my orderdocument", "orderdocument 2015", or simply "orderdocument".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   siteId: JArray
  ##         : Select only order documents that are associated with these sites.
  ##   ids: JArray
  ##      : Select only order documents with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_581628 = newJObject()
  var query_581629 = newJObject()
  add(query_581629, "key", newJString(key))
  add(query_581629, "prettyPrint", newJBool(prettyPrint))
  add(query_581629, "oauth_token", newJString(oauthToken))
  add(path_581628, "projectId", newJString(projectId))
  add(path_581628, "profileId", newJString(profileId))
  add(query_581629, "approved", newJBool(approved))
  add(query_581629, "sortField", newJString(sortField))
  add(query_581629, "alt", newJString(alt))
  add(query_581629, "userIp", newJString(userIp))
  add(query_581629, "quotaUser", newJString(quotaUser))
  if orderId != nil:
    query_581629.add "orderId", orderId
  add(query_581629, "pageToken", newJString(pageToken))
  add(query_581629, "searchString", newJString(searchString))
  add(query_581629, "sortOrder", newJString(sortOrder))
  if siteId != nil:
    query_581629.add "siteId", siteId
  if ids != nil:
    query_581629.add "ids", ids
  add(query_581629, "fields", newJString(fields))
  add(query_581629, "maxResults", newJInt(maxResults))
  result = call_581627.call(path_581628, query_581629, nil, nil, nil)

var dfareportingOrderDocumentsList* = Call_DfareportingOrderDocumentsList_581605(
    name: "dfareportingOrderDocumentsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/orderDocuments",
    validator: validate_DfareportingOrderDocumentsList_581606,
    base: "/dfareporting/v2.7", url: url_DfareportingOrderDocumentsList_581607,
    schemes: {Scheme.Https})
type
  Call_DfareportingOrderDocumentsGet_581630 = ref object of OpenApiRestCall_578364
proc url_DfareportingOrderDocumentsGet_581632(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orderDocuments/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrderDocumentsGet_581631(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one order document by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Order document ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `projectId` field"
  var valid_581633 = path.getOrDefault("projectId")
  valid_581633 = validateParameter(valid_581633, JString, required = true,
                                 default = nil)
  if valid_581633 != nil:
    section.add "projectId", valid_581633
  var valid_581634 = path.getOrDefault("profileId")
  valid_581634 = validateParameter(valid_581634, JString, required = true,
                                 default = nil)
  if valid_581634 != nil:
    section.add "profileId", valid_581634
  var valid_581635 = path.getOrDefault("id")
  valid_581635 = validateParameter(valid_581635, JString, required = true,
                                 default = nil)
  if valid_581635 != nil:
    section.add "id", valid_581635
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581636 = query.getOrDefault("key")
  valid_581636 = validateParameter(valid_581636, JString, required = false,
                                 default = nil)
  if valid_581636 != nil:
    section.add "key", valid_581636
  var valid_581637 = query.getOrDefault("prettyPrint")
  valid_581637 = validateParameter(valid_581637, JBool, required = false,
                                 default = newJBool(true))
  if valid_581637 != nil:
    section.add "prettyPrint", valid_581637
  var valid_581638 = query.getOrDefault("oauth_token")
  valid_581638 = validateParameter(valid_581638, JString, required = false,
                                 default = nil)
  if valid_581638 != nil:
    section.add "oauth_token", valid_581638
  var valid_581639 = query.getOrDefault("alt")
  valid_581639 = validateParameter(valid_581639, JString, required = false,
                                 default = newJString("json"))
  if valid_581639 != nil:
    section.add "alt", valid_581639
  var valid_581640 = query.getOrDefault("userIp")
  valid_581640 = validateParameter(valid_581640, JString, required = false,
                                 default = nil)
  if valid_581640 != nil:
    section.add "userIp", valid_581640
  var valid_581641 = query.getOrDefault("quotaUser")
  valid_581641 = validateParameter(valid_581641, JString, required = false,
                                 default = nil)
  if valid_581641 != nil:
    section.add "quotaUser", valid_581641
  var valid_581642 = query.getOrDefault("fields")
  valid_581642 = validateParameter(valid_581642, JString, required = false,
                                 default = nil)
  if valid_581642 != nil:
    section.add "fields", valid_581642
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581643: Call_DfareportingOrderDocumentsGet_581630; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one order document by ID.
  ## 
  let valid = call_581643.validator(path, query, header, formData, body)
  let scheme = call_581643.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581643.url(scheme.get, call_581643.host, call_581643.base,
                         call_581643.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581643, url, valid)

proc call*(call_581644: Call_DfareportingOrderDocumentsGet_581630;
          projectId: string; profileId: string; id: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingOrderDocumentsGet
  ## Gets one order document by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Order document ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581645 = newJObject()
  var query_581646 = newJObject()
  add(query_581646, "key", newJString(key))
  add(query_581646, "prettyPrint", newJBool(prettyPrint))
  add(query_581646, "oauth_token", newJString(oauthToken))
  add(path_581645, "projectId", newJString(projectId))
  add(path_581645, "profileId", newJString(profileId))
  add(path_581645, "id", newJString(id))
  add(query_581646, "alt", newJString(alt))
  add(query_581646, "userIp", newJString(userIp))
  add(query_581646, "quotaUser", newJString(quotaUser))
  add(query_581646, "fields", newJString(fields))
  result = call_581644.call(path_581645, query_581646, nil, nil, nil)

var dfareportingOrderDocumentsGet* = Call_DfareportingOrderDocumentsGet_581630(
    name: "dfareportingOrderDocumentsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects/{projectId}/orderDocuments/{id}",
    validator: validate_DfareportingOrderDocumentsGet_581631,
    base: "/dfareporting/v2.7", url: url_DfareportingOrderDocumentsGet_581632,
    schemes: {Scheme.Https})
type
  Call_DfareportingOrdersList_581647 = ref object of OpenApiRestCall_578364
proc url_DfareportingOrdersList_581649(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orders")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrdersList_581648(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of orders, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   projectId: JString (required)
  ##            : Project ID for orders.
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `projectId` field"
  var valid_581650 = path.getOrDefault("projectId")
  valid_581650 = validateParameter(valid_581650, JString, required = true,
                                 default = nil)
  if valid_581650 != nil:
    section.add "projectId", valid_581650
  var valid_581651 = path.getOrDefault("profileId")
  valid_581651 = validateParameter(valid_581651, JString, required = true,
                                 default = nil)
  if valid_581651 != nil:
    section.add "profileId", valid_581651
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for orders by name or ID. Wildcards (*) are allowed. For example, "order*2015" will return orders with names like "order June 2015", "order April 2015", or simply "order 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "order" will match orders with name "my order", "order 2015", or simply "order".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   siteId: JArray
  ##         : Select only orders that are associated with these site IDs.
  ##   ids: JArray
  ##      : Select only orders with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_581652 = query.getOrDefault("key")
  valid_581652 = validateParameter(valid_581652, JString, required = false,
                                 default = nil)
  if valid_581652 != nil:
    section.add "key", valid_581652
  var valid_581653 = query.getOrDefault("prettyPrint")
  valid_581653 = validateParameter(valid_581653, JBool, required = false,
                                 default = newJBool(true))
  if valid_581653 != nil:
    section.add "prettyPrint", valid_581653
  var valid_581654 = query.getOrDefault("oauth_token")
  valid_581654 = validateParameter(valid_581654, JString, required = false,
                                 default = nil)
  if valid_581654 != nil:
    section.add "oauth_token", valid_581654
  var valid_581655 = query.getOrDefault("sortField")
  valid_581655 = validateParameter(valid_581655, JString, required = false,
                                 default = newJString("ID"))
  if valid_581655 != nil:
    section.add "sortField", valid_581655
  var valid_581656 = query.getOrDefault("alt")
  valid_581656 = validateParameter(valid_581656, JString, required = false,
                                 default = newJString("json"))
  if valid_581656 != nil:
    section.add "alt", valid_581656
  var valid_581657 = query.getOrDefault("userIp")
  valid_581657 = validateParameter(valid_581657, JString, required = false,
                                 default = nil)
  if valid_581657 != nil:
    section.add "userIp", valid_581657
  var valid_581658 = query.getOrDefault("quotaUser")
  valid_581658 = validateParameter(valid_581658, JString, required = false,
                                 default = nil)
  if valid_581658 != nil:
    section.add "quotaUser", valid_581658
  var valid_581659 = query.getOrDefault("pageToken")
  valid_581659 = validateParameter(valid_581659, JString, required = false,
                                 default = nil)
  if valid_581659 != nil:
    section.add "pageToken", valid_581659
  var valid_581660 = query.getOrDefault("searchString")
  valid_581660 = validateParameter(valid_581660, JString, required = false,
                                 default = nil)
  if valid_581660 != nil:
    section.add "searchString", valid_581660
  var valid_581661 = query.getOrDefault("sortOrder")
  valid_581661 = validateParameter(valid_581661, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581661 != nil:
    section.add "sortOrder", valid_581661
  var valid_581662 = query.getOrDefault("siteId")
  valid_581662 = validateParameter(valid_581662, JArray, required = false,
                                 default = nil)
  if valid_581662 != nil:
    section.add "siteId", valid_581662
  var valid_581663 = query.getOrDefault("ids")
  valid_581663 = validateParameter(valid_581663, JArray, required = false,
                                 default = nil)
  if valid_581663 != nil:
    section.add "ids", valid_581663
  var valid_581664 = query.getOrDefault("fields")
  valid_581664 = validateParameter(valid_581664, JString, required = false,
                                 default = nil)
  if valid_581664 != nil:
    section.add "fields", valid_581664
  var valid_581665 = query.getOrDefault("maxResults")
  valid_581665 = validateParameter(valid_581665, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581665 != nil:
    section.add "maxResults", valid_581665
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581666: Call_DfareportingOrdersList_581647; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of orders, possibly filtered. This method supports paging.
  ## 
  let valid = call_581666.validator(path, query, header, formData, body)
  let scheme = call_581666.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581666.url(scheme.get, call_581666.host, call_581666.base,
                         call_581666.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581666, url, valid)

proc call*(call_581667: Call_DfareportingOrdersList_581647; projectId: string;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; sortField: string = "ID"; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; pageToken: string = "";
          searchString: string = ""; sortOrder: string = "ASCENDING";
          siteId: JsonNode = nil; ids: JsonNode = nil; fields: string = "";
          maxResults: int = 1000): Recallable =
  ## dfareportingOrdersList
  ## Retrieves a list of orders, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   projectId: string (required)
  ##            : Project ID for orders.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for orders by name or ID. Wildcards (*) are allowed. For example, "order*2015" will return orders with names like "order June 2015", "order April 2015", or simply "order 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "order" will match orders with name "my order", "order 2015", or simply "order".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   siteId: JArray
  ##         : Select only orders that are associated with these site IDs.
  ##   ids: JArray
  ##      : Select only orders with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_581668 = newJObject()
  var query_581669 = newJObject()
  add(query_581669, "key", newJString(key))
  add(query_581669, "prettyPrint", newJBool(prettyPrint))
  add(query_581669, "oauth_token", newJString(oauthToken))
  add(path_581668, "projectId", newJString(projectId))
  add(path_581668, "profileId", newJString(profileId))
  add(query_581669, "sortField", newJString(sortField))
  add(query_581669, "alt", newJString(alt))
  add(query_581669, "userIp", newJString(userIp))
  add(query_581669, "quotaUser", newJString(quotaUser))
  add(query_581669, "pageToken", newJString(pageToken))
  add(query_581669, "searchString", newJString(searchString))
  add(query_581669, "sortOrder", newJString(sortOrder))
  if siteId != nil:
    query_581669.add "siteId", siteId
  if ids != nil:
    query_581669.add "ids", ids
  add(query_581669, "fields", newJString(fields))
  add(query_581669, "maxResults", newJInt(maxResults))
  result = call_581667.call(path_581668, query_581669, nil, nil, nil)

var dfareportingOrdersList* = Call_DfareportingOrdersList_581647(
    name: "dfareportingOrdersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/orders",
    validator: validate_DfareportingOrdersList_581648, base: "/dfareporting/v2.7",
    url: url_DfareportingOrdersList_581649, schemes: {Scheme.Https})
type
  Call_DfareportingOrdersGet_581670 = ref object of OpenApiRestCall_578364
proc url_DfareportingOrdersGet_581672(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orders/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrdersGet_581671(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one order by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   projectId: JString (required)
  ##            : Project ID for orders.
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Order ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `projectId` field"
  var valid_581673 = path.getOrDefault("projectId")
  valid_581673 = validateParameter(valid_581673, JString, required = true,
                                 default = nil)
  if valid_581673 != nil:
    section.add "projectId", valid_581673
  var valid_581674 = path.getOrDefault("profileId")
  valid_581674 = validateParameter(valid_581674, JString, required = true,
                                 default = nil)
  if valid_581674 != nil:
    section.add "profileId", valid_581674
  var valid_581675 = path.getOrDefault("id")
  valid_581675 = validateParameter(valid_581675, JString, required = true,
                                 default = nil)
  if valid_581675 != nil:
    section.add "id", valid_581675
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581676 = query.getOrDefault("key")
  valid_581676 = validateParameter(valid_581676, JString, required = false,
                                 default = nil)
  if valid_581676 != nil:
    section.add "key", valid_581676
  var valid_581677 = query.getOrDefault("prettyPrint")
  valid_581677 = validateParameter(valid_581677, JBool, required = false,
                                 default = newJBool(true))
  if valid_581677 != nil:
    section.add "prettyPrint", valid_581677
  var valid_581678 = query.getOrDefault("oauth_token")
  valid_581678 = validateParameter(valid_581678, JString, required = false,
                                 default = nil)
  if valid_581678 != nil:
    section.add "oauth_token", valid_581678
  var valid_581679 = query.getOrDefault("alt")
  valid_581679 = validateParameter(valid_581679, JString, required = false,
                                 default = newJString("json"))
  if valid_581679 != nil:
    section.add "alt", valid_581679
  var valid_581680 = query.getOrDefault("userIp")
  valid_581680 = validateParameter(valid_581680, JString, required = false,
                                 default = nil)
  if valid_581680 != nil:
    section.add "userIp", valid_581680
  var valid_581681 = query.getOrDefault("quotaUser")
  valid_581681 = validateParameter(valid_581681, JString, required = false,
                                 default = nil)
  if valid_581681 != nil:
    section.add "quotaUser", valid_581681
  var valid_581682 = query.getOrDefault("fields")
  valid_581682 = validateParameter(valid_581682, JString, required = false,
                                 default = nil)
  if valid_581682 != nil:
    section.add "fields", valid_581682
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581683: Call_DfareportingOrdersGet_581670; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one order by ID.
  ## 
  let valid = call_581683.validator(path, query, header, formData, body)
  let scheme = call_581683.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581683.url(scheme.get, call_581683.host, call_581683.base,
                         call_581683.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581683, url, valid)

proc call*(call_581684: Call_DfareportingOrdersGet_581670; projectId: string;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingOrdersGet
  ## Gets one order by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   projectId: string (required)
  ##            : Project ID for orders.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Order ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581685 = newJObject()
  var query_581686 = newJObject()
  add(query_581686, "key", newJString(key))
  add(query_581686, "prettyPrint", newJBool(prettyPrint))
  add(query_581686, "oauth_token", newJString(oauthToken))
  add(path_581685, "projectId", newJString(projectId))
  add(path_581685, "profileId", newJString(profileId))
  add(path_581685, "id", newJString(id))
  add(query_581686, "alt", newJString(alt))
  add(query_581686, "userIp", newJString(userIp))
  add(query_581686, "quotaUser", newJString(quotaUser))
  add(query_581686, "fields", newJString(fields))
  result = call_581684.call(path_581685, query_581686, nil, nil, nil)

var dfareportingOrdersGet* = Call_DfareportingOrdersGet_581670(
    name: "dfareportingOrdersGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/orders/{id}",
    validator: validate_DfareportingOrdersGet_581671, base: "/dfareporting/v2.7",
    url: url_DfareportingOrdersGet_581672, schemes: {Scheme.Https})
type
  Call_DfareportingRegionsList_581687 = ref object of OpenApiRestCall_578364
proc url_DfareportingRegionsList_581689(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/regions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRegionsList_581688(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of regions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581690 = path.getOrDefault("profileId")
  valid_581690 = validateParameter(valid_581690, JString, required = true,
                                 default = nil)
  if valid_581690 != nil:
    section.add "profileId", valid_581690
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581691 = query.getOrDefault("key")
  valid_581691 = validateParameter(valid_581691, JString, required = false,
                                 default = nil)
  if valid_581691 != nil:
    section.add "key", valid_581691
  var valid_581692 = query.getOrDefault("prettyPrint")
  valid_581692 = validateParameter(valid_581692, JBool, required = false,
                                 default = newJBool(true))
  if valid_581692 != nil:
    section.add "prettyPrint", valid_581692
  var valid_581693 = query.getOrDefault("oauth_token")
  valid_581693 = validateParameter(valid_581693, JString, required = false,
                                 default = nil)
  if valid_581693 != nil:
    section.add "oauth_token", valid_581693
  var valid_581694 = query.getOrDefault("alt")
  valid_581694 = validateParameter(valid_581694, JString, required = false,
                                 default = newJString("json"))
  if valid_581694 != nil:
    section.add "alt", valid_581694
  var valid_581695 = query.getOrDefault("userIp")
  valid_581695 = validateParameter(valid_581695, JString, required = false,
                                 default = nil)
  if valid_581695 != nil:
    section.add "userIp", valid_581695
  var valid_581696 = query.getOrDefault("quotaUser")
  valid_581696 = validateParameter(valid_581696, JString, required = false,
                                 default = nil)
  if valid_581696 != nil:
    section.add "quotaUser", valid_581696
  var valid_581697 = query.getOrDefault("fields")
  valid_581697 = validateParameter(valid_581697, JString, required = false,
                                 default = nil)
  if valid_581697 != nil:
    section.add "fields", valid_581697
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581698: Call_DfareportingRegionsList_581687; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of regions.
  ## 
  let valid = call_581698.validator(path, query, header, formData, body)
  let scheme = call_581698.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581698.url(scheme.get, call_581698.host, call_581698.base,
                         call_581698.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581698, url, valid)

proc call*(call_581699: Call_DfareportingRegionsList_581687; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingRegionsList
  ## Retrieves a list of regions.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581700 = newJObject()
  var query_581701 = newJObject()
  add(query_581701, "key", newJString(key))
  add(query_581701, "prettyPrint", newJBool(prettyPrint))
  add(query_581701, "oauth_token", newJString(oauthToken))
  add(path_581700, "profileId", newJString(profileId))
  add(query_581701, "alt", newJString(alt))
  add(query_581701, "userIp", newJString(userIp))
  add(query_581701, "quotaUser", newJString(quotaUser))
  add(query_581701, "fields", newJString(fields))
  result = call_581699.call(path_581700, query_581701, nil, nil, nil)

var dfareportingRegionsList* = Call_DfareportingRegionsList_581687(
    name: "dfareportingRegionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/regions",
    validator: validate_DfareportingRegionsList_581688,
    base: "/dfareporting/v2.7", url: url_DfareportingRegionsList_581689,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListSharesUpdate_581702 = ref object of OpenApiRestCall_578364
proc url_DfareportingRemarketingListSharesUpdate_581704(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingListShares")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListSharesUpdate_581703(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list share.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581705 = path.getOrDefault("profileId")
  valid_581705 = validateParameter(valid_581705, JString, required = true,
                                 default = nil)
  if valid_581705 != nil:
    section.add "profileId", valid_581705
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581706 = query.getOrDefault("key")
  valid_581706 = validateParameter(valid_581706, JString, required = false,
                                 default = nil)
  if valid_581706 != nil:
    section.add "key", valid_581706
  var valid_581707 = query.getOrDefault("prettyPrint")
  valid_581707 = validateParameter(valid_581707, JBool, required = false,
                                 default = newJBool(true))
  if valid_581707 != nil:
    section.add "prettyPrint", valid_581707
  var valid_581708 = query.getOrDefault("oauth_token")
  valid_581708 = validateParameter(valid_581708, JString, required = false,
                                 default = nil)
  if valid_581708 != nil:
    section.add "oauth_token", valid_581708
  var valid_581709 = query.getOrDefault("alt")
  valid_581709 = validateParameter(valid_581709, JString, required = false,
                                 default = newJString("json"))
  if valid_581709 != nil:
    section.add "alt", valid_581709
  var valid_581710 = query.getOrDefault("userIp")
  valid_581710 = validateParameter(valid_581710, JString, required = false,
                                 default = nil)
  if valid_581710 != nil:
    section.add "userIp", valid_581710
  var valid_581711 = query.getOrDefault("quotaUser")
  valid_581711 = validateParameter(valid_581711, JString, required = false,
                                 default = nil)
  if valid_581711 != nil:
    section.add "quotaUser", valid_581711
  var valid_581712 = query.getOrDefault("fields")
  valid_581712 = validateParameter(valid_581712, JString, required = false,
                                 default = nil)
  if valid_581712 != nil:
    section.add "fields", valid_581712
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581714: Call_DfareportingRemarketingListSharesUpdate_581702;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list share.
  ## 
  let valid = call_581714.validator(path, query, header, formData, body)
  let scheme = call_581714.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581714.url(scheme.get, call_581714.host, call_581714.base,
                         call_581714.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581714, url, valid)

proc call*(call_581715: Call_DfareportingRemarketingListSharesUpdate_581702;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingRemarketingListSharesUpdate
  ## Updates an existing remarketing list share.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581716 = newJObject()
  var query_581717 = newJObject()
  var body_581718 = newJObject()
  add(query_581717, "key", newJString(key))
  add(query_581717, "prettyPrint", newJBool(prettyPrint))
  add(query_581717, "oauth_token", newJString(oauthToken))
  add(path_581716, "profileId", newJString(profileId))
  add(query_581717, "alt", newJString(alt))
  add(query_581717, "userIp", newJString(userIp))
  add(query_581717, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_581718 = body
  add(query_581717, "fields", newJString(fields))
  result = call_581715.call(path_581716, query_581717, nil, nil, body_581718)

var dfareportingRemarketingListSharesUpdate* = Call_DfareportingRemarketingListSharesUpdate_581702(
    name: "dfareportingRemarketingListSharesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingListShares",
    validator: validate_DfareportingRemarketingListSharesUpdate_581703,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListSharesUpdate_581704,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListSharesPatch_581719 = ref object of OpenApiRestCall_578364
proc url_DfareportingRemarketingListSharesPatch_581721(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingListShares")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListSharesPatch_581720(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list share. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581722 = path.getOrDefault("profileId")
  valid_581722 = validateParameter(valid_581722, JString, required = true,
                                 default = nil)
  if valid_581722 != nil:
    section.add "profileId", valid_581722
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   remarketingListId: JString (required)
  ##                    : Remarketing list ID.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581723 = query.getOrDefault("key")
  valid_581723 = validateParameter(valid_581723, JString, required = false,
                                 default = nil)
  if valid_581723 != nil:
    section.add "key", valid_581723
  assert query != nil,
        "query argument is necessary due to required `remarketingListId` field"
  var valid_581724 = query.getOrDefault("remarketingListId")
  valid_581724 = validateParameter(valid_581724, JString, required = true,
                                 default = nil)
  if valid_581724 != nil:
    section.add "remarketingListId", valid_581724
  var valid_581725 = query.getOrDefault("prettyPrint")
  valid_581725 = validateParameter(valid_581725, JBool, required = false,
                                 default = newJBool(true))
  if valid_581725 != nil:
    section.add "prettyPrint", valid_581725
  var valid_581726 = query.getOrDefault("oauth_token")
  valid_581726 = validateParameter(valid_581726, JString, required = false,
                                 default = nil)
  if valid_581726 != nil:
    section.add "oauth_token", valid_581726
  var valid_581727 = query.getOrDefault("alt")
  valid_581727 = validateParameter(valid_581727, JString, required = false,
                                 default = newJString("json"))
  if valid_581727 != nil:
    section.add "alt", valid_581727
  var valid_581728 = query.getOrDefault("userIp")
  valid_581728 = validateParameter(valid_581728, JString, required = false,
                                 default = nil)
  if valid_581728 != nil:
    section.add "userIp", valid_581728
  var valid_581729 = query.getOrDefault("quotaUser")
  valid_581729 = validateParameter(valid_581729, JString, required = false,
                                 default = nil)
  if valid_581729 != nil:
    section.add "quotaUser", valid_581729
  var valid_581730 = query.getOrDefault("fields")
  valid_581730 = validateParameter(valid_581730, JString, required = false,
                                 default = nil)
  if valid_581730 != nil:
    section.add "fields", valid_581730
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581732: Call_DfareportingRemarketingListSharesPatch_581719;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list share. This method supports patch semantics.
  ## 
  let valid = call_581732.validator(path, query, header, formData, body)
  let scheme = call_581732.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581732.url(scheme.get, call_581732.host, call_581732.base,
                         call_581732.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581732, url, valid)

proc call*(call_581733: Call_DfareportingRemarketingListSharesPatch_581719;
          remarketingListId: string; profileId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; body: JsonNode = nil;
          fields: string = ""): Recallable =
  ## dfareportingRemarketingListSharesPatch
  ## Updates an existing remarketing list share. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   remarketingListId: string (required)
  ##                    : Remarketing list ID.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581734 = newJObject()
  var query_581735 = newJObject()
  var body_581736 = newJObject()
  add(query_581735, "key", newJString(key))
  add(query_581735, "remarketingListId", newJString(remarketingListId))
  add(query_581735, "prettyPrint", newJBool(prettyPrint))
  add(query_581735, "oauth_token", newJString(oauthToken))
  add(path_581734, "profileId", newJString(profileId))
  add(query_581735, "alt", newJString(alt))
  add(query_581735, "userIp", newJString(userIp))
  add(query_581735, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_581736 = body
  add(query_581735, "fields", newJString(fields))
  result = call_581733.call(path_581734, query_581735, nil, nil, body_581736)

var dfareportingRemarketingListSharesPatch* = Call_DfareportingRemarketingListSharesPatch_581719(
    name: "dfareportingRemarketingListSharesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingListShares",
    validator: validate_DfareportingRemarketingListSharesPatch_581720,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListSharesPatch_581721,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListSharesGet_581737 = ref object of OpenApiRestCall_578364
proc url_DfareportingRemarketingListSharesGet_581739(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "remarketingListId" in path,
        "`remarketingListId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingListShares/"),
               (kind: VariableSegment, value: "remarketingListId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListSharesGet_581738(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one remarketing list share by remarketing list ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   remarketingListId: JString (required)
  ##                    : Remarketing list ID.
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `remarketingListId` field"
  var valid_581740 = path.getOrDefault("remarketingListId")
  valid_581740 = validateParameter(valid_581740, JString, required = true,
                                 default = nil)
  if valid_581740 != nil:
    section.add "remarketingListId", valid_581740
  var valid_581741 = path.getOrDefault("profileId")
  valid_581741 = validateParameter(valid_581741, JString, required = true,
                                 default = nil)
  if valid_581741 != nil:
    section.add "profileId", valid_581741
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581742 = query.getOrDefault("key")
  valid_581742 = validateParameter(valid_581742, JString, required = false,
                                 default = nil)
  if valid_581742 != nil:
    section.add "key", valid_581742
  var valid_581743 = query.getOrDefault("prettyPrint")
  valid_581743 = validateParameter(valid_581743, JBool, required = false,
                                 default = newJBool(true))
  if valid_581743 != nil:
    section.add "prettyPrint", valid_581743
  var valid_581744 = query.getOrDefault("oauth_token")
  valid_581744 = validateParameter(valid_581744, JString, required = false,
                                 default = nil)
  if valid_581744 != nil:
    section.add "oauth_token", valid_581744
  var valid_581745 = query.getOrDefault("alt")
  valid_581745 = validateParameter(valid_581745, JString, required = false,
                                 default = newJString("json"))
  if valid_581745 != nil:
    section.add "alt", valid_581745
  var valid_581746 = query.getOrDefault("userIp")
  valid_581746 = validateParameter(valid_581746, JString, required = false,
                                 default = nil)
  if valid_581746 != nil:
    section.add "userIp", valid_581746
  var valid_581747 = query.getOrDefault("quotaUser")
  valid_581747 = validateParameter(valid_581747, JString, required = false,
                                 default = nil)
  if valid_581747 != nil:
    section.add "quotaUser", valid_581747
  var valid_581748 = query.getOrDefault("fields")
  valid_581748 = validateParameter(valid_581748, JString, required = false,
                                 default = nil)
  if valid_581748 != nil:
    section.add "fields", valid_581748
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581749: Call_DfareportingRemarketingListSharesGet_581737;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one remarketing list share by remarketing list ID.
  ## 
  let valid = call_581749.validator(path, query, header, formData, body)
  let scheme = call_581749.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581749.url(scheme.get, call_581749.host, call_581749.base,
                         call_581749.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581749, url, valid)

proc call*(call_581750: Call_DfareportingRemarketingListSharesGet_581737;
          remarketingListId: string; profileId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingRemarketingListSharesGet
  ## Gets one remarketing list share by remarketing list ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   remarketingListId: string (required)
  ##                    : Remarketing list ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581751 = newJObject()
  var query_581752 = newJObject()
  add(query_581752, "key", newJString(key))
  add(query_581752, "prettyPrint", newJBool(prettyPrint))
  add(query_581752, "oauth_token", newJString(oauthToken))
  add(path_581751, "remarketingListId", newJString(remarketingListId))
  add(path_581751, "profileId", newJString(profileId))
  add(query_581752, "alt", newJString(alt))
  add(query_581752, "userIp", newJString(userIp))
  add(query_581752, "quotaUser", newJString(quotaUser))
  add(query_581752, "fields", newJString(fields))
  result = call_581750.call(path_581751, query_581752, nil, nil, nil)

var dfareportingRemarketingListSharesGet* = Call_DfareportingRemarketingListSharesGet_581737(
    name: "dfareportingRemarketingListSharesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/remarketingListShares/{remarketingListId}",
    validator: validate_DfareportingRemarketingListSharesGet_581738,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListSharesGet_581739,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsUpdate_581776 = ref object of OpenApiRestCall_578364
proc url_DfareportingRemarketingListsUpdate_581778(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsUpdate_581777(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581779 = path.getOrDefault("profileId")
  valid_581779 = validateParameter(valid_581779, JString, required = true,
                                 default = nil)
  if valid_581779 != nil:
    section.add "profileId", valid_581779
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581780 = query.getOrDefault("key")
  valid_581780 = validateParameter(valid_581780, JString, required = false,
                                 default = nil)
  if valid_581780 != nil:
    section.add "key", valid_581780
  var valid_581781 = query.getOrDefault("prettyPrint")
  valid_581781 = validateParameter(valid_581781, JBool, required = false,
                                 default = newJBool(true))
  if valid_581781 != nil:
    section.add "prettyPrint", valid_581781
  var valid_581782 = query.getOrDefault("oauth_token")
  valid_581782 = validateParameter(valid_581782, JString, required = false,
                                 default = nil)
  if valid_581782 != nil:
    section.add "oauth_token", valid_581782
  var valid_581783 = query.getOrDefault("alt")
  valid_581783 = validateParameter(valid_581783, JString, required = false,
                                 default = newJString("json"))
  if valid_581783 != nil:
    section.add "alt", valid_581783
  var valid_581784 = query.getOrDefault("userIp")
  valid_581784 = validateParameter(valid_581784, JString, required = false,
                                 default = nil)
  if valid_581784 != nil:
    section.add "userIp", valid_581784
  var valid_581785 = query.getOrDefault("quotaUser")
  valid_581785 = validateParameter(valid_581785, JString, required = false,
                                 default = nil)
  if valid_581785 != nil:
    section.add "quotaUser", valid_581785
  var valid_581786 = query.getOrDefault("fields")
  valid_581786 = validateParameter(valid_581786, JString, required = false,
                                 default = nil)
  if valid_581786 != nil:
    section.add "fields", valid_581786
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581788: Call_DfareportingRemarketingListsUpdate_581776;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list.
  ## 
  let valid = call_581788.validator(path, query, header, formData, body)
  let scheme = call_581788.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581788.url(scheme.get, call_581788.host, call_581788.base,
                         call_581788.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581788, url, valid)

proc call*(call_581789: Call_DfareportingRemarketingListsUpdate_581776;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingRemarketingListsUpdate
  ## Updates an existing remarketing list.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581790 = newJObject()
  var query_581791 = newJObject()
  var body_581792 = newJObject()
  add(query_581791, "key", newJString(key))
  add(query_581791, "prettyPrint", newJBool(prettyPrint))
  add(query_581791, "oauth_token", newJString(oauthToken))
  add(path_581790, "profileId", newJString(profileId))
  add(query_581791, "alt", newJString(alt))
  add(query_581791, "userIp", newJString(userIp))
  add(query_581791, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_581792 = body
  add(query_581791, "fields", newJString(fields))
  result = call_581789.call(path_581790, query_581791, nil, nil, body_581792)

var dfareportingRemarketingListsUpdate* = Call_DfareportingRemarketingListsUpdate_581776(
    name: "dfareportingRemarketingListsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsUpdate_581777,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsUpdate_581778,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsInsert_581793 = ref object of OpenApiRestCall_578364
proc url_DfareportingRemarketingListsInsert_581795(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsInsert_581794(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new remarketing list.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581796 = path.getOrDefault("profileId")
  valid_581796 = validateParameter(valid_581796, JString, required = true,
                                 default = nil)
  if valid_581796 != nil:
    section.add "profileId", valid_581796
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581797 = query.getOrDefault("key")
  valid_581797 = validateParameter(valid_581797, JString, required = false,
                                 default = nil)
  if valid_581797 != nil:
    section.add "key", valid_581797
  var valid_581798 = query.getOrDefault("prettyPrint")
  valid_581798 = validateParameter(valid_581798, JBool, required = false,
                                 default = newJBool(true))
  if valid_581798 != nil:
    section.add "prettyPrint", valid_581798
  var valid_581799 = query.getOrDefault("oauth_token")
  valid_581799 = validateParameter(valid_581799, JString, required = false,
                                 default = nil)
  if valid_581799 != nil:
    section.add "oauth_token", valid_581799
  var valid_581800 = query.getOrDefault("alt")
  valid_581800 = validateParameter(valid_581800, JString, required = false,
                                 default = newJString("json"))
  if valid_581800 != nil:
    section.add "alt", valid_581800
  var valid_581801 = query.getOrDefault("userIp")
  valid_581801 = validateParameter(valid_581801, JString, required = false,
                                 default = nil)
  if valid_581801 != nil:
    section.add "userIp", valid_581801
  var valid_581802 = query.getOrDefault("quotaUser")
  valid_581802 = validateParameter(valid_581802, JString, required = false,
                                 default = nil)
  if valid_581802 != nil:
    section.add "quotaUser", valid_581802
  var valid_581803 = query.getOrDefault("fields")
  valid_581803 = validateParameter(valid_581803, JString, required = false,
                                 default = nil)
  if valid_581803 != nil:
    section.add "fields", valid_581803
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581805: Call_DfareportingRemarketingListsInsert_581793;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new remarketing list.
  ## 
  let valid = call_581805.validator(path, query, header, formData, body)
  let scheme = call_581805.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581805.url(scheme.get, call_581805.host, call_581805.base,
                         call_581805.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581805, url, valid)

proc call*(call_581806: Call_DfareportingRemarketingListsInsert_581793;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingRemarketingListsInsert
  ## Inserts a new remarketing list.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581807 = newJObject()
  var query_581808 = newJObject()
  var body_581809 = newJObject()
  add(query_581808, "key", newJString(key))
  add(query_581808, "prettyPrint", newJBool(prettyPrint))
  add(query_581808, "oauth_token", newJString(oauthToken))
  add(path_581807, "profileId", newJString(profileId))
  add(query_581808, "alt", newJString(alt))
  add(query_581808, "userIp", newJString(userIp))
  add(query_581808, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_581809 = body
  add(query_581808, "fields", newJString(fields))
  result = call_581806.call(path_581807, query_581808, nil, nil, body_581809)

var dfareportingRemarketingListsInsert* = Call_DfareportingRemarketingListsInsert_581793(
    name: "dfareportingRemarketingListsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsInsert_581794,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsInsert_581795,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsList_581753 = ref object of OpenApiRestCall_578364
proc url_DfareportingRemarketingListsList_581755(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsList_581754(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of remarketing lists, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581756 = path.getOrDefault("profileId")
  valid_581756 = validateParameter(valid_581756, JString, required = true,
                                 default = nil)
  if valid_581756 != nil:
    section.add "profileId", valid_581756
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   name: JString
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   floodlightActivityId: JString
  ##                       : Select only remarketing lists that have this floodlight activity ID.
  ##   active: JBool
  ##         : Select only active or only inactive remarketing lists.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   advertiserId: JString (required)
  ##               : Select only remarketing lists owned by this advertiser.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_581757 = query.getOrDefault("key")
  valid_581757 = validateParameter(valid_581757, JString, required = false,
                                 default = nil)
  if valid_581757 != nil:
    section.add "key", valid_581757
  var valid_581758 = query.getOrDefault("prettyPrint")
  valid_581758 = validateParameter(valid_581758, JBool, required = false,
                                 default = newJBool(true))
  if valid_581758 != nil:
    section.add "prettyPrint", valid_581758
  var valid_581759 = query.getOrDefault("oauth_token")
  valid_581759 = validateParameter(valid_581759, JString, required = false,
                                 default = nil)
  if valid_581759 != nil:
    section.add "oauth_token", valid_581759
  var valid_581760 = query.getOrDefault("name")
  valid_581760 = validateParameter(valid_581760, JString, required = false,
                                 default = nil)
  if valid_581760 != nil:
    section.add "name", valid_581760
  var valid_581761 = query.getOrDefault("floodlightActivityId")
  valid_581761 = validateParameter(valid_581761, JString, required = false,
                                 default = nil)
  if valid_581761 != nil:
    section.add "floodlightActivityId", valid_581761
  var valid_581762 = query.getOrDefault("active")
  valid_581762 = validateParameter(valid_581762, JBool, required = false, default = nil)
  if valid_581762 != nil:
    section.add "active", valid_581762
  var valid_581763 = query.getOrDefault("sortField")
  valid_581763 = validateParameter(valid_581763, JString, required = false,
                                 default = newJString("ID"))
  if valid_581763 != nil:
    section.add "sortField", valid_581763
  var valid_581764 = query.getOrDefault("alt")
  valid_581764 = validateParameter(valid_581764, JString, required = false,
                                 default = newJString("json"))
  if valid_581764 != nil:
    section.add "alt", valid_581764
  var valid_581765 = query.getOrDefault("userIp")
  valid_581765 = validateParameter(valid_581765, JString, required = false,
                                 default = nil)
  if valid_581765 != nil:
    section.add "userIp", valid_581765
  var valid_581766 = query.getOrDefault("quotaUser")
  valid_581766 = validateParameter(valid_581766, JString, required = false,
                                 default = nil)
  if valid_581766 != nil:
    section.add "quotaUser", valid_581766
  var valid_581767 = query.getOrDefault("pageToken")
  valid_581767 = validateParameter(valid_581767, JString, required = false,
                                 default = nil)
  if valid_581767 != nil:
    section.add "pageToken", valid_581767
  var valid_581768 = query.getOrDefault("sortOrder")
  valid_581768 = validateParameter(valid_581768, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581768 != nil:
    section.add "sortOrder", valid_581768
  assert query != nil,
        "query argument is necessary due to required `advertiserId` field"
  var valid_581769 = query.getOrDefault("advertiserId")
  valid_581769 = validateParameter(valid_581769, JString, required = true,
                                 default = nil)
  if valid_581769 != nil:
    section.add "advertiserId", valid_581769
  var valid_581770 = query.getOrDefault("fields")
  valid_581770 = validateParameter(valid_581770, JString, required = false,
                                 default = nil)
  if valid_581770 != nil:
    section.add "fields", valid_581770
  var valid_581771 = query.getOrDefault("maxResults")
  valid_581771 = validateParameter(valid_581771, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581771 != nil:
    section.add "maxResults", valid_581771
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581772: Call_DfareportingRemarketingListsList_581753;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of remarketing lists, possibly filtered. This method supports paging.
  ## 
  let valid = call_581772.validator(path, query, header, formData, body)
  let scheme = call_581772.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581772.url(scheme.get, call_581772.host, call_581772.base,
                         call_581772.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581772, url, valid)

proc call*(call_581773: Call_DfareportingRemarketingListsList_581753;
          profileId: string; advertiserId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; name: string = "";
          floodlightActivityId: string = ""; active: bool = false;
          sortField: string = "ID"; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; pageToken: string = "";
          sortOrder: string = "ASCENDING"; fields: string = ""; maxResults: int = 1000): Recallable =
  ## dfareportingRemarketingListsList
  ## Retrieves a list of remarketing lists, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   name: string
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   floodlightActivityId: string
  ##                       : Select only remarketing lists that have this floodlight activity ID.
  ##   active: bool
  ##         : Select only active or only inactive remarketing lists.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   advertiserId: string (required)
  ##               : Select only remarketing lists owned by this advertiser.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_581774 = newJObject()
  var query_581775 = newJObject()
  add(query_581775, "key", newJString(key))
  add(query_581775, "prettyPrint", newJBool(prettyPrint))
  add(query_581775, "oauth_token", newJString(oauthToken))
  add(query_581775, "name", newJString(name))
  add(query_581775, "floodlightActivityId", newJString(floodlightActivityId))
  add(query_581775, "active", newJBool(active))
  add(path_581774, "profileId", newJString(profileId))
  add(query_581775, "sortField", newJString(sortField))
  add(query_581775, "alt", newJString(alt))
  add(query_581775, "userIp", newJString(userIp))
  add(query_581775, "quotaUser", newJString(quotaUser))
  add(query_581775, "pageToken", newJString(pageToken))
  add(query_581775, "sortOrder", newJString(sortOrder))
  add(query_581775, "advertiserId", newJString(advertiserId))
  add(query_581775, "fields", newJString(fields))
  add(query_581775, "maxResults", newJInt(maxResults))
  result = call_581773.call(path_581774, query_581775, nil, nil, nil)

var dfareportingRemarketingListsList* = Call_DfareportingRemarketingListsList_581753(
    name: "dfareportingRemarketingListsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsList_581754,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsList_581755,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsPatch_581810 = ref object of OpenApiRestCall_578364
proc url_DfareportingRemarketingListsPatch_581812(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsPatch_581811(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581813 = path.getOrDefault("profileId")
  valid_581813 = validateParameter(valid_581813, JString, required = true,
                                 default = nil)
  if valid_581813 != nil:
    section.add "profileId", valid_581813
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Remarketing list ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581814 = query.getOrDefault("key")
  valid_581814 = validateParameter(valid_581814, JString, required = false,
                                 default = nil)
  if valid_581814 != nil:
    section.add "key", valid_581814
  var valid_581815 = query.getOrDefault("prettyPrint")
  valid_581815 = validateParameter(valid_581815, JBool, required = false,
                                 default = newJBool(true))
  if valid_581815 != nil:
    section.add "prettyPrint", valid_581815
  var valid_581816 = query.getOrDefault("oauth_token")
  valid_581816 = validateParameter(valid_581816, JString, required = false,
                                 default = nil)
  if valid_581816 != nil:
    section.add "oauth_token", valid_581816
  var valid_581817 = query.getOrDefault("alt")
  valid_581817 = validateParameter(valid_581817, JString, required = false,
                                 default = newJString("json"))
  if valid_581817 != nil:
    section.add "alt", valid_581817
  var valid_581818 = query.getOrDefault("userIp")
  valid_581818 = validateParameter(valid_581818, JString, required = false,
                                 default = nil)
  if valid_581818 != nil:
    section.add "userIp", valid_581818
  var valid_581819 = query.getOrDefault("quotaUser")
  valid_581819 = validateParameter(valid_581819, JString, required = false,
                                 default = nil)
  if valid_581819 != nil:
    section.add "quotaUser", valid_581819
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_581820 = query.getOrDefault("id")
  valid_581820 = validateParameter(valid_581820, JString, required = true,
                                 default = nil)
  if valid_581820 != nil:
    section.add "id", valid_581820
  var valid_581821 = query.getOrDefault("fields")
  valid_581821 = validateParameter(valid_581821, JString, required = false,
                                 default = nil)
  if valid_581821 != nil:
    section.add "fields", valid_581821
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581823: Call_DfareportingRemarketingListsPatch_581810;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list. This method supports patch semantics.
  ## 
  let valid = call_581823.validator(path, query, header, formData, body)
  let scheme = call_581823.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581823.url(scheme.get, call_581823.host, call_581823.base,
                         call_581823.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581823, url, valid)

proc call*(call_581824: Call_DfareportingRemarketingListsPatch_581810;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingRemarketingListsPatch
  ## Updates an existing remarketing list. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Remarketing list ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581825 = newJObject()
  var query_581826 = newJObject()
  var body_581827 = newJObject()
  add(query_581826, "key", newJString(key))
  add(query_581826, "prettyPrint", newJBool(prettyPrint))
  add(query_581826, "oauth_token", newJString(oauthToken))
  add(path_581825, "profileId", newJString(profileId))
  add(query_581826, "alt", newJString(alt))
  add(query_581826, "userIp", newJString(userIp))
  add(query_581826, "quotaUser", newJString(quotaUser))
  add(query_581826, "id", newJString(id))
  if body != nil:
    body_581827 = body
  add(query_581826, "fields", newJString(fields))
  result = call_581824.call(path_581825, query_581826, nil, nil, body_581827)

var dfareportingRemarketingListsPatch* = Call_DfareportingRemarketingListsPatch_581810(
    name: "dfareportingRemarketingListsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsPatch_581811,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsPatch_581812,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsGet_581828 = ref object of OpenApiRestCall_578364
proc url_DfareportingRemarketingListsGet_581830(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsGet_581829(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one remarketing list by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Remarketing list ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581831 = path.getOrDefault("profileId")
  valid_581831 = validateParameter(valid_581831, JString, required = true,
                                 default = nil)
  if valid_581831 != nil:
    section.add "profileId", valid_581831
  var valid_581832 = path.getOrDefault("id")
  valid_581832 = validateParameter(valid_581832, JString, required = true,
                                 default = nil)
  if valid_581832 != nil:
    section.add "id", valid_581832
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581833 = query.getOrDefault("key")
  valid_581833 = validateParameter(valid_581833, JString, required = false,
                                 default = nil)
  if valid_581833 != nil:
    section.add "key", valid_581833
  var valid_581834 = query.getOrDefault("prettyPrint")
  valid_581834 = validateParameter(valid_581834, JBool, required = false,
                                 default = newJBool(true))
  if valid_581834 != nil:
    section.add "prettyPrint", valid_581834
  var valid_581835 = query.getOrDefault("oauth_token")
  valid_581835 = validateParameter(valid_581835, JString, required = false,
                                 default = nil)
  if valid_581835 != nil:
    section.add "oauth_token", valid_581835
  var valid_581836 = query.getOrDefault("alt")
  valid_581836 = validateParameter(valid_581836, JString, required = false,
                                 default = newJString("json"))
  if valid_581836 != nil:
    section.add "alt", valid_581836
  var valid_581837 = query.getOrDefault("userIp")
  valid_581837 = validateParameter(valid_581837, JString, required = false,
                                 default = nil)
  if valid_581837 != nil:
    section.add "userIp", valid_581837
  var valid_581838 = query.getOrDefault("quotaUser")
  valid_581838 = validateParameter(valid_581838, JString, required = false,
                                 default = nil)
  if valid_581838 != nil:
    section.add "quotaUser", valid_581838
  var valid_581839 = query.getOrDefault("fields")
  valid_581839 = validateParameter(valid_581839, JString, required = false,
                                 default = nil)
  if valid_581839 != nil:
    section.add "fields", valid_581839
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581840: Call_DfareportingRemarketingListsGet_581828;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one remarketing list by ID.
  ## 
  let valid = call_581840.validator(path, query, header, formData, body)
  let scheme = call_581840.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581840.url(scheme.get, call_581840.host, call_581840.base,
                         call_581840.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581840, url, valid)

proc call*(call_581841: Call_DfareportingRemarketingListsGet_581828;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingRemarketingListsGet
  ## Gets one remarketing list by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Remarketing list ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581842 = newJObject()
  var query_581843 = newJObject()
  add(query_581843, "key", newJString(key))
  add(query_581843, "prettyPrint", newJBool(prettyPrint))
  add(query_581843, "oauth_token", newJString(oauthToken))
  add(path_581842, "profileId", newJString(profileId))
  add(path_581842, "id", newJString(id))
  add(query_581843, "alt", newJString(alt))
  add(query_581843, "userIp", newJString(userIp))
  add(query_581843, "quotaUser", newJString(quotaUser))
  add(query_581843, "fields", newJString(fields))
  result = call_581841.call(path_581842, query_581843, nil, nil, nil)

var dfareportingRemarketingListsGet* = Call_DfareportingRemarketingListsGet_581828(
    name: "dfareportingRemarketingListsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists/{id}",
    validator: validate_DfareportingRemarketingListsGet_581829,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsGet_581830,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsInsert_581864 = ref object of OpenApiRestCall_578364
proc url_DfareportingReportsInsert_581866(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsInsert_581865(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581867 = path.getOrDefault("profileId")
  valid_581867 = validateParameter(valid_581867, JString, required = true,
                                 default = nil)
  if valid_581867 != nil:
    section.add "profileId", valid_581867
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581868 = query.getOrDefault("key")
  valid_581868 = validateParameter(valid_581868, JString, required = false,
                                 default = nil)
  if valid_581868 != nil:
    section.add "key", valid_581868
  var valid_581869 = query.getOrDefault("prettyPrint")
  valid_581869 = validateParameter(valid_581869, JBool, required = false,
                                 default = newJBool(true))
  if valid_581869 != nil:
    section.add "prettyPrint", valid_581869
  var valid_581870 = query.getOrDefault("oauth_token")
  valid_581870 = validateParameter(valid_581870, JString, required = false,
                                 default = nil)
  if valid_581870 != nil:
    section.add "oauth_token", valid_581870
  var valid_581871 = query.getOrDefault("alt")
  valid_581871 = validateParameter(valid_581871, JString, required = false,
                                 default = newJString("json"))
  if valid_581871 != nil:
    section.add "alt", valid_581871
  var valid_581872 = query.getOrDefault("userIp")
  valid_581872 = validateParameter(valid_581872, JString, required = false,
                                 default = nil)
  if valid_581872 != nil:
    section.add "userIp", valid_581872
  var valid_581873 = query.getOrDefault("quotaUser")
  valid_581873 = validateParameter(valid_581873, JString, required = false,
                                 default = nil)
  if valid_581873 != nil:
    section.add "quotaUser", valid_581873
  var valid_581874 = query.getOrDefault("fields")
  valid_581874 = validateParameter(valid_581874, JString, required = false,
                                 default = nil)
  if valid_581874 != nil:
    section.add "fields", valid_581874
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581876: Call_DfareportingReportsInsert_581864; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a report.
  ## 
  let valid = call_581876.validator(path, query, header, formData, body)
  let scheme = call_581876.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581876.url(scheme.get, call_581876.host, call_581876.base,
                         call_581876.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581876, url, valid)

proc call*(call_581877: Call_DfareportingReportsInsert_581864; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingReportsInsert
  ## Creates a report.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581878 = newJObject()
  var query_581879 = newJObject()
  var body_581880 = newJObject()
  add(query_581879, "key", newJString(key))
  add(query_581879, "prettyPrint", newJBool(prettyPrint))
  add(query_581879, "oauth_token", newJString(oauthToken))
  add(path_581878, "profileId", newJString(profileId))
  add(query_581879, "alt", newJString(alt))
  add(query_581879, "userIp", newJString(userIp))
  add(query_581879, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_581880 = body
  add(query_581879, "fields", newJString(fields))
  result = call_581877.call(path_581878, query_581879, nil, nil, body_581880)

var dfareportingReportsInsert* = Call_DfareportingReportsInsert_581864(
    name: "dfareportingReportsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/reports",
    validator: validate_DfareportingReportsInsert_581865,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsInsert_581866,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsList_581844 = ref object of OpenApiRestCall_578364
proc url_DfareportingReportsList_581846(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsList_581845(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves list of reports.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581847 = path.getOrDefault("profileId")
  valid_581847 = validateParameter(valid_581847, JString, required = true,
                                 default = nil)
  if valid_581847 != nil:
    section.add "profileId", valid_581847
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   scope: JString
  ##        : The scope that defines which results are returned.
  ##   sortField: JString
  ##            : The field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_581848 = query.getOrDefault("key")
  valid_581848 = validateParameter(valid_581848, JString, required = false,
                                 default = nil)
  if valid_581848 != nil:
    section.add "key", valid_581848
  var valid_581849 = query.getOrDefault("prettyPrint")
  valid_581849 = validateParameter(valid_581849, JBool, required = false,
                                 default = newJBool(true))
  if valid_581849 != nil:
    section.add "prettyPrint", valid_581849
  var valid_581850 = query.getOrDefault("oauth_token")
  valid_581850 = validateParameter(valid_581850, JString, required = false,
                                 default = nil)
  if valid_581850 != nil:
    section.add "oauth_token", valid_581850
  var valid_581851 = query.getOrDefault("scope")
  valid_581851 = validateParameter(valid_581851, JString, required = false,
                                 default = newJString("MINE"))
  if valid_581851 != nil:
    section.add "scope", valid_581851
  var valid_581852 = query.getOrDefault("sortField")
  valid_581852 = validateParameter(valid_581852, JString, required = false,
                                 default = newJString("LAST_MODIFIED_TIME"))
  if valid_581852 != nil:
    section.add "sortField", valid_581852
  var valid_581853 = query.getOrDefault("alt")
  valid_581853 = validateParameter(valid_581853, JString, required = false,
                                 default = newJString("json"))
  if valid_581853 != nil:
    section.add "alt", valid_581853
  var valid_581854 = query.getOrDefault("userIp")
  valid_581854 = validateParameter(valid_581854, JString, required = false,
                                 default = nil)
  if valid_581854 != nil:
    section.add "userIp", valid_581854
  var valid_581855 = query.getOrDefault("quotaUser")
  valid_581855 = validateParameter(valid_581855, JString, required = false,
                                 default = nil)
  if valid_581855 != nil:
    section.add "quotaUser", valid_581855
  var valid_581856 = query.getOrDefault("pageToken")
  valid_581856 = validateParameter(valid_581856, JString, required = false,
                                 default = nil)
  if valid_581856 != nil:
    section.add "pageToken", valid_581856
  var valid_581857 = query.getOrDefault("sortOrder")
  valid_581857 = validateParameter(valid_581857, JString, required = false,
                                 default = newJString("DESCENDING"))
  if valid_581857 != nil:
    section.add "sortOrder", valid_581857
  var valid_581858 = query.getOrDefault("fields")
  valid_581858 = validateParameter(valid_581858, JString, required = false,
                                 default = nil)
  if valid_581858 != nil:
    section.add "fields", valid_581858
  var valid_581859 = query.getOrDefault("maxResults")
  valid_581859 = validateParameter(valid_581859, JInt, required = false,
                                 default = newJInt(10))
  if valid_581859 != nil:
    section.add "maxResults", valid_581859
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581860: Call_DfareportingReportsList_581844; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves list of reports.
  ## 
  let valid = call_581860.validator(path, query, header, formData, body)
  let scheme = call_581860.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581860.url(scheme.get, call_581860.host, call_581860.base,
                         call_581860.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581860, url, valid)

proc call*(call_581861: Call_DfareportingReportsList_581844; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          scope: string = "MINE"; sortField: string = "LAST_MODIFIED_TIME";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          pageToken: string = ""; sortOrder: string = "DESCENDING"; fields: string = "";
          maxResults: int = 10): Recallable =
  ## dfareportingReportsList
  ## Retrieves list of reports.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   scope: string
  ##        : The scope that defines which results are returned.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   sortField: string
  ##            : The field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_581862 = newJObject()
  var query_581863 = newJObject()
  add(query_581863, "key", newJString(key))
  add(query_581863, "prettyPrint", newJBool(prettyPrint))
  add(query_581863, "oauth_token", newJString(oauthToken))
  add(query_581863, "scope", newJString(scope))
  add(path_581862, "profileId", newJString(profileId))
  add(query_581863, "sortField", newJString(sortField))
  add(query_581863, "alt", newJString(alt))
  add(query_581863, "userIp", newJString(userIp))
  add(query_581863, "quotaUser", newJString(quotaUser))
  add(query_581863, "pageToken", newJString(pageToken))
  add(query_581863, "sortOrder", newJString(sortOrder))
  add(query_581863, "fields", newJString(fields))
  add(query_581863, "maxResults", newJInt(maxResults))
  result = call_581861.call(path_581862, query_581863, nil, nil, nil)

var dfareportingReportsList* = Call_DfareportingReportsList_581844(
    name: "dfareportingReportsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/reports",
    validator: validate_DfareportingReportsList_581845,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsList_581846,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsCompatibleFieldsQuery_581881 = ref object of OpenApiRestCall_578364
proc url_DfareportingReportsCompatibleFieldsQuery_581883(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"), (kind: ConstantSegment,
        value: "/reports/compatiblefields/query")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsCompatibleFieldsQuery_581882(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the fields that are compatible to be selected in the respective sections of a report criteria, given the fields already selected in the input report and user permissions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581884 = path.getOrDefault("profileId")
  valid_581884 = validateParameter(valid_581884, JString, required = true,
                                 default = nil)
  if valid_581884 != nil:
    section.add "profileId", valid_581884
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581885 = query.getOrDefault("key")
  valid_581885 = validateParameter(valid_581885, JString, required = false,
                                 default = nil)
  if valid_581885 != nil:
    section.add "key", valid_581885
  var valid_581886 = query.getOrDefault("prettyPrint")
  valid_581886 = validateParameter(valid_581886, JBool, required = false,
                                 default = newJBool(true))
  if valid_581886 != nil:
    section.add "prettyPrint", valid_581886
  var valid_581887 = query.getOrDefault("oauth_token")
  valid_581887 = validateParameter(valid_581887, JString, required = false,
                                 default = nil)
  if valid_581887 != nil:
    section.add "oauth_token", valid_581887
  var valid_581888 = query.getOrDefault("alt")
  valid_581888 = validateParameter(valid_581888, JString, required = false,
                                 default = newJString("json"))
  if valid_581888 != nil:
    section.add "alt", valid_581888
  var valid_581889 = query.getOrDefault("userIp")
  valid_581889 = validateParameter(valid_581889, JString, required = false,
                                 default = nil)
  if valid_581889 != nil:
    section.add "userIp", valid_581889
  var valid_581890 = query.getOrDefault("quotaUser")
  valid_581890 = validateParameter(valid_581890, JString, required = false,
                                 default = nil)
  if valid_581890 != nil:
    section.add "quotaUser", valid_581890
  var valid_581891 = query.getOrDefault("fields")
  valid_581891 = validateParameter(valid_581891, JString, required = false,
                                 default = nil)
  if valid_581891 != nil:
    section.add "fields", valid_581891
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581893: Call_DfareportingReportsCompatibleFieldsQuery_581881;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the fields that are compatible to be selected in the respective sections of a report criteria, given the fields already selected in the input report and user permissions.
  ## 
  let valid = call_581893.validator(path, query, header, formData, body)
  let scheme = call_581893.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581893.url(scheme.get, call_581893.host, call_581893.base,
                         call_581893.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581893, url, valid)

proc call*(call_581894: Call_DfareportingReportsCompatibleFieldsQuery_581881;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingReportsCompatibleFieldsQuery
  ## Returns the fields that are compatible to be selected in the respective sections of a report criteria, given the fields already selected in the input report and user permissions.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581895 = newJObject()
  var query_581896 = newJObject()
  var body_581897 = newJObject()
  add(query_581896, "key", newJString(key))
  add(query_581896, "prettyPrint", newJBool(prettyPrint))
  add(query_581896, "oauth_token", newJString(oauthToken))
  add(path_581895, "profileId", newJString(profileId))
  add(query_581896, "alt", newJString(alt))
  add(query_581896, "userIp", newJString(userIp))
  add(query_581896, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_581897 = body
  add(query_581896, "fields", newJString(fields))
  result = call_581894.call(path_581895, query_581896, nil, nil, body_581897)

var dfareportingReportsCompatibleFieldsQuery* = Call_DfareportingReportsCompatibleFieldsQuery_581881(
    name: "dfareportingReportsCompatibleFieldsQuery", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/compatiblefields/query",
    validator: validate_DfareportingReportsCompatibleFieldsQuery_581882,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsCompatibleFieldsQuery_581883,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsUpdate_581914 = ref object of OpenApiRestCall_578364
proc url_DfareportingReportsUpdate_581916(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsUpdate_581915(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581917 = path.getOrDefault("profileId")
  valid_581917 = validateParameter(valid_581917, JString, required = true,
                                 default = nil)
  if valid_581917 != nil:
    section.add "profileId", valid_581917
  var valid_581918 = path.getOrDefault("reportId")
  valid_581918 = validateParameter(valid_581918, JString, required = true,
                                 default = nil)
  if valid_581918 != nil:
    section.add "reportId", valid_581918
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581919 = query.getOrDefault("key")
  valid_581919 = validateParameter(valid_581919, JString, required = false,
                                 default = nil)
  if valid_581919 != nil:
    section.add "key", valid_581919
  var valid_581920 = query.getOrDefault("prettyPrint")
  valid_581920 = validateParameter(valid_581920, JBool, required = false,
                                 default = newJBool(true))
  if valid_581920 != nil:
    section.add "prettyPrint", valid_581920
  var valid_581921 = query.getOrDefault("oauth_token")
  valid_581921 = validateParameter(valid_581921, JString, required = false,
                                 default = nil)
  if valid_581921 != nil:
    section.add "oauth_token", valid_581921
  var valid_581922 = query.getOrDefault("alt")
  valid_581922 = validateParameter(valid_581922, JString, required = false,
                                 default = newJString("json"))
  if valid_581922 != nil:
    section.add "alt", valid_581922
  var valid_581923 = query.getOrDefault("userIp")
  valid_581923 = validateParameter(valid_581923, JString, required = false,
                                 default = nil)
  if valid_581923 != nil:
    section.add "userIp", valid_581923
  var valid_581924 = query.getOrDefault("quotaUser")
  valid_581924 = validateParameter(valid_581924, JString, required = false,
                                 default = nil)
  if valid_581924 != nil:
    section.add "quotaUser", valid_581924
  var valid_581925 = query.getOrDefault("fields")
  valid_581925 = validateParameter(valid_581925, JString, required = false,
                                 default = nil)
  if valid_581925 != nil:
    section.add "fields", valid_581925
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581927: Call_DfareportingReportsUpdate_581914; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a report.
  ## 
  let valid = call_581927.validator(path, query, header, formData, body)
  let scheme = call_581927.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581927.url(scheme.get, call_581927.host, call_581927.base,
                         call_581927.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581927, url, valid)

proc call*(call_581928: Call_DfareportingReportsUpdate_581914; profileId: string;
          reportId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingReportsUpdate
  ## Updates a report.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581929 = newJObject()
  var query_581930 = newJObject()
  var body_581931 = newJObject()
  add(query_581930, "key", newJString(key))
  add(query_581930, "prettyPrint", newJBool(prettyPrint))
  add(query_581930, "oauth_token", newJString(oauthToken))
  add(path_581929, "profileId", newJString(profileId))
  add(query_581930, "alt", newJString(alt))
  add(query_581930, "userIp", newJString(userIp))
  add(query_581930, "quotaUser", newJString(quotaUser))
  add(path_581929, "reportId", newJString(reportId))
  if body != nil:
    body_581931 = body
  add(query_581930, "fields", newJString(fields))
  result = call_581928.call(path_581929, query_581930, nil, nil, body_581931)

var dfareportingReportsUpdate* = Call_DfareportingReportsUpdate_581914(
    name: "dfareportingReportsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsUpdate_581915,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsUpdate_581916,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsGet_581898 = ref object of OpenApiRestCall_578364
proc url_DfareportingReportsGet_581900(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsGet_581899(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a report by its ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581901 = path.getOrDefault("profileId")
  valid_581901 = validateParameter(valid_581901, JString, required = true,
                                 default = nil)
  if valid_581901 != nil:
    section.add "profileId", valid_581901
  var valid_581902 = path.getOrDefault("reportId")
  valid_581902 = validateParameter(valid_581902, JString, required = true,
                                 default = nil)
  if valid_581902 != nil:
    section.add "reportId", valid_581902
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581903 = query.getOrDefault("key")
  valid_581903 = validateParameter(valid_581903, JString, required = false,
                                 default = nil)
  if valid_581903 != nil:
    section.add "key", valid_581903
  var valid_581904 = query.getOrDefault("prettyPrint")
  valid_581904 = validateParameter(valid_581904, JBool, required = false,
                                 default = newJBool(true))
  if valid_581904 != nil:
    section.add "prettyPrint", valid_581904
  var valid_581905 = query.getOrDefault("oauth_token")
  valid_581905 = validateParameter(valid_581905, JString, required = false,
                                 default = nil)
  if valid_581905 != nil:
    section.add "oauth_token", valid_581905
  var valid_581906 = query.getOrDefault("alt")
  valid_581906 = validateParameter(valid_581906, JString, required = false,
                                 default = newJString("json"))
  if valid_581906 != nil:
    section.add "alt", valid_581906
  var valid_581907 = query.getOrDefault("userIp")
  valid_581907 = validateParameter(valid_581907, JString, required = false,
                                 default = nil)
  if valid_581907 != nil:
    section.add "userIp", valid_581907
  var valid_581908 = query.getOrDefault("quotaUser")
  valid_581908 = validateParameter(valid_581908, JString, required = false,
                                 default = nil)
  if valid_581908 != nil:
    section.add "quotaUser", valid_581908
  var valid_581909 = query.getOrDefault("fields")
  valid_581909 = validateParameter(valid_581909, JString, required = false,
                                 default = nil)
  if valid_581909 != nil:
    section.add "fields", valid_581909
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581910: Call_DfareportingReportsGet_581898; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a report by its ID.
  ## 
  let valid = call_581910.validator(path, query, header, formData, body)
  let scheme = call_581910.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581910.url(scheme.get, call_581910.host, call_581910.base,
                         call_581910.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581910, url, valid)

proc call*(call_581911: Call_DfareportingReportsGet_581898; profileId: string;
          reportId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingReportsGet
  ## Retrieves a report by its ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581912 = newJObject()
  var query_581913 = newJObject()
  add(query_581913, "key", newJString(key))
  add(query_581913, "prettyPrint", newJBool(prettyPrint))
  add(query_581913, "oauth_token", newJString(oauthToken))
  add(path_581912, "profileId", newJString(profileId))
  add(query_581913, "alt", newJString(alt))
  add(query_581913, "userIp", newJString(userIp))
  add(query_581913, "quotaUser", newJString(quotaUser))
  add(path_581912, "reportId", newJString(reportId))
  add(query_581913, "fields", newJString(fields))
  result = call_581911.call(path_581912, query_581913, nil, nil, nil)

var dfareportingReportsGet* = Call_DfareportingReportsGet_581898(
    name: "dfareportingReportsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsGet_581899, base: "/dfareporting/v2.7",
    url: url_DfareportingReportsGet_581900, schemes: {Scheme.Https})
type
  Call_DfareportingReportsPatch_581948 = ref object of OpenApiRestCall_578364
proc url_DfareportingReportsPatch_581950(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsPatch_581949(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a report. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581951 = path.getOrDefault("profileId")
  valid_581951 = validateParameter(valid_581951, JString, required = true,
                                 default = nil)
  if valid_581951 != nil:
    section.add "profileId", valid_581951
  var valid_581952 = path.getOrDefault("reportId")
  valid_581952 = validateParameter(valid_581952, JString, required = true,
                                 default = nil)
  if valid_581952 != nil:
    section.add "reportId", valid_581952
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581953 = query.getOrDefault("key")
  valid_581953 = validateParameter(valid_581953, JString, required = false,
                                 default = nil)
  if valid_581953 != nil:
    section.add "key", valid_581953
  var valid_581954 = query.getOrDefault("prettyPrint")
  valid_581954 = validateParameter(valid_581954, JBool, required = false,
                                 default = newJBool(true))
  if valid_581954 != nil:
    section.add "prettyPrint", valid_581954
  var valid_581955 = query.getOrDefault("oauth_token")
  valid_581955 = validateParameter(valid_581955, JString, required = false,
                                 default = nil)
  if valid_581955 != nil:
    section.add "oauth_token", valid_581955
  var valid_581956 = query.getOrDefault("alt")
  valid_581956 = validateParameter(valid_581956, JString, required = false,
                                 default = newJString("json"))
  if valid_581956 != nil:
    section.add "alt", valid_581956
  var valid_581957 = query.getOrDefault("userIp")
  valid_581957 = validateParameter(valid_581957, JString, required = false,
                                 default = nil)
  if valid_581957 != nil:
    section.add "userIp", valid_581957
  var valid_581958 = query.getOrDefault("quotaUser")
  valid_581958 = validateParameter(valid_581958, JString, required = false,
                                 default = nil)
  if valid_581958 != nil:
    section.add "quotaUser", valid_581958
  var valid_581959 = query.getOrDefault("fields")
  valid_581959 = validateParameter(valid_581959, JString, required = false,
                                 default = nil)
  if valid_581959 != nil:
    section.add "fields", valid_581959
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581961: Call_DfareportingReportsPatch_581948; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a report. This method supports patch semantics.
  ## 
  let valid = call_581961.validator(path, query, header, formData, body)
  let scheme = call_581961.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581961.url(scheme.get, call_581961.host, call_581961.base,
                         call_581961.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581961, url, valid)

proc call*(call_581962: Call_DfareportingReportsPatch_581948; profileId: string;
          reportId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingReportsPatch
  ## Updates a report. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581963 = newJObject()
  var query_581964 = newJObject()
  var body_581965 = newJObject()
  add(query_581964, "key", newJString(key))
  add(query_581964, "prettyPrint", newJBool(prettyPrint))
  add(query_581964, "oauth_token", newJString(oauthToken))
  add(path_581963, "profileId", newJString(profileId))
  add(query_581964, "alt", newJString(alt))
  add(query_581964, "userIp", newJString(userIp))
  add(query_581964, "quotaUser", newJString(quotaUser))
  add(path_581963, "reportId", newJString(reportId))
  if body != nil:
    body_581965 = body
  add(query_581964, "fields", newJString(fields))
  result = call_581962.call(path_581963, query_581964, nil, nil, body_581965)

var dfareportingReportsPatch* = Call_DfareportingReportsPatch_581948(
    name: "dfareportingReportsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsPatch_581949,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsPatch_581950,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsDelete_581932 = ref object of OpenApiRestCall_578364
proc url_DfareportingReportsDelete_581934(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsDelete_581933(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a report by its ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581935 = path.getOrDefault("profileId")
  valid_581935 = validateParameter(valid_581935, JString, required = true,
                                 default = nil)
  if valid_581935 != nil:
    section.add "profileId", valid_581935
  var valid_581936 = path.getOrDefault("reportId")
  valid_581936 = validateParameter(valid_581936, JString, required = true,
                                 default = nil)
  if valid_581936 != nil:
    section.add "reportId", valid_581936
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581937 = query.getOrDefault("key")
  valid_581937 = validateParameter(valid_581937, JString, required = false,
                                 default = nil)
  if valid_581937 != nil:
    section.add "key", valid_581937
  var valid_581938 = query.getOrDefault("prettyPrint")
  valid_581938 = validateParameter(valid_581938, JBool, required = false,
                                 default = newJBool(true))
  if valid_581938 != nil:
    section.add "prettyPrint", valid_581938
  var valid_581939 = query.getOrDefault("oauth_token")
  valid_581939 = validateParameter(valid_581939, JString, required = false,
                                 default = nil)
  if valid_581939 != nil:
    section.add "oauth_token", valid_581939
  var valid_581940 = query.getOrDefault("alt")
  valid_581940 = validateParameter(valid_581940, JString, required = false,
                                 default = newJString("json"))
  if valid_581940 != nil:
    section.add "alt", valid_581940
  var valid_581941 = query.getOrDefault("userIp")
  valid_581941 = validateParameter(valid_581941, JString, required = false,
                                 default = nil)
  if valid_581941 != nil:
    section.add "userIp", valid_581941
  var valid_581942 = query.getOrDefault("quotaUser")
  valid_581942 = validateParameter(valid_581942, JString, required = false,
                                 default = nil)
  if valid_581942 != nil:
    section.add "quotaUser", valid_581942
  var valid_581943 = query.getOrDefault("fields")
  valid_581943 = validateParameter(valid_581943, JString, required = false,
                                 default = nil)
  if valid_581943 != nil:
    section.add "fields", valid_581943
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581944: Call_DfareportingReportsDelete_581932; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a report by its ID.
  ## 
  let valid = call_581944.validator(path, query, header, formData, body)
  let scheme = call_581944.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581944.url(scheme.get, call_581944.host, call_581944.base,
                         call_581944.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581944, url, valid)

proc call*(call_581945: Call_DfareportingReportsDelete_581932; profileId: string;
          reportId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingReportsDelete
  ## Deletes a report by its ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_581946 = newJObject()
  var query_581947 = newJObject()
  add(query_581947, "key", newJString(key))
  add(query_581947, "prettyPrint", newJBool(prettyPrint))
  add(query_581947, "oauth_token", newJString(oauthToken))
  add(path_581946, "profileId", newJString(profileId))
  add(query_581947, "alt", newJString(alt))
  add(query_581947, "userIp", newJString(userIp))
  add(query_581947, "quotaUser", newJString(quotaUser))
  add(path_581946, "reportId", newJString(reportId))
  add(query_581947, "fields", newJString(fields))
  result = call_581945.call(path_581946, query_581947, nil, nil, nil)

var dfareportingReportsDelete* = Call_DfareportingReportsDelete_581932(
    name: "dfareportingReportsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsDelete_581933,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsDelete_581934,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsFilesList_581966 = ref object of OpenApiRestCall_578364
proc url_DfareportingReportsFilesList_581968(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsFilesList_581967(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists files for a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the parent report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581969 = path.getOrDefault("profileId")
  valid_581969 = validateParameter(valid_581969, JString, required = true,
                                 default = nil)
  if valid_581969 != nil:
    section.add "profileId", valid_581969
  var valid_581970 = path.getOrDefault("reportId")
  valid_581970 = validateParameter(valid_581970, JString, required = true,
                                 default = nil)
  if valid_581970 != nil:
    section.add "reportId", valid_581970
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : The field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_581971 = query.getOrDefault("key")
  valid_581971 = validateParameter(valid_581971, JString, required = false,
                                 default = nil)
  if valid_581971 != nil:
    section.add "key", valid_581971
  var valid_581972 = query.getOrDefault("prettyPrint")
  valid_581972 = validateParameter(valid_581972, JBool, required = false,
                                 default = newJBool(true))
  if valid_581972 != nil:
    section.add "prettyPrint", valid_581972
  var valid_581973 = query.getOrDefault("oauth_token")
  valid_581973 = validateParameter(valid_581973, JString, required = false,
                                 default = nil)
  if valid_581973 != nil:
    section.add "oauth_token", valid_581973
  var valid_581974 = query.getOrDefault("sortField")
  valid_581974 = validateParameter(valid_581974, JString, required = false,
                                 default = newJString("LAST_MODIFIED_TIME"))
  if valid_581974 != nil:
    section.add "sortField", valid_581974
  var valid_581975 = query.getOrDefault("alt")
  valid_581975 = validateParameter(valid_581975, JString, required = false,
                                 default = newJString("json"))
  if valid_581975 != nil:
    section.add "alt", valid_581975
  var valid_581976 = query.getOrDefault("userIp")
  valid_581976 = validateParameter(valid_581976, JString, required = false,
                                 default = nil)
  if valid_581976 != nil:
    section.add "userIp", valid_581976
  var valid_581977 = query.getOrDefault("quotaUser")
  valid_581977 = validateParameter(valid_581977, JString, required = false,
                                 default = nil)
  if valid_581977 != nil:
    section.add "quotaUser", valid_581977
  var valid_581978 = query.getOrDefault("pageToken")
  valid_581978 = validateParameter(valid_581978, JString, required = false,
                                 default = nil)
  if valid_581978 != nil:
    section.add "pageToken", valid_581978
  var valid_581979 = query.getOrDefault("sortOrder")
  valid_581979 = validateParameter(valid_581979, JString, required = false,
                                 default = newJString("DESCENDING"))
  if valid_581979 != nil:
    section.add "sortOrder", valid_581979
  var valid_581980 = query.getOrDefault("fields")
  valid_581980 = validateParameter(valid_581980, JString, required = false,
                                 default = nil)
  if valid_581980 != nil:
    section.add "fields", valid_581980
  var valid_581981 = query.getOrDefault("maxResults")
  valid_581981 = validateParameter(valid_581981, JInt, required = false,
                                 default = newJInt(10))
  if valid_581981 != nil:
    section.add "maxResults", valid_581981
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581982: Call_DfareportingReportsFilesList_581966; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists files for a report.
  ## 
  let valid = call_581982.validator(path, query, header, formData, body)
  let scheme = call_581982.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581982.url(scheme.get, call_581982.host, call_581982.base,
                         call_581982.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581982, url, valid)

proc call*(call_581983: Call_DfareportingReportsFilesList_581966;
          profileId: string; reportId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = "";
          sortField: string = "LAST_MODIFIED_TIME"; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; pageToken: string = "";
          sortOrder: string = "DESCENDING"; fields: string = ""; maxResults: int = 10): Recallable =
  ## dfareportingReportsFilesList
  ## Lists files for a report.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   sortField: string
  ##            : The field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   reportId: string (required)
  ##           : The ID of the parent report.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_581984 = newJObject()
  var query_581985 = newJObject()
  add(query_581985, "key", newJString(key))
  add(query_581985, "prettyPrint", newJBool(prettyPrint))
  add(query_581985, "oauth_token", newJString(oauthToken))
  add(path_581984, "profileId", newJString(profileId))
  add(query_581985, "sortField", newJString(sortField))
  add(query_581985, "alt", newJString(alt))
  add(query_581985, "userIp", newJString(userIp))
  add(query_581985, "quotaUser", newJString(quotaUser))
  add(query_581985, "pageToken", newJString(pageToken))
  add(query_581985, "sortOrder", newJString(sortOrder))
  add(path_581984, "reportId", newJString(reportId))
  add(query_581985, "fields", newJString(fields))
  add(query_581985, "maxResults", newJInt(maxResults))
  result = call_581983.call(path_581984, query_581985, nil, nil, nil)

var dfareportingReportsFilesList* = Call_DfareportingReportsFilesList_581966(
    name: "dfareportingReportsFilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}/files",
    validator: validate_DfareportingReportsFilesList_581967,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsFilesList_581968,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsFilesGet_581986 = ref object of OpenApiRestCall_578364
proc url_DfareportingReportsFilesGet_581988(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  assert "fileId" in path, "`fileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/files/"),
               (kind: VariableSegment, value: "fileId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsFilesGet_581987(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a report file. This method supports media download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  ##   fileId: JString (required)
  ##         : The ID of the report file.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581989 = path.getOrDefault("profileId")
  valid_581989 = validateParameter(valid_581989, JString, required = true,
                                 default = nil)
  if valid_581989 != nil:
    section.add "profileId", valid_581989
  var valid_581990 = path.getOrDefault("fileId")
  valid_581990 = validateParameter(valid_581990, JString, required = true,
                                 default = nil)
  if valid_581990 != nil:
    section.add "fileId", valid_581990
  var valid_581991 = path.getOrDefault("reportId")
  valid_581991 = validateParameter(valid_581991, JString, required = true,
                                 default = nil)
  if valid_581991 != nil:
    section.add "reportId", valid_581991
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_581992 = query.getOrDefault("key")
  valid_581992 = validateParameter(valid_581992, JString, required = false,
                                 default = nil)
  if valid_581992 != nil:
    section.add "key", valid_581992
  var valid_581993 = query.getOrDefault("prettyPrint")
  valid_581993 = validateParameter(valid_581993, JBool, required = false,
                                 default = newJBool(true))
  if valid_581993 != nil:
    section.add "prettyPrint", valid_581993
  var valid_581994 = query.getOrDefault("oauth_token")
  valid_581994 = validateParameter(valid_581994, JString, required = false,
                                 default = nil)
  if valid_581994 != nil:
    section.add "oauth_token", valid_581994
  var valid_581995 = query.getOrDefault("alt")
  valid_581995 = validateParameter(valid_581995, JString, required = false,
                                 default = newJString("json"))
  if valid_581995 != nil:
    section.add "alt", valid_581995
  var valid_581996 = query.getOrDefault("userIp")
  valid_581996 = validateParameter(valid_581996, JString, required = false,
                                 default = nil)
  if valid_581996 != nil:
    section.add "userIp", valid_581996
  var valid_581997 = query.getOrDefault("quotaUser")
  valid_581997 = validateParameter(valid_581997, JString, required = false,
                                 default = nil)
  if valid_581997 != nil:
    section.add "quotaUser", valid_581997
  var valid_581998 = query.getOrDefault("fields")
  valid_581998 = validateParameter(valid_581998, JString, required = false,
                                 default = nil)
  if valid_581998 != nil:
    section.add "fields", valid_581998
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581999: Call_DfareportingReportsFilesGet_581986; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a report file. This method supports media download.
  ## 
  let valid = call_581999.validator(path, query, header, formData, body)
  let scheme = call_581999.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581999.url(scheme.get, call_581999.host, call_581999.base,
                         call_581999.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581999, url, valid)

proc call*(call_582000: Call_DfareportingReportsFilesGet_581986; profileId: string;
          fileId: string; reportId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingReportsFilesGet
  ## Retrieves a report file. This method supports media download.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fileId: string (required)
  ##         : The ID of the report file.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582001 = newJObject()
  var query_582002 = newJObject()
  add(query_582002, "key", newJString(key))
  add(query_582002, "prettyPrint", newJBool(prettyPrint))
  add(query_582002, "oauth_token", newJString(oauthToken))
  add(path_582001, "profileId", newJString(profileId))
  add(query_582002, "alt", newJString(alt))
  add(query_582002, "userIp", newJString(userIp))
  add(query_582002, "quotaUser", newJString(quotaUser))
  add(path_582001, "fileId", newJString(fileId))
  add(path_582001, "reportId", newJString(reportId))
  add(query_582002, "fields", newJString(fields))
  result = call_582000.call(path_582001, query_582002, nil, nil, nil)

var dfareportingReportsFilesGet* = Call_DfareportingReportsFilesGet_581986(
    name: "dfareportingReportsFilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}/files/{fileId}",
    validator: validate_DfareportingReportsFilesGet_581987,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsFilesGet_581988,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsRun_582003 = ref object of OpenApiRestCall_578364
proc url_DfareportingReportsRun_582005(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/run")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsRun_582004(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Runs a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582006 = path.getOrDefault("profileId")
  valid_582006 = validateParameter(valid_582006, JString, required = true,
                                 default = nil)
  if valid_582006 != nil:
    section.add "profileId", valid_582006
  var valid_582007 = path.getOrDefault("reportId")
  valid_582007 = validateParameter(valid_582007, JString, required = true,
                                 default = nil)
  if valid_582007 != nil:
    section.add "reportId", valid_582007
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   synchronous: JBool
  ##              : If set and true, tries to run the report synchronously.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582008 = query.getOrDefault("key")
  valid_582008 = validateParameter(valid_582008, JString, required = false,
                                 default = nil)
  if valid_582008 != nil:
    section.add "key", valid_582008
  var valid_582009 = query.getOrDefault("prettyPrint")
  valid_582009 = validateParameter(valid_582009, JBool, required = false,
                                 default = newJBool(true))
  if valid_582009 != nil:
    section.add "prettyPrint", valid_582009
  var valid_582010 = query.getOrDefault("oauth_token")
  valid_582010 = validateParameter(valid_582010, JString, required = false,
                                 default = nil)
  if valid_582010 != nil:
    section.add "oauth_token", valid_582010
  var valid_582011 = query.getOrDefault("synchronous")
  valid_582011 = validateParameter(valid_582011, JBool, required = false,
                                 default = newJBool(false))
  if valid_582011 != nil:
    section.add "synchronous", valid_582011
  var valid_582012 = query.getOrDefault("alt")
  valid_582012 = validateParameter(valid_582012, JString, required = false,
                                 default = newJString("json"))
  if valid_582012 != nil:
    section.add "alt", valid_582012
  var valid_582013 = query.getOrDefault("userIp")
  valid_582013 = validateParameter(valid_582013, JString, required = false,
                                 default = nil)
  if valid_582013 != nil:
    section.add "userIp", valid_582013
  var valid_582014 = query.getOrDefault("quotaUser")
  valid_582014 = validateParameter(valid_582014, JString, required = false,
                                 default = nil)
  if valid_582014 != nil:
    section.add "quotaUser", valid_582014
  var valid_582015 = query.getOrDefault("fields")
  valid_582015 = validateParameter(valid_582015, JString, required = false,
                                 default = nil)
  if valid_582015 != nil:
    section.add "fields", valid_582015
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582016: Call_DfareportingReportsRun_582003; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Runs a report.
  ## 
  let valid = call_582016.validator(path, query, header, formData, body)
  let scheme = call_582016.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582016.url(scheme.get, call_582016.host, call_582016.base,
                         call_582016.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582016, url, valid)

proc call*(call_582017: Call_DfareportingReportsRun_582003; profileId: string;
          reportId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; synchronous: bool = false; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingReportsRun
  ## Runs a report.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   synchronous: bool
  ##              : If set and true, tries to run the report synchronously.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582018 = newJObject()
  var query_582019 = newJObject()
  add(query_582019, "key", newJString(key))
  add(query_582019, "prettyPrint", newJBool(prettyPrint))
  add(query_582019, "oauth_token", newJString(oauthToken))
  add(query_582019, "synchronous", newJBool(synchronous))
  add(path_582018, "profileId", newJString(profileId))
  add(query_582019, "alt", newJString(alt))
  add(query_582019, "userIp", newJString(userIp))
  add(query_582019, "quotaUser", newJString(quotaUser))
  add(path_582018, "reportId", newJString(reportId))
  add(query_582019, "fields", newJString(fields))
  result = call_582017.call(path_582018, query_582019, nil, nil, nil)

var dfareportingReportsRun* = Call_DfareportingReportsRun_582003(
    name: "dfareportingReportsRun", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}/run",
    validator: validate_DfareportingReportsRun_582004, base: "/dfareporting/v2.7",
    url: url_DfareportingReportsRun_582005, schemes: {Scheme.Https})
type
  Call_DfareportingSitesUpdate_582050 = ref object of OpenApiRestCall_578364
proc url_DfareportingSitesUpdate_582052(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesUpdate_582051(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing site.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582053 = path.getOrDefault("profileId")
  valid_582053 = validateParameter(valid_582053, JString, required = true,
                                 default = nil)
  if valid_582053 != nil:
    section.add "profileId", valid_582053
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582054 = query.getOrDefault("key")
  valid_582054 = validateParameter(valid_582054, JString, required = false,
                                 default = nil)
  if valid_582054 != nil:
    section.add "key", valid_582054
  var valid_582055 = query.getOrDefault("prettyPrint")
  valid_582055 = validateParameter(valid_582055, JBool, required = false,
                                 default = newJBool(true))
  if valid_582055 != nil:
    section.add "prettyPrint", valid_582055
  var valid_582056 = query.getOrDefault("oauth_token")
  valid_582056 = validateParameter(valid_582056, JString, required = false,
                                 default = nil)
  if valid_582056 != nil:
    section.add "oauth_token", valid_582056
  var valid_582057 = query.getOrDefault("alt")
  valid_582057 = validateParameter(valid_582057, JString, required = false,
                                 default = newJString("json"))
  if valid_582057 != nil:
    section.add "alt", valid_582057
  var valid_582058 = query.getOrDefault("userIp")
  valid_582058 = validateParameter(valid_582058, JString, required = false,
                                 default = nil)
  if valid_582058 != nil:
    section.add "userIp", valid_582058
  var valid_582059 = query.getOrDefault("quotaUser")
  valid_582059 = validateParameter(valid_582059, JString, required = false,
                                 default = nil)
  if valid_582059 != nil:
    section.add "quotaUser", valid_582059
  var valid_582060 = query.getOrDefault("fields")
  valid_582060 = validateParameter(valid_582060, JString, required = false,
                                 default = nil)
  if valid_582060 != nil:
    section.add "fields", valid_582060
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582062: Call_DfareportingSitesUpdate_582050; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing site.
  ## 
  let valid = call_582062.validator(path, query, header, formData, body)
  let scheme = call_582062.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582062.url(scheme.get, call_582062.host, call_582062.base,
                         call_582062.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582062, url, valid)

proc call*(call_582063: Call_DfareportingSitesUpdate_582050; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingSitesUpdate
  ## Updates an existing site.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582064 = newJObject()
  var query_582065 = newJObject()
  var body_582066 = newJObject()
  add(query_582065, "key", newJString(key))
  add(query_582065, "prettyPrint", newJBool(prettyPrint))
  add(query_582065, "oauth_token", newJString(oauthToken))
  add(path_582064, "profileId", newJString(profileId))
  add(query_582065, "alt", newJString(alt))
  add(query_582065, "userIp", newJString(userIp))
  add(query_582065, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_582066 = body
  add(query_582065, "fields", newJString(fields))
  result = call_582063.call(path_582064, query_582065, nil, nil, body_582066)

var dfareportingSitesUpdate* = Call_DfareportingSitesUpdate_582050(
    name: "dfareportingSitesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesUpdate_582051,
    base: "/dfareporting/v2.7", url: url_DfareportingSitesUpdate_582052,
    schemes: {Scheme.Https})
type
  Call_DfareportingSitesInsert_582067 = ref object of OpenApiRestCall_578364
proc url_DfareportingSitesInsert_582069(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesInsert_582068(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new site.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582070 = path.getOrDefault("profileId")
  valid_582070 = validateParameter(valid_582070, JString, required = true,
                                 default = nil)
  if valid_582070 != nil:
    section.add "profileId", valid_582070
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582071 = query.getOrDefault("key")
  valid_582071 = validateParameter(valid_582071, JString, required = false,
                                 default = nil)
  if valid_582071 != nil:
    section.add "key", valid_582071
  var valid_582072 = query.getOrDefault("prettyPrint")
  valid_582072 = validateParameter(valid_582072, JBool, required = false,
                                 default = newJBool(true))
  if valid_582072 != nil:
    section.add "prettyPrint", valid_582072
  var valid_582073 = query.getOrDefault("oauth_token")
  valid_582073 = validateParameter(valid_582073, JString, required = false,
                                 default = nil)
  if valid_582073 != nil:
    section.add "oauth_token", valid_582073
  var valid_582074 = query.getOrDefault("alt")
  valid_582074 = validateParameter(valid_582074, JString, required = false,
                                 default = newJString("json"))
  if valid_582074 != nil:
    section.add "alt", valid_582074
  var valid_582075 = query.getOrDefault("userIp")
  valid_582075 = validateParameter(valid_582075, JString, required = false,
                                 default = nil)
  if valid_582075 != nil:
    section.add "userIp", valid_582075
  var valid_582076 = query.getOrDefault("quotaUser")
  valid_582076 = validateParameter(valid_582076, JString, required = false,
                                 default = nil)
  if valid_582076 != nil:
    section.add "quotaUser", valid_582076
  var valid_582077 = query.getOrDefault("fields")
  valid_582077 = validateParameter(valid_582077, JString, required = false,
                                 default = nil)
  if valid_582077 != nil:
    section.add "fields", valid_582077
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582079: Call_DfareportingSitesInsert_582067; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new site.
  ## 
  let valid = call_582079.validator(path, query, header, formData, body)
  let scheme = call_582079.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582079.url(scheme.get, call_582079.host, call_582079.base,
                         call_582079.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582079, url, valid)

proc call*(call_582080: Call_DfareportingSitesInsert_582067; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingSitesInsert
  ## Inserts a new site.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582081 = newJObject()
  var query_582082 = newJObject()
  var body_582083 = newJObject()
  add(query_582082, "key", newJString(key))
  add(query_582082, "prettyPrint", newJBool(prettyPrint))
  add(query_582082, "oauth_token", newJString(oauthToken))
  add(path_582081, "profileId", newJString(profileId))
  add(query_582082, "alt", newJString(alt))
  add(query_582082, "userIp", newJString(userIp))
  add(query_582082, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_582083 = body
  add(query_582082, "fields", newJString(fields))
  result = call_582080.call(path_582081, query_582082, nil, nil, body_582083)

var dfareportingSitesInsert* = Call_DfareportingSitesInsert_582067(
    name: "dfareportingSitesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesInsert_582068,
    base: "/dfareporting/v2.7", url: url_DfareportingSitesInsert_582069,
    schemes: {Scheme.Https})
type
  Call_DfareportingSitesList_582020 = ref object of OpenApiRestCall_578364
proc url_DfareportingSitesList_582022(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesList_582021(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of sites, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582023 = path.getOrDefault("profileId")
  valid_582023 = validateParameter(valid_582023, JString, required = true,
                                 default = nil)
  if valid_582023 != nil:
    section.add "profileId", valid_582023
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsPublisherPaidPlacements: JBool
  ##                                 : Select only sites that accept publisher paid placements.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   approved: JBool
  ##           : Select only approved sites.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   acceptsInterstitialPlacements: JBool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   directorySiteIds: JArray
  ##                   : Select only sites with these directory site IDs.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or keyName. Wildcards (*) are allowed. For example, "site*2015" will return objects with names like "site June 2015", "site April 2015", or simply "site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "site" will match objects with name "my site", "site 2015", or simply "site".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   subaccountId: JString
  ##               : Select only sites with this subaccount ID.
  ##   acceptsInStreamVideoPlacements: JBool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   campaignIds: JArray
  ##              : Select only sites with these campaign IDs.
  ##   unmappedSite: JBool
  ##               : Select only sites that have not been mapped to a directory site.
  ##   adWordsSite: JBool
  ##              : Select only AdWords sites.
  ##   ids: JArray
  ##      : Select only sites with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_582024 = query.getOrDefault("key")
  valid_582024 = validateParameter(valid_582024, JString, required = false,
                                 default = nil)
  if valid_582024 != nil:
    section.add "key", valid_582024
  var valid_582025 = query.getOrDefault("acceptsPublisherPaidPlacements")
  valid_582025 = validateParameter(valid_582025, JBool, required = false, default = nil)
  if valid_582025 != nil:
    section.add "acceptsPublisherPaidPlacements", valid_582025
  var valid_582026 = query.getOrDefault("prettyPrint")
  valid_582026 = validateParameter(valid_582026, JBool, required = false,
                                 default = newJBool(true))
  if valid_582026 != nil:
    section.add "prettyPrint", valid_582026
  var valid_582027 = query.getOrDefault("oauth_token")
  valid_582027 = validateParameter(valid_582027, JString, required = false,
                                 default = nil)
  if valid_582027 != nil:
    section.add "oauth_token", valid_582027
  var valid_582028 = query.getOrDefault("approved")
  valid_582028 = validateParameter(valid_582028, JBool, required = false, default = nil)
  if valid_582028 != nil:
    section.add "approved", valid_582028
  var valid_582029 = query.getOrDefault("sortField")
  valid_582029 = validateParameter(valid_582029, JString, required = false,
                                 default = newJString("ID"))
  if valid_582029 != nil:
    section.add "sortField", valid_582029
  var valid_582030 = query.getOrDefault("alt")
  valid_582030 = validateParameter(valid_582030, JString, required = false,
                                 default = newJString("json"))
  if valid_582030 != nil:
    section.add "alt", valid_582030
  var valid_582031 = query.getOrDefault("userIp")
  valid_582031 = validateParameter(valid_582031, JString, required = false,
                                 default = nil)
  if valid_582031 != nil:
    section.add "userIp", valid_582031
  var valid_582032 = query.getOrDefault("acceptsInterstitialPlacements")
  valid_582032 = validateParameter(valid_582032, JBool, required = false, default = nil)
  if valid_582032 != nil:
    section.add "acceptsInterstitialPlacements", valid_582032
  var valid_582033 = query.getOrDefault("quotaUser")
  valid_582033 = validateParameter(valid_582033, JString, required = false,
                                 default = nil)
  if valid_582033 != nil:
    section.add "quotaUser", valid_582033
  var valid_582034 = query.getOrDefault("directorySiteIds")
  valid_582034 = validateParameter(valid_582034, JArray, required = false,
                                 default = nil)
  if valid_582034 != nil:
    section.add "directorySiteIds", valid_582034
  var valid_582035 = query.getOrDefault("pageToken")
  valid_582035 = validateParameter(valid_582035, JString, required = false,
                                 default = nil)
  if valid_582035 != nil:
    section.add "pageToken", valid_582035
  var valid_582036 = query.getOrDefault("searchString")
  valid_582036 = validateParameter(valid_582036, JString, required = false,
                                 default = nil)
  if valid_582036 != nil:
    section.add "searchString", valid_582036
  var valid_582037 = query.getOrDefault("sortOrder")
  valid_582037 = validateParameter(valid_582037, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_582037 != nil:
    section.add "sortOrder", valid_582037
  var valid_582038 = query.getOrDefault("subaccountId")
  valid_582038 = validateParameter(valid_582038, JString, required = false,
                                 default = nil)
  if valid_582038 != nil:
    section.add "subaccountId", valid_582038
  var valid_582039 = query.getOrDefault("acceptsInStreamVideoPlacements")
  valid_582039 = validateParameter(valid_582039, JBool, required = false, default = nil)
  if valid_582039 != nil:
    section.add "acceptsInStreamVideoPlacements", valid_582039
  var valid_582040 = query.getOrDefault("campaignIds")
  valid_582040 = validateParameter(valid_582040, JArray, required = false,
                                 default = nil)
  if valid_582040 != nil:
    section.add "campaignIds", valid_582040
  var valid_582041 = query.getOrDefault("unmappedSite")
  valid_582041 = validateParameter(valid_582041, JBool, required = false, default = nil)
  if valid_582041 != nil:
    section.add "unmappedSite", valid_582041
  var valid_582042 = query.getOrDefault("adWordsSite")
  valid_582042 = validateParameter(valid_582042, JBool, required = false, default = nil)
  if valid_582042 != nil:
    section.add "adWordsSite", valid_582042
  var valid_582043 = query.getOrDefault("ids")
  valid_582043 = validateParameter(valid_582043, JArray, required = false,
                                 default = nil)
  if valid_582043 != nil:
    section.add "ids", valid_582043
  var valid_582044 = query.getOrDefault("fields")
  valid_582044 = validateParameter(valid_582044, JString, required = false,
                                 default = nil)
  if valid_582044 != nil:
    section.add "fields", valid_582044
  var valid_582045 = query.getOrDefault("maxResults")
  valid_582045 = validateParameter(valid_582045, JInt, required = false,
                                 default = newJInt(1000))
  if valid_582045 != nil:
    section.add "maxResults", valid_582045
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582046: Call_DfareportingSitesList_582020; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of sites, possibly filtered. This method supports paging.
  ## 
  let valid = call_582046.validator(path, query, header, formData, body)
  let scheme = call_582046.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582046.url(scheme.get, call_582046.host, call_582046.base,
                         call_582046.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582046, url, valid)

proc call*(call_582047: Call_DfareportingSitesList_582020; profileId: string;
          key: string = ""; acceptsPublisherPaidPlacements: bool = false;
          prettyPrint: bool = true; oauthToken: string = ""; approved: bool = false;
          sortField: string = "ID"; alt: string = "json"; userIp: string = "";
          acceptsInterstitialPlacements: bool = false; quotaUser: string = "";
          directorySiteIds: JsonNode = nil; pageToken: string = "";
          searchString: string = ""; sortOrder: string = "ASCENDING";
          subaccountId: string = ""; acceptsInStreamVideoPlacements: bool = false;
          campaignIds: JsonNode = nil; unmappedSite: bool = false;
          adWordsSite: bool = false; ids: JsonNode = nil; fields: string = "";
          maxResults: int = 1000): Recallable =
  ## dfareportingSitesList
  ## Retrieves a list of sites, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsPublisherPaidPlacements: bool
  ##                                 : Select only sites that accept publisher paid placements.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   approved: bool
  ##           : Select only approved sites.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   acceptsInterstitialPlacements: bool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   directorySiteIds: JArray
  ##                   : Select only sites with these directory site IDs.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or keyName. Wildcards (*) are allowed. For example, "site*2015" will return objects with names like "site June 2015", "site April 2015", or simply "site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "site" will match objects with name "my site", "site 2015", or simply "site".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   subaccountId: string
  ##               : Select only sites with this subaccount ID.
  ##   acceptsInStreamVideoPlacements: bool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   campaignIds: JArray
  ##              : Select only sites with these campaign IDs.
  ##   unmappedSite: bool
  ##               : Select only sites that have not been mapped to a directory site.
  ##   adWordsSite: bool
  ##              : Select only AdWords sites.
  ##   ids: JArray
  ##      : Select only sites with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_582048 = newJObject()
  var query_582049 = newJObject()
  add(query_582049, "key", newJString(key))
  add(query_582049, "acceptsPublisherPaidPlacements",
      newJBool(acceptsPublisherPaidPlacements))
  add(query_582049, "prettyPrint", newJBool(prettyPrint))
  add(query_582049, "oauth_token", newJString(oauthToken))
  add(path_582048, "profileId", newJString(profileId))
  add(query_582049, "approved", newJBool(approved))
  add(query_582049, "sortField", newJString(sortField))
  add(query_582049, "alt", newJString(alt))
  add(query_582049, "userIp", newJString(userIp))
  add(query_582049, "acceptsInterstitialPlacements",
      newJBool(acceptsInterstitialPlacements))
  add(query_582049, "quotaUser", newJString(quotaUser))
  if directorySiteIds != nil:
    query_582049.add "directorySiteIds", directorySiteIds
  add(query_582049, "pageToken", newJString(pageToken))
  add(query_582049, "searchString", newJString(searchString))
  add(query_582049, "sortOrder", newJString(sortOrder))
  add(query_582049, "subaccountId", newJString(subaccountId))
  add(query_582049, "acceptsInStreamVideoPlacements",
      newJBool(acceptsInStreamVideoPlacements))
  if campaignIds != nil:
    query_582049.add "campaignIds", campaignIds
  add(query_582049, "unmappedSite", newJBool(unmappedSite))
  add(query_582049, "adWordsSite", newJBool(adWordsSite))
  if ids != nil:
    query_582049.add "ids", ids
  add(query_582049, "fields", newJString(fields))
  add(query_582049, "maxResults", newJInt(maxResults))
  result = call_582047.call(path_582048, query_582049, nil, nil, nil)

var dfareportingSitesList* = Call_DfareportingSitesList_582020(
    name: "dfareportingSitesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesList_582021, base: "/dfareporting/v2.7",
    url: url_DfareportingSitesList_582022, schemes: {Scheme.Https})
type
  Call_DfareportingSitesPatch_582084 = ref object of OpenApiRestCall_578364
proc url_DfareportingSitesPatch_582086(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesPatch_582085(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing site. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582087 = path.getOrDefault("profileId")
  valid_582087 = validateParameter(valid_582087, JString, required = true,
                                 default = nil)
  if valid_582087 != nil:
    section.add "profileId", valid_582087
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Site ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582088 = query.getOrDefault("key")
  valid_582088 = validateParameter(valid_582088, JString, required = false,
                                 default = nil)
  if valid_582088 != nil:
    section.add "key", valid_582088
  var valid_582089 = query.getOrDefault("prettyPrint")
  valid_582089 = validateParameter(valid_582089, JBool, required = false,
                                 default = newJBool(true))
  if valid_582089 != nil:
    section.add "prettyPrint", valid_582089
  var valid_582090 = query.getOrDefault("oauth_token")
  valid_582090 = validateParameter(valid_582090, JString, required = false,
                                 default = nil)
  if valid_582090 != nil:
    section.add "oauth_token", valid_582090
  var valid_582091 = query.getOrDefault("alt")
  valid_582091 = validateParameter(valid_582091, JString, required = false,
                                 default = newJString("json"))
  if valid_582091 != nil:
    section.add "alt", valid_582091
  var valid_582092 = query.getOrDefault("userIp")
  valid_582092 = validateParameter(valid_582092, JString, required = false,
                                 default = nil)
  if valid_582092 != nil:
    section.add "userIp", valid_582092
  var valid_582093 = query.getOrDefault("quotaUser")
  valid_582093 = validateParameter(valid_582093, JString, required = false,
                                 default = nil)
  if valid_582093 != nil:
    section.add "quotaUser", valid_582093
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_582094 = query.getOrDefault("id")
  valid_582094 = validateParameter(valid_582094, JString, required = true,
                                 default = nil)
  if valid_582094 != nil:
    section.add "id", valid_582094
  var valid_582095 = query.getOrDefault("fields")
  valid_582095 = validateParameter(valid_582095, JString, required = false,
                                 default = nil)
  if valid_582095 != nil:
    section.add "fields", valid_582095
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582097: Call_DfareportingSitesPatch_582084; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing site. This method supports patch semantics.
  ## 
  let valid = call_582097.validator(path, query, header, formData, body)
  let scheme = call_582097.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582097.url(scheme.get, call_582097.host, call_582097.base,
                         call_582097.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582097, url, valid)

proc call*(call_582098: Call_DfareportingSitesPatch_582084; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingSitesPatch
  ## Updates an existing site. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Site ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582099 = newJObject()
  var query_582100 = newJObject()
  var body_582101 = newJObject()
  add(query_582100, "key", newJString(key))
  add(query_582100, "prettyPrint", newJBool(prettyPrint))
  add(query_582100, "oauth_token", newJString(oauthToken))
  add(path_582099, "profileId", newJString(profileId))
  add(query_582100, "alt", newJString(alt))
  add(query_582100, "userIp", newJString(userIp))
  add(query_582100, "quotaUser", newJString(quotaUser))
  add(query_582100, "id", newJString(id))
  if body != nil:
    body_582101 = body
  add(query_582100, "fields", newJString(fields))
  result = call_582098.call(path_582099, query_582100, nil, nil, body_582101)

var dfareportingSitesPatch* = Call_DfareportingSitesPatch_582084(
    name: "dfareportingSitesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesPatch_582085, base: "/dfareporting/v2.7",
    url: url_DfareportingSitesPatch_582086, schemes: {Scheme.Https})
type
  Call_DfareportingSitesGet_582102 = ref object of OpenApiRestCall_578364
proc url_DfareportingSitesGet_582104(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesGet_582103(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one site by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Site ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582105 = path.getOrDefault("profileId")
  valid_582105 = validateParameter(valid_582105, JString, required = true,
                                 default = nil)
  if valid_582105 != nil:
    section.add "profileId", valid_582105
  var valid_582106 = path.getOrDefault("id")
  valid_582106 = validateParameter(valid_582106, JString, required = true,
                                 default = nil)
  if valid_582106 != nil:
    section.add "id", valid_582106
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582107 = query.getOrDefault("key")
  valid_582107 = validateParameter(valid_582107, JString, required = false,
                                 default = nil)
  if valid_582107 != nil:
    section.add "key", valid_582107
  var valid_582108 = query.getOrDefault("prettyPrint")
  valid_582108 = validateParameter(valid_582108, JBool, required = false,
                                 default = newJBool(true))
  if valid_582108 != nil:
    section.add "prettyPrint", valid_582108
  var valid_582109 = query.getOrDefault("oauth_token")
  valid_582109 = validateParameter(valid_582109, JString, required = false,
                                 default = nil)
  if valid_582109 != nil:
    section.add "oauth_token", valid_582109
  var valid_582110 = query.getOrDefault("alt")
  valid_582110 = validateParameter(valid_582110, JString, required = false,
                                 default = newJString("json"))
  if valid_582110 != nil:
    section.add "alt", valid_582110
  var valid_582111 = query.getOrDefault("userIp")
  valid_582111 = validateParameter(valid_582111, JString, required = false,
                                 default = nil)
  if valid_582111 != nil:
    section.add "userIp", valid_582111
  var valid_582112 = query.getOrDefault("quotaUser")
  valid_582112 = validateParameter(valid_582112, JString, required = false,
                                 default = nil)
  if valid_582112 != nil:
    section.add "quotaUser", valid_582112
  var valid_582113 = query.getOrDefault("fields")
  valid_582113 = validateParameter(valid_582113, JString, required = false,
                                 default = nil)
  if valid_582113 != nil:
    section.add "fields", valid_582113
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582114: Call_DfareportingSitesGet_582102; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one site by ID.
  ## 
  let valid = call_582114.validator(path, query, header, formData, body)
  let scheme = call_582114.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582114.url(scheme.get, call_582114.host, call_582114.base,
                         call_582114.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582114, url, valid)

proc call*(call_582115: Call_DfareportingSitesGet_582102; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingSitesGet
  ## Gets one site by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Site ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582116 = newJObject()
  var query_582117 = newJObject()
  add(query_582117, "key", newJString(key))
  add(query_582117, "prettyPrint", newJBool(prettyPrint))
  add(query_582117, "oauth_token", newJString(oauthToken))
  add(path_582116, "profileId", newJString(profileId))
  add(path_582116, "id", newJString(id))
  add(query_582117, "alt", newJString(alt))
  add(query_582117, "userIp", newJString(userIp))
  add(query_582117, "quotaUser", newJString(quotaUser))
  add(query_582117, "fields", newJString(fields))
  result = call_582115.call(path_582116, query_582117, nil, nil, nil)

var dfareportingSitesGet* = Call_DfareportingSitesGet_582102(
    name: "dfareportingSitesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites/{id}",
    validator: validate_DfareportingSitesGet_582103, base: "/dfareporting/v2.7",
    url: url_DfareportingSitesGet_582104, schemes: {Scheme.Https})
type
  Call_DfareportingSizesInsert_582137 = ref object of OpenApiRestCall_578364
proc url_DfareportingSizesInsert_582139(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sizes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSizesInsert_582138(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new size.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582140 = path.getOrDefault("profileId")
  valid_582140 = validateParameter(valid_582140, JString, required = true,
                                 default = nil)
  if valid_582140 != nil:
    section.add "profileId", valid_582140
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582141 = query.getOrDefault("key")
  valid_582141 = validateParameter(valid_582141, JString, required = false,
                                 default = nil)
  if valid_582141 != nil:
    section.add "key", valid_582141
  var valid_582142 = query.getOrDefault("prettyPrint")
  valid_582142 = validateParameter(valid_582142, JBool, required = false,
                                 default = newJBool(true))
  if valid_582142 != nil:
    section.add "prettyPrint", valid_582142
  var valid_582143 = query.getOrDefault("oauth_token")
  valid_582143 = validateParameter(valid_582143, JString, required = false,
                                 default = nil)
  if valid_582143 != nil:
    section.add "oauth_token", valid_582143
  var valid_582144 = query.getOrDefault("alt")
  valid_582144 = validateParameter(valid_582144, JString, required = false,
                                 default = newJString("json"))
  if valid_582144 != nil:
    section.add "alt", valid_582144
  var valid_582145 = query.getOrDefault("userIp")
  valid_582145 = validateParameter(valid_582145, JString, required = false,
                                 default = nil)
  if valid_582145 != nil:
    section.add "userIp", valid_582145
  var valid_582146 = query.getOrDefault("quotaUser")
  valid_582146 = validateParameter(valid_582146, JString, required = false,
                                 default = nil)
  if valid_582146 != nil:
    section.add "quotaUser", valid_582146
  var valid_582147 = query.getOrDefault("fields")
  valid_582147 = validateParameter(valid_582147, JString, required = false,
                                 default = nil)
  if valid_582147 != nil:
    section.add "fields", valid_582147
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582149: Call_DfareportingSizesInsert_582137; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new size.
  ## 
  let valid = call_582149.validator(path, query, header, formData, body)
  let scheme = call_582149.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582149.url(scheme.get, call_582149.host, call_582149.base,
                         call_582149.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582149, url, valid)

proc call*(call_582150: Call_DfareportingSizesInsert_582137; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingSizesInsert
  ## Inserts a new size.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582151 = newJObject()
  var query_582152 = newJObject()
  var body_582153 = newJObject()
  add(query_582152, "key", newJString(key))
  add(query_582152, "prettyPrint", newJBool(prettyPrint))
  add(query_582152, "oauth_token", newJString(oauthToken))
  add(path_582151, "profileId", newJString(profileId))
  add(query_582152, "alt", newJString(alt))
  add(query_582152, "userIp", newJString(userIp))
  add(query_582152, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_582153 = body
  add(query_582152, "fields", newJString(fields))
  result = call_582150.call(path_582151, query_582152, nil, nil, body_582153)

var dfareportingSizesInsert* = Call_DfareportingSizesInsert_582137(
    name: "dfareportingSizesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sizes",
    validator: validate_DfareportingSizesInsert_582138,
    base: "/dfareporting/v2.7", url: url_DfareportingSizesInsert_582139,
    schemes: {Scheme.Https})
type
  Call_DfareportingSizesList_582118 = ref object of OpenApiRestCall_578364
proc url_DfareportingSizesList_582120(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sizes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSizesList_582119(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of sizes, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582121 = path.getOrDefault("profileId")
  valid_582121 = validateParameter(valid_582121, JString, required = true,
                                 default = nil)
  if valid_582121 != nil:
    section.add "profileId", valid_582121
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   height: JInt
  ##         : Select only sizes with this height.
  ##   iabStandard: JBool
  ##              : Select only IAB standard sizes.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   width: JInt
  ##        : Select only sizes with this width.
  ##   ids: JArray
  ##      : Select only sizes with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582122 = query.getOrDefault("key")
  valid_582122 = validateParameter(valid_582122, JString, required = false,
                                 default = nil)
  if valid_582122 != nil:
    section.add "key", valid_582122
  var valid_582123 = query.getOrDefault("prettyPrint")
  valid_582123 = validateParameter(valid_582123, JBool, required = false,
                                 default = newJBool(true))
  if valid_582123 != nil:
    section.add "prettyPrint", valid_582123
  var valid_582124 = query.getOrDefault("oauth_token")
  valid_582124 = validateParameter(valid_582124, JString, required = false,
                                 default = nil)
  if valid_582124 != nil:
    section.add "oauth_token", valid_582124
  var valid_582125 = query.getOrDefault("height")
  valid_582125 = validateParameter(valid_582125, JInt, required = false, default = nil)
  if valid_582125 != nil:
    section.add "height", valid_582125
  var valid_582126 = query.getOrDefault("iabStandard")
  valid_582126 = validateParameter(valid_582126, JBool, required = false, default = nil)
  if valid_582126 != nil:
    section.add "iabStandard", valid_582126
  var valid_582127 = query.getOrDefault("alt")
  valid_582127 = validateParameter(valid_582127, JString, required = false,
                                 default = newJString("json"))
  if valid_582127 != nil:
    section.add "alt", valid_582127
  var valid_582128 = query.getOrDefault("userIp")
  valid_582128 = validateParameter(valid_582128, JString, required = false,
                                 default = nil)
  if valid_582128 != nil:
    section.add "userIp", valid_582128
  var valid_582129 = query.getOrDefault("quotaUser")
  valid_582129 = validateParameter(valid_582129, JString, required = false,
                                 default = nil)
  if valid_582129 != nil:
    section.add "quotaUser", valid_582129
  var valid_582130 = query.getOrDefault("width")
  valid_582130 = validateParameter(valid_582130, JInt, required = false, default = nil)
  if valid_582130 != nil:
    section.add "width", valid_582130
  var valid_582131 = query.getOrDefault("ids")
  valid_582131 = validateParameter(valid_582131, JArray, required = false,
                                 default = nil)
  if valid_582131 != nil:
    section.add "ids", valid_582131
  var valid_582132 = query.getOrDefault("fields")
  valid_582132 = validateParameter(valid_582132, JString, required = false,
                                 default = nil)
  if valid_582132 != nil:
    section.add "fields", valid_582132
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582133: Call_DfareportingSizesList_582118; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of sizes, possibly filtered.
  ## 
  let valid = call_582133.validator(path, query, header, formData, body)
  let scheme = call_582133.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582133.url(scheme.get, call_582133.host, call_582133.base,
                         call_582133.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582133, url, valid)

proc call*(call_582134: Call_DfareportingSizesList_582118; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          height: int = 0; iabStandard: bool = false; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; width: int = 0; ids: JsonNode = nil;
          fields: string = ""): Recallable =
  ## dfareportingSizesList
  ## Retrieves a list of sizes, possibly filtered.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   height: int
  ##         : Select only sizes with this height.
  ##   iabStandard: bool
  ##              : Select only IAB standard sizes.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   width: int
  ##        : Select only sizes with this width.
  ##   ids: JArray
  ##      : Select only sizes with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582135 = newJObject()
  var query_582136 = newJObject()
  add(query_582136, "key", newJString(key))
  add(query_582136, "prettyPrint", newJBool(prettyPrint))
  add(query_582136, "oauth_token", newJString(oauthToken))
  add(query_582136, "height", newJInt(height))
  add(query_582136, "iabStandard", newJBool(iabStandard))
  add(path_582135, "profileId", newJString(profileId))
  add(query_582136, "alt", newJString(alt))
  add(query_582136, "userIp", newJString(userIp))
  add(query_582136, "quotaUser", newJString(quotaUser))
  add(query_582136, "width", newJInt(width))
  if ids != nil:
    query_582136.add "ids", ids
  add(query_582136, "fields", newJString(fields))
  result = call_582134.call(path_582135, query_582136, nil, nil, nil)

var dfareportingSizesList* = Call_DfareportingSizesList_582118(
    name: "dfareportingSizesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sizes",
    validator: validate_DfareportingSizesList_582119, base: "/dfareporting/v2.7",
    url: url_DfareportingSizesList_582120, schemes: {Scheme.Https})
type
  Call_DfareportingSizesGet_582154 = ref object of OpenApiRestCall_578364
proc url_DfareportingSizesGet_582156(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sizes/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSizesGet_582155(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one size by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Size ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582157 = path.getOrDefault("profileId")
  valid_582157 = validateParameter(valid_582157, JString, required = true,
                                 default = nil)
  if valid_582157 != nil:
    section.add "profileId", valid_582157
  var valid_582158 = path.getOrDefault("id")
  valid_582158 = validateParameter(valid_582158, JString, required = true,
                                 default = nil)
  if valid_582158 != nil:
    section.add "id", valid_582158
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582159 = query.getOrDefault("key")
  valid_582159 = validateParameter(valid_582159, JString, required = false,
                                 default = nil)
  if valid_582159 != nil:
    section.add "key", valid_582159
  var valid_582160 = query.getOrDefault("prettyPrint")
  valid_582160 = validateParameter(valid_582160, JBool, required = false,
                                 default = newJBool(true))
  if valid_582160 != nil:
    section.add "prettyPrint", valid_582160
  var valid_582161 = query.getOrDefault("oauth_token")
  valid_582161 = validateParameter(valid_582161, JString, required = false,
                                 default = nil)
  if valid_582161 != nil:
    section.add "oauth_token", valid_582161
  var valid_582162 = query.getOrDefault("alt")
  valid_582162 = validateParameter(valid_582162, JString, required = false,
                                 default = newJString("json"))
  if valid_582162 != nil:
    section.add "alt", valid_582162
  var valid_582163 = query.getOrDefault("userIp")
  valid_582163 = validateParameter(valid_582163, JString, required = false,
                                 default = nil)
  if valid_582163 != nil:
    section.add "userIp", valid_582163
  var valid_582164 = query.getOrDefault("quotaUser")
  valid_582164 = validateParameter(valid_582164, JString, required = false,
                                 default = nil)
  if valid_582164 != nil:
    section.add "quotaUser", valid_582164
  var valid_582165 = query.getOrDefault("fields")
  valid_582165 = validateParameter(valid_582165, JString, required = false,
                                 default = nil)
  if valid_582165 != nil:
    section.add "fields", valid_582165
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582166: Call_DfareportingSizesGet_582154; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one size by ID.
  ## 
  let valid = call_582166.validator(path, query, header, formData, body)
  let scheme = call_582166.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582166.url(scheme.get, call_582166.host, call_582166.base,
                         call_582166.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582166, url, valid)

proc call*(call_582167: Call_DfareportingSizesGet_582154; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingSizesGet
  ## Gets one size by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Size ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582168 = newJObject()
  var query_582169 = newJObject()
  add(query_582169, "key", newJString(key))
  add(query_582169, "prettyPrint", newJBool(prettyPrint))
  add(query_582169, "oauth_token", newJString(oauthToken))
  add(path_582168, "profileId", newJString(profileId))
  add(path_582168, "id", newJString(id))
  add(query_582169, "alt", newJString(alt))
  add(query_582169, "userIp", newJString(userIp))
  add(query_582169, "quotaUser", newJString(quotaUser))
  add(query_582169, "fields", newJString(fields))
  result = call_582167.call(path_582168, query_582169, nil, nil, nil)

var dfareportingSizesGet* = Call_DfareportingSizesGet_582154(
    name: "dfareportingSizesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sizes/{id}",
    validator: validate_DfareportingSizesGet_582155, base: "/dfareporting/v2.7",
    url: url_DfareportingSizesGet_582156, schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsUpdate_582191 = ref object of OpenApiRestCall_578364
proc url_DfareportingSubaccountsUpdate_582193(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsUpdate_582192(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing subaccount.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582194 = path.getOrDefault("profileId")
  valid_582194 = validateParameter(valid_582194, JString, required = true,
                                 default = nil)
  if valid_582194 != nil:
    section.add "profileId", valid_582194
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582195 = query.getOrDefault("key")
  valid_582195 = validateParameter(valid_582195, JString, required = false,
                                 default = nil)
  if valid_582195 != nil:
    section.add "key", valid_582195
  var valid_582196 = query.getOrDefault("prettyPrint")
  valid_582196 = validateParameter(valid_582196, JBool, required = false,
                                 default = newJBool(true))
  if valid_582196 != nil:
    section.add "prettyPrint", valid_582196
  var valid_582197 = query.getOrDefault("oauth_token")
  valid_582197 = validateParameter(valid_582197, JString, required = false,
                                 default = nil)
  if valid_582197 != nil:
    section.add "oauth_token", valid_582197
  var valid_582198 = query.getOrDefault("alt")
  valid_582198 = validateParameter(valid_582198, JString, required = false,
                                 default = newJString("json"))
  if valid_582198 != nil:
    section.add "alt", valid_582198
  var valid_582199 = query.getOrDefault("userIp")
  valid_582199 = validateParameter(valid_582199, JString, required = false,
                                 default = nil)
  if valid_582199 != nil:
    section.add "userIp", valid_582199
  var valid_582200 = query.getOrDefault("quotaUser")
  valid_582200 = validateParameter(valid_582200, JString, required = false,
                                 default = nil)
  if valid_582200 != nil:
    section.add "quotaUser", valid_582200
  var valid_582201 = query.getOrDefault("fields")
  valid_582201 = validateParameter(valid_582201, JString, required = false,
                                 default = nil)
  if valid_582201 != nil:
    section.add "fields", valid_582201
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582203: Call_DfareportingSubaccountsUpdate_582191; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing subaccount.
  ## 
  let valid = call_582203.validator(path, query, header, formData, body)
  let scheme = call_582203.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582203.url(scheme.get, call_582203.host, call_582203.base,
                         call_582203.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582203, url, valid)

proc call*(call_582204: Call_DfareportingSubaccountsUpdate_582191;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingSubaccountsUpdate
  ## Updates an existing subaccount.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582205 = newJObject()
  var query_582206 = newJObject()
  var body_582207 = newJObject()
  add(query_582206, "key", newJString(key))
  add(query_582206, "prettyPrint", newJBool(prettyPrint))
  add(query_582206, "oauth_token", newJString(oauthToken))
  add(path_582205, "profileId", newJString(profileId))
  add(query_582206, "alt", newJString(alt))
  add(query_582206, "userIp", newJString(userIp))
  add(query_582206, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_582207 = body
  add(query_582206, "fields", newJString(fields))
  result = call_582204.call(path_582205, query_582206, nil, nil, body_582207)

var dfareportingSubaccountsUpdate* = Call_DfareportingSubaccountsUpdate_582191(
    name: "dfareportingSubaccountsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsUpdate_582192,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsUpdate_582193,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsInsert_582208 = ref object of OpenApiRestCall_578364
proc url_DfareportingSubaccountsInsert_582210(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsInsert_582209(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new subaccount.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582211 = path.getOrDefault("profileId")
  valid_582211 = validateParameter(valid_582211, JString, required = true,
                                 default = nil)
  if valid_582211 != nil:
    section.add "profileId", valid_582211
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582212 = query.getOrDefault("key")
  valid_582212 = validateParameter(valid_582212, JString, required = false,
                                 default = nil)
  if valid_582212 != nil:
    section.add "key", valid_582212
  var valid_582213 = query.getOrDefault("prettyPrint")
  valid_582213 = validateParameter(valid_582213, JBool, required = false,
                                 default = newJBool(true))
  if valid_582213 != nil:
    section.add "prettyPrint", valid_582213
  var valid_582214 = query.getOrDefault("oauth_token")
  valid_582214 = validateParameter(valid_582214, JString, required = false,
                                 default = nil)
  if valid_582214 != nil:
    section.add "oauth_token", valid_582214
  var valid_582215 = query.getOrDefault("alt")
  valid_582215 = validateParameter(valid_582215, JString, required = false,
                                 default = newJString("json"))
  if valid_582215 != nil:
    section.add "alt", valid_582215
  var valid_582216 = query.getOrDefault("userIp")
  valid_582216 = validateParameter(valid_582216, JString, required = false,
                                 default = nil)
  if valid_582216 != nil:
    section.add "userIp", valid_582216
  var valid_582217 = query.getOrDefault("quotaUser")
  valid_582217 = validateParameter(valid_582217, JString, required = false,
                                 default = nil)
  if valid_582217 != nil:
    section.add "quotaUser", valid_582217
  var valid_582218 = query.getOrDefault("fields")
  valid_582218 = validateParameter(valid_582218, JString, required = false,
                                 default = nil)
  if valid_582218 != nil:
    section.add "fields", valid_582218
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582220: Call_DfareportingSubaccountsInsert_582208; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new subaccount.
  ## 
  let valid = call_582220.validator(path, query, header, formData, body)
  let scheme = call_582220.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582220.url(scheme.get, call_582220.host, call_582220.base,
                         call_582220.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582220, url, valid)

proc call*(call_582221: Call_DfareportingSubaccountsInsert_582208;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingSubaccountsInsert
  ## Inserts a new subaccount.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582222 = newJObject()
  var query_582223 = newJObject()
  var body_582224 = newJObject()
  add(query_582223, "key", newJString(key))
  add(query_582223, "prettyPrint", newJBool(prettyPrint))
  add(query_582223, "oauth_token", newJString(oauthToken))
  add(path_582222, "profileId", newJString(profileId))
  add(query_582223, "alt", newJString(alt))
  add(query_582223, "userIp", newJString(userIp))
  add(query_582223, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_582224 = body
  add(query_582223, "fields", newJString(fields))
  result = call_582221.call(path_582222, query_582223, nil, nil, body_582224)

var dfareportingSubaccountsInsert* = Call_DfareportingSubaccountsInsert_582208(
    name: "dfareportingSubaccountsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsInsert_582209,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsInsert_582210,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsList_582170 = ref object of OpenApiRestCall_578364
proc url_DfareportingSubaccountsList_582172(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsList_582171(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of subaccounts, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582173 = path.getOrDefault("profileId")
  valid_582173 = validateParameter(valid_582173, JString, required = true,
                                 default = nil)
  if valid_582173 != nil:
    section.add "profileId", valid_582173
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "subaccount*2015" will return objects with names like "subaccount June 2015", "subaccount April 2015", or simply "subaccount 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "subaccount" will match objects with name "my subaccount", "subaccount 2015", or simply "subaccount".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only subaccounts with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_582174 = query.getOrDefault("key")
  valid_582174 = validateParameter(valid_582174, JString, required = false,
                                 default = nil)
  if valid_582174 != nil:
    section.add "key", valid_582174
  var valid_582175 = query.getOrDefault("prettyPrint")
  valid_582175 = validateParameter(valid_582175, JBool, required = false,
                                 default = newJBool(true))
  if valid_582175 != nil:
    section.add "prettyPrint", valid_582175
  var valid_582176 = query.getOrDefault("oauth_token")
  valid_582176 = validateParameter(valid_582176, JString, required = false,
                                 default = nil)
  if valid_582176 != nil:
    section.add "oauth_token", valid_582176
  var valid_582177 = query.getOrDefault("sortField")
  valid_582177 = validateParameter(valid_582177, JString, required = false,
                                 default = newJString("ID"))
  if valid_582177 != nil:
    section.add "sortField", valid_582177
  var valid_582178 = query.getOrDefault("alt")
  valid_582178 = validateParameter(valid_582178, JString, required = false,
                                 default = newJString("json"))
  if valid_582178 != nil:
    section.add "alt", valid_582178
  var valid_582179 = query.getOrDefault("userIp")
  valid_582179 = validateParameter(valid_582179, JString, required = false,
                                 default = nil)
  if valid_582179 != nil:
    section.add "userIp", valid_582179
  var valid_582180 = query.getOrDefault("quotaUser")
  valid_582180 = validateParameter(valid_582180, JString, required = false,
                                 default = nil)
  if valid_582180 != nil:
    section.add "quotaUser", valid_582180
  var valid_582181 = query.getOrDefault("pageToken")
  valid_582181 = validateParameter(valid_582181, JString, required = false,
                                 default = nil)
  if valid_582181 != nil:
    section.add "pageToken", valid_582181
  var valid_582182 = query.getOrDefault("searchString")
  valid_582182 = validateParameter(valid_582182, JString, required = false,
                                 default = nil)
  if valid_582182 != nil:
    section.add "searchString", valid_582182
  var valid_582183 = query.getOrDefault("sortOrder")
  valid_582183 = validateParameter(valid_582183, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_582183 != nil:
    section.add "sortOrder", valid_582183
  var valid_582184 = query.getOrDefault("ids")
  valid_582184 = validateParameter(valid_582184, JArray, required = false,
                                 default = nil)
  if valid_582184 != nil:
    section.add "ids", valid_582184
  var valid_582185 = query.getOrDefault("fields")
  valid_582185 = validateParameter(valid_582185, JString, required = false,
                                 default = nil)
  if valid_582185 != nil:
    section.add "fields", valid_582185
  var valid_582186 = query.getOrDefault("maxResults")
  valid_582186 = validateParameter(valid_582186, JInt, required = false,
                                 default = newJInt(1000))
  if valid_582186 != nil:
    section.add "maxResults", valid_582186
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582187: Call_DfareportingSubaccountsList_582170; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of subaccounts, possibly filtered. This method supports paging.
  ## 
  let valid = call_582187.validator(path, query, header, formData, body)
  let scheme = call_582187.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582187.url(scheme.get, call_582187.host, call_582187.base,
                         call_582187.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582187, url, valid)

proc call*(call_582188: Call_DfareportingSubaccountsList_582170; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          sortField: string = "ID"; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; pageToken: string = ""; searchString: string = "";
          sortOrder: string = "ASCENDING"; ids: JsonNode = nil; fields: string = "";
          maxResults: int = 1000): Recallable =
  ## dfareportingSubaccountsList
  ## Gets a list of subaccounts, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "subaccount*2015" will return objects with names like "subaccount June 2015", "subaccount April 2015", or simply "subaccount 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "subaccount" will match objects with name "my subaccount", "subaccount 2015", or simply "subaccount".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   ids: JArray
  ##      : Select only subaccounts with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_582189 = newJObject()
  var query_582190 = newJObject()
  add(query_582190, "key", newJString(key))
  add(query_582190, "prettyPrint", newJBool(prettyPrint))
  add(query_582190, "oauth_token", newJString(oauthToken))
  add(path_582189, "profileId", newJString(profileId))
  add(query_582190, "sortField", newJString(sortField))
  add(query_582190, "alt", newJString(alt))
  add(query_582190, "userIp", newJString(userIp))
  add(query_582190, "quotaUser", newJString(quotaUser))
  add(query_582190, "pageToken", newJString(pageToken))
  add(query_582190, "searchString", newJString(searchString))
  add(query_582190, "sortOrder", newJString(sortOrder))
  if ids != nil:
    query_582190.add "ids", ids
  add(query_582190, "fields", newJString(fields))
  add(query_582190, "maxResults", newJInt(maxResults))
  result = call_582188.call(path_582189, query_582190, nil, nil, nil)

var dfareportingSubaccountsList* = Call_DfareportingSubaccountsList_582170(
    name: "dfareportingSubaccountsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsList_582171,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsList_582172,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsPatch_582225 = ref object of OpenApiRestCall_578364
proc url_DfareportingSubaccountsPatch_582227(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsPatch_582226(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing subaccount. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582228 = path.getOrDefault("profileId")
  valid_582228 = validateParameter(valid_582228, JString, required = true,
                                 default = nil)
  if valid_582228 != nil:
    section.add "profileId", valid_582228
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Subaccount ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582229 = query.getOrDefault("key")
  valid_582229 = validateParameter(valid_582229, JString, required = false,
                                 default = nil)
  if valid_582229 != nil:
    section.add "key", valid_582229
  var valid_582230 = query.getOrDefault("prettyPrint")
  valid_582230 = validateParameter(valid_582230, JBool, required = false,
                                 default = newJBool(true))
  if valid_582230 != nil:
    section.add "prettyPrint", valid_582230
  var valid_582231 = query.getOrDefault("oauth_token")
  valid_582231 = validateParameter(valid_582231, JString, required = false,
                                 default = nil)
  if valid_582231 != nil:
    section.add "oauth_token", valid_582231
  var valid_582232 = query.getOrDefault("alt")
  valid_582232 = validateParameter(valid_582232, JString, required = false,
                                 default = newJString("json"))
  if valid_582232 != nil:
    section.add "alt", valid_582232
  var valid_582233 = query.getOrDefault("userIp")
  valid_582233 = validateParameter(valid_582233, JString, required = false,
                                 default = nil)
  if valid_582233 != nil:
    section.add "userIp", valid_582233
  var valid_582234 = query.getOrDefault("quotaUser")
  valid_582234 = validateParameter(valid_582234, JString, required = false,
                                 default = nil)
  if valid_582234 != nil:
    section.add "quotaUser", valid_582234
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_582235 = query.getOrDefault("id")
  valid_582235 = validateParameter(valid_582235, JString, required = true,
                                 default = nil)
  if valid_582235 != nil:
    section.add "id", valid_582235
  var valid_582236 = query.getOrDefault("fields")
  valid_582236 = validateParameter(valid_582236, JString, required = false,
                                 default = nil)
  if valid_582236 != nil:
    section.add "fields", valid_582236
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582238: Call_DfareportingSubaccountsPatch_582225; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing subaccount. This method supports patch semantics.
  ## 
  let valid = call_582238.validator(path, query, header, formData, body)
  let scheme = call_582238.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582238.url(scheme.get, call_582238.host, call_582238.base,
                         call_582238.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582238, url, valid)

proc call*(call_582239: Call_DfareportingSubaccountsPatch_582225;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingSubaccountsPatch
  ## Updates an existing subaccount. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Subaccount ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582240 = newJObject()
  var query_582241 = newJObject()
  var body_582242 = newJObject()
  add(query_582241, "key", newJString(key))
  add(query_582241, "prettyPrint", newJBool(prettyPrint))
  add(query_582241, "oauth_token", newJString(oauthToken))
  add(path_582240, "profileId", newJString(profileId))
  add(query_582241, "alt", newJString(alt))
  add(query_582241, "userIp", newJString(userIp))
  add(query_582241, "quotaUser", newJString(quotaUser))
  add(query_582241, "id", newJString(id))
  if body != nil:
    body_582242 = body
  add(query_582241, "fields", newJString(fields))
  result = call_582239.call(path_582240, query_582241, nil, nil, body_582242)

var dfareportingSubaccountsPatch* = Call_DfareportingSubaccountsPatch_582225(
    name: "dfareportingSubaccountsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsPatch_582226,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsPatch_582227,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsGet_582243 = ref object of OpenApiRestCall_578364
proc url_DfareportingSubaccountsGet_582245(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsGet_582244(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one subaccount by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Subaccount ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582246 = path.getOrDefault("profileId")
  valid_582246 = validateParameter(valid_582246, JString, required = true,
                                 default = nil)
  if valid_582246 != nil:
    section.add "profileId", valid_582246
  var valid_582247 = path.getOrDefault("id")
  valid_582247 = validateParameter(valid_582247, JString, required = true,
                                 default = nil)
  if valid_582247 != nil:
    section.add "id", valid_582247
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582248 = query.getOrDefault("key")
  valid_582248 = validateParameter(valid_582248, JString, required = false,
                                 default = nil)
  if valid_582248 != nil:
    section.add "key", valid_582248
  var valid_582249 = query.getOrDefault("prettyPrint")
  valid_582249 = validateParameter(valid_582249, JBool, required = false,
                                 default = newJBool(true))
  if valid_582249 != nil:
    section.add "prettyPrint", valid_582249
  var valid_582250 = query.getOrDefault("oauth_token")
  valid_582250 = validateParameter(valid_582250, JString, required = false,
                                 default = nil)
  if valid_582250 != nil:
    section.add "oauth_token", valid_582250
  var valid_582251 = query.getOrDefault("alt")
  valid_582251 = validateParameter(valid_582251, JString, required = false,
                                 default = newJString("json"))
  if valid_582251 != nil:
    section.add "alt", valid_582251
  var valid_582252 = query.getOrDefault("userIp")
  valid_582252 = validateParameter(valid_582252, JString, required = false,
                                 default = nil)
  if valid_582252 != nil:
    section.add "userIp", valid_582252
  var valid_582253 = query.getOrDefault("quotaUser")
  valid_582253 = validateParameter(valid_582253, JString, required = false,
                                 default = nil)
  if valid_582253 != nil:
    section.add "quotaUser", valid_582253
  var valid_582254 = query.getOrDefault("fields")
  valid_582254 = validateParameter(valid_582254, JString, required = false,
                                 default = nil)
  if valid_582254 != nil:
    section.add "fields", valid_582254
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582255: Call_DfareportingSubaccountsGet_582243; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one subaccount by ID.
  ## 
  let valid = call_582255.validator(path, query, header, formData, body)
  let scheme = call_582255.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582255.url(scheme.get, call_582255.host, call_582255.base,
                         call_582255.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582255, url, valid)

proc call*(call_582256: Call_DfareportingSubaccountsGet_582243; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingSubaccountsGet
  ## Gets one subaccount by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Subaccount ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582257 = newJObject()
  var query_582258 = newJObject()
  add(query_582258, "key", newJString(key))
  add(query_582258, "prettyPrint", newJBool(prettyPrint))
  add(query_582258, "oauth_token", newJString(oauthToken))
  add(path_582257, "profileId", newJString(profileId))
  add(path_582257, "id", newJString(id))
  add(query_582258, "alt", newJString(alt))
  add(query_582258, "userIp", newJString(userIp))
  add(query_582258, "quotaUser", newJString(quotaUser))
  add(query_582258, "fields", newJString(fields))
  result = call_582256.call(path_582257, query_582258, nil, nil, nil)

var dfareportingSubaccountsGet* = Call_DfareportingSubaccountsGet_582243(
    name: "dfareportingSubaccountsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/subaccounts/{id}",
    validator: validate_DfareportingSubaccountsGet_582244,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsGet_582245,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetableRemarketingListsList_582259 = ref object of OpenApiRestCall_578364
proc url_DfareportingTargetableRemarketingListsList_582261(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetableRemarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetableRemarketingListsList_582260(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of targetable remarketing lists, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582262 = path.getOrDefault("profileId")
  valid_582262 = validateParameter(valid_582262, JString, required = true,
                                 default = nil)
  if valid_582262 != nil:
    section.add "profileId", valid_582262
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   name: JString
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   active: JBool
  ##         : Select only active or only inactive targetable remarketing lists.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   advertiserId: JString (required)
  ##               : Select only targetable remarketing lists targetable by these advertisers.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_582263 = query.getOrDefault("key")
  valid_582263 = validateParameter(valid_582263, JString, required = false,
                                 default = nil)
  if valid_582263 != nil:
    section.add "key", valid_582263
  var valid_582264 = query.getOrDefault("prettyPrint")
  valid_582264 = validateParameter(valid_582264, JBool, required = false,
                                 default = newJBool(true))
  if valid_582264 != nil:
    section.add "prettyPrint", valid_582264
  var valid_582265 = query.getOrDefault("oauth_token")
  valid_582265 = validateParameter(valid_582265, JString, required = false,
                                 default = nil)
  if valid_582265 != nil:
    section.add "oauth_token", valid_582265
  var valid_582266 = query.getOrDefault("name")
  valid_582266 = validateParameter(valid_582266, JString, required = false,
                                 default = nil)
  if valid_582266 != nil:
    section.add "name", valid_582266
  var valid_582267 = query.getOrDefault("active")
  valid_582267 = validateParameter(valid_582267, JBool, required = false, default = nil)
  if valid_582267 != nil:
    section.add "active", valid_582267
  var valid_582268 = query.getOrDefault("sortField")
  valid_582268 = validateParameter(valid_582268, JString, required = false,
                                 default = newJString("ID"))
  if valid_582268 != nil:
    section.add "sortField", valid_582268
  var valid_582269 = query.getOrDefault("alt")
  valid_582269 = validateParameter(valid_582269, JString, required = false,
                                 default = newJString("json"))
  if valid_582269 != nil:
    section.add "alt", valid_582269
  var valid_582270 = query.getOrDefault("userIp")
  valid_582270 = validateParameter(valid_582270, JString, required = false,
                                 default = nil)
  if valid_582270 != nil:
    section.add "userIp", valid_582270
  var valid_582271 = query.getOrDefault("quotaUser")
  valid_582271 = validateParameter(valid_582271, JString, required = false,
                                 default = nil)
  if valid_582271 != nil:
    section.add "quotaUser", valid_582271
  var valid_582272 = query.getOrDefault("pageToken")
  valid_582272 = validateParameter(valid_582272, JString, required = false,
                                 default = nil)
  if valid_582272 != nil:
    section.add "pageToken", valid_582272
  var valid_582273 = query.getOrDefault("sortOrder")
  valid_582273 = validateParameter(valid_582273, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_582273 != nil:
    section.add "sortOrder", valid_582273
  assert query != nil,
        "query argument is necessary due to required `advertiserId` field"
  var valid_582274 = query.getOrDefault("advertiserId")
  valid_582274 = validateParameter(valid_582274, JString, required = true,
                                 default = nil)
  if valid_582274 != nil:
    section.add "advertiserId", valid_582274
  var valid_582275 = query.getOrDefault("fields")
  valid_582275 = validateParameter(valid_582275, JString, required = false,
                                 default = nil)
  if valid_582275 != nil:
    section.add "fields", valid_582275
  var valid_582276 = query.getOrDefault("maxResults")
  valid_582276 = validateParameter(valid_582276, JInt, required = false,
                                 default = newJInt(1000))
  if valid_582276 != nil:
    section.add "maxResults", valid_582276
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582277: Call_DfareportingTargetableRemarketingListsList_582259;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of targetable remarketing lists, possibly filtered. This method supports paging.
  ## 
  let valid = call_582277.validator(path, query, header, formData, body)
  let scheme = call_582277.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582277.url(scheme.get, call_582277.host, call_582277.base,
                         call_582277.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582277, url, valid)

proc call*(call_582278: Call_DfareportingTargetableRemarketingListsList_582259;
          profileId: string; advertiserId: string; key: string = "";
          prettyPrint: bool = true; oauthToken: string = ""; name: string = "";
          active: bool = false; sortField: string = "ID"; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; pageToken: string = "";
          sortOrder: string = "ASCENDING"; fields: string = ""; maxResults: int = 1000): Recallable =
  ## dfareportingTargetableRemarketingListsList
  ## Retrieves a list of targetable remarketing lists, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   name: string
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   active: bool
  ##         : Select only active or only inactive targetable remarketing lists.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   advertiserId: string (required)
  ##               : Select only targetable remarketing lists targetable by these advertisers.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_582279 = newJObject()
  var query_582280 = newJObject()
  add(query_582280, "key", newJString(key))
  add(query_582280, "prettyPrint", newJBool(prettyPrint))
  add(query_582280, "oauth_token", newJString(oauthToken))
  add(query_582280, "name", newJString(name))
  add(query_582280, "active", newJBool(active))
  add(path_582279, "profileId", newJString(profileId))
  add(query_582280, "sortField", newJString(sortField))
  add(query_582280, "alt", newJString(alt))
  add(query_582280, "userIp", newJString(userIp))
  add(query_582280, "quotaUser", newJString(quotaUser))
  add(query_582280, "pageToken", newJString(pageToken))
  add(query_582280, "sortOrder", newJString(sortOrder))
  add(query_582280, "advertiserId", newJString(advertiserId))
  add(query_582280, "fields", newJString(fields))
  add(query_582280, "maxResults", newJInt(maxResults))
  result = call_582278.call(path_582279, query_582280, nil, nil, nil)

var dfareportingTargetableRemarketingListsList* = Call_DfareportingTargetableRemarketingListsList_582259(
    name: "dfareportingTargetableRemarketingListsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetableRemarketingLists",
    validator: validate_DfareportingTargetableRemarketingListsList_582260,
    base: "/dfareporting/v2.7",
    url: url_DfareportingTargetableRemarketingListsList_582261,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetableRemarketingListsGet_582281 = ref object of OpenApiRestCall_578364
proc url_DfareportingTargetableRemarketingListsGet_582283(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetableRemarketingLists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetableRemarketingListsGet_582282(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one remarketing list by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Remarketing list ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582284 = path.getOrDefault("profileId")
  valid_582284 = validateParameter(valid_582284, JString, required = true,
                                 default = nil)
  if valid_582284 != nil:
    section.add "profileId", valid_582284
  var valid_582285 = path.getOrDefault("id")
  valid_582285 = validateParameter(valid_582285, JString, required = true,
                                 default = nil)
  if valid_582285 != nil:
    section.add "id", valid_582285
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582286 = query.getOrDefault("key")
  valid_582286 = validateParameter(valid_582286, JString, required = false,
                                 default = nil)
  if valid_582286 != nil:
    section.add "key", valid_582286
  var valid_582287 = query.getOrDefault("prettyPrint")
  valid_582287 = validateParameter(valid_582287, JBool, required = false,
                                 default = newJBool(true))
  if valid_582287 != nil:
    section.add "prettyPrint", valid_582287
  var valid_582288 = query.getOrDefault("oauth_token")
  valid_582288 = validateParameter(valid_582288, JString, required = false,
                                 default = nil)
  if valid_582288 != nil:
    section.add "oauth_token", valid_582288
  var valid_582289 = query.getOrDefault("alt")
  valid_582289 = validateParameter(valid_582289, JString, required = false,
                                 default = newJString("json"))
  if valid_582289 != nil:
    section.add "alt", valid_582289
  var valid_582290 = query.getOrDefault("userIp")
  valid_582290 = validateParameter(valid_582290, JString, required = false,
                                 default = nil)
  if valid_582290 != nil:
    section.add "userIp", valid_582290
  var valid_582291 = query.getOrDefault("quotaUser")
  valid_582291 = validateParameter(valid_582291, JString, required = false,
                                 default = nil)
  if valid_582291 != nil:
    section.add "quotaUser", valid_582291
  var valid_582292 = query.getOrDefault("fields")
  valid_582292 = validateParameter(valid_582292, JString, required = false,
                                 default = nil)
  if valid_582292 != nil:
    section.add "fields", valid_582292
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582293: Call_DfareportingTargetableRemarketingListsGet_582281;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one remarketing list by ID.
  ## 
  let valid = call_582293.validator(path, query, header, formData, body)
  let scheme = call_582293.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582293.url(scheme.get, call_582293.host, call_582293.base,
                         call_582293.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582293, url, valid)

proc call*(call_582294: Call_DfareportingTargetableRemarketingListsGet_582281;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingTargetableRemarketingListsGet
  ## Gets one remarketing list by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Remarketing list ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582295 = newJObject()
  var query_582296 = newJObject()
  add(query_582296, "key", newJString(key))
  add(query_582296, "prettyPrint", newJBool(prettyPrint))
  add(query_582296, "oauth_token", newJString(oauthToken))
  add(path_582295, "profileId", newJString(profileId))
  add(path_582295, "id", newJString(id))
  add(query_582296, "alt", newJString(alt))
  add(query_582296, "userIp", newJString(userIp))
  add(query_582296, "quotaUser", newJString(quotaUser))
  add(query_582296, "fields", newJString(fields))
  result = call_582294.call(path_582295, query_582296, nil, nil, nil)

var dfareportingTargetableRemarketingListsGet* = Call_DfareportingTargetableRemarketingListsGet_582281(
    name: "dfareportingTargetableRemarketingListsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetableRemarketingLists/{id}",
    validator: validate_DfareportingTargetableRemarketingListsGet_582282,
    base: "/dfareporting/v2.7",
    url: url_DfareportingTargetableRemarketingListsGet_582283,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesUpdate_582319 = ref object of OpenApiRestCall_578364
proc url_DfareportingTargetingTemplatesUpdate_582321(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesUpdate_582320(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing targeting template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582322 = path.getOrDefault("profileId")
  valid_582322 = validateParameter(valid_582322, JString, required = true,
                                 default = nil)
  if valid_582322 != nil:
    section.add "profileId", valid_582322
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582323 = query.getOrDefault("key")
  valid_582323 = validateParameter(valid_582323, JString, required = false,
                                 default = nil)
  if valid_582323 != nil:
    section.add "key", valid_582323
  var valid_582324 = query.getOrDefault("prettyPrint")
  valid_582324 = validateParameter(valid_582324, JBool, required = false,
                                 default = newJBool(true))
  if valid_582324 != nil:
    section.add "prettyPrint", valid_582324
  var valid_582325 = query.getOrDefault("oauth_token")
  valid_582325 = validateParameter(valid_582325, JString, required = false,
                                 default = nil)
  if valid_582325 != nil:
    section.add "oauth_token", valid_582325
  var valid_582326 = query.getOrDefault("alt")
  valid_582326 = validateParameter(valid_582326, JString, required = false,
                                 default = newJString("json"))
  if valid_582326 != nil:
    section.add "alt", valid_582326
  var valid_582327 = query.getOrDefault("userIp")
  valid_582327 = validateParameter(valid_582327, JString, required = false,
                                 default = nil)
  if valid_582327 != nil:
    section.add "userIp", valid_582327
  var valid_582328 = query.getOrDefault("quotaUser")
  valid_582328 = validateParameter(valid_582328, JString, required = false,
                                 default = nil)
  if valid_582328 != nil:
    section.add "quotaUser", valid_582328
  var valid_582329 = query.getOrDefault("fields")
  valid_582329 = validateParameter(valid_582329, JString, required = false,
                                 default = nil)
  if valid_582329 != nil:
    section.add "fields", valid_582329
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582331: Call_DfareportingTargetingTemplatesUpdate_582319;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing targeting template.
  ## 
  let valid = call_582331.validator(path, query, header, formData, body)
  let scheme = call_582331.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582331.url(scheme.get, call_582331.host, call_582331.base,
                         call_582331.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582331, url, valid)

proc call*(call_582332: Call_DfareportingTargetingTemplatesUpdate_582319;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingTargetingTemplatesUpdate
  ## Updates an existing targeting template.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582333 = newJObject()
  var query_582334 = newJObject()
  var body_582335 = newJObject()
  add(query_582334, "key", newJString(key))
  add(query_582334, "prettyPrint", newJBool(prettyPrint))
  add(query_582334, "oauth_token", newJString(oauthToken))
  add(path_582333, "profileId", newJString(profileId))
  add(query_582334, "alt", newJString(alt))
  add(query_582334, "userIp", newJString(userIp))
  add(query_582334, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_582335 = body
  add(query_582334, "fields", newJString(fields))
  result = call_582332.call(path_582333, query_582334, nil, nil, body_582335)

var dfareportingTargetingTemplatesUpdate* = Call_DfareportingTargetingTemplatesUpdate_582319(
    name: "dfareportingTargetingTemplatesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesUpdate_582320,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesUpdate_582321,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesInsert_582336 = ref object of OpenApiRestCall_578364
proc url_DfareportingTargetingTemplatesInsert_582338(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesInsert_582337(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new targeting template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582339 = path.getOrDefault("profileId")
  valid_582339 = validateParameter(valid_582339, JString, required = true,
                                 default = nil)
  if valid_582339 != nil:
    section.add "profileId", valid_582339
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582340 = query.getOrDefault("key")
  valid_582340 = validateParameter(valid_582340, JString, required = false,
                                 default = nil)
  if valid_582340 != nil:
    section.add "key", valid_582340
  var valid_582341 = query.getOrDefault("prettyPrint")
  valid_582341 = validateParameter(valid_582341, JBool, required = false,
                                 default = newJBool(true))
  if valid_582341 != nil:
    section.add "prettyPrint", valid_582341
  var valid_582342 = query.getOrDefault("oauth_token")
  valid_582342 = validateParameter(valid_582342, JString, required = false,
                                 default = nil)
  if valid_582342 != nil:
    section.add "oauth_token", valid_582342
  var valid_582343 = query.getOrDefault("alt")
  valid_582343 = validateParameter(valid_582343, JString, required = false,
                                 default = newJString("json"))
  if valid_582343 != nil:
    section.add "alt", valid_582343
  var valid_582344 = query.getOrDefault("userIp")
  valid_582344 = validateParameter(valid_582344, JString, required = false,
                                 default = nil)
  if valid_582344 != nil:
    section.add "userIp", valid_582344
  var valid_582345 = query.getOrDefault("quotaUser")
  valid_582345 = validateParameter(valid_582345, JString, required = false,
                                 default = nil)
  if valid_582345 != nil:
    section.add "quotaUser", valid_582345
  var valid_582346 = query.getOrDefault("fields")
  valid_582346 = validateParameter(valid_582346, JString, required = false,
                                 default = nil)
  if valid_582346 != nil:
    section.add "fields", valid_582346
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582348: Call_DfareportingTargetingTemplatesInsert_582336;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new targeting template.
  ## 
  let valid = call_582348.validator(path, query, header, formData, body)
  let scheme = call_582348.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582348.url(scheme.get, call_582348.host, call_582348.base,
                         call_582348.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582348, url, valid)

proc call*(call_582349: Call_DfareportingTargetingTemplatesInsert_582336;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingTargetingTemplatesInsert
  ## Inserts a new targeting template.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582350 = newJObject()
  var query_582351 = newJObject()
  var body_582352 = newJObject()
  add(query_582351, "key", newJString(key))
  add(query_582351, "prettyPrint", newJBool(prettyPrint))
  add(query_582351, "oauth_token", newJString(oauthToken))
  add(path_582350, "profileId", newJString(profileId))
  add(query_582351, "alt", newJString(alt))
  add(query_582351, "userIp", newJString(userIp))
  add(query_582351, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_582352 = body
  add(query_582351, "fields", newJString(fields))
  result = call_582349.call(path_582350, query_582351, nil, nil, body_582352)

var dfareportingTargetingTemplatesInsert* = Call_DfareportingTargetingTemplatesInsert_582336(
    name: "dfareportingTargetingTemplatesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesInsert_582337,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesInsert_582338,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesList_582297 = ref object of OpenApiRestCall_578364
proc url_DfareportingTargetingTemplatesList_582299(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesList_582298(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of targeting templates, optionally filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582300 = path.getOrDefault("profileId")
  valid_582300 = validateParameter(valid_582300, JString, required = true,
                                 default = nil)
  if valid_582300 != nil:
    section.add "profileId", valid_582300
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "template*2015" will return objects with names like "template June 2015", "template April 2015", or simply "template 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "template" will match objects with name "my template", "template 2015", or simply "template".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   advertiserId: JString
  ##               : Select only targeting templates with this advertiser ID.
  ##   ids: JArray
  ##      : Select only targeting templates with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_582301 = query.getOrDefault("key")
  valid_582301 = validateParameter(valid_582301, JString, required = false,
                                 default = nil)
  if valid_582301 != nil:
    section.add "key", valid_582301
  var valid_582302 = query.getOrDefault("prettyPrint")
  valid_582302 = validateParameter(valid_582302, JBool, required = false,
                                 default = newJBool(true))
  if valid_582302 != nil:
    section.add "prettyPrint", valid_582302
  var valid_582303 = query.getOrDefault("oauth_token")
  valid_582303 = validateParameter(valid_582303, JString, required = false,
                                 default = nil)
  if valid_582303 != nil:
    section.add "oauth_token", valid_582303
  var valid_582304 = query.getOrDefault("sortField")
  valid_582304 = validateParameter(valid_582304, JString, required = false,
                                 default = newJString("ID"))
  if valid_582304 != nil:
    section.add "sortField", valid_582304
  var valid_582305 = query.getOrDefault("alt")
  valid_582305 = validateParameter(valid_582305, JString, required = false,
                                 default = newJString("json"))
  if valid_582305 != nil:
    section.add "alt", valid_582305
  var valid_582306 = query.getOrDefault("userIp")
  valid_582306 = validateParameter(valid_582306, JString, required = false,
                                 default = nil)
  if valid_582306 != nil:
    section.add "userIp", valid_582306
  var valid_582307 = query.getOrDefault("quotaUser")
  valid_582307 = validateParameter(valid_582307, JString, required = false,
                                 default = nil)
  if valid_582307 != nil:
    section.add "quotaUser", valid_582307
  var valid_582308 = query.getOrDefault("pageToken")
  valid_582308 = validateParameter(valid_582308, JString, required = false,
                                 default = nil)
  if valid_582308 != nil:
    section.add "pageToken", valid_582308
  var valid_582309 = query.getOrDefault("searchString")
  valid_582309 = validateParameter(valid_582309, JString, required = false,
                                 default = nil)
  if valid_582309 != nil:
    section.add "searchString", valid_582309
  var valid_582310 = query.getOrDefault("sortOrder")
  valid_582310 = validateParameter(valid_582310, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_582310 != nil:
    section.add "sortOrder", valid_582310
  var valid_582311 = query.getOrDefault("advertiserId")
  valid_582311 = validateParameter(valid_582311, JString, required = false,
                                 default = nil)
  if valid_582311 != nil:
    section.add "advertiserId", valid_582311
  var valid_582312 = query.getOrDefault("ids")
  valid_582312 = validateParameter(valid_582312, JArray, required = false,
                                 default = nil)
  if valid_582312 != nil:
    section.add "ids", valid_582312
  var valid_582313 = query.getOrDefault("fields")
  valid_582313 = validateParameter(valid_582313, JString, required = false,
                                 default = nil)
  if valid_582313 != nil:
    section.add "fields", valid_582313
  var valid_582314 = query.getOrDefault("maxResults")
  valid_582314 = validateParameter(valid_582314, JInt, required = false,
                                 default = newJInt(1000))
  if valid_582314 != nil:
    section.add "maxResults", valid_582314
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582315: Call_DfareportingTargetingTemplatesList_582297;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of targeting templates, optionally filtered. This method supports paging.
  ## 
  let valid = call_582315.validator(path, query, header, formData, body)
  let scheme = call_582315.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582315.url(scheme.get, call_582315.host, call_582315.base,
                         call_582315.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582315, url, valid)

proc call*(call_582316: Call_DfareportingTargetingTemplatesList_582297;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; sortField: string = "ID"; alt: string = "json";
          userIp: string = ""; quotaUser: string = ""; pageToken: string = "";
          searchString: string = ""; sortOrder: string = "ASCENDING";
          advertiserId: string = ""; ids: JsonNode = nil; fields: string = "";
          maxResults: int = 1000): Recallable =
  ## dfareportingTargetingTemplatesList
  ## Retrieves a list of targeting templates, optionally filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "template*2015" will return objects with names like "template June 2015", "template April 2015", or simply "template 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "template" will match objects with name "my template", "template 2015", or simply "template".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   advertiserId: string
  ##               : Select only targeting templates with this advertiser ID.
  ##   ids: JArray
  ##      : Select only targeting templates with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_582317 = newJObject()
  var query_582318 = newJObject()
  add(query_582318, "key", newJString(key))
  add(query_582318, "prettyPrint", newJBool(prettyPrint))
  add(query_582318, "oauth_token", newJString(oauthToken))
  add(path_582317, "profileId", newJString(profileId))
  add(query_582318, "sortField", newJString(sortField))
  add(query_582318, "alt", newJString(alt))
  add(query_582318, "userIp", newJString(userIp))
  add(query_582318, "quotaUser", newJString(quotaUser))
  add(query_582318, "pageToken", newJString(pageToken))
  add(query_582318, "searchString", newJString(searchString))
  add(query_582318, "sortOrder", newJString(sortOrder))
  add(query_582318, "advertiserId", newJString(advertiserId))
  if ids != nil:
    query_582318.add "ids", ids
  add(query_582318, "fields", newJString(fields))
  add(query_582318, "maxResults", newJInt(maxResults))
  result = call_582316.call(path_582317, query_582318, nil, nil, nil)

var dfareportingTargetingTemplatesList* = Call_DfareportingTargetingTemplatesList_582297(
    name: "dfareportingTargetingTemplatesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesList_582298,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesList_582299,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesPatch_582353 = ref object of OpenApiRestCall_578364
proc url_DfareportingTargetingTemplatesPatch_582355(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesPatch_582354(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing targeting template. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582356 = path.getOrDefault("profileId")
  valid_582356 = validateParameter(valid_582356, JString, required = true,
                                 default = nil)
  if valid_582356 != nil:
    section.add "profileId", valid_582356
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Targeting template ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582357 = query.getOrDefault("key")
  valid_582357 = validateParameter(valid_582357, JString, required = false,
                                 default = nil)
  if valid_582357 != nil:
    section.add "key", valid_582357
  var valid_582358 = query.getOrDefault("prettyPrint")
  valid_582358 = validateParameter(valid_582358, JBool, required = false,
                                 default = newJBool(true))
  if valid_582358 != nil:
    section.add "prettyPrint", valid_582358
  var valid_582359 = query.getOrDefault("oauth_token")
  valid_582359 = validateParameter(valid_582359, JString, required = false,
                                 default = nil)
  if valid_582359 != nil:
    section.add "oauth_token", valid_582359
  var valid_582360 = query.getOrDefault("alt")
  valid_582360 = validateParameter(valid_582360, JString, required = false,
                                 default = newJString("json"))
  if valid_582360 != nil:
    section.add "alt", valid_582360
  var valid_582361 = query.getOrDefault("userIp")
  valid_582361 = validateParameter(valid_582361, JString, required = false,
                                 default = nil)
  if valid_582361 != nil:
    section.add "userIp", valid_582361
  var valid_582362 = query.getOrDefault("quotaUser")
  valid_582362 = validateParameter(valid_582362, JString, required = false,
                                 default = nil)
  if valid_582362 != nil:
    section.add "quotaUser", valid_582362
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_582363 = query.getOrDefault("id")
  valid_582363 = validateParameter(valid_582363, JString, required = true,
                                 default = nil)
  if valid_582363 != nil:
    section.add "id", valid_582363
  var valid_582364 = query.getOrDefault("fields")
  valid_582364 = validateParameter(valid_582364, JString, required = false,
                                 default = nil)
  if valid_582364 != nil:
    section.add "fields", valid_582364
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582366: Call_DfareportingTargetingTemplatesPatch_582353;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing targeting template. This method supports patch semantics.
  ## 
  let valid = call_582366.validator(path, query, header, formData, body)
  let scheme = call_582366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582366.url(scheme.get, call_582366.host, call_582366.base,
                         call_582366.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582366, url, valid)

proc call*(call_582367: Call_DfareportingTargetingTemplatesPatch_582353;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingTargetingTemplatesPatch
  ## Updates an existing targeting template. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Targeting template ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582368 = newJObject()
  var query_582369 = newJObject()
  var body_582370 = newJObject()
  add(query_582369, "key", newJString(key))
  add(query_582369, "prettyPrint", newJBool(prettyPrint))
  add(query_582369, "oauth_token", newJString(oauthToken))
  add(path_582368, "profileId", newJString(profileId))
  add(query_582369, "alt", newJString(alt))
  add(query_582369, "userIp", newJString(userIp))
  add(query_582369, "quotaUser", newJString(quotaUser))
  add(query_582369, "id", newJString(id))
  if body != nil:
    body_582370 = body
  add(query_582369, "fields", newJString(fields))
  result = call_582367.call(path_582368, query_582369, nil, nil, body_582370)

var dfareportingTargetingTemplatesPatch* = Call_DfareportingTargetingTemplatesPatch_582353(
    name: "dfareportingTargetingTemplatesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesPatch_582354,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesPatch_582355,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesGet_582371 = ref object of OpenApiRestCall_578364
proc url_DfareportingTargetingTemplatesGet_582373(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesGet_582372(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one targeting template by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Targeting template ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582374 = path.getOrDefault("profileId")
  valid_582374 = validateParameter(valid_582374, JString, required = true,
                                 default = nil)
  if valid_582374 != nil:
    section.add "profileId", valid_582374
  var valid_582375 = path.getOrDefault("id")
  valid_582375 = validateParameter(valid_582375, JString, required = true,
                                 default = nil)
  if valid_582375 != nil:
    section.add "id", valid_582375
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582376 = query.getOrDefault("key")
  valid_582376 = validateParameter(valid_582376, JString, required = false,
                                 default = nil)
  if valid_582376 != nil:
    section.add "key", valid_582376
  var valid_582377 = query.getOrDefault("prettyPrint")
  valid_582377 = validateParameter(valid_582377, JBool, required = false,
                                 default = newJBool(true))
  if valid_582377 != nil:
    section.add "prettyPrint", valid_582377
  var valid_582378 = query.getOrDefault("oauth_token")
  valid_582378 = validateParameter(valid_582378, JString, required = false,
                                 default = nil)
  if valid_582378 != nil:
    section.add "oauth_token", valid_582378
  var valid_582379 = query.getOrDefault("alt")
  valid_582379 = validateParameter(valid_582379, JString, required = false,
                                 default = newJString("json"))
  if valid_582379 != nil:
    section.add "alt", valid_582379
  var valid_582380 = query.getOrDefault("userIp")
  valid_582380 = validateParameter(valid_582380, JString, required = false,
                                 default = nil)
  if valid_582380 != nil:
    section.add "userIp", valid_582380
  var valid_582381 = query.getOrDefault("quotaUser")
  valid_582381 = validateParameter(valid_582381, JString, required = false,
                                 default = nil)
  if valid_582381 != nil:
    section.add "quotaUser", valid_582381
  var valid_582382 = query.getOrDefault("fields")
  valid_582382 = validateParameter(valid_582382, JString, required = false,
                                 default = nil)
  if valid_582382 != nil:
    section.add "fields", valid_582382
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582383: Call_DfareportingTargetingTemplatesGet_582371;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one targeting template by ID.
  ## 
  let valid = call_582383.validator(path, query, header, formData, body)
  let scheme = call_582383.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582383.url(scheme.get, call_582383.host, call_582383.base,
                         call_582383.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582383, url, valid)

proc call*(call_582384: Call_DfareportingTargetingTemplatesGet_582371;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingTargetingTemplatesGet
  ## Gets one targeting template by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : Targeting template ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582385 = newJObject()
  var query_582386 = newJObject()
  add(query_582386, "key", newJString(key))
  add(query_582386, "prettyPrint", newJBool(prettyPrint))
  add(query_582386, "oauth_token", newJString(oauthToken))
  add(path_582385, "profileId", newJString(profileId))
  add(path_582385, "id", newJString(id))
  add(query_582386, "alt", newJString(alt))
  add(query_582386, "userIp", newJString(userIp))
  add(query_582386, "quotaUser", newJString(quotaUser))
  add(query_582386, "fields", newJString(fields))
  result = call_582384.call(path_582385, query_582386, nil, nil, nil)

var dfareportingTargetingTemplatesGet* = Call_DfareportingTargetingTemplatesGet_582371(
    name: "dfareportingTargetingTemplatesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates/{id}",
    validator: validate_DfareportingTargetingTemplatesGet_582372,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesGet_582373,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionGroupsList_582387 = ref object of OpenApiRestCall_578364
proc url_DfareportingUserRolePermissionGroupsList_582389(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissionGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionGroupsList_582388(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of all supported user role permission groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582390 = path.getOrDefault("profileId")
  valid_582390 = validateParameter(valid_582390, JString, required = true,
                                 default = nil)
  if valid_582390 != nil:
    section.add "profileId", valid_582390
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582391 = query.getOrDefault("key")
  valid_582391 = validateParameter(valid_582391, JString, required = false,
                                 default = nil)
  if valid_582391 != nil:
    section.add "key", valid_582391
  var valid_582392 = query.getOrDefault("prettyPrint")
  valid_582392 = validateParameter(valid_582392, JBool, required = false,
                                 default = newJBool(true))
  if valid_582392 != nil:
    section.add "prettyPrint", valid_582392
  var valid_582393 = query.getOrDefault("oauth_token")
  valid_582393 = validateParameter(valid_582393, JString, required = false,
                                 default = nil)
  if valid_582393 != nil:
    section.add "oauth_token", valid_582393
  var valid_582394 = query.getOrDefault("alt")
  valid_582394 = validateParameter(valid_582394, JString, required = false,
                                 default = newJString("json"))
  if valid_582394 != nil:
    section.add "alt", valid_582394
  var valid_582395 = query.getOrDefault("userIp")
  valid_582395 = validateParameter(valid_582395, JString, required = false,
                                 default = nil)
  if valid_582395 != nil:
    section.add "userIp", valid_582395
  var valid_582396 = query.getOrDefault("quotaUser")
  valid_582396 = validateParameter(valid_582396, JString, required = false,
                                 default = nil)
  if valid_582396 != nil:
    section.add "quotaUser", valid_582396
  var valid_582397 = query.getOrDefault("fields")
  valid_582397 = validateParameter(valid_582397, JString, required = false,
                                 default = nil)
  if valid_582397 != nil:
    section.add "fields", valid_582397
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582398: Call_DfareportingUserRolePermissionGroupsList_582387;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of all supported user role permission groups.
  ## 
  let valid = call_582398.validator(path, query, header, formData, body)
  let scheme = call_582398.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582398.url(scheme.get, call_582398.host, call_582398.base,
                         call_582398.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582398, url, valid)

proc call*(call_582399: Call_DfareportingUserRolePermissionGroupsList_582387;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingUserRolePermissionGroupsList
  ## Gets a list of all supported user role permission groups.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582400 = newJObject()
  var query_582401 = newJObject()
  add(query_582401, "key", newJString(key))
  add(query_582401, "prettyPrint", newJBool(prettyPrint))
  add(query_582401, "oauth_token", newJString(oauthToken))
  add(path_582400, "profileId", newJString(profileId))
  add(query_582401, "alt", newJString(alt))
  add(query_582401, "userIp", newJString(userIp))
  add(query_582401, "quotaUser", newJString(quotaUser))
  add(query_582401, "fields", newJString(fields))
  result = call_582399.call(path_582400, query_582401, nil, nil, nil)

var dfareportingUserRolePermissionGroupsList* = Call_DfareportingUserRolePermissionGroupsList_582387(
    name: "dfareportingUserRolePermissionGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissionGroups",
    validator: validate_DfareportingUserRolePermissionGroupsList_582388,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionGroupsList_582389,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionGroupsGet_582402 = ref object of OpenApiRestCall_578364
proc url_DfareportingUserRolePermissionGroupsGet_582404(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissionGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionGroupsGet_582403(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user role permission group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role permission group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582405 = path.getOrDefault("profileId")
  valid_582405 = validateParameter(valid_582405, JString, required = true,
                                 default = nil)
  if valid_582405 != nil:
    section.add "profileId", valid_582405
  var valid_582406 = path.getOrDefault("id")
  valid_582406 = validateParameter(valid_582406, JString, required = true,
                                 default = nil)
  if valid_582406 != nil:
    section.add "id", valid_582406
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582407 = query.getOrDefault("key")
  valid_582407 = validateParameter(valid_582407, JString, required = false,
                                 default = nil)
  if valid_582407 != nil:
    section.add "key", valid_582407
  var valid_582408 = query.getOrDefault("prettyPrint")
  valid_582408 = validateParameter(valid_582408, JBool, required = false,
                                 default = newJBool(true))
  if valid_582408 != nil:
    section.add "prettyPrint", valid_582408
  var valid_582409 = query.getOrDefault("oauth_token")
  valid_582409 = validateParameter(valid_582409, JString, required = false,
                                 default = nil)
  if valid_582409 != nil:
    section.add "oauth_token", valid_582409
  var valid_582410 = query.getOrDefault("alt")
  valid_582410 = validateParameter(valid_582410, JString, required = false,
                                 default = newJString("json"))
  if valid_582410 != nil:
    section.add "alt", valid_582410
  var valid_582411 = query.getOrDefault("userIp")
  valid_582411 = validateParameter(valid_582411, JString, required = false,
                                 default = nil)
  if valid_582411 != nil:
    section.add "userIp", valid_582411
  var valid_582412 = query.getOrDefault("quotaUser")
  valid_582412 = validateParameter(valid_582412, JString, required = false,
                                 default = nil)
  if valid_582412 != nil:
    section.add "quotaUser", valid_582412
  var valid_582413 = query.getOrDefault("fields")
  valid_582413 = validateParameter(valid_582413, JString, required = false,
                                 default = nil)
  if valid_582413 != nil:
    section.add "fields", valid_582413
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582414: Call_DfareportingUserRolePermissionGroupsGet_582402;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one user role permission group by ID.
  ## 
  let valid = call_582414.validator(path, query, header, formData, body)
  let scheme = call_582414.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582414.url(scheme.get, call_582414.host, call_582414.base,
                         call_582414.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582414, url, valid)

proc call*(call_582415: Call_DfareportingUserRolePermissionGroupsGet_582402;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingUserRolePermissionGroupsGet
  ## Gets one user role permission group by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : User role permission group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582416 = newJObject()
  var query_582417 = newJObject()
  add(query_582417, "key", newJString(key))
  add(query_582417, "prettyPrint", newJBool(prettyPrint))
  add(query_582417, "oauth_token", newJString(oauthToken))
  add(path_582416, "profileId", newJString(profileId))
  add(path_582416, "id", newJString(id))
  add(query_582417, "alt", newJString(alt))
  add(query_582417, "userIp", newJString(userIp))
  add(query_582417, "quotaUser", newJString(quotaUser))
  add(query_582417, "fields", newJString(fields))
  result = call_582415.call(path_582416, query_582417, nil, nil, nil)

var dfareportingUserRolePermissionGroupsGet* = Call_DfareportingUserRolePermissionGroupsGet_582402(
    name: "dfareportingUserRolePermissionGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissionGroups/{id}",
    validator: validate_DfareportingUserRolePermissionGroupsGet_582403,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionGroupsGet_582404,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionsList_582418 = ref object of OpenApiRestCall_578364
proc url_DfareportingUserRolePermissionsList_582420(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionsList_582419(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of user role permissions, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582421 = path.getOrDefault("profileId")
  valid_582421 = validateParameter(valid_582421, JString, required = true,
                                 default = nil)
  if valid_582421 != nil:
    section.add "profileId", valid_582421
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   ids: JArray
  ##      : Select only user role permissions with these IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582422 = query.getOrDefault("key")
  valid_582422 = validateParameter(valid_582422, JString, required = false,
                                 default = nil)
  if valid_582422 != nil:
    section.add "key", valid_582422
  var valid_582423 = query.getOrDefault("prettyPrint")
  valid_582423 = validateParameter(valid_582423, JBool, required = false,
                                 default = newJBool(true))
  if valid_582423 != nil:
    section.add "prettyPrint", valid_582423
  var valid_582424 = query.getOrDefault("oauth_token")
  valid_582424 = validateParameter(valid_582424, JString, required = false,
                                 default = nil)
  if valid_582424 != nil:
    section.add "oauth_token", valid_582424
  var valid_582425 = query.getOrDefault("alt")
  valid_582425 = validateParameter(valid_582425, JString, required = false,
                                 default = newJString("json"))
  if valid_582425 != nil:
    section.add "alt", valid_582425
  var valid_582426 = query.getOrDefault("userIp")
  valid_582426 = validateParameter(valid_582426, JString, required = false,
                                 default = nil)
  if valid_582426 != nil:
    section.add "userIp", valid_582426
  var valid_582427 = query.getOrDefault("quotaUser")
  valid_582427 = validateParameter(valid_582427, JString, required = false,
                                 default = nil)
  if valid_582427 != nil:
    section.add "quotaUser", valid_582427
  var valid_582428 = query.getOrDefault("ids")
  valid_582428 = validateParameter(valid_582428, JArray, required = false,
                                 default = nil)
  if valid_582428 != nil:
    section.add "ids", valid_582428
  var valid_582429 = query.getOrDefault("fields")
  valid_582429 = validateParameter(valid_582429, JString, required = false,
                                 default = nil)
  if valid_582429 != nil:
    section.add "fields", valid_582429
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582430: Call_DfareportingUserRolePermissionsList_582418;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of user role permissions, possibly filtered.
  ## 
  let valid = call_582430.validator(path, query, header, formData, body)
  let scheme = call_582430.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582430.url(scheme.get, call_582430.host, call_582430.base,
                         call_582430.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582430, url, valid)

proc call*(call_582431: Call_DfareportingUserRolePermissionsList_582418;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; ids: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingUserRolePermissionsList
  ## Gets a list of user role permissions, possibly filtered.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   ids: JArray
  ##      : Select only user role permissions with these IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582432 = newJObject()
  var query_582433 = newJObject()
  add(query_582433, "key", newJString(key))
  add(query_582433, "prettyPrint", newJBool(prettyPrint))
  add(query_582433, "oauth_token", newJString(oauthToken))
  add(path_582432, "profileId", newJString(profileId))
  add(query_582433, "alt", newJString(alt))
  add(query_582433, "userIp", newJString(userIp))
  add(query_582433, "quotaUser", newJString(quotaUser))
  if ids != nil:
    query_582433.add "ids", ids
  add(query_582433, "fields", newJString(fields))
  result = call_582431.call(path_582432, query_582433, nil, nil, nil)

var dfareportingUserRolePermissionsList* = Call_DfareportingUserRolePermissionsList_582418(
    name: "dfareportingUserRolePermissionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissions",
    validator: validate_DfareportingUserRolePermissionsList_582419,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionsList_582420,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionsGet_582434 = ref object of OpenApiRestCall_578364
proc url_DfareportingUserRolePermissionsGet_582436(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissions/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionsGet_582435(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user role permission by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role permission ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582437 = path.getOrDefault("profileId")
  valid_582437 = validateParameter(valid_582437, JString, required = true,
                                 default = nil)
  if valid_582437 != nil:
    section.add "profileId", valid_582437
  var valid_582438 = path.getOrDefault("id")
  valid_582438 = validateParameter(valid_582438, JString, required = true,
                                 default = nil)
  if valid_582438 != nil:
    section.add "id", valid_582438
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582439 = query.getOrDefault("key")
  valid_582439 = validateParameter(valid_582439, JString, required = false,
                                 default = nil)
  if valid_582439 != nil:
    section.add "key", valid_582439
  var valid_582440 = query.getOrDefault("prettyPrint")
  valid_582440 = validateParameter(valid_582440, JBool, required = false,
                                 default = newJBool(true))
  if valid_582440 != nil:
    section.add "prettyPrint", valid_582440
  var valid_582441 = query.getOrDefault("oauth_token")
  valid_582441 = validateParameter(valid_582441, JString, required = false,
                                 default = nil)
  if valid_582441 != nil:
    section.add "oauth_token", valid_582441
  var valid_582442 = query.getOrDefault("alt")
  valid_582442 = validateParameter(valid_582442, JString, required = false,
                                 default = newJString("json"))
  if valid_582442 != nil:
    section.add "alt", valid_582442
  var valid_582443 = query.getOrDefault("userIp")
  valid_582443 = validateParameter(valid_582443, JString, required = false,
                                 default = nil)
  if valid_582443 != nil:
    section.add "userIp", valid_582443
  var valid_582444 = query.getOrDefault("quotaUser")
  valid_582444 = validateParameter(valid_582444, JString, required = false,
                                 default = nil)
  if valid_582444 != nil:
    section.add "quotaUser", valid_582444
  var valid_582445 = query.getOrDefault("fields")
  valid_582445 = validateParameter(valid_582445, JString, required = false,
                                 default = nil)
  if valid_582445 != nil:
    section.add "fields", valid_582445
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582446: Call_DfareportingUserRolePermissionsGet_582434;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one user role permission by ID.
  ## 
  let valid = call_582446.validator(path, query, header, formData, body)
  let scheme = call_582446.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582446.url(scheme.get, call_582446.host, call_582446.base,
                         call_582446.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582446, url, valid)

proc call*(call_582447: Call_DfareportingUserRolePermissionsGet_582434;
          profileId: string; id: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingUserRolePermissionsGet
  ## Gets one user role permission by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : User role permission ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582448 = newJObject()
  var query_582449 = newJObject()
  add(query_582449, "key", newJString(key))
  add(query_582449, "prettyPrint", newJBool(prettyPrint))
  add(query_582449, "oauth_token", newJString(oauthToken))
  add(path_582448, "profileId", newJString(profileId))
  add(path_582448, "id", newJString(id))
  add(query_582449, "alt", newJString(alt))
  add(query_582449, "userIp", newJString(userIp))
  add(query_582449, "quotaUser", newJString(quotaUser))
  add(query_582449, "fields", newJString(fields))
  result = call_582447.call(path_582448, query_582449, nil, nil, nil)

var dfareportingUserRolePermissionsGet* = Call_DfareportingUserRolePermissionsGet_582434(
    name: "dfareportingUserRolePermissionsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissions/{id}",
    validator: validate_DfareportingUserRolePermissionsGet_582435,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionsGet_582436,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesUpdate_582473 = ref object of OpenApiRestCall_578364
proc url_DfareportingUserRolesUpdate_582475(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesUpdate_582474(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing user role.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582476 = path.getOrDefault("profileId")
  valid_582476 = validateParameter(valid_582476, JString, required = true,
                                 default = nil)
  if valid_582476 != nil:
    section.add "profileId", valid_582476
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582477 = query.getOrDefault("key")
  valid_582477 = validateParameter(valid_582477, JString, required = false,
                                 default = nil)
  if valid_582477 != nil:
    section.add "key", valid_582477
  var valid_582478 = query.getOrDefault("prettyPrint")
  valid_582478 = validateParameter(valid_582478, JBool, required = false,
                                 default = newJBool(true))
  if valid_582478 != nil:
    section.add "prettyPrint", valid_582478
  var valid_582479 = query.getOrDefault("oauth_token")
  valid_582479 = validateParameter(valid_582479, JString, required = false,
                                 default = nil)
  if valid_582479 != nil:
    section.add "oauth_token", valid_582479
  var valid_582480 = query.getOrDefault("alt")
  valid_582480 = validateParameter(valid_582480, JString, required = false,
                                 default = newJString("json"))
  if valid_582480 != nil:
    section.add "alt", valid_582480
  var valid_582481 = query.getOrDefault("userIp")
  valid_582481 = validateParameter(valid_582481, JString, required = false,
                                 default = nil)
  if valid_582481 != nil:
    section.add "userIp", valid_582481
  var valid_582482 = query.getOrDefault("quotaUser")
  valid_582482 = validateParameter(valid_582482, JString, required = false,
                                 default = nil)
  if valid_582482 != nil:
    section.add "quotaUser", valid_582482
  var valid_582483 = query.getOrDefault("fields")
  valid_582483 = validateParameter(valid_582483, JString, required = false,
                                 default = nil)
  if valid_582483 != nil:
    section.add "fields", valid_582483
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582485: Call_DfareportingUserRolesUpdate_582473; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing user role.
  ## 
  let valid = call_582485.validator(path, query, header, formData, body)
  let scheme = call_582485.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582485.url(scheme.get, call_582485.host, call_582485.base,
                         call_582485.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582485, url, valid)

proc call*(call_582486: Call_DfareportingUserRolesUpdate_582473; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingUserRolesUpdate
  ## Updates an existing user role.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582487 = newJObject()
  var query_582488 = newJObject()
  var body_582489 = newJObject()
  add(query_582488, "key", newJString(key))
  add(query_582488, "prettyPrint", newJBool(prettyPrint))
  add(query_582488, "oauth_token", newJString(oauthToken))
  add(path_582487, "profileId", newJString(profileId))
  add(query_582488, "alt", newJString(alt))
  add(query_582488, "userIp", newJString(userIp))
  add(query_582488, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_582489 = body
  add(query_582488, "fields", newJString(fields))
  result = call_582486.call(path_582487, query_582488, nil, nil, body_582489)

var dfareportingUserRolesUpdate* = Call_DfareportingUserRolesUpdate_582473(
    name: "dfareportingUserRolesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesUpdate_582474,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesUpdate_582475,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesInsert_582490 = ref object of OpenApiRestCall_578364
proc url_DfareportingUserRolesInsert_582492(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesInsert_582491(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new user role.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582493 = path.getOrDefault("profileId")
  valid_582493 = validateParameter(valid_582493, JString, required = true,
                                 default = nil)
  if valid_582493 != nil:
    section.add "profileId", valid_582493
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582494 = query.getOrDefault("key")
  valid_582494 = validateParameter(valid_582494, JString, required = false,
                                 default = nil)
  if valid_582494 != nil:
    section.add "key", valid_582494
  var valid_582495 = query.getOrDefault("prettyPrint")
  valid_582495 = validateParameter(valid_582495, JBool, required = false,
                                 default = newJBool(true))
  if valid_582495 != nil:
    section.add "prettyPrint", valid_582495
  var valid_582496 = query.getOrDefault("oauth_token")
  valid_582496 = validateParameter(valid_582496, JString, required = false,
                                 default = nil)
  if valid_582496 != nil:
    section.add "oauth_token", valid_582496
  var valid_582497 = query.getOrDefault("alt")
  valid_582497 = validateParameter(valid_582497, JString, required = false,
                                 default = newJString("json"))
  if valid_582497 != nil:
    section.add "alt", valid_582497
  var valid_582498 = query.getOrDefault("userIp")
  valid_582498 = validateParameter(valid_582498, JString, required = false,
                                 default = nil)
  if valid_582498 != nil:
    section.add "userIp", valid_582498
  var valid_582499 = query.getOrDefault("quotaUser")
  valid_582499 = validateParameter(valid_582499, JString, required = false,
                                 default = nil)
  if valid_582499 != nil:
    section.add "quotaUser", valid_582499
  var valid_582500 = query.getOrDefault("fields")
  valid_582500 = validateParameter(valid_582500, JString, required = false,
                                 default = nil)
  if valid_582500 != nil:
    section.add "fields", valid_582500
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582502: Call_DfareportingUserRolesInsert_582490; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new user role.
  ## 
  let valid = call_582502.validator(path, query, header, formData, body)
  let scheme = call_582502.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582502.url(scheme.get, call_582502.host, call_582502.base,
                         call_582502.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582502, url, valid)

proc call*(call_582503: Call_DfareportingUserRolesInsert_582490; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingUserRolesInsert
  ## Inserts a new user role.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582504 = newJObject()
  var query_582505 = newJObject()
  var body_582506 = newJObject()
  add(query_582505, "key", newJString(key))
  add(query_582505, "prettyPrint", newJBool(prettyPrint))
  add(query_582505, "oauth_token", newJString(oauthToken))
  add(path_582504, "profileId", newJString(profileId))
  add(query_582505, "alt", newJString(alt))
  add(query_582505, "userIp", newJString(userIp))
  add(query_582505, "quotaUser", newJString(quotaUser))
  if body != nil:
    body_582506 = body
  add(query_582505, "fields", newJString(fields))
  result = call_582503.call(path_582504, query_582505, nil, nil, body_582506)

var dfareportingUserRolesInsert* = Call_DfareportingUserRolesInsert_582490(
    name: "dfareportingUserRolesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesInsert_582491,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesInsert_582492,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesList_582450 = ref object of OpenApiRestCall_578364
proc url_DfareportingUserRolesList_582452(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesList_582451(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of user roles, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582453 = path.getOrDefault("profileId")
  valid_582453 = validateParameter(valid_582453, JString, required = true,
                                 default = nil)
  if valid_582453 != nil:
    section.add "profileId", valid_582453
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "userrole*2015" will return objects with names like "userrole June 2015", "userrole April 2015", or simply "userrole 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "userrole" will match objects with name "my userrole", "userrole 2015", or simply "userrole".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   subaccountId: JString
  ##               : Select only user roles that belong to this subaccount.
  ##   ids: JArray
  ##      : Select only user roles with the specified IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   accountUserRoleOnly: JBool
  ##                      : Select only account level user roles not associated with any specific subaccount.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  section = newJObject()
  var valid_582454 = query.getOrDefault("key")
  valid_582454 = validateParameter(valid_582454, JString, required = false,
                                 default = nil)
  if valid_582454 != nil:
    section.add "key", valid_582454
  var valid_582455 = query.getOrDefault("prettyPrint")
  valid_582455 = validateParameter(valid_582455, JBool, required = false,
                                 default = newJBool(true))
  if valid_582455 != nil:
    section.add "prettyPrint", valid_582455
  var valid_582456 = query.getOrDefault("oauth_token")
  valid_582456 = validateParameter(valid_582456, JString, required = false,
                                 default = nil)
  if valid_582456 != nil:
    section.add "oauth_token", valid_582456
  var valid_582457 = query.getOrDefault("sortField")
  valid_582457 = validateParameter(valid_582457, JString, required = false,
                                 default = newJString("ID"))
  if valid_582457 != nil:
    section.add "sortField", valid_582457
  var valid_582458 = query.getOrDefault("alt")
  valid_582458 = validateParameter(valid_582458, JString, required = false,
                                 default = newJString("json"))
  if valid_582458 != nil:
    section.add "alt", valid_582458
  var valid_582459 = query.getOrDefault("userIp")
  valid_582459 = validateParameter(valid_582459, JString, required = false,
                                 default = nil)
  if valid_582459 != nil:
    section.add "userIp", valid_582459
  var valid_582460 = query.getOrDefault("quotaUser")
  valid_582460 = validateParameter(valid_582460, JString, required = false,
                                 default = nil)
  if valid_582460 != nil:
    section.add "quotaUser", valid_582460
  var valid_582461 = query.getOrDefault("pageToken")
  valid_582461 = validateParameter(valid_582461, JString, required = false,
                                 default = nil)
  if valid_582461 != nil:
    section.add "pageToken", valid_582461
  var valid_582462 = query.getOrDefault("searchString")
  valid_582462 = validateParameter(valid_582462, JString, required = false,
                                 default = nil)
  if valid_582462 != nil:
    section.add "searchString", valid_582462
  var valid_582463 = query.getOrDefault("sortOrder")
  valid_582463 = validateParameter(valid_582463, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_582463 != nil:
    section.add "sortOrder", valid_582463
  var valid_582464 = query.getOrDefault("subaccountId")
  valid_582464 = validateParameter(valid_582464, JString, required = false,
                                 default = nil)
  if valid_582464 != nil:
    section.add "subaccountId", valid_582464
  var valid_582465 = query.getOrDefault("ids")
  valid_582465 = validateParameter(valid_582465, JArray, required = false,
                                 default = nil)
  if valid_582465 != nil:
    section.add "ids", valid_582465
  var valid_582466 = query.getOrDefault("fields")
  valid_582466 = validateParameter(valid_582466, JString, required = false,
                                 default = nil)
  if valid_582466 != nil:
    section.add "fields", valid_582466
  var valid_582467 = query.getOrDefault("accountUserRoleOnly")
  valid_582467 = validateParameter(valid_582467, JBool, required = false, default = nil)
  if valid_582467 != nil:
    section.add "accountUserRoleOnly", valid_582467
  var valid_582468 = query.getOrDefault("maxResults")
  valid_582468 = validateParameter(valid_582468, JInt, required = false,
                                 default = newJInt(1000))
  if valid_582468 != nil:
    section.add "maxResults", valid_582468
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582469: Call_DfareportingUserRolesList_582450; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of user roles, possibly filtered. This method supports paging.
  ## 
  let valid = call_582469.validator(path, query, header, formData, body)
  let scheme = call_582469.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582469.url(scheme.get, call_582469.host, call_582469.base,
                         call_582469.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582469, url, valid)

proc call*(call_582470: Call_DfareportingUserRolesList_582450; profileId: string;
          key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          sortField: string = "ID"; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; pageToken: string = ""; searchString: string = "";
          sortOrder: string = "ASCENDING"; subaccountId: string = "";
          ids: JsonNode = nil; fields: string = ""; accountUserRoleOnly: bool = false;
          maxResults: int = 1000): Recallable =
  ## dfareportingUserRolesList
  ## Retrieves a list of user roles, possibly filtered. This method supports paging.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "userrole*2015" will return objects with names like "userrole June 2015", "userrole April 2015", or simply "userrole 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "userrole" will match objects with name "my userrole", "userrole 2015", or simply "userrole".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   subaccountId: string
  ##               : Select only user roles that belong to this subaccount.
  ##   ids: JArray
  ##      : Select only user roles with the specified IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   accountUserRoleOnly: bool
  ##                      : Select only account level user roles not associated with any specific subaccount.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  var path_582471 = newJObject()
  var query_582472 = newJObject()
  add(query_582472, "key", newJString(key))
  add(query_582472, "prettyPrint", newJBool(prettyPrint))
  add(query_582472, "oauth_token", newJString(oauthToken))
  add(path_582471, "profileId", newJString(profileId))
  add(query_582472, "sortField", newJString(sortField))
  add(query_582472, "alt", newJString(alt))
  add(query_582472, "userIp", newJString(userIp))
  add(query_582472, "quotaUser", newJString(quotaUser))
  add(query_582472, "pageToken", newJString(pageToken))
  add(query_582472, "searchString", newJString(searchString))
  add(query_582472, "sortOrder", newJString(sortOrder))
  add(query_582472, "subaccountId", newJString(subaccountId))
  if ids != nil:
    query_582472.add "ids", ids
  add(query_582472, "fields", newJString(fields))
  add(query_582472, "accountUserRoleOnly", newJBool(accountUserRoleOnly))
  add(query_582472, "maxResults", newJInt(maxResults))
  result = call_582470.call(path_582471, query_582472, nil, nil, nil)

var dfareportingUserRolesList* = Call_DfareportingUserRolesList_582450(
    name: "dfareportingUserRolesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesList_582451,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesList_582452,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesPatch_582507 = ref object of OpenApiRestCall_578364
proc url_DfareportingUserRolesPatch_582509(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesPatch_582508(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing user role. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582510 = path.getOrDefault("profileId")
  valid_582510 = validateParameter(valid_582510, JString, required = true,
                                 default = nil)
  if valid_582510 != nil:
    section.add "profileId", valid_582510
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : User role ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582511 = query.getOrDefault("key")
  valid_582511 = validateParameter(valid_582511, JString, required = false,
                                 default = nil)
  if valid_582511 != nil:
    section.add "key", valid_582511
  var valid_582512 = query.getOrDefault("prettyPrint")
  valid_582512 = validateParameter(valid_582512, JBool, required = false,
                                 default = newJBool(true))
  if valid_582512 != nil:
    section.add "prettyPrint", valid_582512
  var valid_582513 = query.getOrDefault("oauth_token")
  valid_582513 = validateParameter(valid_582513, JString, required = false,
                                 default = nil)
  if valid_582513 != nil:
    section.add "oauth_token", valid_582513
  var valid_582514 = query.getOrDefault("alt")
  valid_582514 = validateParameter(valid_582514, JString, required = false,
                                 default = newJString("json"))
  if valid_582514 != nil:
    section.add "alt", valid_582514
  var valid_582515 = query.getOrDefault("userIp")
  valid_582515 = validateParameter(valid_582515, JString, required = false,
                                 default = nil)
  if valid_582515 != nil:
    section.add "userIp", valid_582515
  var valid_582516 = query.getOrDefault("quotaUser")
  valid_582516 = validateParameter(valid_582516, JString, required = false,
                                 default = nil)
  if valid_582516 != nil:
    section.add "quotaUser", valid_582516
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_582517 = query.getOrDefault("id")
  valid_582517 = validateParameter(valid_582517, JString, required = true,
                                 default = nil)
  if valid_582517 != nil:
    section.add "id", valid_582517
  var valid_582518 = query.getOrDefault("fields")
  valid_582518 = validateParameter(valid_582518, JString, required = false,
                                 default = nil)
  if valid_582518 != nil:
    section.add "fields", valid_582518
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582520: Call_DfareportingUserRolesPatch_582507; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing user role. This method supports patch semantics.
  ## 
  let valid = call_582520.validator(path, query, header, formData, body)
  let scheme = call_582520.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582520.url(scheme.get, call_582520.host, call_582520.base,
                         call_582520.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582520, url, valid)

proc call*(call_582521: Call_DfareportingUserRolesPatch_582507; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          body: JsonNode = nil; fields: string = ""): Recallable =
  ## dfareportingUserRolesPatch
  ## Updates an existing user role. This method supports patch semantics.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : User role ID.
  ##   body: JObject
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582522 = newJObject()
  var query_582523 = newJObject()
  var body_582524 = newJObject()
  add(query_582523, "key", newJString(key))
  add(query_582523, "prettyPrint", newJBool(prettyPrint))
  add(query_582523, "oauth_token", newJString(oauthToken))
  add(path_582522, "profileId", newJString(profileId))
  add(query_582523, "alt", newJString(alt))
  add(query_582523, "userIp", newJString(userIp))
  add(query_582523, "quotaUser", newJString(quotaUser))
  add(query_582523, "id", newJString(id))
  if body != nil:
    body_582524 = body
  add(query_582523, "fields", newJString(fields))
  result = call_582521.call(path_582522, query_582523, nil, nil, body_582524)

var dfareportingUserRolesPatch* = Call_DfareportingUserRolesPatch_582507(
    name: "dfareportingUserRolesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesPatch_582508,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesPatch_582509,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesGet_582525 = ref object of OpenApiRestCall_578364
proc url_DfareportingUserRolesGet_582527(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesGet_582526(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user role by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582528 = path.getOrDefault("profileId")
  valid_582528 = validateParameter(valid_582528, JString, required = true,
                                 default = nil)
  if valid_582528 != nil:
    section.add "profileId", valid_582528
  var valid_582529 = path.getOrDefault("id")
  valid_582529 = validateParameter(valid_582529, JString, required = true,
                                 default = nil)
  if valid_582529 != nil:
    section.add "id", valid_582529
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582530 = query.getOrDefault("key")
  valid_582530 = validateParameter(valid_582530, JString, required = false,
                                 default = nil)
  if valid_582530 != nil:
    section.add "key", valid_582530
  var valid_582531 = query.getOrDefault("prettyPrint")
  valid_582531 = validateParameter(valid_582531, JBool, required = false,
                                 default = newJBool(true))
  if valid_582531 != nil:
    section.add "prettyPrint", valid_582531
  var valid_582532 = query.getOrDefault("oauth_token")
  valid_582532 = validateParameter(valid_582532, JString, required = false,
                                 default = nil)
  if valid_582532 != nil:
    section.add "oauth_token", valid_582532
  var valid_582533 = query.getOrDefault("alt")
  valid_582533 = validateParameter(valid_582533, JString, required = false,
                                 default = newJString("json"))
  if valid_582533 != nil:
    section.add "alt", valid_582533
  var valid_582534 = query.getOrDefault("userIp")
  valid_582534 = validateParameter(valid_582534, JString, required = false,
                                 default = nil)
  if valid_582534 != nil:
    section.add "userIp", valid_582534
  var valid_582535 = query.getOrDefault("quotaUser")
  valid_582535 = validateParameter(valid_582535, JString, required = false,
                                 default = nil)
  if valid_582535 != nil:
    section.add "quotaUser", valid_582535
  var valid_582536 = query.getOrDefault("fields")
  valid_582536 = validateParameter(valid_582536, JString, required = false,
                                 default = nil)
  if valid_582536 != nil:
    section.add "fields", valid_582536
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582537: Call_DfareportingUserRolesGet_582525; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one user role by ID.
  ## 
  let valid = call_582537.validator(path, query, header, formData, body)
  let scheme = call_582537.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582537.url(scheme.get, call_582537.host, call_582537.base,
                         call_582537.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582537, url, valid)

proc call*(call_582538: Call_DfareportingUserRolesGet_582525; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingUserRolesGet
  ## Gets one user role by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : User role ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582539 = newJObject()
  var query_582540 = newJObject()
  add(query_582540, "key", newJString(key))
  add(query_582540, "prettyPrint", newJBool(prettyPrint))
  add(query_582540, "oauth_token", newJString(oauthToken))
  add(path_582539, "profileId", newJString(profileId))
  add(path_582539, "id", newJString(id))
  add(query_582540, "alt", newJString(alt))
  add(query_582540, "userIp", newJString(userIp))
  add(query_582540, "quotaUser", newJString(quotaUser))
  add(query_582540, "fields", newJString(fields))
  result = call_582538.call(path_582539, query_582540, nil, nil, nil)

var dfareportingUserRolesGet* = Call_DfareportingUserRolesGet_582525(
    name: "dfareportingUserRolesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles/{id}",
    validator: validate_DfareportingUserRolesGet_582526,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesGet_582527,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesDelete_582541 = ref object of OpenApiRestCall_578364
proc url_DfareportingUserRolesDelete_582543(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesDelete_582542(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing user role.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582544 = path.getOrDefault("profileId")
  valid_582544 = validateParameter(valid_582544, JString, required = true,
                                 default = nil)
  if valid_582544 != nil:
    section.add "profileId", valid_582544
  var valid_582545 = path.getOrDefault("id")
  valid_582545 = validateParameter(valid_582545, JString, required = true,
                                 default = nil)
  if valid_582545 != nil:
    section.add "id", valid_582545
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582546 = query.getOrDefault("key")
  valid_582546 = validateParameter(valid_582546, JString, required = false,
                                 default = nil)
  if valid_582546 != nil:
    section.add "key", valid_582546
  var valid_582547 = query.getOrDefault("prettyPrint")
  valid_582547 = validateParameter(valid_582547, JBool, required = false,
                                 default = newJBool(true))
  if valid_582547 != nil:
    section.add "prettyPrint", valid_582547
  var valid_582548 = query.getOrDefault("oauth_token")
  valid_582548 = validateParameter(valid_582548, JString, required = false,
                                 default = nil)
  if valid_582548 != nil:
    section.add "oauth_token", valid_582548
  var valid_582549 = query.getOrDefault("alt")
  valid_582549 = validateParameter(valid_582549, JString, required = false,
                                 default = newJString("json"))
  if valid_582549 != nil:
    section.add "alt", valid_582549
  var valid_582550 = query.getOrDefault("userIp")
  valid_582550 = validateParameter(valid_582550, JString, required = false,
                                 default = nil)
  if valid_582550 != nil:
    section.add "userIp", valid_582550
  var valid_582551 = query.getOrDefault("quotaUser")
  valid_582551 = validateParameter(valid_582551, JString, required = false,
                                 default = nil)
  if valid_582551 != nil:
    section.add "quotaUser", valid_582551
  var valid_582552 = query.getOrDefault("fields")
  valid_582552 = validateParameter(valid_582552, JString, required = false,
                                 default = nil)
  if valid_582552 != nil:
    section.add "fields", valid_582552
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582553: Call_DfareportingUserRolesDelete_582541; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing user role.
  ## 
  let valid = call_582553.validator(path, query, header, formData, body)
  let scheme = call_582553.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582553.url(scheme.get, call_582553.host, call_582553.base,
                         call_582553.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582553, url, valid)

proc call*(call_582554: Call_DfareportingUserRolesDelete_582541; profileId: string;
          id: string; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingUserRolesDelete
  ## Deletes an existing user role.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: string (required)
  ##     : User role ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582555 = newJObject()
  var query_582556 = newJObject()
  add(query_582556, "key", newJString(key))
  add(query_582556, "prettyPrint", newJBool(prettyPrint))
  add(query_582556, "oauth_token", newJString(oauthToken))
  add(path_582555, "profileId", newJString(profileId))
  add(path_582555, "id", newJString(id))
  add(query_582556, "alt", newJString(alt))
  add(query_582556, "userIp", newJString(userIp))
  add(query_582556, "quotaUser", newJString(quotaUser))
  add(query_582556, "fields", newJString(fields))
  result = call_582554.call(path_582555, query_582556, nil, nil, nil)

var dfareportingUserRolesDelete* = Call_DfareportingUserRolesDelete_582541(
    name: "dfareportingUserRolesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles/{id}",
    validator: validate_DfareportingUserRolesDelete_582542,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesDelete_582543,
    schemes: {Scheme.Https})
type
  Call_DfareportingVideoFormatsList_582557 = ref object of OpenApiRestCall_578364
proc url_DfareportingVideoFormatsList_582559(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/videoFormats")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingVideoFormatsList_582558(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists available video formats.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582560 = path.getOrDefault("profileId")
  valid_582560 = validateParameter(valid_582560, JString, required = true,
                                 default = nil)
  if valid_582560 != nil:
    section.add "profileId", valid_582560
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582561 = query.getOrDefault("key")
  valid_582561 = validateParameter(valid_582561, JString, required = false,
                                 default = nil)
  if valid_582561 != nil:
    section.add "key", valid_582561
  var valid_582562 = query.getOrDefault("prettyPrint")
  valid_582562 = validateParameter(valid_582562, JBool, required = false,
                                 default = newJBool(true))
  if valid_582562 != nil:
    section.add "prettyPrint", valid_582562
  var valid_582563 = query.getOrDefault("oauth_token")
  valid_582563 = validateParameter(valid_582563, JString, required = false,
                                 default = nil)
  if valid_582563 != nil:
    section.add "oauth_token", valid_582563
  var valid_582564 = query.getOrDefault("alt")
  valid_582564 = validateParameter(valid_582564, JString, required = false,
                                 default = newJString("json"))
  if valid_582564 != nil:
    section.add "alt", valid_582564
  var valid_582565 = query.getOrDefault("userIp")
  valid_582565 = validateParameter(valid_582565, JString, required = false,
                                 default = nil)
  if valid_582565 != nil:
    section.add "userIp", valid_582565
  var valid_582566 = query.getOrDefault("quotaUser")
  valid_582566 = validateParameter(valid_582566, JString, required = false,
                                 default = nil)
  if valid_582566 != nil:
    section.add "quotaUser", valid_582566
  var valid_582567 = query.getOrDefault("fields")
  valid_582567 = validateParameter(valid_582567, JString, required = false,
                                 default = nil)
  if valid_582567 != nil:
    section.add "fields", valid_582567
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582568: Call_DfareportingVideoFormatsList_582557; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists available video formats.
  ## 
  let valid = call_582568.validator(path, query, header, formData, body)
  let scheme = call_582568.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582568.url(scheme.get, call_582568.host, call_582568.base,
                         call_582568.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582568, url, valid)

proc call*(call_582569: Call_DfareportingVideoFormatsList_582557;
          profileId: string; key: string = ""; prettyPrint: bool = true;
          oauthToken: string = ""; alt: string = "json"; userIp: string = "";
          quotaUser: string = ""; fields: string = ""): Recallable =
  ## dfareportingVideoFormatsList
  ## Lists available video formats.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582570 = newJObject()
  var query_582571 = newJObject()
  add(query_582571, "key", newJString(key))
  add(query_582571, "prettyPrint", newJBool(prettyPrint))
  add(query_582571, "oauth_token", newJString(oauthToken))
  add(path_582570, "profileId", newJString(profileId))
  add(query_582571, "alt", newJString(alt))
  add(query_582571, "userIp", newJString(userIp))
  add(query_582571, "quotaUser", newJString(quotaUser))
  add(query_582571, "fields", newJString(fields))
  result = call_582569.call(path_582570, query_582571, nil, nil, nil)

var dfareportingVideoFormatsList* = Call_DfareportingVideoFormatsList_582557(
    name: "dfareportingVideoFormatsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/videoFormats",
    validator: validate_DfareportingVideoFormatsList_582558,
    base: "/dfareporting/v2.7", url: url_DfareportingVideoFormatsList_582559,
    schemes: {Scheme.Https})
type
  Call_DfareportingVideoFormatsGet_582572 = ref object of OpenApiRestCall_578364
proc url_DfareportingVideoFormatsGet_582574(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/videoFormats/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingVideoFormatsGet_582573(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one video format by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JInt (required)
  ##     : Video format ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582575 = path.getOrDefault("profileId")
  valid_582575 = validateParameter(valid_582575, JString, required = true,
                                 default = nil)
  if valid_582575 != nil:
    section.add "profileId", valid_582575
  var valid_582576 = path.getOrDefault("id")
  valid_582576 = validateParameter(valid_582576, JInt, required = true, default = nil)
  if valid_582576 != nil:
    section.add "id", valid_582576
  result.add "path", section
  ## parameters in `query` object:
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   alt: JString
  ##      : Data format for the response.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  section = newJObject()
  var valid_582577 = query.getOrDefault("key")
  valid_582577 = validateParameter(valid_582577, JString, required = false,
                                 default = nil)
  if valid_582577 != nil:
    section.add "key", valid_582577
  var valid_582578 = query.getOrDefault("prettyPrint")
  valid_582578 = validateParameter(valid_582578, JBool, required = false,
                                 default = newJBool(true))
  if valid_582578 != nil:
    section.add "prettyPrint", valid_582578
  var valid_582579 = query.getOrDefault("oauth_token")
  valid_582579 = validateParameter(valid_582579, JString, required = false,
                                 default = nil)
  if valid_582579 != nil:
    section.add "oauth_token", valid_582579
  var valid_582580 = query.getOrDefault("alt")
  valid_582580 = validateParameter(valid_582580, JString, required = false,
                                 default = newJString("json"))
  if valid_582580 != nil:
    section.add "alt", valid_582580
  var valid_582581 = query.getOrDefault("userIp")
  valid_582581 = validateParameter(valid_582581, JString, required = false,
                                 default = nil)
  if valid_582581 != nil:
    section.add "userIp", valid_582581
  var valid_582582 = query.getOrDefault("quotaUser")
  valid_582582 = validateParameter(valid_582582, JString, required = false,
                                 default = nil)
  if valid_582582 != nil:
    section.add "quotaUser", valid_582582
  var valid_582583 = query.getOrDefault("fields")
  valid_582583 = validateParameter(valid_582583, JString, required = false,
                                 default = nil)
  if valid_582583 != nil:
    section.add "fields", valid_582583
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582584: Call_DfareportingVideoFormatsGet_582572; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one video format by ID.
  ## 
  let valid = call_582584.validator(path, query, header, formData, body)
  let scheme = call_582584.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582584.url(scheme.get, call_582584.host, call_582584.base,
                         call_582584.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582584, url, valid)

proc call*(call_582585: Call_DfareportingVideoFormatsGet_582572; profileId: string;
          id: int; key: string = ""; prettyPrint: bool = true; oauthToken: string = "";
          alt: string = "json"; userIp: string = ""; quotaUser: string = "";
          fields: string = ""): Recallable =
  ## dfareportingVideoFormatsGet
  ## Gets one video format by ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   id: int (required)
  ##     : Video format ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  var path_582586 = newJObject()
  var query_582587 = newJObject()
  add(query_582587, "key", newJString(key))
  add(query_582587, "prettyPrint", newJBool(prettyPrint))
  add(query_582587, "oauth_token", newJString(oauthToken))
  add(path_582586, "profileId", newJString(profileId))
  add(path_582586, "id", newJInt(id))
  add(query_582587, "alt", newJString(alt))
  add(query_582587, "userIp", newJString(userIp))
  add(query_582587, "quotaUser", newJString(quotaUser))
  add(query_582587, "fields", newJString(fields))
  result = call_582585.call(path_582586, query_582587, nil, nil, nil)

var dfareportingVideoFormatsGet* = Call_DfareportingVideoFormatsGet_582572(
    name: "dfareportingVideoFormatsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/videoFormats/{id}",
    validator: validate_DfareportingVideoFormatsGet_582573,
    base: "/dfareporting/v2.7", url: url_DfareportingVideoFormatsGet_582574,
    schemes: {Scheme.Https})
export
  rest

type
  GoogleAuth = ref object
    endpoint*: Uri
    token: string
    expiry*: float64
    issued*: float64
    email: string
    key: string
    scope*: seq[string]
    form: string
    digest: Hash

const
  endpoint = "https://www.googleapis.com/oauth2/v4/token".parseUri
var auth = GoogleAuth(endpoint: endpoint)
proc hash(auth: GoogleAuth): Hash =
  ## yield differing values for effectively different auth payloads
  result = hash($auth.endpoint)
  result = result !& hash(auth.email)
  result = result !& hash(auth.key)
  result = result !& hash(auth.scope.join(" "))
  result = !$result

proc newAuthenticator*(path: string): GoogleAuth =
  let
    input = readFile(path)
    js = parseJson(input)
  auth.email = js["client_email"].getStr
  auth.key = js["private_key"].getStr
  result = auth

proc store(auth: var GoogleAuth; token: string; expiry: int; form: string) =
  auth.token = token
  auth.issued = epochTime()
  auth.expiry = auth.issued + expiry.float64
  auth.form = form
  auth.digest = auth.hash

proc authenticate*(fresh: float64 = 3600.0; lifetime: int = 3600): Future[bool] {.async.} =
  ## get or refresh an authentication token; provide `fresh`
  ## to ensure that the token won't expire in the next N seconds.
  ## provide `lifetime` to indicate how long the token should last.
  let clock = epochTime()
  if auth.expiry > clock + fresh:
    if auth.hash == auth.digest:
      return true
  let
    expiry = clock.int + lifetime
    header = JOSEHeader(alg: RS256, typ: "JWT")
    claims = %*{"iss": auth.email, "scope": auth.scope.join(" "),
              "aud": "https://www.googleapis.com/oauth2/v4/token", "exp": expiry,
              "iat": clock.int}
  var tok = JWT(header: header, claims: toClaims(claims))
  tok.sign(auth.key)
  let post = encodeQuery({"grant_type": "urn:ietf:params:oauth:grant-type:jwt-bearer",
                       "assertion": $tok}, usePlus = false, omitEq = false)
  var client = newAsyncHttpClient()
  client.headers = newHttpHeaders({"Content-Type": "application/x-www-form-urlencoded",
                                 "Content-Length": $post.len})
  let response = await client.request($auth.endpoint, HttpPost, body = post)
  if not response.code.is2xx:
    return false
  let body = await response.body
  client.close
  try:
    let js = parseJson(body)
    auth.store(js["access_token"].getStr, js["expires_in"].getInt,
               js["token_type"].getStr)
  except KeyError:
    return false
  except JsonParsingError:
    return false
  return true

proc composeQueryString(query: JsonNode): string =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs, usePlus = false, omitEq = false)

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  var headers = massageHeaders(input.getOrDefault("header"))
  let body = input.getOrDefault("body").getStr
  if auth.scope.len == 0:
    raise newException(ValueError, "specify authentication scopes")
  if not waitfor authenticate(fresh = 10.0):
    raise newException(IOError, "unable to refresh authentication token")
  headers.add ("Authorization", auth.form & " " & auth.token)
  headers.add ("Content-Type", "application/json")
  headers.add ("Content-Length", $body.len)
  result = newRecallable(call, url, headers, body = body)
