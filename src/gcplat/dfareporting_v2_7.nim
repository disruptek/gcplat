
import
  json, options, hashes, uri, rest, os, uri, strutils, times, httpcore, httpclient,
  asyncdispatch, jwt

## auto-generated via openapi macro
## title: DCM/DFA Reporting And Trafficking
## version: v2.7
## termsOfService: (not provided)
## license: (not provided)
## 
## Manages your DoubleClick Campaign Manager ad campaigns and reports.
## 
## https://developers.google.com/doubleclick-advertisers/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_579437 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_579437](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_579437): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    if js.kind notin {JString, JInt, JFloat, JNull, JBool}:
      return
    head = $js
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  gcpServiceName = "dfareporting"
proc composeQueryString(query: JsonNode): string
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_DfareportingFilesGet_579706 = ref object of OpenApiRestCall_579437
proc url_DfareportingFilesGet_579708(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "reportId" in path, "`reportId` is a required path parameter"
  assert "fileId" in path, "`fileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/files/"),
               (kind: VariableSegment, value: "fileId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFilesGet_579707(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a report file by its report ID and file ID. This method supports media download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   fileId: JString (required)
  ##         : The ID of the report file.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `fileId` field"
  var valid_579834 = path.getOrDefault("fileId")
  valid_579834 = validateParameter(valid_579834, JString, required = true,
                                 default = nil)
  if valid_579834 != nil:
    section.add "fileId", valid_579834
  var valid_579835 = path.getOrDefault("reportId")
  valid_579835 = validateParameter(valid_579835, JString, required = true,
                                 default = nil)
  if valid_579835 != nil:
    section.add "reportId", valid_579835
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_579836 = query.getOrDefault("fields")
  valid_579836 = validateParameter(valid_579836, JString, required = false,
                                 default = nil)
  if valid_579836 != nil:
    section.add "fields", valid_579836
  var valid_579837 = query.getOrDefault("quotaUser")
  valid_579837 = validateParameter(valid_579837, JString, required = false,
                                 default = nil)
  if valid_579837 != nil:
    section.add "quotaUser", valid_579837
  var valid_579851 = query.getOrDefault("alt")
  valid_579851 = validateParameter(valid_579851, JString, required = false,
                                 default = newJString("json"))
  if valid_579851 != nil:
    section.add "alt", valid_579851
  var valid_579852 = query.getOrDefault("oauth_token")
  valid_579852 = validateParameter(valid_579852, JString, required = false,
                                 default = nil)
  if valid_579852 != nil:
    section.add "oauth_token", valid_579852
  var valid_579853 = query.getOrDefault("userIp")
  valid_579853 = validateParameter(valid_579853, JString, required = false,
                                 default = nil)
  if valid_579853 != nil:
    section.add "userIp", valid_579853
  var valid_579854 = query.getOrDefault("key")
  valid_579854 = validateParameter(valid_579854, JString, required = false,
                                 default = nil)
  if valid_579854 != nil:
    section.add "key", valid_579854
  var valid_579855 = query.getOrDefault("prettyPrint")
  valid_579855 = validateParameter(valid_579855, JBool, required = false,
                                 default = newJBool(true))
  if valid_579855 != nil:
    section.add "prettyPrint", valid_579855
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579878: Call_DfareportingFilesGet_579706; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a report file by its report ID and file ID. This method supports media download.
  ## 
  let valid = call_579878.validator(path, query, header, formData, body)
  let scheme = call_579878.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579878.url(scheme.get, call_579878.host, call_579878.base,
                         call_579878.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579878, url, valid)

proc call*(call_579949: Call_DfareportingFilesGet_579706; fileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFilesGet
  ## Retrieves a report file by its report ID and file ID. This method supports media download.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fileId: string (required)
  ##         : The ID of the report file.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_579950 = newJObject()
  var query_579952 = newJObject()
  add(query_579952, "fields", newJString(fields))
  add(query_579952, "quotaUser", newJString(quotaUser))
  add(path_579950, "fileId", newJString(fileId))
  add(query_579952, "alt", newJString(alt))
  add(query_579952, "oauth_token", newJString(oauthToken))
  add(query_579952, "userIp", newJString(userIp))
  add(query_579952, "key", newJString(key))
  add(path_579950, "reportId", newJString(reportId))
  add(query_579952, "prettyPrint", newJBool(prettyPrint))
  result = call_579949.call(path_579950, query_579952, nil, nil, nil)

var dfareportingFilesGet* = Call_DfareportingFilesGet_579706(
    name: "dfareportingFilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/reports/{reportId}/files/{fileId}",
    validator: validate_DfareportingFilesGet_579707, base: "/dfareporting/v2.7",
    url: url_DfareportingFilesGet_579708, schemes: {Scheme.Https})
type
  Call_DfareportingUserProfilesList_579991 = ref object of OpenApiRestCall_579437
proc url_DfareportingUserProfilesList_579993(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  result.path = base & route

proc validate_DfareportingUserProfilesList_579992(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves list of user profiles for a user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_579994 = query.getOrDefault("fields")
  valid_579994 = validateParameter(valid_579994, JString, required = false,
                                 default = nil)
  if valid_579994 != nil:
    section.add "fields", valid_579994
  var valid_579995 = query.getOrDefault("quotaUser")
  valid_579995 = validateParameter(valid_579995, JString, required = false,
                                 default = nil)
  if valid_579995 != nil:
    section.add "quotaUser", valid_579995
  var valid_579996 = query.getOrDefault("alt")
  valid_579996 = validateParameter(valid_579996, JString, required = false,
                                 default = newJString("json"))
  if valid_579996 != nil:
    section.add "alt", valid_579996
  var valid_579997 = query.getOrDefault("oauth_token")
  valid_579997 = validateParameter(valid_579997, JString, required = false,
                                 default = nil)
  if valid_579997 != nil:
    section.add "oauth_token", valid_579997
  var valid_579998 = query.getOrDefault("userIp")
  valid_579998 = validateParameter(valid_579998, JString, required = false,
                                 default = nil)
  if valid_579998 != nil:
    section.add "userIp", valid_579998
  var valid_579999 = query.getOrDefault("key")
  valid_579999 = validateParameter(valid_579999, JString, required = false,
                                 default = nil)
  if valid_579999 != nil:
    section.add "key", valid_579999
  var valid_580000 = query.getOrDefault("prettyPrint")
  valid_580000 = validateParameter(valid_580000, JBool, required = false,
                                 default = newJBool(true))
  if valid_580000 != nil:
    section.add "prettyPrint", valid_580000
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580001: Call_DfareportingUserProfilesList_579991; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves list of user profiles for a user.
  ## 
  let valid = call_580001.validator(path, query, header, formData, body)
  let scheme = call_580001.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580001.url(scheme.get, call_580001.host, call_580001.base,
                         call_580001.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580001, url, valid)

proc call*(call_580002: Call_DfareportingUserProfilesList_579991;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingUserProfilesList
  ## Retrieves list of user profiles for a user.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var query_580003 = newJObject()
  add(query_580003, "fields", newJString(fields))
  add(query_580003, "quotaUser", newJString(quotaUser))
  add(query_580003, "alt", newJString(alt))
  add(query_580003, "oauth_token", newJString(oauthToken))
  add(query_580003, "userIp", newJString(userIp))
  add(query_580003, "key", newJString(key))
  add(query_580003, "prettyPrint", newJBool(prettyPrint))
  result = call_580002.call(nil, query_580003, nil, nil, nil)

var dfareportingUserProfilesList* = Call_DfareportingUserProfilesList_579991(
    name: "dfareportingUserProfilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles",
    validator: validate_DfareportingUserProfilesList_579992,
    base: "/dfareporting/v2.7", url: url_DfareportingUserProfilesList_579993,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserProfilesGet_580004 = ref object of OpenApiRestCall_579437
proc url_DfareportingUserProfilesGet_580006(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserProfilesGet_580005(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user profile by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580007 = path.getOrDefault("profileId")
  valid_580007 = validateParameter(valid_580007, JString, required = true,
                                 default = nil)
  if valid_580007 != nil:
    section.add "profileId", valid_580007
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580008 = query.getOrDefault("fields")
  valid_580008 = validateParameter(valid_580008, JString, required = false,
                                 default = nil)
  if valid_580008 != nil:
    section.add "fields", valid_580008
  var valid_580009 = query.getOrDefault("quotaUser")
  valid_580009 = validateParameter(valid_580009, JString, required = false,
                                 default = nil)
  if valid_580009 != nil:
    section.add "quotaUser", valid_580009
  var valid_580010 = query.getOrDefault("alt")
  valid_580010 = validateParameter(valid_580010, JString, required = false,
                                 default = newJString("json"))
  if valid_580010 != nil:
    section.add "alt", valid_580010
  var valid_580011 = query.getOrDefault("oauth_token")
  valid_580011 = validateParameter(valid_580011, JString, required = false,
                                 default = nil)
  if valid_580011 != nil:
    section.add "oauth_token", valid_580011
  var valid_580012 = query.getOrDefault("userIp")
  valid_580012 = validateParameter(valid_580012, JString, required = false,
                                 default = nil)
  if valid_580012 != nil:
    section.add "userIp", valid_580012
  var valid_580013 = query.getOrDefault("key")
  valid_580013 = validateParameter(valid_580013, JString, required = false,
                                 default = nil)
  if valid_580013 != nil:
    section.add "key", valid_580013
  var valid_580014 = query.getOrDefault("prettyPrint")
  valid_580014 = validateParameter(valid_580014, JBool, required = false,
                                 default = newJBool(true))
  if valid_580014 != nil:
    section.add "prettyPrint", valid_580014
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580015: Call_DfareportingUserProfilesGet_580004; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one user profile by ID.
  ## 
  let valid = call_580015.validator(path, query, header, formData, body)
  let scheme = call_580015.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580015.url(scheme.get, call_580015.host, call_580015.base,
                         call_580015.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580015, url, valid)

proc call*(call_580016: Call_DfareportingUserProfilesGet_580004; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingUserProfilesGet
  ## Gets one user profile by ID.
  ##   profileId: string (required)
  ##            : The user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580017 = newJObject()
  var query_580018 = newJObject()
  add(path_580017, "profileId", newJString(profileId))
  add(query_580018, "fields", newJString(fields))
  add(query_580018, "quotaUser", newJString(quotaUser))
  add(query_580018, "alt", newJString(alt))
  add(query_580018, "oauth_token", newJString(oauthToken))
  add(query_580018, "userIp", newJString(userIp))
  add(query_580018, "key", newJString(key))
  add(query_580018, "prettyPrint", newJBool(prettyPrint))
  result = call_580016.call(path_580017, query_580018, nil, nil, nil)

var dfareportingUserProfilesGet* = Call_DfareportingUserProfilesGet_580004(
    name: "dfareportingUserProfilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}",
    validator: validate_DfareportingUserProfilesGet_580005,
    base: "/dfareporting/v2.7", url: url_DfareportingUserProfilesGet_580006,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountActiveAdSummariesGet_580019 = ref object of OpenApiRestCall_579437
proc url_DfareportingAccountActiveAdSummariesGet_580021(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "summaryAccountId" in path,
        "`summaryAccountId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountActiveAdSummaries/"),
               (kind: VariableSegment, value: "summaryAccountId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountActiveAdSummariesGet_580020(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the account's active ad summary by account ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   summaryAccountId: JString (required)
  ##                   : Account ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580022 = path.getOrDefault("profileId")
  valid_580022 = validateParameter(valid_580022, JString, required = true,
                                 default = nil)
  if valid_580022 != nil:
    section.add "profileId", valid_580022
  var valid_580023 = path.getOrDefault("summaryAccountId")
  valid_580023 = validateParameter(valid_580023, JString, required = true,
                                 default = nil)
  if valid_580023 != nil:
    section.add "summaryAccountId", valid_580023
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580024 = query.getOrDefault("fields")
  valid_580024 = validateParameter(valid_580024, JString, required = false,
                                 default = nil)
  if valid_580024 != nil:
    section.add "fields", valid_580024
  var valid_580025 = query.getOrDefault("quotaUser")
  valid_580025 = validateParameter(valid_580025, JString, required = false,
                                 default = nil)
  if valid_580025 != nil:
    section.add "quotaUser", valid_580025
  var valid_580026 = query.getOrDefault("alt")
  valid_580026 = validateParameter(valid_580026, JString, required = false,
                                 default = newJString("json"))
  if valid_580026 != nil:
    section.add "alt", valid_580026
  var valid_580027 = query.getOrDefault("oauth_token")
  valid_580027 = validateParameter(valid_580027, JString, required = false,
                                 default = nil)
  if valid_580027 != nil:
    section.add "oauth_token", valid_580027
  var valid_580028 = query.getOrDefault("userIp")
  valid_580028 = validateParameter(valid_580028, JString, required = false,
                                 default = nil)
  if valid_580028 != nil:
    section.add "userIp", valid_580028
  var valid_580029 = query.getOrDefault("key")
  valid_580029 = validateParameter(valid_580029, JString, required = false,
                                 default = nil)
  if valid_580029 != nil:
    section.add "key", valid_580029
  var valid_580030 = query.getOrDefault("prettyPrint")
  valid_580030 = validateParameter(valid_580030, JBool, required = false,
                                 default = newJBool(true))
  if valid_580030 != nil:
    section.add "prettyPrint", valid_580030
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580031: Call_DfareportingAccountActiveAdSummariesGet_580019;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the account's active ad summary by account ID.
  ## 
  let valid = call_580031.validator(path, query, header, formData, body)
  let scheme = call_580031.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580031.url(scheme.get, call_580031.host, call_580031.base,
                         call_580031.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580031, url, valid)

proc call*(call_580032: Call_DfareportingAccountActiveAdSummariesGet_580019;
          profileId: string; summaryAccountId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountActiveAdSummariesGet
  ## Gets the account's active ad summary by account ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   summaryAccountId: string (required)
  ##                   : Account ID.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580033 = newJObject()
  var query_580034 = newJObject()
  add(path_580033, "profileId", newJString(profileId))
  add(query_580034, "fields", newJString(fields))
  add(query_580034, "quotaUser", newJString(quotaUser))
  add(query_580034, "alt", newJString(alt))
  add(query_580034, "oauth_token", newJString(oauthToken))
  add(query_580034, "userIp", newJString(userIp))
  add(query_580034, "key", newJString(key))
  add(path_580033, "summaryAccountId", newJString(summaryAccountId))
  add(query_580034, "prettyPrint", newJBool(prettyPrint))
  result = call_580032.call(path_580033, query_580034, nil, nil, nil)

var dfareportingAccountActiveAdSummariesGet* = Call_DfareportingAccountActiveAdSummariesGet_580019(
    name: "dfareportingAccountActiveAdSummariesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accountActiveAdSummaries/{summaryAccountId}",
    validator: validate_DfareportingAccountActiveAdSummariesGet_580020,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountActiveAdSummariesGet_580021,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionGroupsList_580035 = ref object of OpenApiRestCall_579437
proc url_DfareportingAccountPermissionGroupsList_580037(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissionGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionGroupsList_580036(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of account permission groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580038 = path.getOrDefault("profileId")
  valid_580038 = validateParameter(valid_580038, JString, required = true,
                                 default = nil)
  if valid_580038 != nil:
    section.add "profileId", valid_580038
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580039 = query.getOrDefault("fields")
  valid_580039 = validateParameter(valid_580039, JString, required = false,
                                 default = nil)
  if valid_580039 != nil:
    section.add "fields", valid_580039
  var valid_580040 = query.getOrDefault("quotaUser")
  valid_580040 = validateParameter(valid_580040, JString, required = false,
                                 default = nil)
  if valid_580040 != nil:
    section.add "quotaUser", valid_580040
  var valid_580041 = query.getOrDefault("alt")
  valid_580041 = validateParameter(valid_580041, JString, required = false,
                                 default = newJString("json"))
  if valid_580041 != nil:
    section.add "alt", valid_580041
  var valid_580042 = query.getOrDefault("oauth_token")
  valid_580042 = validateParameter(valid_580042, JString, required = false,
                                 default = nil)
  if valid_580042 != nil:
    section.add "oauth_token", valid_580042
  var valid_580043 = query.getOrDefault("userIp")
  valid_580043 = validateParameter(valid_580043, JString, required = false,
                                 default = nil)
  if valid_580043 != nil:
    section.add "userIp", valid_580043
  var valid_580044 = query.getOrDefault("key")
  valid_580044 = validateParameter(valid_580044, JString, required = false,
                                 default = nil)
  if valid_580044 != nil:
    section.add "key", valid_580044
  var valid_580045 = query.getOrDefault("prettyPrint")
  valid_580045 = validateParameter(valid_580045, JBool, required = false,
                                 default = newJBool(true))
  if valid_580045 != nil:
    section.add "prettyPrint", valid_580045
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580046: Call_DfareportingAccountPermissionGroupsList_580035;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves the list of account permission groups.
  ## 
  let valid = call_580046.validator(path, query, header, formData, body)
  let scheme = call_580046.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580046.url(scheme.get, call_580046.host, call_580046.base,
                         call_580046.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580046, url, valid)

proc call*(call_580047: Call_DfareportingAccountPermissionGroupsList_580035;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountPermissionGroupsList
  ## Retrieves the list of account permission groups.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580048 = newJObject()
  var query_580049 = newJObject()
  add(path_580048, "profileId", newJString(profileId))
  add(query_580049, "fields", newJString(fields))
  add(query_580049, "quotaUser", newJString(quotaUser))
  add(query_580049, "alt", newJString(alt))
  add(query_580049, "oauth_token", newJString(oauthToken))
  add(query_580049, "userIp", newJString(userIp))
  add(query_580049, "key", newJString(key))
  add(query_580049, "prettyPrint", newJBool(prettyPrint))
  result = call_580047.call(path_580048, query_580049, nil, nil, nil)

var dfareportingAccountPermissionGroupsList* = Call_DfareportingAccountPermissionGroupsList_580035(
    name: "dfareportingAccountPermissionGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissionGroups",
    validator: validate_DfareportingAccountPermissionGroupsList_580036,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionGroupsList_580037,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionGroupsGet_580050 = ref object of OpenApiRestCall_579437
proc url_DfareportingAccountPermissionGroupsGet_580052(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissionGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionGroupsGet_580051(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account permission group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Account permission group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580053 = path.getOrDefault("profileId")
  valid_580053 = validateParameter(valid_580053, JString, required = true,
                                 default = nil)
  if valid_580053 != nil:
    section.add "profileId", valid_580053
  var valid_580054 = path.getOrDefault("id")
  valid_580054 = validateParameter(valid_580054, JString, required = true,
                                 default = nil)
  if valid_580054 != nil:
    section.add "id", valid_580054
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580055 = query.getOrDefault("fields")
  valid_580055 = validateParameter(valid_580055, JString, required = false,
                                 default = nil)
  if valid_580055 != nil:
    section.add "fields", valid_580055
  var valid_580056 = query.getOrDefault("quotaUser")
  valid_580056 = validateParameter(valid_580056, JString, required = false,
                                 default = nil)
  if valid_580056 != nil:
    section.add "quotaUser", valid_580056
  var valid_580057 = query.getOrDefault("alt")
  valid_580057 = validateParameter(valid_580057, JString, required = false,
                                 default = newJString("json"))
  if valid_580057 != nil:
    section.add "alt", valid_580057
  var valid_580058 = query.getOrDefault("oauth_token")
  valid_580058 = validateParameter(valid_580058, JString, required = false,
                                 default = nil)
  if valid_580058 != nil:
    section.add "oauth_token", valid_580058
  var valid_580059 = query.getOrDefault("userIp")
  valid_580059 = validateParameter(valid_580059, JString, required = false,
                                 default = nil)
  if valid_580059 != nil:
    section.add "userIp", valid_580059
  var valid_580060 = query.getOrDefault("key")
  valid_580060 = validateParameter(valid_580060, JString, required = false,
                                 default = nil)
  if valid_580060 != nil:
    section.add "key", valid_580060
  var valid_580061 = query.getOrDefault("prettyPrint")
  valid_580061 = validateParameter(valid_580061, JBool, required = false,
                                 default = newJBool(true))
  if valid_580061 != nil:
    section.add "prettyPrint", valid_580061
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580062: Call_DfareportingAccountPermissionGroupsGet_580050;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one account permission group by ID.
  ## 
  let valid = call_580062.validator(path, query, header, formData, body)
  let scheme = call_580062.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580062.url(scheme.get, call_580062.host, call_580062.base,
                         call_580062.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580062, url, valid)

proc call*(call_580063: Call_DfareportingAccountPermissionGroupsGet_580050;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountPermissionGroupsGet
  ## Gets one account permission group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Account permission group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580064 = newJObject()
  var query_580065 = newJObject()
  add(path_580064, "profileId", newJString(profileId))
  add(query_580065, "fields", newJString(fields))
  add(query_580065, "quotaUser", newJString(quotaUser))
  add(query_580065, "alt", newJString(alt))
  add(query_580065, "oauth_token", newJString(oauthToken))
  add(query_580065, "userIp", newJString(userIp))
  add(path_580064, "id", newJString(id))
  add(query_580065, "key", newJString(key))
  add(query_580065, "prettyPrint", newJBool(prettyPrint))
  result = call_580063.call(path_580064, query_580065, nil, nil, nil)

var dfareportingAccountPermissionGroupsGet* = Call_DfareportingAccountPermissionGroupsGet_580050(
    name: "dfareportingAccountPermissionGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissionGroups/{id}",
    validator: validate_DfareportingAccountPermissionGroupsGet_580051,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionGroupsGet_580052,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionsList_580066 = ref object of OpenApiRestCall_579437
proc url_DfareportingAccountPermissionsList_580068(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionsList_580067(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of account permissions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580069 = path.getOrDefault("profileId")
  valid_580069 = validateParameter(valid_580069, JString, required = true,
                                 default = nil)
  if valid_580069 != nil:
    section.add "profileId", valid_580069
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580070 = query.getOrDefault("fields")
  valid_580070 = validateParameter(valid_580070, JString, required = false,
                                 default = nil)
  if valid_580070 != nil:
    section.add "fields", valid_580070
  var valid_580071 = query.getOrDefault("quotaUser")
  valid_580071 = validateParameter(valid_580071, JString, required = false,
                                 default = nil)
  if valid_580071 != nil:
    section.add "quotaUser", valid_580071
  var valid_580072 = query.getOrDefault("alt")
  valid_580072 = validateParameter(valid_580072, JString, required = false,
                                 default = newJString("json"))
  if valid_580072 != nil:
    section.add "alt", valid_580072
  var valid_580073 = query.getOrDefault("oauth_token")
  valid_580073 = validateParameter(valid_580073, JString, required = false,
                                 default = nil)
  if valid_580073 != nil:
    section.add "oauth_token", valid_580073
  var valid_580074 = query.getOrDefault("userIp")
  valid_580074 = validateParameter(valid_580074, JString, required = false,
                                 default = nil)
  if valid_580074 != nil:
    section.add "userIp", valid_580074
  var valid_580075 = query.getOrDefault("key")
  valid_580075 = validateParameter(valid_580075, JString, required = false,
                                 default = nil)
  if valid_580075 != nil:
    section.add "key", valid_580075
  var valid_580076 = query.getOrDefault("prettyPrint")
  valid_580076 = validateParameter(valid_580076, JBool, required = false,
                                 default = newJBool(true))
  if valid_580076 != nil:
    section.add "prettyPrint", valid_580076
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580077: Call_DfareportingAccountPermissionsList_580066;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves the list of account permissions.
  ## 
  let valid = call_580077.validator(path, query, header, formData, body)
  let scheme = call_580077.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580077.url(scheme.get, call_580077.host, call_580077.base,
                         call_580077.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580077, url, valid)

proc call*(call_580078: Call_DfareportingAccountPermissionsList_580066;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountPermissionsList
  ## Retrieves the list of account permissions.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580079 = newJObject()
  var query_580080 = newJObject()
  add(path_580079, "profileId", newJString(profileId))
  add(query_580080, "fields", newJString(fields))
  add(query_580080, "quotaUser", newJString(quotaUser))
  add(query_580080, "alt", newJString(alt))
  add(query_580080, "oauth_token", newJString(oauthToken))
  add(query_580080, "userIp", newJString(userIp))
  add(query_580080, "key", newJString(key))
  add(query_580080, "prettyPrint", newJBool(prettyPrint))
  result = call_580078.call(path_580079, query_580080, nil, nil, nil)

var dfareportingAccountPermissionsList* = Call_DfareportingAccountPermissionsList_580066(
    name: "dfareportingAccountPermissionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissions",
    validator: validate_DfareportingAccountPermissionsList_580067,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionsList_580068,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionsGet_580081 = ref object of OpenApiRestCall_579437
proc url_DfareportingAccountPermissionsGet_580083(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissions/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionsGet_580082(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account permission by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Account permission ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580084 = path.getOrDefault("profileId")
  valid_580084 = validateParameter(valid_580084, JString, required = true,
                                 default = nil)
  if valid_580084 != nil:
    section.add "profileId", valid_580084
  var valid_580085 = path.getOrDefault("id")
  valid_580085 = validateParameter(valid_580085, JString, required = true,
                                 default = nil)
  if valid_580085 != nil:
    section.add "id", valid_580085
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580086 = query.getOrDefault("fields")
  valid_580086 = validateParameter(valid_580086, JString, required = false,
                                 default = nil)
  if valid_580086 != nil:
    section.add "fields", valid_580086
  var valid_580087 = query.getOrDefault("quotaUser")
  valid_580087 = validateParameter(valid_580087, JString, required = false,
                                 default = nil)
  if valid_580087 != nil:
    section.add "quotaUser", valid_580087
  var valid_580088 = query.getOrDefault("alt")
  valid_580088 = validateParameter(valid_580088, JString, required = false,
                                 default = newJString("json"))
  if valid_580088 != nil:
    section.add "alt", valid_580088
  var valid_580089 = query.getOrDefault("oauth_token")
  valid_580089 = validateParameter(valid_580089, JString, required = false,
                                 default = nil)
  if valid_580089 != nil:
    section.add "oauth_token", valid_580089
  var valid_580090 = query.getOrDefault("userIp")
  valid_580090 = validateParameter(valid_580090, JString, required = false,
                                 default = nil)
  if valid_580090 != nil:
    section.add "userIp", valid_580090
  var valid_580091 = query.getOrDefault("key")
  valid_580091 = validateParameter(valid_580091, JString, required = false,
                                 default = nil)
  if valid_580091 != nil:
    section.add "key", valid_580091
  var valid_580092 = query.getOrDefault("prettyPrint")
  valid_580092 = validateParameter(valid_580092, JBool, required = false,
                                 default = newJBool(true))
  if valid_580092 != nil:
    section.add "prettyPrint", valid_580092
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580093: Call_DfareportingAccountPermissionsGet_580081;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one account permission by ID.
  ## 
  let valid = call_580093.validator(path, query, header, formData, body)
  let scheme = call_580093.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580093.url(scheme.get, call_580093.host, call_580093.base,
                         call_580093.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580093, url, valid)

proc call*(call_580094: Call_DfareportingAccountPermissionsGet_580081;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountPermissionsGet
  ## Gets one account permission by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Account permission ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580095 = newJObject()
  var query_580096 = newJObject()
  add(path_580095, "profileId", newJString(profileId))
  add(query_580096, "fields", newJString(fields))
  add(query_580096, "quotaUser", newJString(quotaUser))
  add(query_580096, "alt", newJString(alt))
  add(query_580096, "oauth_token", newJString(oauthToken))
  add(query_580096, "userIp", newJString(userIp))
  add(path_580095, "id", newJString(id))
  add(query_580096, "key", newJString(key))
  add(query_580096, "prettyPrint", newJBool(prettyPrint))
  result = call_580094.call(path_580095, query_580096, nil, nil, nil)

var dfareportingAccountPermissionsGet* = Call_DfareportingAccountPermissionsGet_580081(
    name: "dfareportingAccountPermissionsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissions/{id}",
    validator: validate_DfareportingAccountPermissionsGet_580082,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionsGet_580083,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesUpdate_580122 = ref object of OpenApiRestCall_579437
proc url_DfareportingAccountUserProfilesUpdate_580124(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesUpdate_580123(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account user profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580125 = path.getOrDefault("profileId")
  valid_580125 = validateParameter(valid_580125, JString, required = true,
                                 default = nil)
  if valid_580125 != nil:
    section.add "profileId", valid_580125
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580126 = query.getOrDefault("fields")
  valid_580126 = validateParameter(valid_580126, JString, required = false,
                                 default = nil)
  if valid_580126 != nil:
    section.add "fields", valid_580126
  var valid_580127 = query.getOrDefault("quotaUser")
  valid_580127 = validateParameter(valid_580127, JString, required = false,
                                 default = nil)
  if valid_580127 != nil:
    section.add "quotaUser", valid_580127
  var valid_580128 = query.getOrDefault("alt")
  valid_580128 = validateParameter(valid_580128, JString, required = false,
                                 default = newJString("json"))
  if valid_580128 != nil:
    section.add "alt", valid_580128
  var valid_580129 = query.getOrDefault("oauth_token")
  valid_580129 = validateParameter(valid_580129, JString, required = false,
                                 default = nil)
  if valid_580129 != nil:
    section.add "oauth_token", valid_580129
  var valid_580130 = query.getOrDefault("userIp")
  valid_580130 = validateParameter(valid_580130, JString, required = false,
                                 default = nil)
  if valid_580130 != nil:
    section.add "userIp", valid_580130
  var valid_580131 = query.getOrDefault("key")
  valid_580131 = validateParameter(valid_580131, JString, required = false,
                                 default = nil)
  if valid_580131 != nil:
    section.add "key", valid_580131
  var valid_580132 = query.getOrDefault("prettyPrint")
  valid_580132 = validateParameter(valid_580132, JBool, required = false,
                                 default = newJBool(true))
  if valid_580132 != nil:
    section.add "prettyPrint", valid_580132
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580134: Call_DfareportingAccountUserProfilesUpdate_580122;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing account user profile.
  ## 
  let valid = call_580134.validator(path, query, header, formData, body)
  let scheme = call_580134.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580134.url(scheme.get, call_580134.host, call_580134.base,
                         call_580134.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580134, url, valid)

proc call*(call_580135: Call_DfareportingAccountUserProfilesUpdate_580122;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountUserProfilesUpdate
  ## Updates an existing account user profile.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580136 = newJObject()
  var query_580137 = newJObject()
  var body_580138 = newJObject()
  add(path_580136, "profileId", newJString(profileId))
  add(query_580137, "fields", newJString(fields))
  add(query_580137, "quotaUser", newJString(quotaUser))
  add(query_580137, "alt", newJString(alt))
  add(query_580137, "oauth_token", newJString(oauthToken))
  add(query_580137, "userIp", newJString(userIp))
  add(query_580137, "key", newJString(key))
  if body != nil:
    body_580138 = body
  add(query_580137, "prettyPrint", newJBool(prettyPrint))
  result = call_580135.call(path_580136, query_580137, nil, nil, body_580138)

var dfareportingAccountUserProfilesUpdate* = Call_DfareportingAccountUserProfilesUpdate_580122(
    name: "dfareportingAccountUserProfilesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesUpdate_580123,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesUpdate_580124,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesInsert_580139 = ref object of OpenApiRestCall_579437
proc url_DfareportingAccountUserProfilesInsert_580141(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesInsert_580140(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new account user profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580142 = path.getOrDefault("profileId")
  valid_580142 = validateParameter(valid_580142, JString, required = true,
                                 default = nil)
  if valid_580142 != nil:
    section.add "profileId", valid_580142
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580143 = query.getOrDefault("fields")
  valid_580143 = validateParameter(valid_580143, JString, required = false,
                                 default = nil)
  if valid_580143 != nil:
    section.add "fields", valid_580143
  var valid_580144 = query.getOrDefault("quotaUser")
  valid_580144 = validateParameter(valid_580144, JString, required = false,
                                 default = nil)
  if valid_580144 != nil:
    section.add "quotaUser", valid_580144
  var valid_580145 = query.getOrDefault("alt")
  valid_580145 = validateParameter(valid_580145, JString, required = false,
                                 default = newJString("json"))
  if valid_580145 != nil:
    section.add "alt", valid_580145
  var valid_580146 = query.getOrDefault("oauth_token")
  valid_580146 = validateParameter(valid_580146, JString, required = false,
                                 default = nil)
  if valid_580146 != nil:
    section.add "oauth_token", valid_580146
  var valid_580147 = query.getOrDefault("userIp")
  valid_580147 = validateParameter(valid_580147, JString, required = false,
                                 default = nil)
  if valid_580147 != nil:
    section.add "userIp", valid_580147
  var valid_580148 = query.getOrDefault("key")
  valid_580148 = validateParameter(valid_580148, JString, required = false,
                                 default = nil)
  if valid_580148 != nil:
    section.add "key", valid_580148
  var valid_580149 = query.getOrDefault("prettyPrint")
  valid_580149 = validateParameter(valid_580149, JBool, required = false,
                                 default = newJBool(true))
  if valid_580149 != nil:
    section.add "prettyPrint", valid_580149
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580151: Call_DfareportingAccountUserProfilesInsert_580139;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new account user profile.
  ## 
  let valid = call_580151.validator(path, query, header, formData, body)
  let scheme = call_580151.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580151.url(scheme.get, call_580151.host, call_580151.base,
                         call_580151.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580151, url, valid)

proc call*(call_580152: Call_DfareportingAccountUserProfilesInsert_580139;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountUserProfilesInsert
  ## Inserts a new account user profile.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580153 = newJObject()
  var query_580154 = newJObject()
  var body_580155 = newJObject()
  add(path_580153, "profileId", newJString(profileId))
  add(query_580154, "fields", newJString(fields))
  add(query_580154, "quotaUser", newJString(quotaUser))
  add(query_580154, "alt", newJString(alt))
  add(query_580154, "oauth_token", newJString(oauthToken))
  add(query_580154, "userIp", newJString(userIp))
  add(query_580154, "key", newJString(key))
  if body != nil:
    body_580155 = body
  add(query_580154, "prettyPrint", newJBool(prettyPrint))
  result = call_580152.call(path_580153, query_580154, nil, nil, body_580155)

var dfareportingAccountUserProfilesInsert* = Call_DfareportingAccountUserProfilesInsert_580139(
    name: "dfareportingAccountUserProfilesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesInsert_580140,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesInsert_580141,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesList_580097 = ref object of OpenApiRestCall_579437
proc url_DfareportingAccountUserProfilesList_580099(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesList_580098(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of account user profiles, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580100 = path.getOrDefault("profileId")
  valid_580100 = validateParameter(valid_580100, JString, required = true,
                                 default = nil)
  if valid_580100 != nil:
    section.add "profileId", valid_580100
  result.add "path", section
  ## parameters in `query` object:
  ##   subaccountId: JString
  ##               : Select only user profiles with the specified subaccount ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "user profile*2015" will return objects with names like "user profile June 2015", "user profile April 2015", or simply "user profile 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "user profile" will match objects with name "my user profile", "user profile 2015", or simply "user profile".
  ##   active: JBool
  ##         : Select only active user profiles.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only user profiles with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   userRoleId: JString
  ##             : Select only user profiles with the specified user role ID.
  section = newJObject()
  var valid_580101 = query.getOrDefault("subaccountId")
  valid_580101 = validateParameter(valid_580101, JString, required = false,
                                 default = nil)
  if valid_580101 != nil:
    section.add "subaccountId", valid_580101
  var valid_580102 = query.getOrDefault("fields")
  valid_580102 = validateParameter(valid_580102, JString, required = false,
                                 default = nil)
  if valid_580102 != nil:
    section.add "fields", valid_580102
  var valid_580103 = query.getOrDefault("pageToken")
  valid_580103 = validateParameter(valid_580103, JString, required = false,
                                 default = nil)
  if valid_580103 != nil:
    section.add "pageToken", valid_580103
  var valid_580104 = query.getOrDefault("quotaUser")
  valid_580104 = validateParameter(valid_580104, JString, required = false,
                                 default = nil)
  if valid_580104 != nil:
    section.add "quotaUser", valid_580104
  var valid_580105 = query.getOrDefault("sortField")
  valid_580105 = validateParameter(valid_580105, JString, required = false,
                                 default = newJString("ID"))
  if valid_580105 != nil:
    section.add "sortField", valid_580105
  var valid_580106 = query.getOrDefault("alt")
  valid_580106 = validateParameter(valid_580106, JString, required = false,
                                 default = newJString("json"))
  if valid_580106 != nil:
    section.add "alt", valid_580106
  var valid_580107 = query.getOrDefault("searchString")
  valid_580107 = validateParameter(valid_580107, JString, required = false,
                                 default = nil)
  if valid_580107 != nil:
    section.add "searchString", valid_580107
  var valid_580108 = query.getOrDefault("active")
  valid_580108 = validateParameter(valid_580108, JBool, required = false, default = nil)
  if valid_580108 != nil:
    section.add "active", valid_580108
  var valid_580109 = query.getOrDefault("oauth_token")
  valid_580109 = validateParameter(valid_580109, JString, required = false,
                                 default = nil)
  if valid_580109 != nil:
    section.add "oauth_token", valid_580109
  var valid_580110 = query.getOrDefault("userIp")
  valid_580110 = validateParameter(valid_580110, JString, required = false,
                                 default = nil)
  if valid_580110 != nil:
    section.add "userIp", valid_580110
  var valid_580112 = query.getOrDefault("maxResults")
  valid_580112 = validateParameter(valid_580112, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580112 != nil:
    section.add "maxResults", valid_580112
  var valid_580113 = query.getOrDefault("ids")
  valid_580113 = validateParameter(valid_580113, JArray, required = false,
                                 default = nil)
  if valid_580113 != nil:
    section.add "ids", valid_580113
  var valid_580114 = query.getOrDefault("key")
  valid_580114 = validateParameter(valid_580114, JString, required = false,
                                 default = nil)
  if valid_580114 != nil:
    section.add "key", valid_580114
  var valid_580115 = query.getOrDefault("sortOrder")
  valid_580115 = validateParameter(valid_580115, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580115 != nil:
    section.add "sortOrder", valid_580115
  var valid_580116 = query.getOrDefault("prettyPrint")
  valid_580116 = validateParameter(valid_580116, JBool, required = false,
                                 default = newJBool(true))
  if valid_580116 != nil:
    section.add "prettyPrint", valid_580116
  var valid_580117 = query.getOrDefault("userRoleId")
  valid_580117 = validateParameter(valid_580117, JString, required = false,
                                 default = nil)
  if valid_580117 != nil:
    section.add "userRoleId", valid_580117
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580118: Call_DfareportingAccountUserProfilesList_580097;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of account user profiles, possibly filtered. This method supports paging.
  ## 
  let valid = call_580118.validator(path, query, header, formData, body)
  let scheme = call_580118.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580118.url(scheme.get, call_580118.host, call_580118.base,
                         call_580118.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580118, url, valid)

proc call*(call_580119: Call_DfareportingAccountUserProfilesList_580097;
          profileId: string; subaccountId: string = ""; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; searchString: string = ""; active: bool = false;
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true; userRoleId: string = ""): Recallable =
  ## dfareportingAccountUserProfilesList
  ## Retrieves a list of account user profiles, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only user profiles with the specified subaccount ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "user profile*2015" will return objects with names like "user profile June 2015", "user profile April 2015", or simply "user profile 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "user profile" will match objects with name "my user profile", "user profile 2015", or simply "user profile".
  ##   active: bool
  ##         : Select only active user profiles.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only user profiles with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userRoleId: string
  ##             : Select only user profiles with the specified user role ID.
  var path_580120 = newJObject()
  var query_580121 = newJObject()
  add(path_580120, "profileId", newJString(profileId))
  add(query_580121, "subaccountId", newJString(subaccountId))
  add(query_580121, "fields", newJString(fields))
  add(query_580121, "pageToken", newJString(pageToken))
  add(query_580121, "quotaUser", newJString(quotaUser))
  add(query_580121, "sortField", newJString(sortField))
  add(query_580121, "alt", newJString(alt))
  add(query_580121, "searchString", newJString(searchString))
  add(query_580121, "active", newJBool(active))
  add(query_580121, "oauth_token", newJString(oauthToken))
  add(query_580121, "userIp", newJString(userIp))
  add(query_580121, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_580121.add "ids", ids
  add(query_580121, "key", newJString(key))
  add(query_580121, "sortOrder", newJString(sortOrder))
  add(query_580121, "prettyPrint", newJBool(prettyPrint))
  add(query_580121, "userRoleId", newJString(userRoleId))
  result = call_580119.call(path_580120, query_580121, nil, nil, nil)

var dfareportingAccountUserProfilesList* = Call_DfareportingAccountUserProfilesList_580097(
    name: "dfareportingAccountUserProfilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesList_580098,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesList_580099,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesPatch_580156 = ref object of OpenApiRestCall_579437
proc url_DfareportingAccountUserProfilesPatch_580158(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesPatch_580157(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account user profile. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580159 = path.getOrDefault("profileId")
  valid_580159 = validateParameter(valid_580159, JString, required = true,
                                 default = nil)
  if valid_580159 != nil:
    section.add "profileId", valid_580159
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : User profile ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580160 = query.getOrDefault("fields")
  valid_580160 = validateParameter(valid_580160, JString, required = false,
                                 default = nil)
  if valid_580160 != nil:
    section.add "fields", valid_580160
  var valid_580161 = query.getOrDefault("quotaUser")
  valid_580161 = validateParameter(valid_580161, JString, required = false,
                                 default = nil)
  if valid_580161 != nil:
    section.add "quotaUser", valid_580161
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580162 = query.getOrDefault("id")
  valid_580162 = validateParameter(valid_580162, JString, required = true,
                                 default = nil)
  if valid_580162 != nil:
    section.add "id", valid_580162
  var valid_580163 = query.getOrDefault("alt")
  valid_580163 = validateParameter(valid_580163, JString, required = false,
                                 default = newJString("json"))
  if valid_580163 != nil:
    section.add "alt", valid_580163
  var valid_580164 = query.getOrDefault("oauth_token")
  valid_580164 = validateParameter(valid_580164, JString, required = false,
                                 default = nil)
  if valid_580164 != nil:
    section.add "oauth_token", valid_580164
  var valid_580165 = query.getOrDefault("userIp")
  valid_580165 = validateParameter(valid_580165, JString, required = false,
                                 default = nil)
  if valid_580165 != nil:
    section.add "userIp", valid_580165
  var valid_580166 = query.getOrDefault("key")
  valid_580166 = validateParameter(valid_580166, JString, required = false,
                                 default = nil)
  if valid_580166 != nil:
    section.add "key", valid_580166
  var valid_580167 = query.getOrDefault("prettyPrint")
  valid_580167 = validateParameter(valid_580167, JBool, required = false,
                                 default = newJBool(true))
  if valid_580167 != nil:
    section.add "prettyPrint", valid_580167
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580169: Call_DfareportingAccountUserProfilesPatch_580156;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing account user profile. This method supports patch semantics.
  ## 
  let valid = call_580169.validator(path, query, header, formData, body)
  let scheme = call_580169.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580169.url(scheme.get, call_580169.host, call_580169.base,
                         call_580169.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580169, url, valid)

proc call*(call_580170: Call_DfareportingAccountUserProfilesPatch_580156;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountUserProfilesPatch
  ## Updates an existing account user profile. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : User profile ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580171 = newJObject()
  var query_580172 = newJObject()
  var body_580173 = newJObject()
  add(path_580171, "profileId", newJString(profileId))
  add(query_580172, "fields", newJString(fields))
  add(query_580172, "quotaUser", newJString(quotaUser))
  add(query_580172, "id", newJString(id))
  add(query_580172, "alt", newJString(alt))
  add(query_580172, "oauth_token", newJString(oauthToken))
  add(query_580172, "userIp", newJString(userIp))
  add(query_580172, "key", newJString(key))
  if body != nil:
    body_580173 = body
  add(query_580172, "prettyPrint", newJBool(prettyPrint))
  result = call_580170.call(path_580171, query_580172, nil, nil, body_580173)

var dfareportingAccountUserProfilesPatch* = Call_DfareportingAccountUserProfilesPatch_580156(
    name: "dfareportingAccountUserProfilesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesPatch_580157,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesPatch_580158,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesGet_580174 = ref object of OpenApiRestCall_579437
proc url_DfareportingAccountUserProfilesGet_580176(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesGet_580175(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account user profile by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580177 = path.getOrDefault("profileId")
  valid_580177 = validateParameter(valid_580177, JString, required = true,
                                 default = nil)
  if valid_580177 != nil:
    section.add "profileId", valid_580177
  var valid_580178 = path.getOrDefault("id")
  valid_580178 = validateParameter(valid_580178, JString, required = true,
                                 default = nil)
  if valid_580178 != nil:
    section.add "id", valid_580178
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580179 = query.getOrDefault("fields")
  valid_580179 = validateParameter(valid_580179, JString, required = false,
                                 default = nil)
  if valid_580179 != nil:
    section.add "fields", valid_580179
  var valid_580180 = query.getOrDefault("quotaUser")
  valid_580180 = validateParameter(valid_580180, JString, required = false,
                                 default = nil)
  if valid_580180 != nil:
    section.add "quotaUser", valid_580180
  var valid_580181 = query.getOrDefault("alt")
  valid_580181 = validateParameter(valid_580181, JString, required = false,
                                 default = newJString("json"))
  if valid_580181 != nil:
    section.add "alt", valid_580181
  var valid_580182 = query.getOrDefault("oauth_token")
  valid_580182 = validateParameter(valid_580182, JString, required = false,
                                 default = nil)
  if valid_580182 != nil:
    section.add "oauth_token", valid_580182
  var valid_580183 = query.getOrDefault("userIp")
  valid_580183 = validateParameter(valid_580183, JString, required = false,
                                 default = nil)
  if valid_580183 != nil:
    section.add "userIp", valid_580183
  var valid_580184 = query.getOrDefault("key")
  valid_580184 = validateParameter(valid_580184, JString, required = false,
                                 default = nil)
  if valid_580184 != nil:
    section.add "key", valid_580184
  var valid_580185 = query.getOrDefault("prettyPrint")
  valid_580185 = validateParameter(valid_580185, JBool, required = false,
                                 default = newJBool(true))
  if valid_580185 != nil:
    section.add "prettyPrint", valid_580185
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580186: Call_DfareportingAccountUserProfilesGet_580174;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one account user profile by ID.
  ## 
  let valid = call_580186.validator(path, query, header, formData, body)
  let scheme = call_580186.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580186.url(scheme.get, call_580186.host, call_580186.base,
                         call_580186.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580186, url, valid)

proc call*(call_580187: Call_DfareportingAccountUserProfilesGet_580174;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountUserProfilesGet
  ## Gets one account user profile by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User profile ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580188 = newJObject()
  var query_580189 = newJObject()
  add(path_580188, "profileId", newJString(profileId))
  add(query_580189, "fields", newJString(fields))
  add(query_580189, "quotaUser", newJString(quotaUser))
  add(query_580189, "alt", newJString(alt))
  add(query_580189, "oauth_token", newJString(oauthToken))
  add(query_580189, "userIp", newJString(userIp))
  add(path_580188, "id", newJString(id))
  add(query_580189, "key", newJString(key))
  add(query_580189, "prettyPrint", newJBool(prettyPrint))
  result = call_580187.call(path_580188, query_580189, nil, nil, nil)

var dfareportingAccountUserProfilesGet* = Call_DfareportingAccountUserProfilesGet_580174(
    name: "dfareportingAccountUserProfilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles/{id}",
    validator: validate_DfareportingAccountUserProfilesGet_580175,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesGet_580176,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsUpdate_580212 = ref object of OpenApiRestCall_579437
proc url_DfareportingAccountsUpdate_580214(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsUpdate_580213(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580215 = path.getOrDefault("profileId")
  valid_580215 = validateParameter(valid_580215, JString, required = true,
                                 default = nil)
  if valid_580215 != nil:
    section.add "profileId", valid_580215
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580216 = query.getOrDefault("fields")
  valid_580216 = validateParameter(valid_580216, JString, required = false,
                                 default = nil)
  if valid_580216 != nil:
    section.add "fields", valid_580216
  var valid_580217 = query.getOrDefault("quotaUser")
  valid_580217 = validateParameter(valid_580217, JString, required = false,
                                 default = nil)
  if valid_580217 != nil:
    section.add "quotaUser", valid_580217
  var valid_580218 = query.getOrDefault("alt")
  valid_580218 = validateParameter(valid_580218, JString, required = false,
                                 default = newJString("json"))
  if valid_580218 != nil:
    section.add "alt", valid_580218
  var valid_580219 = query.getOrDefault("oauth_token")
  valid_580219 = validateParameter(valid_580219, JString, required = false,
                                 default = nil)
  if valid_580219 != nil:
    section.add "oauth_token", valid_580219
  var valid_580220 = query.getOrDefault("userIp")
  valid_580220 = validateParameter(valid_580220, JString, required = false,
                                 default = nil)
  if valid_580220 != nil:
    section.add "userIp", valid_580220
  var valid_580221 = query.getOrDefault("key")
  valid_580221 = validateParameter(valid_580221, JString, required = false,
                                 default = nil)
  if valid_580221 != nil:
    section.add "key", valid_580221
  var valid_580222 = query.getOrDefault("prettyPrint")
  valid_580222 = validateParameter(valid_580222, JBool, required = false,
                                 default = newJBool(true))
  if valid_580222 != nil:
    section.add "prettyPrint", valid_580222
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580224: Call_DfareportingAccountsUpdate_580212; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing account.
  ## 
  let valid = call_580224.validator(path, query, header, formData, body)
  let scheme = call_580224.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580224.url(scheme.get, call_580224.host, call_580224.base,
                         call_580224.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580224, url, valid)

proc call*(call_580225: Call_DfareportingAccountsUpdate_580212; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountsUpdate
  ## Updates an existing account.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580226 = newJObject()
  var query_580227 = newJObject()
  var body_580228 = newJObject()
  add(path_580226, "profileId", newJString(profileId))
  add(query_580227, "fields", newJString(fields))
  add(query_580227, "quotaUser", newJString(quotaUser))
  add(query_580227, "alt", newJString(alt))
  add(query_580227, "oauth_token", newJString(oauthToken))
  add(query_580227, "userIp", newJString(userIp))
  add(query_580227, "key", newJString(key))
  if body != nil:
    body_580228 = body
  add(query_580227, "prettyPrint", newJBool(prettyPrint))
  result = call_580225.call(path_580226, query_580227, nil, nil, body_580228)

var dfareportingAccountsUpdate* = Call_DfareportingAccountsUpdate_580212(
    name: "dfareportingAccountsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts",
    validator: validate_DfareportingAccountsUpdate_580213,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsUpdate_580214,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsList_580190 = ref object of OpenApiRestCall_579437
proc url_DfareportingAccountsList_580192(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsList_580191(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of accounts, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580193 = path.getOrDefault("profileId")
  valid_580193 = validateParameter(valid_580193, JString, required = true,
                                 default = nil)
  if valid_580193 != nil:
    section.add "profileId", valid_580193
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "account*2015" will return objects with names like "account June 2015", "account April 2015", or simply "account 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "account" will match objects with name "my account", "account 2015", or simply "account".
  ##   active: JBool
  ##         : Select only active accounts. Don't set this field to select both active and non-active accounts.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only accounts with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580194 = query.getOrDefault("fields")
  valid_580194 = validateParameter(valid_580194, JString, required = false,
                                 default = nil)
  if valid_580194 != nil:
    section.add "fields", valid_580194
  var valid_580195 = query.getOrDefault("pageToken")
  valid_580195 = validateParameter(valid_580195, JString, required = false,
                                 default = nil)
  if valid_580195 != nil:
    section.add "pageToken", valid_580195
  var valid_580196 = query.getOrDefault("quotaUser")
  valid_580196 = validateParameter(valid_580196, JString, required = false,
                                 default = nil)
  if valid_580196 != nil:
    section.add "quotaUser", valid_580196
  var valid_580197 = query.getOrDefault("sortField")
  valid_580197 = validateParameter(valid_580197, JString, required = false,
                                 default = newJString("ID"))
  if valid_580197 != nil:
    section.add "sortField", valid_580197
  var valid_580198 = query.getOrDefault("alt")
  valid_580198 = validateParameter(valid_580198, JString, required = false,
                                 default = newJString("json"))
  if valid_580198 != nil:
    section.add "alt", valid_580198
  var valid_580199 = query.getOrDefault("searchString")
  valid_580199 = validateParameter(valid_580199, JString, required = false,
                                 default = nil)
  if valid_580199 != nil:
    section.add "searchString", valid_580199
  var valid_580200 = query.getOrDefault("active")
  valid_580200 = validateParameter(valid_580200, JBool, required = false, default = nil)
  if valid_580200 != nil:
    section.add "active", valid_580200
  var valid_580201 = query.getOrDefault("oauth_token")
  valid_580201 = validateParameter(valid_580201, JString, required = false,
                                 default = nil)
  if valid_580201 != nil:
    section.add "oauth_token", valid_580201
  var valid_580202 = query.getOrDefault("userIp")
  valid_580202 = validateParameter(valid_580202, JString, required = false,
                                 default = nil)
  if valid_580202 != nil:
    section.add "userIp", valid_580202
  var valid_580203 = query.getOrDefault("maxResults")
  valid_580203 = validateParameter(valid_580203, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580203 != nil:
    section.add "maxResults", valid_580203
  var valid_580204 = query.getOrDefault("ids")
  valid_580204 = validateParameter(valid_580204, JArray, required = false,
                                 default = nil)
  if valid_580204 != nil:
    section.add "ids", valid_580204
  var valid_580205 = query.getOrDefault("key")
  valid_580205 = validateParameter(valid_580205, JString, required = false,
                                 default = nil)
  if valid_580205 != nil:
    section.add "key", valid_580205
  var valid_580206 = query.getOrDefault("sortOrder")
  valid_580206 = validateParameter(valid_580206, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580206 != nil:
    section.add "sortOrder", valid_580206
  var valid_580207 = query.getOrDefault("prettyPrint")
  valid_580207 = validateParameter(valid_580207, JBool, required = false,
                                 default = newJBool(true))
  if valid_580207 != nil:
    section.add "prettyPrint", valid_580207
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580208: Call_DfareportingAccountsList_580190; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves the list of accounts, possibly filtered. This method supports paging.
  ## 
  let valid = call_580208.validator(path, query, header, formData, body)
  let scheme = call_580208.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580208.url(scheme.get, call_580208.host, call_580208.base,
                         call_580208.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580208, url, valid)

proc call*(call_580209: Call_DfareportingAccountsList_580190; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; searchString: string = "";
          active: bool = false; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountsList
  ## Retrieves the list of accounts, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "account*2015" will return objects with names like "account June 2015", "account April 2015", or simply "account 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "account" will match objects with name "my account", "account 2015", or simply "account".
  ##   active: bool
  ##         : Select only active accounts. Don't set this field to select both active and non-active accounts.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only accounts with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580210 = newJObject()
  var query_580211 = newJObject()
  add(path_580210, "profileId", newJString(profileId))
  add(query_580211, "fields", newJString(fields))
  add(query_580211, "pageToken", newJString(pageToken))
  add(query_580211, "quotaUser", newJString(quotaUser))
  add(query_580211, "sortField", newJString(sortField))
  add(query_580211, "alt", newJString(alt))
  add(query_580211, "searchString", newJString(searchString))
  add(query_580211, "active", newJBool(active))
  add(query_580211, "oauth_token", newJString(oauthToken))
  add(query_580211, "userIp", newJString(userIp))
  add(query_580211, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_580211.add "ids", ids
  add(query_580211, "key", newJString(key))
  add(query_580211, "sortOrder", newJString(sortOrder))
  add(query_580211, "prettyPrint", newJBool(prettyPrint))
  result = call_580209.call(path_580210, query_580211, nil, nil, nil)

var dfareportingAccountsList* = Call_DfareportingAccountsList_580190(
    name: "dfareportingAccountsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts",
    validator: validate_DfareportingAccountsList_580191,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsList_580192,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsPatch_580229 = ref object of OpenApiRestCall_579437
proc url_DfareportingAccountsPatch_580231(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsPatch_580230(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580232 = path.getOrDefault("profileId")
  valid_580232 = validateParameter(valid_580232, JString, required = true,
                                 default = nil)
  if valid_580232 != nil:
    section.add "profileId", valid_580232
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Account ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580233 = query.getOrDefault("fields")
  valid_580233 = validateParameter(valid_580233, JString, required = false,
                                 default = nil)
  if valid_580233 != nil:
    section.add "fields", valid_580233
  var valid_580234 = query.getOrDefault("quotaUser")
  valid_580234 = validateParameter(valid_580234, JString, required = false,
                                 default = nil)
  if valid_580234 != nil:
    section.add "quotaUser", valid_580234
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580235 = query.getOrDefault("id")
  valid_580235 = validateParameter(valid_580235, JString, required = true,
                                 default = nil)
  if valid_580235 != nil:
    section.add "id", valid_580235
  var valid_580236 = query.getOrDefault("alt")
  valid_580236 = validateParameter(valid_580236, JString, required = false,
                                 default = newJString("json"))
  if valid_580236 != nil:
    section.add "alt", valid_580236
  var valid_580237 = query.getOrDefault("oauth_token")
  valid_580237 = validateParameter(valid_580237, JString, required = false,
                                 default = nil)
  if valid_580237 != nil:
    section.add "oauth_token", valid_580237
  var valid_580238 = query.getOrDefault("userIp")
  valid_580238 = validateParameter(valid_580238, JString, required = false,
                                 default = nil)
  if valid_580238 != nil:
    section.add "userIp", valid_580238
  var valid_580239 = query.getOrDefault("key")
  valid_580239 = validateParameter(valid_580239, JString, required = false,
                                 default = nil)
  if valid_580239 != nil:
    section.add "key", valid_580239
  var valid_580240 = query.getOrDefault("prettyPrint")
  valid_580240 = validateParameter(valid_580240, JBool, required = false,
                                 default = newJBool(true))
  if valid_580240 != nil:
    section.add "prettyPrint", valid_580240
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580242: Call_DfareportingAccountsPatch_580229; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing account. This method supports patch semantics.
  ## 
  let valid = call_580242.validator(path, query, header, formData, body)
  let scheme = call_580242.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580242.url(scheme.get, call_580242.host, call_580242.base,
                         call_580242.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580242, url, valid)

proc call*(call_580243: Call_DfareportingAccountsPatch_580229; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountsPatch
  ## Updates an existing account. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Account ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580244 = newJObject()
  var query_580245 = newJObject()
  var body_580246 = newJObject()
  add(path_580244, "profileId", newJString(profileId))
  add(query_580245, "fields", newJString(fields))
  add(query_580245, "quotaUser", newJString(quotaUser))
  add(query_580245, "id", newJString(id))
  add(query_580245, "alt", newJString(alt))
  add(query_580245, "oauth_token", newJString(oauthToken))
  add(query_580245, "userIp", newJString(userIp))
  add(query_580245, "key", newJString(key))
  if body != nil:
    body_580246 = body
  add(query_580245, "prettyPrint", newJBool(prettyPrint))
  result = call_580243.call(path_580244, query_580245, nil, nil, body_580246)

var dfareportingAccountsPatch* = Call_DfareportingAccountsPatch_580229(
    name: "dfareportingAccountsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts",
    validator: validate_DfareportingAccountsPatch_580230,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsPatch_580231,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsGet_580247 = ref object of OpenApiRestCall_579437
proc url_DfareportingAccountsGet_580249(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsGet_580248(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Account ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580250 = path.getOrDefault("profileId")
  valid_580250 = validateParameter(valid_580250, JString, required = true,
                                 default = nil)
  if valid_580250 != nil:
    section.add "profileId", valid_580250
  var valid_580251 = path.getOrDefault("id")
  valid_580251 = validateParameter(valid_580251, JString, required = true,
                                 default = nil)
  if valid_580251 != nil:
    section.add "id", valid_580251
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580252 = query.getOrDefault("fields")
  valid_580252 = validateParameter(valid_580252, JString, required = false,
                                 default = nil)
  if valid_580252 != nil:
    section.add "fields", valid_580252
  var valid_580253 = query.getOrDefault("quotaUser")
  valid_580253 = validateParameter(valid_580253, JString, required = false,
                                 default = nil)
  if valid_580253 != nil:
    section.add "quotaUser", valid_580253
  var valid_580254 = query.getOrDefault("alt")
  valid_580254 = validateParameter(valid_580254, JString, required = false,
                                 default = newJString("json"))
  if valid_580254 != nil:
    section.add "alt", valid_580254
  var valid_580255 = query.getOrDefault("oauth_token")
  valid_580255 = validateParameter(valid_580255, JString, required = false,
                                 default = nil)
  if valid_580255 != nil:
    section.add "oauth_token", valid_580255
  var valid_580256 = query.getOrDefault("userIp")
  valid_580256 = validateParameter(valid_580256, JString, required = false,
                                 default = nil)
  if valid_580256 != nil:
    section.add "userIp", valid_580256
  var valid_580257 = query.getOrDefault("key")
  valid_580257 = validateParameter(valid_580257, JString, required = false,
                                 default = nil)
  if valid_580257 != nil:
    section.add "key", valid_580257
  var valid_580258 = query.getOrDefault("prettyPrint")
  valid_580258 = validateParameter(valid_580258, JBool, required = false,
                                 default = newJBool(true))
  if valid_580258 != nil:
    section.add "prettyPrint", valid_580258
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580259: Call_DfareportingAccountsGet_580247; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one account by ID.
  ## 
  let valid = call_580259.validator(path, query, header, formData, body)
  let scheme = call_580259.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580259.url(scheme.get, call_580259.host, call_580259.base,
                         call_580259.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580259, url, valid)

proc call*(call_580260: Call_DfareportingAccountsGet_580247; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingAccountsGet
  ## Gets one account by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Account ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580261 = newJObject()
  var query_580262 = newJObject()
  add(path_580261, "profileId", newJString(profileId))
  add(query_580262, "fields", newJString(fields))
  add(query_580262, "quotaUser", newJString(quotaUser))
  add(query_580262, "alt", newJString(alt))
  add(query_580262, "oauth_token", newJString(oauthToken))
  add(query_580262, "userIp", newJString(userIp))
  add(path_580261, "id", newJString(id))
  add(query_580262, "key", newJString(key))
  add(query_580262, "prettyPrint", newJBool(prettyPrint))
  result = call_580260.call(path_580261, query_580262, nil, nil, nil)

var dfareportingAccountsGet* = Call_DfareportingAccountsGet_580247(
    name: "dfareportingAccountsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts/{id}",
    validator: validate_DfareportingAccountsGet_580248,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsGet_580249,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdsUpdate_580301 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdsUpdate_580303(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsUpdate_580302(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing ad.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580304 = path.getOrDefault("profileId")
  valid_580304 = validateParameter(valid_580304, JString, required = true,
                                 default = nil)
  if valid_580304 != nil:
    section.add "profileId", valid_580304
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580305 = query.getOrDefault("fields")
  valid_580305 = validateParameter(valid_580305, JString, required = false,
                                 default = nil)
  if valid_580305 != nil:
    section.add "fields", valid_580305
  var valid_580306 = query.getOrDefault("quotaUser")
  valid_580306 = validateParameter(valid_580306, JString, required = false,
                                 default = nil)
  if valid_580306 != nil:
    section.add "quotaUser", valid_580306
  var valid_580307 = query.getOrDefault("alt")
  valid_580307 = validateParameter(valid_580307, JString, required = false,
                                 default = newJString("json"))
  if valid_580307 != nil:
    section.add "alt", valid_580307
  var valid_580308 = query.getOrDefault("oauth_token")
  valid_580308 = validateParameter(valid_580308, JString, required = false,
                                 default = nil)
  if valid_580308 != nil:
    section.add "oauth_token", valid_580308
  var valid_580309 = query.getOrDefault("userIp")
  valid_580309 = validateParameter(valid_580309, JString, required = false,
                                 default = nil)
  if valid_580309 != nil:
    section.add "userIp", valid_580309
  var valid_580310 = query.getOrDefault("key")
  valid_580310 = validateParameter(valid_580310, JString, required = false,
                                 default = nil)
  if valid_580310 != nil:
    section.add "key", valid_580310
  var valid_580311 = query.getOrDefault("prettyPrint")
  valid_580311 = validateParameter(valid_580311, JBool, required = false,
                                 default = newJBool(true))
  if valid_580311 != nil:
    section.add "prettyPrint", valid_580311
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580313: Call_DfareportingAdsUpdate_580301; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing ad.
  ## 
  let valid = call_580313.validator(path, query, header, formData, body)
  let scheme = call_580313.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580313.url(scheme.get, call_580313.host, call_580313.base,
                         call_580313.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580313, url, valid)

proc call*(call_580314: Call_DfareportingAdsUpdate_580301; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdsUpdate
  ## Updates an existing ad.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580315 = newJObject()
  var query_580316 = newJObject()
  var body_580317 = newJObject()
  add(path_580315, "profileId", newJString(profileId))
  add(query_580316, "fields", newJString(fields))
  add(query_580316, "quotaUser", newJString(quotaUser))
  add(query_580316, "alt", newJString(alt))
  add(query_580316, "oauth_token", newJString(oauthToken))
  add(query_580316, "userIp", newJString(userIp))
  add(query_580316, "key", newJString(key))
  if body != nil:
    body_580317 = body
  add(query_580316, "prettyPrint", newJBool(prettyPrint))
  result = call_580314.call(path_580315, query_580316, nil, nil, body_580317)

var dfareportingAdsUpdate* = Call_DfareportingAdsUpdate_580301(
    name: "dfareportingAdsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsUpdate_580302, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsUpdate_580303, schemes: {Scheme.Https})
type
  Call_DfareportingAdsInsert_580318 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdsInsert_580320(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsInsert_580319(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new ad.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580321 = path.getOrDefault("profileId")
  valid_580321 = validateParameter(valid_580321, JString, required = true,
                                 default = nil)
  if valid_580321 != nil:
    section.add "profileId", valid_580321
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580322 = query.getOrDefault("fields")
  valid_580322 = validateParameter(valid_580322, JString, required = false,
                                 default = nil)
  if valid_580322 != nil:
    section.add "fields", valid_580322
  var valid_580323 = query.getOrDefault("quotaUser")
  valid_580323 = validateParameter(valid_580323, JString, required = false,
                                 default = nil)
  if valid_580323 != nil:
    section.add "quotaUser", valid_580323
  var valid_580324 = query.getOrDefault("alt")
  valid_580324 = validateParameter(valid_580324, JString, required = false,
                                 default = newJString("json"))
  if valid_580324 != nil:
    section.add "alt", valid_580324
  var valid_580325 = query.getOrDefault("oauth_token")
  valid_580325 = validateParameter(valid_580325, JString, required = false,
                                 default = nil)
  if valid_580325 != nil:
    section.add "oauth_token", valid_580325
  var valid_580326 = query.getOrDefault("userIp")
  valid_580326 = validateParameter(valid_580326, JString, required = false,
                                 default = nil)
  if valid_580326 != nil:
    section.add "userIp", valid_580326
  var valid_580327 = query.getOrDefault("key")
  valid_580327 = validateParameter(valid_580327, JString, required = false,
                                 default = nil)
  if valid_580327 != nil:
    section.add "key", valid_580327
  var valid_580328 = query.getOrDefault("prettyPrint")
  valid_580328 = validateParameter(valid_580328, JBool, required = false,
                                 default = newJBool(true))
  if valid_580328 != nil:
    section.add "prettyPrint", valid_580328
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580330: Call_DfareportingAdsInsert_580318; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new ad.
  ## 
  let valid = call_580330.validator(path, query, header, formData, body)
  let scheme = call_580330.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580330.url(scheme.get, call_580330.host, call_580330.base,
                         call_580330.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580330, url, valid)

proc call*(call_580331: Call_DfareportingAdsInsert_580318; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdsInsert
  ## Inserts a new ad.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580332 = newJObject()
  var query_580333 = newJObject()
  var body_580334 = newJObject()
  add(path_580332, "profileId", newJString(profileId))
  add(query_580333, "fields", newJString(fields))
  add(query_580333, "quotaUser", newJString(quotaUser))
  add(query_580333, "alt", newJString(alt))
  add(query_580333, "oauth_token", newJString(oauthToken))
  add(query_580333, "userIp", newJString(userIp))
  add(query_580333, "key", newJString(key))
  if body != nil:
    body_580334 = body
  add(query_580333, "prettyPrint", newJBool(prettyPrint))
  result = call_580331.call(path_580332, query_580333, nil, nil, body_580334)

var dfareportingAdsInsert* = Call_DfareportingAdsInsert_580318(
    name: "dfareportingAdsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsInsert_580319, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsInsert_580320, schemes: {Scheme.Https})
type
  Call_DfareportingAdsList_580263 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdsList_580265(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsList_580264(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Retrieves a list of ads, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580266 = path.getOrDefault("profileId")
  valid_580266 = validateParameter(valid_580266, JString, required = true,
                                 default = nil)
  if valid_580266 != nil:
    section.add "profileId", valid_580266
  result.add "path", section
  ## parameters in `query` object:
  ##   overriddenEventTagId: JString
  ##                       : Select only ads with this event tag override ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   creativeIds: JArray
  ##              : Select only ads with these creative IDs assigned.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   sslCompliant: JBool
  ##               : Select only ads that are SSL-compliant.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "ad*2015" will return objects with names like "ad June 2015", "ad April 2015", or simply "ad 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "ad" will match objects with name "my ad", "ad 2015", or simply "ad".
  ##   advertiserId: JString
  ##               : Select only ads with this advertiser ID.
  ##   dynamicClickTracker: JBool
  ##                      : Select only dynamic click trackers. Applicable when type is AD_SERVING_CLICK_TRACKER. If true, select dynamic click trackers. If false, select static click trackers. Leave unset to select both.
  ##   sizeIds: JArray
  ##          : Select only ads with these size IDs.
  ##   type: JArray
  ##       : Select only ads with these types.
  ##   active: JBool
  ##         : Select only active ads.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   campaignIds: JArray
  ##              : Select only ads with these campaign IDs.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   creativeOptimizationConfigurationIds: JArray
  ##                                       : Select only ads with these creative optimization configuration IDs.
  ##   archived: JBool
  ##           : Select only archived ads.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only ads with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   compatibility: JString
  ##                : Select default ads with the specified compatibility. Applicable when type is AD_SERVING_DEFAULT_AD. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads, respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering an in-stream video ads developed with the VAST standard.
  ##   landingPageIds: JArray
  ##                 : Select only ads with these landing page IDs.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   remarketingListIds: JArray
  ##                     : Select only ads whose list targeting expression use these remarketing list IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   sslRequired: JBool
  ##              : Select only ads that require SSL.
  ##   audienceSegmentIds: JArray
  ##                     : Select only ads with these audience segment IDs.
  ##   placementIds: JArray
  ##               : Select only ads with these placement IDs assigned.
  section = newJObject()
  var valid_580267 = query.getOrDefault("overriddenEventTagId")
  valid_580267 = validateParameter(valid_580267, JString, required = false,
                                 default = nil)
  if valid_580267 != nil:
    section.add "overriddenEventTagId", valid_580267
  var valid_580268 = query.getOrDefault("fields")
  valid_580268 = validateParameter(valid_580268, JString, required = false,
                                 default = nil)
  if valid_580268 != nil:
    section.add "fields", valid_580268
  var valid_580269 = query.getOrDefault("creativeIds")
  valid_580269 = validateParameter(valid_580269, JArray, required = false,
                                 default = nil)
  if valid_580269 != nil:
    section.add "creativeIds", valid_580269
  var valid_580270 = query.getOrDefault("quotaUser")
  valid_580270 = validateParameter(valid_580270, JString, required = false,
                                 default = nil)
  if valid_580270 != nil:
    section.add "quotaUser", valid_580270
  var valid_580271 = query.getOrDefault("pageToken")
  valid_580271 = validateParameter(valid_580271, JString, required = false,
                                 default = nil)
  if valid_580271 != nil:
    section.add "pageToken", valid_580271
  var valid_580272 = query.getOrDefault("sortField")
  valid_580272 = validateParameter(valid_580272, JString, required = false,
                                 default = newJString("ID"))
  if valid_580272 != nil:
    section.add "sortField", valid_580272
  var valid_580273 = query.getOrDefault("alt")
  valid_580273 = validateParameter(valid_580273, JString, required = false,
                                 default = newJString("json"))
  if valid_580273 != nil:
    section.add "alt", valid_580273
  var valid_580274 = query.getOrDefault("sslCompliant")
  valid_580274 = validateParameter(valid_580274, JBool, required = false, default = nil)
  if valid_580274 != nil:
    section.add "sslCompliant", valid_580274
  var valid_580275 = query.getOrDefault("searchString")
  valid_580275 = validateParameter(valid_580275, JString, required = false,
                                 default = nil)
  if valid_580275 != nil:
    section.add "searchString", valid_580275
  var valid_580276 = query.getOrDefault("advertiserId")
  valid_580276 = validateParameter(valid_580276, JString, required = false,
                                 default = nil)
  if valid_580276 != nil:
    section.add "advertiserId", valid_580276
  var valid_580277 = query.getOrDefault("dynamicClickTracker")
  valid_580277 = validateParameter(valid_580277, JBool, required = false, default = nil)
  if valid_580277 != nil:
    section.add "dynamicClickTracker", valid_580277
  var valid_580278 = query.getOrDefault("sizeIds")
  valid_580278 = validateParameter(valid_580278, JArray, required = false,
                                 default = nil)
  if valid_580278 != nil:
    section.add "sizeIds", valid_580278
  var valid_580279 = query.getOrDefault("type")
  valid_580279 = validateParameter(valid_580279, JArray, required = false,
                                 default = nil)
  if valid_580279 != nil:
    section.add "type", valid_580279
  var valid_580280 = query.getOrDefault("active")
  valid_580280 = validateParameter(valid_580280, JBool, required = false, default = nil)
  if valid_580280 != nil:
    section.add "active", valid_580280
  var valid_580281 = query.getOrDefault("oauth_token")
  valid_580281 = validateParameter(valid_580281, JString, required = false,
                                 default = nil)
  if valid_580281 != nil:
    section.add "oauth_token", valid_580281
  var valid_580282 = query.getOrDefault("campaignIds")
  valid_580282 = validateParameter(valid_580282, JArray, required = false,
                                 default = nil)
  if valid_580282 != nil:
    section.add "campaignIds", valid_580282
  var valid_580283 = query.getOrDefault("userIp")
  valid_580283 = validateParameter(valid_580283, JString, required = false,
                                 default = nil)
  if valid_580283 != nil:
    section.add "userIp", valid_580283
  var valid_580284 = query.getOrDefault("creativeOptimizationConfigurationIds")
  valid_580284 = validateParameter(valid_580284, JArray, required = false,
                                 default = nil)
  if valid_580284 != nil:
    section.add "creativeOptimizationConfigurationIds", valid_580284
  var valid_580285 = query.getOrDefault("archived")
  valid_580285 = validateParameter(valid_580285, JBool, required = false, default = nil)
  if valid_580285 != nil:
    section.add "archived", valid_580285
  var valid_580286 = query.getOrDefault("maxResults")
  valid_580286 = validateParameter(valid_580286, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580286 != nil:
    section.add "maxResults", valid_580286
  var valid_580287 = query.getOrDefault("ids")
  valid_580287 = validateParameter(valid_580287, JArray, required = false,
                                 default = nil)
  if valid_580287 != nil:
    section.add "ids", valid_580287
  var valid_580288 = query.getOrDefault("key")
  valid_580288 = validateParameter(valid_580288, JString, required = false,
                                 default = nil)
  if valid_580288 != nil:
    section.add "key", valid_580288
  var valid_580289 = query.getOrDefault("compatibility")
  valid_580289 = validateParameter(valid_580289, JString, required = false,
                                 default = newJString("APP"))
  if valid_580289 != nil:
    section.add "compatibility", valid_580289
  var valid_580290 = query.getOrDefault("landingPageIds")
  valid_580290 = validateParameter(valid_580290, JArray, required = false,
                                 default = nil)
  if valid_580290 != nil:
    section.add "landingPageIds", valid_580290
  var valid_580291 = query.getOrDefault("sortOrder")
  valid_580291 = validateParameter(valid_580291, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580291 != nil:
    section.add "sortOrder", valid_580291
  var valid_580292 = query.getOrDefault("remarketingListIds")
  valid_580292 = validateParameter(valid_580292, JArray, required = false,
                                 default = nil)
  if valid_580292 != nil:
    section.add "remarketingListIds", valid_580292
  var valid_580293 = query.getOrDefault("prettyPrint")
  valid_580293 = validateParameter(valid_580293, JBool, required = false,
                                 default = newJBool(true))
  if valid_580293 != nil:
    section.add "prettyPrint", valid_580293
  var valid_580294 = query.getOrDefault("sslRequired")
  valid_580294 = validateParameter(valid_580294, JBool, required = false, default = nil)
  if valid_580294 != nil:
    section.add "sslRequired", valid_580294
  var valid_580295 = query.getOrDefault("audienceSegmentIds")
  valid_580295 = validateParameter(valid_580295, JArray, required = false,
                                 default = nil)
  if valid_580295 != nil:
    section.add "audienceSegmentIds", valid_580295
  var valid_580296 = query.getOrDefault("placementIds")
  valid_580296 = validateParameter(valid_580296, JArray, required = false,
                                 default = nil)
  if valid_580296 != nil:
    section.add "placementIds", valid_580296
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580297: Call_DfareportingAdsList_580263; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of ads, possibly filtered. This method supports paging.
  ## 
  let valid = call_580297.validator(path, query, header, formData, body)
  let scheme = call_580297.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580297.url(scheme.get, call_580297.host, call_580297.base,
                         call_580297.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580297, url, valid)

proc call*(call_580298: Call_DfareportingAdsList_580263; profileId: string;
          overriddenEventTagId: string = ""; fields: string = "";
          creativeIds: JsonNode = nil; quotaUser: string = ""; pageToken: string = "";
          sortField: string = "ID"; alt: string = "json"; sslCompliant: bool = false;
          searchString: string = ""; advertiserId: string = "";
          dynamicClickTracker: bool = false; sizeIds: JsonNode = nil;
          `type`: JsonNode = nil; active: bool = false; oauthToken: string = "";
          campaignIds: JsonNode = nil; userIp: string = "";
          creativeOptimizationConfigurationIds: JsonNode = nil;
          archived: bool = false; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; compatibility: string = "APP";
          landingPageIds: JsonNode = nil; sortOrder: string = "ASCENDING";
          remarketingListIds: JsonNode = nil; prettyPrint: bool = true;
          sslRequired: bool = false; audienceSegmentIds: JsonNode = nil;
          placementIds: JsonNode = nil): Recallable =
  ## dfareportingAdsList
  ## Retrieves a list of ads, possibly filtered. This method supports paging.
  ##   overriddenEventTagId: string
  ##                       : Select only ads with this event tag override ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   creativeIds: JArray
  ##              : Select only ads with these creative IDs assigned.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   sslCompliant: bool
  ##               : Select only ads that are SSL-compliant.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "ad*2015" will return objects with names like "ad June 2015", "ad April 2015", or simply "ad 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "ad" will match objects with name "my ad", "ad 2015", or simply "ad".
  ##   advertiserId: string
  ##               : Select only ads with this advertiser ID.
  ##   dynamicClickTracker: bool
  ##                      : Select only dynamic click trackers. Applicable when type is AD_SERVING_CLICK_TRACKER. If true, select dynamic click trackers. If false, select static click trackers. Leave unset to select both.
  ##   sizeIds: JArray
  ##          : Select only ads with these size IDs.
  ##   type: JArray
  ##       : Select only ads with these types.
  ##   active: bool
  ##         : Select only active ads.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   campaignIds: JArray
  ##              : Select only ads with these campaign IDs.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   creativeOptimizationConfigurationIds: JArray
  ##                                       : Select only ads with these creative optimization configuration IDs.
  ##   archived: bool
  ##           : Select only archived ads.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only ads with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   compatibility: string
  ##                : Select default ads with the specified compatibility. Applicable when type is AD_SERVING_DEFAULT_AD. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads, respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering an in-stream video ads developed with the VAST standard.
  ##   landingPageIds: JArray
  ##                 : Select only ads with these landing page IDs.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   remarketingListIds: JArray
  ##                     : Select only ads whose list targeting expression use these remarketing list IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   sslRequired: bool
  ##              : Select only ads that require SSL.
  ##   audienceSegmentIds: JArray
  ##                     : Select only ads with these audience segment IDs.
  ##   placementIds: JArray
  ##               : Select only ads with these placement IDs assigned.
  var path_580299 = newJObject()
  var query_580300 = newJObject()
  add(query_580300, "overriddenEventTagId", newJString(overriddenEventTagId))
  add(path_580299, "profileId", newJString(profileId))
  add(query_580300, "fields", newJString(fields))
  if creativeIds != nil:
    query_580300.add "creativeIds", creativeIds
  add(query_580300, "quotaUser", newJString(quotaUser))
  add(query_580300, "pageToken", newJString(pageToken))
  add(query_580300, "sortField", newJString(sortField))
  add(query_580300, "alt", newJString(alt))
  add(query_580300, "sslCompliant", newJBool(sslCompliant))
  add(query_580300, "searchString", newJString(searchString))
  add(query_580300, "advertiserId", newJString(advertiserId))
  add(query_580300, "dynamicClickTracker", newJBool(dynamicClickTracker))
  if sizeIds != nil:
    query_580300.add "sizeIds", sizeIds
  if `type` != nil:
    query_580300.add "type", `type`
  add(query_580300, "active", newJBool(active))
  add(query_580300, "oauth_token", newJString(oauthToken))
  if campaignIds != nil:
    query_580300.add "campaignIds", campaignIds
  add(query_580300, "userIp", newJString(userIp))
  if creativeOptimizationConfigurationIds != nil:
    query_580300.add "creativeOptimizationConfigurationIds",
                    creativeOptimizationConfigurationIds
  add(query_580300, "archived", newJBool(archived))
  add(query_580300, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_580300.add "ids", ids
  add(query_580300, "key", newJString(key))
  add(query_580300, "compatibility", newJString(compatibility))
  if landingPageIds != nil:
    query_580300.add "landingPageIds", landingPageIds
  add(query_580300, "sortOrder", newJString(sortOrder))
  if remarketingListIds != nil:
    query_580300.add "remarketingListIds", remarketingListIds
  add(query_580300, "prettyPrint", newJBool(prettyPrint))
  add(query_580300, "sslRequired", newJBool(sslRequired))
  if audienceSegmentIds != nil:
    query_580300.add "audienceSegmentIds", audienceSegmentIds
  if placementIds != nil:
    query_580300.add "placementIds", placementIds
  result = call_580298.call(path_580299, query_580300, nil, nil, nil)

var dfareportingAdsList* = Call_DfareportingAdsList_580263(
    name: "dfareportingAdsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsList_580264, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsList_580265, schemes: {Scheme.Https})
type
  Call_DfareportingAdsPatch_580335 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdsPatch_580337(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsPatch_580336(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing ad. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580338 = path.getOrDefault("profileId")
  valid_580338 = validateParameter(valid_580338, JString, required = true,
                                 default = nil)
  if valid_580338 != nil:
    section.add "profileId", valid_580338
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Ad ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580339 = query.getOrDefault("fields")
  valid_580339 = validateParameter(valid_580339, JString, required = false,
                                 default = nil)
  if valid_580339 != nil:
    section.add "fields", valid_580339
  var valid_580340 = query.getOrDefault("quotaUser")
  valid_580340 = validateParameter(valid_580340, JString, required = false,
                                 default = nil)
  if valid_580340 != nil:
    section.add "quotaUser", valid_580340
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580341 = query.getOrDefault("id")
  valid_580341 = validateParameter(valid_580341, JString, required = true,
                                 default = nil)
  if valid_580341 != nil:
    section.add "id", valid_580341
  var valid_580342 = query.getOrDefault("alt")
  valid_580342 = validateParameter(valid_580342, JString, required = false,
                                 default = newJString("json"))
  if valid_580342 != nil:
    section.add "alt", valid_580342
  var valid_580343 = query.getOrDefault("oauth_token")
  valid_580343 = validateParameter(valid_580343, JString, required = false,
                                 default = nil)
  if valid_580343 != nil:
    section.add "oauth_token", valid_580343
  var valid_580344 = query.getOrDefault("userIp")
  valid_580344 = validateParameter(valid_580344, JString, required = false,
                                 default = nil)
  if valid_580344 != nil:
    section.add "userIp", valid_580344
  var valid_580345 = query.getOrDefault("key")
  valid_580345 = validateParameter(valid_580345, JString, required = false,
                                 default = nil)
  if valid_580345 != nil:
    section.add "key", valid_580345
  var valid_580346 = query.getOrDefault("prettyPrint")
  valid_580346 = validateParameter(valid_580346, JBool, required = false,
                                 default = newJBool(true))
  if valid_580346 != nil:
    section.add "prettyPrint", valid_580346
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580348: Call_DfareportingAdsPatch_580335; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing ad. This method supports patch semantics.
  ## 
  let valid = call_580348.validator(path, query, header, formData, body)
  let scheme = call_580348.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580348.url(scheme.get, call_580348.host, call_580348.base,
                         call_580348.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580348, url, valid)

proc call*(call_580349: Call_DfareportingAdsPatch_580335; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdsPatch
  ## Updates an existing ad. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Ad ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580350 = newJObject()
  var query_580351 = newJObject()
  var body_580352 = newJObject()
  add(path_580350, "profileId", newJString(profileId))
  add(query_580351, "fields", newJString(fields))
  add(query_580351, "quotaUser", newJString(quotaUser))
  add(query_580351, "id", newJString(id))
  add(query_580351, "alt", newJString(alt))
  add(query_580351, "oauth_token", newJString(oauthToken))
  add(query_580351, "userIp", newJString(userIp))
  add(query_580351, "key", newJString(key))
  if body != nil:
    body_580352 = body
  add(query_580351, "prettyPrint", newJBool(prettyPrint))
  result = call_580349.call(path_580350, query_580351, nil, nil, body_580352)

var dfareportingAdsPatch* = Call_DfareportingAdsPatch_580335(
    name: "dfareportingAdsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsPatch_580336, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsPatch_580337, schemes: {Scheme.Https})
type
  Call_DfareportingAdsGet_580353 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdsGet_580355(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsGet_580354(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Gets one ad by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Ad ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580356 = path.getOrDefault("profileId")
  valid_580356 = validateParameter(valid_580356, JString, required = true,
                                 default = nil)
  if valid_580356 != nil:
    section.add "profileId", valid_580356
  var valid_580357 = path.getOrDefault("id")
  valid_580357 = validateParameter(valid_580357, JString, required = true,
                                 default = nil)
  if valid_580357 != nil:
    section.add "id", valid_580357
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580358 = query.getOrDefault("fields")
  valid_580358 = validateParameter(valid_580358, JString, required = false,
                                 default = nil)
  if valid_580358 != nil:
    section.add "fields", valid_580358
  var valid_580359 = query.getOrDefault("quotaUser")
  valid_580359 = validateParameter(valid_580359, JString, required = false,
                                 default = nil)
  if valid_580359 != nil:
    section.add "quotaUser", valid_580359
  var valid_580360 = query.getOrDefault("alt")
  valid_580360 = validateParameter(valid_580360, JString, required = false,
                                 default = newJString("json"))
  if valid_580360 != nil:
    section.add "alt", valid_580360
  var valid_580361 = query.getOrDefault("oauth_token")
  valid_580361 = validateParameter(valid_580361, JString, required = false,
                                 default = nil)
  if valid_580361 != nil:
    section.add "oauth_token", valid_580361
  var valid_580362 = query.getOrDefault("userIp")
  valid_580362 = validateParameter(valid_580362, JString, required = false,
                                 default = nil)
  if valid_580362 != nil:
    section.add "userIp", valid_580362
  var valid_580363 = query.getOrDefault("key")
  valid_580363 = validateParameter(valid_580363, JString, required = false,
                                 default = nil)
  if valid_580363 != nil:
    section.add "key", valid_580363
  var valid_580364 = query.getOrDefault("prettyPrint")
  valid_580364 = validateParameter(valid_580364, JBool, required = false,
                                 default = newJBool(true))
  if valid_580364 != nil:
    section.add "prettyPrint", valid_580364
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580365: Call_DfareportingAdsGet_580353; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one ad by ID.
  ## 
  let valid = call_580365.validator(path, query, header, formData, body)
  let scheme = call_580365.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580365.url(scheme.get, call_580365.host, call_580365.base,
                         call_580365.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580365, url, valid)

proc call*(call_580366: Call_DfareportingAdsGet_580353; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingAdsGet
  ## Gets one ad by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Ad ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580367 = newJObject()
  var query_580368 = newJObject()
  add(path_580367, "profileId", newJString(profileId))
  add(query_580368, "fields", newJString(fields))
  add(query_580368, "quotaUser", newJString(quotaUser))
  add(query_580368, "alt", newJString(alt))
  add(query_580368, "oauth_token", newJString(oauthToken))
  add(query_580368, "userIp", newJString(userIp))
  add(path_580367, "id", newJString(id))
  add(query_580368, "key", newJString(key))
  add(query_580368, "prettyPrint", newJBool(prettyPrint))
  result = call_580366.call(path_580367, query_580368, nil, nil, nil)

var dfareportingAdsGet* = Call_DfareportingAdsGet_580353(
    name: "dfareportingAdsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads/{id}",
    validator: validate_DfareportingAdsGet_580354, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsGet_580355, schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsUpdate_580390 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdvertiserGroupsUpdate_580392(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsUpdate_580391(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580393 = path.getOrDefault("profileId")
  valid_580393 = validateParameter(valid_580393, JString, required = true,
                                 default = nil)
  if valid_580393 != nil:
    section.add "profileId", valid_580393
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580394 = query.getOrDefault("fields")
  valid_580394 = validateParameter(valid_580394, JString, required = false,
                                 default = nil)
  if valid_580394 != nil:
    section.add "fields", valid_580394
  var valid_580395 = query.getOrDefault("quotaUser")
  valid_580395 = validateParameter(valid_580395, JString, required = false,
                                 default = nil)
  if valid_580395 != nil:
    section.add "quotaUser", valid_580395
  var valid_580396 = query.getOrDefault("alt")
  valid_580396 = validateParameter(valid_580396, JString, required = false,
                                 default = newJString("json"))
  if valid_580396 != nil:
    section.add "alt", valid_580396
  var valid_580397 = query.getOrDefault("oauth_token")
  valid_580397 = validateParameter(valid_580397, JString, required = false,
                                 default = nil)
  if valid_580397 != nil:
    section.add "oauth_token", valid_580397
  var valid_580398 = query.getOrDefault("userIp")
  valid_580398 = validateParameter(valid_580398, JString, required = false,
                                 default = nil)
  if valid_580398 != nil:
    section.add "userIp", valid_580398
  var valid_580399 = query.getOrDefault("key")
  valid_580399 = validateParameter(valid_580399, JString, required = false,
                                 default = nil)
  if valid_580399 != nil:
    section.add "key", valid_580399
  var valid_580400 = query.getOrDefault("prettyPrint")
  valid_580400 = validateParameter(valid_580400, JBool, required = false,
                                 default = newJBool(true))
  if valid_580400 != nil:
    section.add "prettyPrint", valid_580400
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580402: Call_DfareportingAdvertiserGroupsUpdate_580390;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing advertiser group.
  ## 
  let valid = call_580402.validator(path, query, header, formData, body)
  let scheme = call_580402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580402.url(scheme.get, call_580402.host, call_580402.base,
                         call_580402.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580402, url, valid)

proc call*(call_580403: Call_DfareportingAdvertiserGroupsUpdate_580390;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsUpdate
  ## Updates an existing advertiser group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580404 = newJObject()
  var query_580405 = newJObject()
  var body_580406 = newJObject()
  add(path_580404, "profileId", newJString(profileId))
  add(query_580405, "fields", newJString(fields))
  add(query_580405, "quotaUser", newJString(quotaUser))
  add(query_580405, "alt", newJString(alt))
  add(query_580405, "oauth_token", newJString(oauthToken))
  add(query_580405, "userIp", newJString(userIp))
  add(query_580405, "key", newJString(key))
  if body != nil:
    body_580406 = body
  add(query_580405, "prettyPrint", newJBool(prettyPrint))
  result = call_580403.call(path_580404, query_580405, nil, nil, body_580406)

var dfareportingAdvertiserGroupsUpdate* = Call_DfareportingAdvertiserGroupsUpdate_580390(
    name: "dfareportingAdvertiserGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsUpdate_580391,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsUpdate_580392,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsInsert_580407 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdvertiserGroupsInsert_580409(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsInsert_580408(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new advertiser group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580410 = path.getOrDefault("profileId")
  valid_580410 = validateParameter(valid_580410, JString, required = true,
                                 default = nil)
  if valid_580410 != nil:
    section.add "profileId", valid_580410
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580411 = query.getOrDefault("fields")
  valid_580411 = validateParameter(valid_580411, JString, required = false,
                                 default = nil)
  if valid_580411 != nil:
    section.add "fields", valid_580411
  var valid_580412 = query.getOrDefault("quotaUser")
  valid_580412 = validateParameter(valid_580412, JString, required = false,
                                 default = nil)
  if valid_580412 != nil:
    section.add "quotaUser", valid_580412
  var valid_580413 = query.getOrDefault("alt")
  valid_580413 = validateParameter(valid_580413, JString, required = false,
                                 default = newJString("json"))
  if valid_580413 != nil:
    section.add "alt", valid_580413
  var valid_580414 = query.getOrDefault("oauth_token")
  valid_580414 = validateParameter(valid_580414, JString, required = false,
                                 default = nil)
  if valid_580414 != nil:
    section.add "oauth_token", valid_580414
  var valid_580415 = query.getOrDefault("userIp")
  valid_580415 = validateParameter(valid_580415, JString, required = false,
                                 default = nil)
  if valid_580415 != nil:
    section.add "userIp", valid_580415
  var valid_580416 = query.getOrDefault("key")
  valid_580416 = validateParameter(valid_580416, JString, required = false,
                                 default = nil)
  if valid_580416 != nil:
    section.add "key", valid_580416
  var valid_580417 = query.getOrDefault("prettyPrint")
  valid_580417 = validateParameter(valid_580417, JBool, required = false,
                                 default = newJBool(true))
  if valid_580417 != nil:
    section.add "prettyPrint", valid_580417
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580419: Call_DfareportingAdvertiserGroupsInsert_580407;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new advertiser group.
  ## 
  let valid = call_580419.validator(path, query, header, formData, body)
  let scheme = call_580419.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580419.url(scheme.get, call_580419.host, call_580419.base,
                         call_580419.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580419, url, valid)

proc call*(call_580420: Call_DfareportingAdvertiserGroupsInsert_580407;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsInsert
  ## Inserts a new advertiser group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580421 = newJObject()
  var query_580422 = newJObject()
  var body_580423 = newJObject()
  add(path_580421, "profileId", newJString(profileId))
  add(query_580422, "fields", newJString(fields))
  add(query_580422, "quotaUser", newJString(quotaUser))
  add(query_580422, "alt", newJString(alt))
  add(query_580422, "oauth_token", newJString(oauthToken))
  add(query_580422, "userIp", newJString(userIp))
  add(query_580422, "key", newJString(key))
  if body != nil:
    body_580423 = body
  add(query_580422, "prettyPrint", newJBool(prettyPrint))
  result = call_580420.call(path_580421, query_580422, nil, nil, body_580423)

var dfareportingAdvertiserGroupsInsert* = Call_DfareportingAdvertiserGroupsInsert_580407(
    name: "dfareportingAdvertiserGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsInsert_580408,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsInsert_580409,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsList_580369 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdvertiserGroupsList_580371(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsList_580370(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of advertiser groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580372 = path.getOrDefault("profileId")
  valid_580372 = validateParameter(valid_580372, JString, required = true,
                                 default = nil)
  if valid_580372 != nil:
    section.add "profileId", valid_580372
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser group June 2015", "advertiser group April 2015", or simply "advertiser group 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertisergroup" will match objects with name "my advertisergroup", "advertisergroup 2015", or simply "advertisergroup".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only advertiser groups with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580373 = query.getOrDefault("fields")
  valid_580373 = validateParameter(valid_580373, JString, required = false,
                                 default = nil)
  if valid_580373 != nil:
    section.add "fields", valid_580373
  var valid_580374 = query.getOrDefault("pageToken")
  valid_580374 = validateParameter(valid_580374, JString, required = false,
                                 default = nil)
  if valid_580374 != nil:
    section.add "pageToken", valid_580374
  var valid_580375 = query.getOrDefault("quotaUser")
  valid_580375 = validateParameter(valid_580375, JString, required = false,
                                 default = nil)
  if valid_580375 != nil:
    section.add "quotaUser", valid_580375
  var valid_580376 = query.getOrDefault("sortField")
  valid_580376 = validateParameter(valid_580376, JString, required = false,
                                 default = newJString("ID"))
  if valid_580376 != nil:
    section.add "sortField", valid_580376
  var valid_580377 = query.getOrDefault("alt")
  valid_580377 = validateParameter(valid_580377, JString, required = false,
                                 default = newJString("json"))
  if valid_580377 != nil:
    section.add "alt", valid_580377
  var valid_580378 = query.getOrDefault("searchString")
  valid_580378 = validateParameter(valid_580378, JString, required = false,
                                 default = nil)
  if valid_580378 != nil:
    section.add "searchString", valid_580378
  var valid_580379 = query.getOrDefault("oauth_token")
  valid_580379 = validateParameter(valid_580379, JString, required = false,
                                 default = nil)
  if valid_580379 != nil:
    section.add "oauth_token", valid_580379
  var valid_580380 = query.getOrDefault("userIp")
  valid_580380 = validateParameter(valid_580380, JString, required = false,
                                 default = nil)
  if valid_580380 != nil:
    section.add "userIp", valid_580380
  var valid_580381 = query.getOrDefault("maxResults")
  valid_580381 = validateParameter(valid_580381, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580381 != nil:
    section.add "maxResults", valid_580381
  var valid_580382 = query.getOrDefault("ids")
  valid_580382 = validateParameter(valid_580382, JArray, required = false,
                                 default = nil)
  if valid_580382 != nil:
    section.add "ids", valid_580382
  var valid_580383 = query.getOrDefault("key")
  valid_580383 = validateParameter(valid_580383, JString, required = false,
                                 default = nil)
  if valid_580383 != nil:
    section.add "key", valid_580383
  var valid_580384 = query.getOrDefault("sortOrder")
  valid_580384 = validateParameter(valid_580384, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580384 != nil:
    section.add "sortOrder", valid_580384
  var valid_580385 = query.getOrDefault("prettyPrint")
  valid_580385 = validateParameter(valid_580385, JBool, required = false,
                                 default = newJBool(true))
  if valid_580385 != nil:
    section.add "prettyPrint", valid_580385
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580386: Call_DfareportingAdvertiserGroupsList_580369;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of advertiser groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_580386.validator(path, query, header, formData, body)
  let scheme = call_580386.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580386.url(scheme.get, call_580386.host, call_580386.base,
                         call_580386.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580386, url, valid)

proc call*(call_580387: Call_DfareportingAdvertiserGroupsList_580369;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsList
  ## Retrieves a list of advertiser groups, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser group June 2015", "advertiser group April 2015", or simply "advertiser group 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertisergroup" will match objects with name "my advertisergroup", "advertisergroup 2015", or simply "advertisergroup".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only advertiser groups with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580388 = newJObject()
  var query_580389 = newJObject()
  add(path_580388, "profileId", newJString(profileId))
  add(query_580389, "fields", newJString(fields))
  add(query_580389, "pageToken", newJString(pageToken))
  add(query_580389, "quotaUser", newJString(quotaUser))
  add(query_580389, "sortField", newJString(sortField))
  add(query_580389, "alt", newJString(alt))
  add(query_580389, "searchString", newJString(searchString))
  add(query_580389, "oauth_token", newJString(oauthToken))
  add(query_580389, "userIp", newJString(userIp))
  add(query_580389, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_580389.add "ids", ids
  add(query_580389, "key", newJString(key))
  add(query_580389, "sortOrder", newJString(sortOrder))
  add(query_580389, "prettyPrint", newJBool(prettyPrint))
  result = call_580387.call(path_580388, query_580389, nil, nil, nil)

var dfareportingAdvertiserGroupsList* = Call_DfareportingAdvertiserGroupsList_580369(
    name: "dfareportingAdvertiserGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsList_580370,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsList_580371,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsPatch_580424 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdvertiserGroupsPatch_580426(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsPatch_580425(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580427 = path.getOrDefault("profileId")
  valid_580427 = validateParameter(valid_580427, JString, required = true,
                                 default = nil)
  if valid_580427 != nil:
    section.add "profileId", valid_580427
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Advertiser group ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580428 = query.getOrDefault("fields")
  valid_580428 = validateParameter(valid_580428, JString, required = false,
                                 default = nil)
  if valid_580428 != nil:
    section.add "fields", valid_580428
  var valid_580429 = query.getOrDefault("quotaUser")
  valid_580429 = validateParameter(valid_580429, JString, required = false,
                                 default = nil)
  if valid_580429 != nil:
    section.add "quotaUser", valid_580429
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580430 = query.getOrDefault("id")
  valid_580430 = validateParameter(valid_580430, JString, required = true,
                                 default = nil)
  if valid_580430 != nil:
    section.add "id", valid_580430
  var valid_580431 = query.getOrDefault("alt")
  valid_580431 = validateParameter(valid_580431, JString, required = false,
                                 default = newJString("json"))
  if valid_580431 != nil:
    section.add "alt", valid_580431
  var valid_580432 = query.getOrDefault("oauth_token")
  valid_580432 = validateParameter(valid_580432, JString, required = false,
                                 default = nil)
  if valid_580432 != nil:
    section.add "oauth_token", valid_580432
  var valid_580433 = query.getOrDefault("userIp")
  valid_580433 = validateParameter(valid_580433, JString, required = false,
                                 default = nil)
  if valid_580433 != nil:
    section.add "userIp", valid_580433
  var valid_580434 = query.getOrDefault("key")
  valid_580434 = validateParameter(valid_580434, JString, required = false,
                                 default = nil)
  if valid_580434 != nil:
    section.add "key", valid_580434
  var valid_580435 = query.getOrDefault("prettyPrint")
  valid_580435 = validateParameter(valid_580435, JBool, required = false,
                                 default = newJBool(true))
  if valid_580435 != nil:
    section.add "prettyPrint", valid_580435
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580437: Call_DfareportingAdvertiserGroupsPatch_580424;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing advertiser group. This method supports patch semantics.
  ## 
  let valid = call_580437.validator(path, query, header, formData, body)
  let scheme = call_580437.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580437.url(scheme.get, call_580437.host, call_580437.base,
                         call_580437.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580437, url, valid)

proc call*(call_580438: Call_DfareportingAdvertiserGroupsPatch_580424;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsPatch
  ## Updates an existing advertiser group. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Advertiser group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580439 = newJObject()
  var query_580440 = newJObject()
  var body_580441 = newJObject()
  add(path_580439, "profileId", newJString(profileId))
  add(query_580440, "fields", newJString(fields))
  add(query_580440, "quotaUser", newJString(quotaUser))
  add(query_580440, "id", newJString(id))
  add(query_580440, "alt", newJString(alt))
  add(query_580440, "oauth_token", newJString(oauthToken))
  add(query_580440, "userIp", newJString(userIp))
  add(query_580440, "key", newJString(key))
  if body != nil:
    body_580441 = body
  add(query_580440, "prettyPrint", newJBool(prettyPrint))
  result = call_580438.call(path_580439, query_580440, nil, nil, body_580441)

var dfareportingAdvertiserGroupsPatch* = Call_DfareportingAdvertiserGroupsPatch_580424(
    name: "dfareportingAdvertiserGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsPatch_580425,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsPatch_580426,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsGet_580442 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdvertiserGroupsGet_580444(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsGet_580443(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one advertiser group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Advertiser group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580445 = path.getOrDefault("profileId")
  valid_580445 = validateParameter(valid_580445, JString, required = true,
                                 default = nil)
  if valid_580445 != nil:
    section.add "profileId", valid_580445
  var valid_580446 = path.getOrDefault("id")
  valid_580446 = validateParameter(valid_580446, JString, required = true,
                                 default = nil)
  if valid_580446 != nil:
    section.add "id", valid_580446
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580447 = query.getOrDefault("fields")
  valid_580447 = validateParameter(valid_580447, JString, required = false,
                                 default = nil)
  if valid_580447 != nil:
    section.add "fields", valid_580447
  var valid_580448 = query.getOrDefault("quotaUser")
  valid_580448 = validateParameter(valid_580448, JString, required = false,
                                 default = nil)
  if valid_580448 != nil:
    section.add "quotaUser", valid_580448
  var valid_580449 = query.getOrDefault("alt")
  valid_580449 = validateParameter(valid_580449, JString, required = false,
                                 default = newJString("json"))
  if valid_580449 != nil:
    section.add "alt", valid_580449
  var valid_580450 = query.getOrDefault("oauth_token")
  valid_580450 = validateParameter(valid_580450, JString, required = false,
                                 default = nil)
  if valid_580450 != nil:
    section.add "oauth_token", valid_580450
  var valid_580451 = query.getOrDefault("userIp")
  valid_580451 = validateParameter(valid_580451, JString, required = false,
                                 default = nil)
  if valid_580451 != nil:
    section.add "userIp", valid_580451
  var valid_580452 = query.getOrDefault("key")
  valid_580452 = validateParameter(valid_580452, JString, required = false,
                                 default = nil)
  if valid_580452 != nil:
    section.add "key", valid_580452
  var valid_580453 = query.getOrDefault("prettyPrint")
  valid_580453 = validateParameter(valid_580453, JBool, required = false,
                                 default = newJBool(true))
  if valid_580453 != nil:
    section.add "prettyPrint", valid_580453
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580454: Call_DfareportingAdvertiserGroupsGet_580442;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one advertiser group by ID.
  ## 
  let valid = call_580454.validator(path, query, header, formData, body)
  let scheme = call_580454.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580454.url(scheme.get, call_580454.host, call_580454.base,
                         call_580454.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580454, url, valid)

proc call*(call_580455: Call_DfareportingAdvertiserGroupsGet_580442;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsGet
  ## Gets one advertiser group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Advertiser group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580456 = newJObject()
  var query_580457 = newJObject()
  add(path_580456, "profileId", newJString(profileId))
  add(query_580457, "fields", newJString(fields))
  add(query_580457, "quotaUser", newJString(quotaUser))
  add(query_580457, "alt", newJString(alt))
  add(query_580457, "oauth_token", newJString(oauthToken))
  add(query_580457, "userIp", newJString(userIp))
  add(path_580456, "id", newJString(id))
  add(query_580457, "key", newJString(key))
  add(query_580457, "prettyPrint", newJBool(prettyPrint))
  result = call_580455.call(path_580456, query_580457, nil, nil, nil)

var dfareportingAdvertiserGroupsGet* = Call_DfareportingAdvertiserGroupsGet_580442(
    name: "dfareportingAdvertiserGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups/{id}",
    validator: validate_DfareportingAdvertiserGroupsGet_580443,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsGet_580444,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsDelete_580458 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdvertiserGroupsDelete_580460(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsDelete_580459(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing advertiser group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Advertiser group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580461 = path.getOrDefault("profileId")
  valid_580461 = validateParameter(valid_580461, JString, required = true,
                                 default = nil)
  if valid_580461 != nil:
    section.add "profileId", valid_580461
  var valid_580462 = path.getOrDefault("id")
  valid_580462 = validateParameter(valid_580462, JString, required = true,
                                 default = nil)
  if valid_580462 != nil:
    section.add "id", valid_580462
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580463 = query.getOrDefault("fields")
  valid_580463 = validateParameter(valid_580463, JString, required = false,
                                 default = nil)
  if valid_580463 != nil:
    section.add "fields", valid_580463
  var valid_580464 = query.getOrDefault("quotaUser")
  valid_580464 = validateParameter(valid_580464, JString, required = false,
                                 default = nil)
  if valid_580464 != nil:
    section.add "quotaUser", valid_580464
  var valid_580465 = query.getOrDefault("alt")
  valid_580465 = validateParameter(valid_580465, JString, required = false,
                                 default = newJString("json"))
  if valid_580465 != nil:
    section.add "alt", valid_580465
  var valid_580466 = query.getOrDefault("oauth_token")
  valid_580466 = validateParameter(valid_580466, JString, required = false,
                                 default = nil)
  if valid_580466 != nil:
    section.add "oauth_token", valid_580466
  var valid_580467 = query.getOrDefault("userIp")
  valid_580467 = validateParameter(valid_580467, JString, required = false,
                                 default = nil)
  if valid_580467 != nil:
    section.add "userIp", valid_580467
  var valid_580468 = query.getOrDefault("key")
  valid_580468 = validateParameter(valid_580468, JString, required = false,
                                 default = nil)
  if valid_580468 != nil:
    section.add "key", valid_580468
  var valid_580469 = query.getOrDefault("prettyPrint")
  valid_580469 = validateParameter(valid_580469, JBool, required = false,
                                 default = newJBool(true))
  if valid_580469 != nil:
    section.add "prettyPrint", valid_580469
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580470: Call_DfareportingAdvertiserGroupsDelete_580458;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing advertiser group.
  ## 
  let valid = call_580470.validator(path, query, header, formData, body)
  let scheme = call_580470.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580470.url(scheme.get, call_580470.host, call_580470.base,
                         call_580470.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580470, url, valid)

proc call*(call_580471: Call_DfareportingAdvertiserGroupsDelete_580458;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsDelete
  ## Deletes an existing advertiser group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Advertiser group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580472 = newJObject()
  var query_580473 = newJObject()
  add(path_580472, "profileId", newJString(profileId))
  add(query_580473, "fields", newJString(fields))
  add(query_580473, "quotaUser", newJString(quotaUser))
  add(query_580473, "alt", newJString(alt))
  add(query_580473, "oauth_token", newJString(oauthToken))
  add(query_580473, "userIp", newJString(userIp))
  add(path_580472, "id", newJString(id))
  add(query_580473, "key", newJString(key))
  add(query_580473, "prettyPrint", newJBool(prettyPrint))
  result = call_580471.call(path_580472, query_580473, nil, nil, nil)

var dfareportingAdvertiserGroupsDelete* = Call_DfareportingAdvertiserGroupsDelete_580458(
    name: "dfareportingAdvertiserGroupsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups/{id}",
    validator: validate_DfareportingAdvertiserGroupsDelete_580459,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsDelete_580460,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersUpdate_580501 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdvertisersUpdate_580503(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersUpdate_580502(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580504 = path.getOrDefault("profileId")
  valid_580504 = validateParameter(valid_580504, JString, required = true,
                                 default = nil)
  if valid_580504 != nil:
    section.add "profileId", valid_580504
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580505 = query.getOrDefault("fields")
  valid_580505 = validateParameter(valid_580505, JString, required = false,
                                 default = nil)
  if valid_580505 != nil:
    section.add "fields", valid_580505
  var valid_580506 = query.getOrDefault("quotaUser")
  valid_580506 = validateParameter(valid_580506, JString, required = false,
                                 default = nil)
  if valid_580506 != nil:
    section.add "quotaUser", valid_580506
  var valid_580507 = query.getOrDefault("alt")
  valid_580507 = validateParameter(valid_580507, JString, required = false,
                                 default = newJString("json"))
  if valid_580507 != nil:
    section.add "alt", valid_580507
  var valid_580508 = query.getOrDefault("oauth_token")
  valid_580508 = validateParameter(valid_580508, JString, required = false,
                                 default = nil)
  if valid_580508 != nil:
    section.add "oauth_token", valid_580508
  var valid_580509 = query.getOrDefault("userIp")
  valid_580509 = validateParameter(valid_580509, JString, required = false,
                                 default = nil)
  if valid_580509 != nil:
    section.add "userIp", valid_580509
  var valid_580510 = query.getOrDefault("key")
  valid_580510 = validateParameter(valid_580510, JString, required = false,
                                 default = nil)
  if valid_580510 != nil:
    section.add "key", valid_580510
  var valid_580511 = query.getOrDefault("prettyPrint")
  valid_580511 = validateParameter(valid_580511, JBool, required = false,
                                 default = newJBool(true))
  if valid_580511 != nil:
    section.add "prettyPrint", valid_580511
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580513: Call_DfareportingAdvertisersUpdate_580501; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing advertiser.
  ## 
  let valid = call_580513.validator(path, query, header, formData, body)
  let scheme = call_580513.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580513.url(scheme.get, call_580513.host, call_580513.base,
                         call_580513.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580513, url, valid)

proc call*(call_580514: Call_DfareportingAdvertisersUpdate_580501;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertisersUpdate
  ## Updates an existing advertiser.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580515 = newJObject()
  var query_580516 = newJObject()
  var body_580517 = newJObject()
  add(path_580515, "profileId", newJString(profileId))
  add(query_580516, "fields", newJString(fields))
  add(query_580516, "quotaUser", newJString(quotaUser))
  add(query_580516, "alt", newJString(alt))
  add(query_580516, "oauth_token", newJString(oauthToken))
  add(query_580516, "userIp", newJString(userIp))
  add(query_580516, "key", newJString(key))
  if body != nil:
    body_580517 = body
  add(query_580516, "prettyPrint", newJBool(prettyPrint))
  result = call_580514.call(path_580515, query_580516, nil, nil, body_580517)

var dfareportingAdvertisersUpdate* = Call_DfareportingAdvertisersUpdate_580501(
    name: "dfareportingAdvertisersUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersUpdate_580502,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersUpdate_580503,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersInsert_580518 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdvertisersInsert_580520(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersInsert_580519(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new advertiser.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580521 = path.getOrDefault("profileId")
  valid_580521 = validateParameter(valid_580521, JString, required = true,
                                 default = nil)
  if valid_580521 != nil:
    section.add "profileId", valid_580521
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580522 = query.getOrDefault("fields")
  valid_580522 = validateParameter(valid_580522, JString, required = false,
                                 default = nil)
  if valid_580522 != nil:
    section.add "fields", valid_580522
  var valid_580523 = query.getOrDefault("quotaUser")
  valid_580523 = validateParameter(valid_580523, JString, required = false,
                                 default = nil)
  if valid_580523 != nil:
    section.add "quotaUser", valid_580523
  var valid_580524 = query.getOrDefault("alt")
  valid_580524 = validateParameter(valid_580524, JString, required = false,
                                 default = newJString("json"))
  if valid_580524 != nil:
    section.add "alt", valid_580524
  var valid_580525 = query.getOrDefault("oauth_token")
  valid_580525 = validateParameter(valid_580525, JString, required = false,
                                 default = nil)
  if valid_580525 != nil:
    section.add "oauth_token", valid_580525
  var valid_580526 = query.getOrDefault("userIp")
  valid_580526 = validateParameter(valid_580526, JString, required = false,
                                 default = nil)
  if valid_580526 != nil:
    section.add "userIp", valid_580526
  var valid_580527 = query.getOrDefault("key")
  valid_580527 = validateParameter(valid_580527, JString, required = false,
                                 default = nil)
  if valid_580527 != nil:
    section.add "key", valid_580527
  var valid_580528 = query.getOrDefault("prettyPrint")
  valid_580528 = validateParameter(valid_580528, JBool, required = false,
                                 default = newJBool(true))
  if valid_580528 != nil:
    section.add "prettyPrint", valid_580528
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580530: Call_DfareportingAdvertisersInsert_580518; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new advertiser.
  ## 
  let valid = call_580530.validator(path, query, header, formData, body)
  let scheme = call_580530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580530.url(scheme.get, call_580530.host, call_580530.base,
                         call_580530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580530, url, valid)

proc call*(call_580531: Call_DfareportingAdvertisersInsert_580518;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertisersInsert
  ## Inserts a new advertiser.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580532 = newJObject()
  var query_580533 = newJObject()
  var body_580534 = newJObject()
  add(path_580532, "profileId", newJString(profileId))
  add(query_580533, "fields", newJString(fields))
  add(query_580533, "quotaUser", newJString(quotaUser))
  add(query_580533, "alt", newJString(alt))
  add(query_580533, "oauth_token", newJString(oauthToken))
  add(query_580533, "userIp", newJString(userIp))
  add(query_580533, "key", newJString(key))
  if body != nil:
    body_580534 = body
  add(query_580533, "prettyPrint", newJBool(prettyPrint))
  result = call_580531.call(path_580532, query_580533, nil, nil, body_580534)

var dfareportingAdvertisersInsert* = Call_DfareportingAdvertisersInsert_580518(
    name: "dfareportingAdvertisersInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersInsert_580519,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersInsert_580520,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersList_580474 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdvertisersList_580476(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersList_580475(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of advertisers, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580477 = path.getOrDefault("profileId")
  valid_580477 = validateParameter(valid_580477, JString, required = true,
                                 default = nil)
  if valid_580477 != nil:
    section.add "profileId", valid_580477
  result.add "path", section
  ## parameters in `query` object:
  ##   subaccountId: JString
  ##               : Select only advertisers with these subaccount IDs.
  ##   advertiserGroupIds: JArray
  ##                     : Select only advertisers with these advertiser group IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   onlyParent: JBool
  ##             : Select only advertisers which use another advertiser's floodlight configuration.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser June 2015", "advertiser April 2015", or simply "advertiser 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertiser" will match objects with name "my advertiser", "advertiser 2015", or simply "advertiser".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   floodlightConfigurationIds: JArray
  ##                             : Select only advertisers with these floodlight configuration IDs.
  ##   ids: JArray
  ##      : Select only advertisers with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   status: JString
  ##         : Select only advertisers with the specified status.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   includeAdvertisersWithoutGroupsOnly: JBool
  ##                                      : Select only advertisers which do not belong to any advertiser group.
  section = newJObject()
  var valid_580478 = query.getOrDefault("subaccountId")
  valid_580478 = validateParameter(valid_580478, JString, required = false,
                                 default = nil)
  if valid_580478 != nil:
    section.add "subaccountId", valid_580478
  var valid_580479 = query.getOrDefault("advertiserGroupIds")
  valid_580479 = validateParameter(valid_580479, JArray, required = false,
                                 default = nil)
  if valid_580479 != nil:
    section.add "advertiserGroupIds", valid_580479
  var valid_580480 = query.getOrDefault("fields")
  valid_580480 = validateParameter(valid_580480, JString, required = false,
                                 default = nil)
  if valid_580480 != nil:
    section.add "fields", valid_580480
  var valid_580481 = query.getOrDefault("pageToken")
  valid_580481 = validateParameter(valid_580481, JString, required = false,
                                 default = nil)
  if valid_580481 != nil:
    section.add "pageToken", valid_580481
  var valid_580482 = query.getOrDefault("quotaUser")
  valid_580482 = validateParameter(valid_580482, JString, required = false,
                                 default = nil)
  if valid_580482 != nil:
    section.add "quotaUser", valid_580482
  var valid_580483 = query.getOrDefault("sortField")
  valid_580483 = validateParameter(valid_580483, JString, required = false,
                                 default = newJString("ID"))
  if valid_580483 != nil:
    section.add "sortField", valid_580483
  var valid_580484 = query.getOrDefault("alt")
  valid_580484 = validateParameter(valid_580484, JString, required = false,
                                 default = newJString("json"))
  if valid_580484 != nil:
    section.add "alt", valid_580484
  var valid_580485 = query.getOrDefault("onlyParent")
  valid_580485 = validateParameter(valid_580485, JBool, required = false, default = nil)
  if valid_580485 != nil:
    section.add "onlyParent", valid_580485
  var valid_580486 = query.getOrDefault("searchString")
  valid_580486 = validateParameter(valid_580486, JString, required = false,
                                 default = nil)
  if valid_580486 != nil:
    section.add "searchString", valid_580486
  var valid_580487 = query.getOrDefault("oauth_token")
  valid_580487 = validateParameter(valid_580487, JString, required = false,
                                 default = nil)
  if valid_580487 != nil:
    section.add "oauth_token", valid_580487
  var valid_580488 = query.getOrDefault("userIp")
  valid_580488 = validateParameter(valid_580488, JString, required = false,
                                 default = nil)
  if valid_580488 != nil:
    section.add "userIp", valid_580488
  var valid_580489 = query.getOrDefault("maxResults")
  valid_580489 = validateParameter(valid_580489, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580489 != nil:
    section.add "maxResults", valid_580489
  var valid_580490 = query.getOrDefault("floodlightConfigurationIds")
  valid_580490 = validateParameter(valid_580490, JArray, required = false,
                                 default = nil)
  if valid_580490 != nil:
    section.add "floodlightConfigurationIds", valid_580490
  var valid_580491 = query.getOrDefault("ids")
  valid_580491 = validateParameter(valid_580491, JArray, required = false,
                                 default = nil)
  if valid_580491 != nil:
    section.add "ids", valid_580491
  var valid_580492 = query.getOrDefault("key")
  valid_580492 = validateParameter(valid_580492, JString, required = false,
                                 default = nil)
  if valid_580492 != nil:
    section.add "key", valid_580492
  var valid_580493 = query.getOrDefault("status")
  valid_580493 = validateParameter(valid_580493, JString, required = false,
                                 default = newJString("APPROVED"))
  if valid_580493 != nil:
    section.add "status", valid_580493
  var valid_580494 = query.getOrDefault("sortOrder")
  valid_580494 = validateParameter(valid_580494, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580494 != nil:
    section.add "sortOrder", valid_580494
  var valid_580495 = query.getOrDefault("prettyPrint")
  valid_580495 = validateParameter(valid_580495, JBool, required = false,
                                 default = newJBool(true))
  if valid_580495 != nil:
    section.add "prettyPrint", valid_580495
  var valid_580496 = query.getOrDefault("includeAdvertisersWithoutGroupsOnly")
  valid_580496 = validateParameter(valid_580496, JBool, required = false, default = nil)
  if valid_580496 != nil:
    section.add "includeAdvertisersWithoutGroupsOnly", valid_580496
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580497: Call_DfareportingAdvertisersList_580474; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of advertisers, possibly filtered. This method supports paging.
  ## 
  let valid = call_580497.validator(path, query, header, formData, body)
  let scheme = call_580497.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580497.url(scheme.get, call_580497.host, call_580497.base,
                         call_580497.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580497, url, valid)

proc call*(call_580498: Call_DfareportingAdvertisersList_580474; profileId: string;
          subaccountId: string = ""; advertiserGroupIds: JsonNode = nil;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; onlyParent: bool = false;
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; floodlightConfigurationIds: JsonNode = nil;
          ids: JsonNode = nil; key: string = ""; status: string = "APPROVED";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true;
          includeAdvertisersWithoutGroupsOnly: bool = false): Recallable =
  ## dfareportingAdvertisersList
  ## Retrieves a list of advertisers, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only advertisers with these subaccount IDs.
  ##   advertiserGroupIds: JArray
  ##                     : Select only advertisers with these advertiser group IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   onlyParent: bool
  ##             : Select only advertisers which use another advertiser's floodlight configuration.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser June 2015", "advertiser April 2015", or simply "advertiser 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertiser" will match objects with name "my advertiser", "advertiser 2015", or simply "advertiser".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   floodlightConfigurationIds: JArray
  ##                             : Select only advertisers with these floodlight configuration IDs.
  ##   ids: JArray
  ##      : Select only advertisers with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   status: string
  ##         : Select only advertisers with the specified status.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   includeAdvertisersWithoutGroupsOnly: bool
  ##                                      : Select only advertisers which do not belong to any advertiser group.
  var path_580499 = newJObject()
  var query_580500 = newJObject()
  add(path_580499, "profileId", newJString(profileId))
  add(query_580500, "subaccountId", newJString(subaccountId))
  if advertiserGroupIds != nil:
    query_580500.add "advertiserGroupIds", advertiserGroupIds
  add(query_580500, "fields", newJString(fields))
  add(query_580500, "pageToken", newJString(pageToken))
  add(query_580500, "quotaUser", newJString(quotaUser))
  add(query_580500, "sortField", newJString(sortField))
  add(query_580500, "alt", newJString(alt))
  add(query_580500, "onlyParent", newJBool(onlyParent))
  add(query_580500, "searchString", newJString(searchString))
  add(query_580500, "oauth_token", newJString(oauthToken))
  add(query_580500, "userIp", newJString(userIp))
  add(query_580500, "maxResults", newJInt(maxResults))
  if floodlightConfigurationIds != nil:
    query_580500.add "floodlightConfigurationIds", floodlightConfigurationIds
  if ids != nil:
    query_580500.add "ids", ids
  add(query_580500, "key", newJString(key))
  add(query_580500, "status", newJString(status))
  add(query_580500, "sortOrder", newJString(sortOrder))
  add(query_580500, "prettyPrint", newJBool(prettyPrint))
  add(query_580500, "includeAdvertisersWithoutGroupsOnly",
      newJBool(includeAdvertisersWithoutGroupsOnly))
  result = call_580498.call(path_580499, query_580500, nil, nil, nil)

var dfareportingAdvertisersList* = Call_DfareportingAdvertisersList_580474(
    name: "dfareportingAdvertisersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersList_580475,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersList_580476,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersPatch_580535 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdvertisersPatch_580537(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersPatch_580536(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580538 = path.getOrDefault("profileId")
  valid_580538 = validateParameter(valid_580538, JString, required = true,
                                 default = nil)
  if valid_580538 != nil:
    section.add "profileId", valid_580538
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Advertiser ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580539 = query.getOrDefault("fields")
  valid_580539 = validateParameter(valid_580539, JString, required = false,
                                 default = nil)
  if valid_580539 != nil:
    section.add "fields", valid_580539
  var valid_580540 = query.getOrDefault("quotaUser")
  valid_580540 = validateParameter(valid_580540, JString, required = false,
                                 default = nil)
  if valid_580540 != nil:
    section.add "quotaUser", valid_580540
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580541 = query.getOrDefault("id")
  valid_580541 = validateParameter(valid_580541, JString, required = true,
                                 default = nil)
  if valid_580541 != nil:
    section.add "id", valid_580541
  var valid_580542 = query.getOrDefault("alt")
  valid_580542 = validateParameter(valid_580542, JString, required = false,
                                 default = newJString("json"))
  if valid_580542 != nil:
    section.add "alt", valid_580542
  var valid_580543 = query.getOrDefault("oauth_token")
  valid_580543 = validateParameter(valid_580543, JString, required = false,
                                 default = nil)
  if valid_580543 != nil:
    section.add "oauth_token", valid_580543
  var valid_580544 = query.getOrDefault("userIp")
  valid_580544 = validateParameter(valid_580544, JString, required = false,
                                 default = nil)
  if valid_580544 != nil:
    section.add "userIp", valid_580544
  var valid_580545 = query.getOrDefault("key")
  valid_580545 = validateParameter(valid_580545, JString, required = false,
                                 default = nil)
  if valid_580545 != nil:
    section.add "key", valid_580545
  var valid_580546 = query.getOrDefault("prettyPrint")
  valid_580546 = validateParameter(valid_580546, JBool, required = false,
                                 default = newJBool(true))
  if valid_580546 != nil:
    section.add "prettyPrint", valid_580546
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580548: Call_DfareportingAdvertisersPatch_580535; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing advertiser. This method supports patch semantics.
  ## 
  let valid = call_580548.validator(path, query, header, formData, body)
  let scheme = call_580548.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580548.url(scheme.get, call_580548.host, call_580548.base,
                         call_580548.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580548, url, valid)

proc call*(call_580549: Call_DfareportingAdvertisersPatch_580535;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertisersPatch
  ## Updates an existing advertiser. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Advertiser ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580550 = newJObject()
  var query_580551 = newJObject()
  var body_580552 = newJObject()
  add(path_580550, "profileId", newJString(profileId))
  add(query_580551, "fields", newJString(fields))
  add(query_580551, "quotaUser", newJString(quotaUser))
  add(query_580551, "id", newJString(id))
  add(query_580551, "alt", newJString(alt))
  add(query_580551, "oauth_token", newJString(oauthToken))
  add(query_580551, "userIp", newJString(userIp))
  add(query_580551, "key", newJString(key))
  if body != nil:
    body_580552 = body
  add(query_580551, "prettyPrint", newJBool(prettyPrint))
  result = call_580549.call(path_580550, query_580551, nil, nil, body_580552)

var dfareportingAdvertisersPatch* = Call_DfareportingAdvertisersPatch_580535(
    name: "dfareportingAdvertisersPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersPatch_580536,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersPatch_580537,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersGet_580553 = ref object of OpenApiRestCall_579437
proc url_DfareportingAdvertisersGet_580555(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersGet_580554(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one advertiser by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Advertiser ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580556 = path.getOrDefault("profileId")
  valid_580556 = validateParameter(valid_580556, JString, required = true,
                                 default = nil)
  if valid_580556 != nil:
    section.add "profileId", valid_580556
  var valid_580557 = path.getOrDefault("id")
  valid_580557 = validateParameter(valid_580557, JString, required = true,
                                 default = nil)
  if valid_580557 != nil:
    section.add "id", valid_580557
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580558 = query.getOrDefault("fields")
  valid_580558 = validateParameter(valid_580558, JString, required = false,
                                 default = nil)
  if valid_580558 != nil:
    section.add "fields", valid_580558
  var valid_580559 = query.getOrDefault("quotaUser")
  valid_580559 = validateParameter(valid_580559, JString, required = false,
                                 default = nil)
  if valid_580559 != nil:
    section.add "quotaUser", valid_580559
  var valid_580560 = query.getOrDefault("alt")
  valid_580560 = validateParameter(valid_580560, JString, required = false,
                                 default = newJString("json"))
  if valid_580560 != nil:
    section.add "alt", valid_580560
  var valid_580561 = query.getOrDefault("oauth_token")
  valid_580561 = validateParameter(valid_580561, JString, required = false,
                                 default = nil)
  if valid_580561 != nil:
    section.add "oauth_token", valid_580561
  var valid_580562 = query.getOrDefault("userIp")
  valid_580562 = validateParameter(valid_580562, JString, required = false,
                                 default = nil)
  if valid_580562 != nil:
    section.add "userIp", valid_580562
  var valid_580563 = query.getOrDefault("key")
  valid_580563 = validateParameter(valid_580563, JString, required = false,
                                 default = nil)
  if valid_580563 != nil:
    section.add "key", valid_580563
  var valid_580564 = query.getOrDefault("prettyPrint")
  valid_580564 = validateParameter(valid_580564, JBool, required = false,
                                 default = newJBool(true))
  if valid_580564 != nil:
    section.add "prettyPrint", valid_580564
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580565: Call_DfareportingAdvertisersGet_580553; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one advertiser by ID.
  ## 
  let valid = call_580565.validator(path, query, header, formData, body)
  let scheme = call_580565.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580565.url(scheme.get, call_580565.host, call_580565.base,
                         call_580565.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580565, url, valid)

proc call*(call_580566: Call_DfareportingAdvertisersGet_580553; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertisersGet
  ## Gets one advertiser by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Advertiser ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580567 = newJObject()
  var query_580568 = newJObject()
  add(path_580567, "profileId", newJString(profileId))
  add(query_580568, "fields", newJString(fields))
  add(query_580568, "quotaUser", newJString(quotaUser))
  add(query_580568, "alt", newJString(alt))
  add(query_580568, "oauth_token", newJString(oauthToken))
  add(query_580568, "userIp", newJString(userIp))
  add(path_580567, "id", newJString(id))
  add(query_580568, "key", newJString(key))
  add(query_580568, "prettyPrint", newJBool(prettyPrint))
  result = call_580566.call(path_580567, query_580568, nil, nil, nil)

var dfareportingAdvertisersGet* = Call_DfareportingAdvertisersGet_580553(
    name: "dfareportingAdvertisersGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertisers/{id}",
    validator: validate_DfareportingAdvertisersGet_580554,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersGet_580555,
    schemes: {Scheme.Https})
type
  Call_DfareportingBrowsersList_580569 = ref object of OpenApiRestCall_579437
proc url_DfareportingBrowsersList_580571(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/browsers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingBrowsersList_580570(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of browsers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580572 = path.getOrDefault("profileId")
  valid_580572 = validateParameter(valid_580572, JString, required = true,
                                 default = nil)
  if valid_580572 != nil:
    section.add "profileId", valid_580572
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580573 = query.getOrDefault("fields")
  valid_580573 = validateParameter(valid_580573, JString, required = false,
                                 default = nil)
  if valid_580573 != nil:
    section.add "fields", valid_580573
  var valid_580574 = query.getOrDefault("quotaUser")
  valid_580574 = validateParameter(valid_580574, JString, required = false,
                                 default = nil)
  if valid_580574 != nil:
    section.add "quotaUser", valid_580574
  var valid_580575 = query.getOrDefault("alt")
  valid_580575 = validateParameter(valid_580575, JString, required = false,
                                 default = newJString("json"))
  if valid_580575 != nil:
    section.add "alt", valid_580575
  var valid_580576 = query.getOrDefault("oauth_token")
  valid_580576 = validateParameter(valid_580576, JString, required = false,
                                 default = nil)
  if valid_580576 != nil:
    section.add "oauth_token", valid_580576
  var valid_580577 = query.getOrDefault("userIp")
  valid_580577 = validateParameter(valid_580577, JString, required = false,
                                 default = nil)
  if valid_580577 != nil:
    section.add "userIp", valid_580577
  var valid_580578 = query.getOrDefault("key")
  valid_580578 = validateParameter(valid_580578, JString, required = false,
                                 default = nil)
  if valid_580578 != nil:
    section.add "key", valid_580578
  var valid_580579 = query.getOrDefault("prettyPrint")
  valid_580579 = validateParameter(valid_580579, JBool, required = false,
                                 default = newJBool(true))
  if valid_580579 != nil:
    section.add "prettyPrint", valid_580579
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580580: Call_DfareportingBrowsersList_580569; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of browsers.
  ## 
  let valid = call_580580.validator(path, query, header, formData, body)
  let scheme = call_580580.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580580.url(scheme.get, call_580580.host, call_580580.base,
                         call_580580.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580580, url, valid)

proc call*(call_580581: Call_DfareportingBrowsersList_580569; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingBrowsersList
  ## Retrieves a list of browsers.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580582 = newJObject()
  var query_580583 = newJObject()
  add(path_580582, "profileId", newJString(profileId))
  add(query_580583, "fields", newJString(fields))
  add(query_580583, "quotaUser", newJString(quotaUser))
  add(query_580583, "alt", newJString(alt))
  add(query_580583, "oauth_token", newJString(oauthToken))
  add(query_580583, "userIp", newJString(userIp))
  add(query_580583, "key", newJString(key))
  add(query_580583, "prettyPrint", newJBool(prettyPrint))
  result = call_580581.call(path_580582, query_580583, nil, nil, nil)

var dfareportingBrowsersList* = Call_DfareportingBrowsersList_580569(
    name: "dfareportingBrowsersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/browsers",
    validator: validate_DfareportingBrowsersList_580570,
    base: "/dfareporting/v2.7", url: url_DfareportingBrowsersList_580571,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsUpdate_580612 = ref object of OpenApiRestCall_579437
proc url_DfareportingCampaignsUpdate_580614(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsUpdate_580613(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580615 = path.getOrDefault("profileId")
  valid_580615 = validateParameter(valid_580615, JString, required = true,
                                 default = nil)
  if valid_580615 != nil:
    section.add "profileId", valid_580615
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580616 = query.getOrDefault("fields")
  valid_580616 = validateParameter(valid_580616, JString, required = false,
                                 default = nil)
  if valid_580616 != nil:
    section.add "fields", valid_580616
  var valid_580617 = query.getOrDefault("quotaUser")
  valid_580617 = validateParameter(valid_580617, JString, required = false,
                                 default = nil)
  if valid_580617 != nil:
    section.add "quotaUser", valid_580617
  var valid_580618 = query.getOrDefault("alt")
  valid_580618 = validateParameter(valid_580618, JString, required = false,
                                 default = newJString("json"))
  if valid_580618 != nil:
    section.add "alt", valid_580618
  var valid_580619 = query.getOrDefault("oauth_token")
  valid_580619 = validateParameter(valid_580619, JString, required = false,
                                 default = nil)
  if valid_580619 != nil:
    section.add "oauth_token", valid_580619
  var valid_580620 = query.getOrDefault("userIp")
  valid_580620 = validateParameter(valid_580620, JString, required = false,
                                 default = nil)
  if valid_580620 != nil:
    section.add "userIp", valid_580620
  var valid_580621 = query.getOrDefault("key")
  valid_580621 = validateParameter(valid_580621, JString, required = false,
                                 default = nil)
  if valid_580621 != nil:
    section.add "key", valid_580621
  var valid_580622 = query.getOrDefault("prettyPrint")
  valid_580622 = validateParameter(valid_580622, JBool, required = false,
                                 default = newJBool(true))
  if valid_580622 != nil:
    section.add "prettyPrint", valid_580622
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580624: Call_DfareportingCampaignsUpdate_580612; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign.
  ## 
  let valid = call_580624.validator(path, query, header, formData, body)
  let scheme = call_580624.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580624.url(scheme.get, call_580624.host, call_580624.base,
                         call_580624.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580624, url, valid)

proc call*(call_580625: Call_DfareportingCampaignsUpdate_580612; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsUpdate
  ## Updates an existing campaign.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580626 = newJObject()
  var query_580627 = newJObject()
  var body_580628 = newJObject()
  add(path_580626, "profileId", newJString(profileId))
  add(query_580627, "fields", newJString(fields))
  add(query_580627, "quotaUser", newJString(quotaUser))
  add(query_580627, "alt", newJString(alt))
  add(query_580627, "oauth_token", newJString(oauthToken))
  add(query_580627, "userIp", newJString(userIp))
  add(query_580627, "key", newJString(key))
  if body != nil:
    body_580628 = body
  add(query_580627, "prettyPrint", newJBool(prettyPrint))
  result = call_580625.call(path_580626, query_580627, nil, nil, body_580628)

var dfareportingCampaignsUpdate* = Call_DfareportingCampaignsUpdate_580612(
    name: "dfareportingCampaignsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsUpdate_580613,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsUpdate_580614,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsInsert_580629 = ref object of OpenApiRestCall_579437
proc url_DfareportingCampaignsInsert_580631(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsInsert_580630(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580632 = path.getOrDefault("profileId")
  valid_580632 = validateParameter(valid_580632, JString, required = true,
                                 default = nil)
  if valid_580632 != nil:
    section.add "profileId", valid_580632
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   defaultLandingPageName: JString (required)
  ##                         : Default landing page name for this new campaign. Must be less than 256 characters long.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   defaultLandingPageUrl: JString (required)
  ##                        : Default landing page URL for this new campaign.
  section = newJObject()
  var valid_580633 = query.getOrDefault("fields")
  valid_580633 = validateParameter(valid_580633, JString, required = false,
                                 default = nil)
  if valid_580633 != nil:
    section.add "fields", valid_580633
  var valid_580634 = query.getOrDefault("quotaUser")
  valid_580634 = validateParameter(valid_580634, JString, required = false,
                                 default = nil)
  if valid_580634 != nil:
    section.add "quotaUser", valid_580634
  var valid_580635 = query.getOrDefault("alt")
  valid_580635 = validateParameter(valid_580635, JString, required = false,
                                 default = newJString("json"))
  if valid_580635 != nil:
    section.add "alt", valid_580635
  var valid_580636 = query.getOrDefault("oauth_token")
  valid_580636 = validateParameter(valid_580636, JString, required = false,
                                 default = nil)
  if valid_580636 != nil:
    section.add "oauth_token", valid_580636
  var valid_580637 = query.getOrDefault("userIp")
  valid_580637 = validateParameter(valid_580637, JString, required = false,
                                 default = nil)
  if valid_580637 != nil:
    section.add "userIp", valid_580637
  assert query != nil, "query argument is necessary due to required `defaultLandingPageName` field"
  var valid_580638 = query.getOrDefault("defaultLandingPageName")
  valid_580638 = validateParameter(valid_580638, JString, required = true,
                                 default = nil)
  if valid_580638 != nil:
    section.add "defaultLandingPageName", valid_580638
  var valid_580639 = query.getOrDefault("key")
  valid_580639 = validateParameter(valid_580639, JString, required = false,
                                 default = nil)
  if valid_580639 != nil:
    section.add "key", valid_580639
  var valid_580640 = query.getOrDefault("prettyPrint")
  valid_580640 = validateParameter(valid_580640, JBool, required = false,
                                 default = newJBool(true))
  if valid_580640 != nil:
    section.add "prettyPrint", valid_580640
  var valid_580641 = query.getOrDefault("defaultLandingPageUrl")
  valid_580641 = validateParameter(valid_580641, JString, required = true,
                                 default = nil)
  if valid_580641 != nil:
    section.add "defaultLandingPageUrl", valid_580641
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580643: Call_DfareportingCampaignsInsert_580629; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new campaign.
  ## 
  let valid = call_580643.validator(path, query, header, formData, body)
  let scheme = call_580643.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580643.url(scheme.get, call_580643.host, call_580643.base,
                         call_580643.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580643, url, valid)

proc call*(call_580644: Call_DfareportingCampaignsInsert_580629; profileId: string;
          defaultLandingPageName: string; defaultLandingPageUrl: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsInsert
  ## Inserts a new campaign.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   defaultLandingPageName: string (required)
  ##                         : Default landing page name for this new campaign. Must be less than 256 characters long.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   defaultLandingPageUrl: string (required)
  ##                        : Default landing page URL for this new campaign.
  var path_580645 = newJObject()
  var query_580646 = newJObject()
  var body_580647 = newJObject()
  add(path_580645, "profileId", newJString(profileId))
  add(query_580646, "fields", newJString(fields))
  add(query_580646, "quotaUser", newJString(quotaUser))
  add(query_580646, "alt", newJString(alt))
  add(query_580646, "oauth_token", newJString(oauthToken))
  add(query_580646, "userIp", newJString(userIp))
  add(query_580646, "defaultLandingPageName", newJString(defaultLandingPageName))
  add(query_580646, "key", newJString(key))
  if body != nil:
    body_580647 = body
  add(query_580646, "prettyPrint", newJBool(prettyPrint))
  add(query_580646, "defaultLandingPageUrl", newJString(defaultLandingPageUrl))
  result = call_580644.call(path_580645, query_580646, nil, nil, body_580647)

var dfareportingCampaignsInsert* = Call_DfareportingCampaignsInsert_580629(
    name: "dfareportingCampaignsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsInsert_580630,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsInsert_580631,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsList_580584 = ref object of OpenApiRestCall_579437
proc url_DfareportingCampaignsList_580586(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsList_580585(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of campaigns, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580587 = path.getOrDefault("profileId")
  valid_580587 = validateParameter(valid_580587, JString, required = true,
                                 default = nil)
  if valid_580587 != nil:
    section.add "profileId", valid_580587
  result.add "path", section
  ## parameters in `query` object:
  ##   overriddenEventTagId: JString
  ##                       : Select only campaigns that have overridden this event tag ID.
  ##   subaccountId: JString
  ##               : Select only campaigns that belong to this subaccount.
  ##   advertiserGroupIds: JArray
  ##                     : Select only campaigns whose advertisers belong to these advertiser groups.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   atLeastOneOptimizationActivity: JBool
  ##                                 : Select only campaigns that have at least one optimization activity.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for campaigns by name or ID. Wildcards (*) are allowed. For example, "campaign*2015" will return campaigns with names like "campaign June 2015", "campaign April 2015", or simply "campaign 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "campaign" will match campaigns with name "my campaign", "campaign 2015", or simply "campaign".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: JBool
  ##           : Select only archived campaigns. Don't set this field to select both archived and non-archived campaigns.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only campaigns with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only campaigns that belong to these advertisers.
  ##   excludedIds: JArray
  ##              : Exclude campaigns with these IDs.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580588 = query.getOrDefault("overriddenEventTagId")
  valid_580588 = validateParameter(valid_580588, JString, required = false,
                                 default = nil)
  if valid_580588 != nil:
    section.add "overriddenEventTagId", valid_580588
  var valid_580589 = query.getOrDefault("subaccountId")
  valid_580589 = validateParameter(valid_580589, JString, required = false,
                                 default = nil)
  if valid_580589 != nil:
    section.add "subaccountId", valid_580589
  var valid_580590 = query.getOrDefault("advertiserGroupIds")
  valid_580590 = validateParameter(valid_580590, JArray, required = false,
                                 default = nil)
  if valid_580590 != nil:
    section.add "advertiserGroupIds", valid_580590
  var valid_580591 = query.getOrDefault("fields")
  valid_580591 = validateParameter(valid_580591, JString, required = false,
                                 default = nil)
  if valid_580591 != nil:
    section.add "fields", valid_580591
  var valid_580592 = query.getOrDefault("atLeastOneOptimizationActivity")
  valid_580592 = validateParameter(valid_580592, JBool, required = false, default = nil)
  if valid_580592 != nil:
    section.add "atLeastOneOptimizationActivity", valid_580592
  var valid_580593 = query.getOrDefault("quotaUser")
  valid_580593 = validateParameter(valid_580593, JString, required = false,
                                 default = nil)
  if valid_580593 != nil:
    section.add "quotaUser", valid_580593
  var valid_580594 = query.getOrDefault("pageToken")
  valid_580594 = validateParameter(valid_580594, JString, required = false,
                                 default = nil)
  if valid_580594 != nil:
    section.add "pageToken", valid_580594
  var valid_580595 = query.getOrDefault("sortField")
  valid_580595 = validateParameter(valid_580595, JString, required = false,
                                 default = newJString("ID"))
  if valid_580595 != nil:
    section.add "sortField", valid_580595
  var valid_580596 = query.getOrDefault("alt")
  valid_580596 = validateParameter(valid_580596, JString, required = false,
                                 default = newJString("json"))
  if valid_580596 != nil:
    section.add "alt", valid_580596
  var valid_580597 = query.getOrDefault("searchString")
  valid_580597 = validateParameter(valid_580597, JString, required = false,
                                 default = nil)
  if valid_580597 != nil:
    section.add "searchString", valid_580597
  var valid_580598 = query.getOrDefault("oauth_token")
  valid_580598 = validateParameter(valid_580598, JString, required = false,
                                 default = nil)
  if valid_580598 != nil:
    section.add "oauth_token", valid_580598
  var valid_580599 = query.getOrDefault("userIp")
  valid_580599 = validateParameter(valid_580599, JString, required = false,
                                 default = nil)
  if valid_580599 != nil:
    section.add "userIp", valid_580599
  var valid_580600 = query.getOrDefault("archived")
  valid_580600 = validateParameter(valid_580600, JBool, required = false, default = nil)
  if valid_580600 != nil:
    section.add "archived", valid_580600
  var valid_580601 = query.getOrDefault("maxResults")
  valid_580601 = validateParameter(valid_580601, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580601 != nil:
    section.add "maxResults", valid_580601
  var valid_580602 = query.getOrDefault("ids")
  valid_580602 = validateParameter(valid_580602, JArray, required = false,
                                 default = nil)
  if valid_580602 != nil:
    section.add "ids", valid_580602
  var valid_580603 = query.getOrDefault("key")
  valid_580603 = validateParameter(valid_580603, JString, required = false,
                                 default = nil)
  if valid_580603 != nil:
    section.add "key", valid_580603
  var valid_580604 = query.getOrDefault("advertiserIds")
  valid_580604 = validateParameter(valid_580604, JArray, required = false,
                                 default = nil)
  if valid_580604 != nil:
    section.add "advertiserIds", valid_580604
  var valid_580605 = query.getOrDefault("excludedIds")
  valid_580605 = validateParameter(valid_580605, JArray, required = false,
                                 default = nil)
  if valid_580605 != nil:
    section.add "excludedIds", valid_580605
  var valid_580606 = query.getOrDefault("sortOrder")
  valid_580606 = validateParameter(valid_580606, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580606 != nil:
    section.add "sortOrder", valid_580606
  var valid_580607 = query.getOrDefault("prettyPrint")
  valid_580607 = validateParameter(valid_580607, JBool, required = false,
                                 default = newJBool(true))
  if valid_580607 != nil:
    section.add "prettyPrint", valid_580607
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580608: Call_DfareportingCampaignsList_580584; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of campaigns, possibly filtered. This method supports paging.
  ## 
  let valid = call_580608.validator(path, query, header, formData, body)
  let scheme = call_580608.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580608.url(scheme.get, call_580608.host, call_580608.base,
                         call_580608.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580608, url, valid)

proc call*(call_580609: Call_DfareportingCampaignsList_580584; profileId: string;
          overriddenEventTagId: string = ""; subaccountId: string = "";
          advertiserGroupIds: JsonNode = nil; fields: string = "";
          atLeastOneOptimizationActivity: bool = false; quotaUser: string = "";
          pageToken: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          archived: bool = false; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; advertiserIds: JsonNode = nil; excludedIds: JsonNode = nil;
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsList
  ## Retrieves a list of campaigns, possibly filtered. This method supports paging.
  ##   overriddenEventTagId: string
  ##                       : Select only campaigns that have overridden this event tag ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only campaigns that belong to this subaccount.
  ##   advertiserGroupIds: JArray
  ##                     : Select only campaigns whose advertisers belong to these advertiser groups.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   atLeastOneOptimizationActivity: bool
  ##                                 : Select only campaigns that have at least one optimization activity.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for campaigns by name or ID. Wildcards (*) are allowed. For example, "campaign*2015" will return campaigns with names like "campaign June 2015", "campaign April 2015", or simply "campaign 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "campaign" will match campaigns with name "my campaign", "campaign 2015", or simply "campaign".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: bool
  ##           : Select only archived campaigns. Don't set this field to select both archived and non-archived campaigns.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only campaigns with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only campaigns that belong to these advertisers.
  ##   excludedIds: JArray
  ##              : Exclude campaigns with these IDs.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580610 = newJObject()
  var query_580611 = newJObject()
  add(query_580611, "overriddenEventTagId", newJString(overriddenEventTagId))
  add(path_580610, "profileId", newJString(profileId))
  add(query_580611, "subaccountId", newJString(subaccountId))
  if advertiserGroupIds != nil:
    query_580611.add "advertiserGroupIds", advertiserGroupIds
  add(query_580611, "fields", newJString(fields))
  add(query_580611, "atLeastOneOptimizationActivity",
      newJBool(atLeastOneOptimizationActivity))
  add(query_580611, "quotaUser", newJString(quotaUser))
  add(query_580611, "pageToken", newJString(pageToken))
  add(query_580611, "sortField", newJString(sortField))
  add(query_580611, "alt", newJString(alt))
  add(query_580611, "searchString", newJString(searchString))
  add(query_580611, "oauth_token", newJString(oauthToken))
  add(query_580611, "userIp", newJString(userIp))
  add(query_580611, "archived", newJBool(archived))
  add(query_580611, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_580611.add "ids", ids
  add(query_580611, "key", newJString(key))
  if advertiserIds != nil:
    query_580611.add "advertiserIds", advertiserIds
  if excludedIds != nil:
    query_580611.add "excludedIds", excludedIds
  add(query_580611, "sortOrder", newJString(sortOrder))
  add(query_580611, "prettyPrint", newJBool(prettyPrint))
  result = call_580609.call(path_580610, query_580611, nil, nil, nil)

var dfareportingCampaignsList* = Call_DfareportingCampaignsList_580584(
    name: "dfareportingCampaignsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsList_580585,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsList_580586,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsPatch_580648 = ref object of OpenApiRestCall_579437
proc url_DfareportingCampaignsPatch_580650(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsPatch_580649(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580651 = path.getOrDefault("profileId")
  valid_580651 = validateParameter(valid_580651, JString, required = true,
                                 default = nil)
  if valid_580651 != nil:
    section.add "profileId", valid_580651
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Campaign ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580652 = query.getOrDefault("fields")
  valid_580652 = validateParameter(valid_580652, JString, required = false,
                                 default = nil)
  if valid_580652 != nil:
    section.add "fields", valid_580652
  var valid_580653 = query.getOrDefault("quotaUser")
  valid_580653 = validateParameter(valid_580653, JString, required = false,
                                 default = nil)
  if valid_580653 != nil:
    section.add "quotaUser", valid_580653
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580654 = query.getOrDefault("id")
  valid_580654 = validateParameter(valid_580654, JString, required = true,
                                 default = nil)
  if valid_580654 != nil:
    section.add "id", valid_580654
  var valid_580655 = query.getOrDefault("alt")
  valid_580655 = validateParameter(valid_580655, JString, required = false,
                                 default = newJString("json"))
  if valid_580655 != nil:
    section.add "alt", valid_580655
  var valid_580656 = query.getOrDefault("oauth_token")
  valid_580656 = validateParameter(valid_580656, JString, required = false,
                                 default = nil)
  if valid_580656 != nil:
    section.add "oauth_token", valid_580656
  var valid_580657 = query.getOrDefault("userIp")
  valid_580657 = validateParameter(valid_580657, JString, required = false,
                                 default = nil)
  if valid_580657 != nil:
    section.add "userIp", valid_580657
  var valid_580658 = query.getOrDefault("key")
  valid_580658 = validateParameter(valid_580658, JString, required = false,
                                 default = nil)
  if valid_580658 != nil:
    section.add "key", valid_580658
  var valid_580659 = query.getOrDefault("prettyPrint")
  valid_580659 = validateParameter(valid_580659, JBool, required = false,
                                 default = newJBool(true))
  if valid_580659 != nil:
    section.add "prettyPrint", valid_580659
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580661: Call_DfareportingCampaignsPatch_580648; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign. This method supports patch semantics.
  ## 
  let valid = call_580661.validator(path, query, header, formData, body)
  let scheme = call_580661.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580661.url(scheme.get, call_580661.host, call_580661.base,
                         call_580661.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580661, url, valid)

proc call*(call_580662: Call_DfareportingCampaignsPatch_580648; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsPatch
  ## Updates an existing campaign. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Campaign ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580663 = newJObject()
  var query_580664 = newJObject()
  var body_580665 = newJObject()
  add(path_580663, "profileId", newJString(profileId))
  add(query_580664, "fields", newJString(fields))
  add(query_580664, "quotaUser", newJString(quotaUser))
  add(query_580664, "id", newJString(id))
  add(query_580664, "alt", newJString(alt))
  add(query_580664, "oauth_token", newJString(oauthToken))
  add(query_580664, "userIp", newJString(userIp))
  add(query_580664, "key", newJString(key))
  if body != nil:
    body_580665 = body
  add(query_580664, "prettyPrint", newJBool(prettyPrint))
  result = call_580662.call(path_580663, query_580664, nil, nil, body_580665)

var dfareportingCampaignsPatch* = Call_DfareportingCampaignsPatch_580648(
    name: "dfareportingCampaignsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsPatch_580649,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsPatch_580650,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignCreativeAssociationsInsert_580685 = ref object of OpenApiRestCall_579437
proc url_DfareportingCampaignCreativeAssociationsInsert_580687(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/campaignCreativeAssociations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignCreativeAssociationsInsert_580686(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Associates a creative with the specified campaign. This method creates a default ad with dimensions matching the creative in the campaign if such a default ad does not exist already.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Campaign ID in this association.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580688 = path.getOrDefault("profileId")
  valid_580688 = validateParameter(valid_580688, JString, required = true,
                                 default = nil)
  if valid_580688 != nil:
    section.add "profileId", valid_580688
  var valid_580689 = path.getOrDefault("campaignId")
  valid_580689 = validateParameter(valid_580689, JString, required = true,
                                 default = nil)
  if valid_580689 != nil:
    section.add "campaignId", valid_580689
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580690 = query.getOrDefault("fields")
  valid_580690 = validateParameter(valid_580690, JString, required = false,
                                 default = nil)
  if valid_580690 != nil:
    section.add "fields", valid_580690
  var valid_580691 = query.getOrDefault("quotaUser")
  valid_580691 = validateParameter(valid_580691, JString, required = false,
                                 default = nil)
  if valid_580691 != nil:
    section.add "quotaUser", valid_580691
  var valid_580692 = query.getOrDefault("alt")
  valid_580692 = validateParameter(valid_580692, JString, required = false,
                                 default = newJString("json"))
  if valid_580692 != nil:
    section.add "alt", valid_580692
  var valid_580693 = query.getOrDefault("oauth_token")
  valid_580693 = validateParameter(valid_580693, JString, required = false,
                                 default = nil)
  if valid_580693 != nil:
    section.add "oauth_token", valid_580693
  var valid_580694 = query.getOrDefault("userIp")
  valid_580694 = validateParameter(valid_580694, JString, required = false,
                                 default = nil)
  if valid_580694 != nil:
    section.add "userIp", valid_580694
  var valid_580695 = query.getOrDefault("key")
  valid_580695 = validateParameter(valid_580695, JString, required = false,
                                 default = nil)
  if valid_580695 != nil:
    section.add "key", valid_580695
  var valid_580696 = query.getOrDefault("prettyPrint")
  valid_580696 = validateParameter(valid_580696, JBool, required = false,
                                 default = newJBool(true))
  if valid_580696 != nil:
    section.add "prettyPrint", valid_580696
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580698: Call_DfareportingCampaignCreativeAssociationsInsert_580685;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Associates a creative with the specified campaign. This method creates a default ad with dimensions matching the creative in the campaign if such a default ad does not exist already.
  ## 
  let valid = call_580698.validator(path, query, header, formData, body)
  let scheme = call_580698.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580698.url(scheme.get, call_580698.host, call_580698.base,
                         call_580698.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580698, url, valid)

proc call*(call_580699: Call_DfareportingCampaignCreativeAssociationsInsert_580685;
          profileId: string; campaignId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignCreativeAssociationsInsert
  ## Associates a creative with the specified campaign. This method creates a default ad with dimensions matching the creative in the campaign if such a default ad does not exist already.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Campaign ID in this association.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580700 = newJObject()
  var query_580701 = newJObject()
  var body_580702 = newJObject()
  add(path_580700, "profileId", newJString(profileId))
  add(path_580700, "campaignId", newJString(campaignId))
  add(query_580701, "fields", newJString(fields))
  add(query_580701, "quotaUser", newJString(quotaUser))
  add(query_580701, "alt", newJString(alt))
  add(query_580701, "oauth_token", newJString(oauthToken))
  add(query_580701, "userIp", newJString(userIp))
  add(query_580701, "key", newJString(key))
  if body != nil:
    body_580702 = body
  add(query_580701, "prettyPrint", newJBool(prettyPrint))
  result = call_580699.call(path_580700, query_580701, nil, nil, body_580702)

var dfareportingCampaignCreativeAssociationsInsert* = Call_DfareportingCampaignCreativeAssociationsInsert_580685(
    name: "dfareportingCampaignCreativeAssociationsInsert",
    meth: HttpMethod.HttpPost, host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/campaignCreativeAssociations",
    validator: validate_DfareportingCampaignCreativeAssociationsInsert_580686,
    base: "/dfareporting/v2.7",
    url: url_DfareportingCampaignCreativeAssociationsInsert_580687,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignCreativeAssociationsList_580666 = ref object of OpenApiRestCall_579437
proc url_DfareportingCampaignCreativeAssociationsList_580668(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/campaignCreativeAssociations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignCreativeAssociationsList_580667(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of creative IDs associated with the specified campaign. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Campaign ID in this association.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580669 = path.getOrDefault("profileId")
  valid_580669 = validateParameter(valid_580669, JString, required = true,
                                 default = nil)
  if valid_580669 != nil:
    section.add "profileId", valid_580669
  var valid_580670 = path.getOrDefault("campaignId")
  valid_580670 = validateParameter(valid_580670, JString, required = true,
                                 default = nil)
  if valid_580670 != nil:
    section.add "campaignId", valid_580670
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580671 = query.getOrDefault("fields")
  valid_580671 = validateParameter(valid_580671, JString, required = false,
                                 default = nil)
  if valid_580671 != nil:
    section.add "fields", valid_580671
  var valid_580672 = query.getOrDefault("pageToken")
  valid_580672 = validateParameter(valid_580672, JString, required = false,
                                 default = nil)
  if valid_580672 != nil:
    section.add "pageToken", valid_580672
  var valid_580673 = query.getOrDefault("quotaUser")
  valid_580673 = validateParameter(valid_580673, JString, required = false,
                                 default = nil)
  if valid_580673 != nil:
    section.add "quotaUser", valid_580673
  var valid_580674 = query.getOrDefault("alt")
  valid_580674 = validateParameter(valid_580674, JString, required = false,
                                 default = newJString("json"))
  if valid_580674 != nil:
    section.add "alt", valid_580674
  var valid_580675 = query.getOrDefault("oauth_token")
  valid_580675 = validateParameter(valid_580675, JString, required = false,
                                 default = nil)
  if valid_580675 != nil:
    section.add "oauth_token", valid_580675
  var valid_580676 = query.getOrDefault("userIp")
  valid_580676 = validateParameter(valid_580676, JString, required = false,
                                 default = nil)
  if valid_580676 != nil:
    section.add "userIp", valid_580676
  var valid_580677 = query.getOrDefault("maxResults")
  valid_580677 = validateParameter(valid_580677, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580677 != nil:
    section.add "maxResults", valid_580677
  var valid_580678 = query.getOrDefault("key")
  valid_580678 = validateParameter(valid_580678, JString, required = false,
                                 default = nil)
  if valid_580678 != nil:
    section.add "key", valid_580678
  var valid_580679 = query.getOrDefault("sortOrder")
  valid_580679 = validateParameter(valid_580679, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580679 != nil:
    section.add "sortOrder", valid_580679
  var valid_580680 = query.getOrDefault("prettyPrint")
  valid_580680 = validateParameter(valid_580680, JBool, required = false,
                                 default = newJBool(true))
  if valid_580680 != nil:
    section.add "prettyPrint", valid_580680
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580681: Call_DfareportingCampaignCreativeAssociationsList_580666;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves the list of creative IDs associated with the specified campaign. This method supports paging.
  ## 
  let valid = call_580681.validator(path, query, header, formData, body)
  let scheme = call_580681.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580681.url(scheme.get, call_580681.host, call_580681.base,
                         call_580681.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580681, url, valid)

proc call*(call_580682: Call_DfareportingCampaignCreativeAssociationsList_580666;
          profileId: string; campaignId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 1000;
          key: string = ""; sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignCreativeAssociationsList
  ## Retrieves the list of creative IDs associated with the specified campaign. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Campaign ID in this association.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580683 = newJObject()
  var query_580684 = newJObject()
  add(path_580683, "profileId", newJString(profileId))
  add(path_580683, "campaignId", newJString(campaignId))
  add(query_580684, "fields", newJString(fields))
  add(query_580684, "pageToken", newJString(pageToken))
  add(query_580684, "quotaUser", newJString(quotaUser))
  add(query_580684, "alt", newJString(alt))
  add(query_580684, "oauth_token", newJString(oauthToken))
  add(query_580684, "userIp", newJString(userIp))
  add(query_580684, "maxResults", newJInt(maxResults))
  add(query_580684, "key", newJString(key))
  add(query_580684, "sortOrder", newJString(sortOrder))
  add(query_580684, "prettyPrint", newJBool(prettyPrint))
  result = call_580682.call(path_580683, query_580684, nil, nil, nil)

var dfareportingCampaignCreativeAssociationsList* = Call_DfareportingCampaignCreativeAssociationsList_580666(
    name: "dfareportingCampaignCreativeAssociationsList",
    meth: HttpMethod.HttpGet, host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/campaignCreativeAssociations",
    validator: validate_DfareportingCampaignCreativeAssociationsList_580667,
    base: "/dfareporting/v2.7",
    url: url_DfareportingCampaignCreativeAssociationsList_580668,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesUpdate_580719 = ref object of OpenApiRestCall_579437
proc url_DfareportingLandingPagesUpdate_580721(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesUpdate_580720(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign landing page.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580722 = path.getOrDefault("profileId")
  valid_580722 = validateParameter(valid_580722, JString, required = true,
                                 default = nil)
  if valid_580722 != nil:
    section.add "profileId", valid_580722
  var valid_580723 = path.getOrDefault("campaignId")
  valid_580723 = validateParameter(valid_580723, JString, required = true,
                                 default = nil)
  if valid_580723 != nil:
    section.add "campaignId", valid_580723
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580724 = query.getOrDefault("fields")
  valid_580724 = validateParameter(valid_580724, JString, required = false,
                                 default = nil)
  if valid_580724 != nil:
    section.add "fields", valid_580724
  var valid_580725 = query.getOrDefault("quotaUser")
  valid_580725 = validateParameter(valid_580725, JString, required = false,
                                 default = nil)
  if valid_580725 != nil:
    section.add "quotaUser", valid_580725
  var valid_580726 = query.getOrDefault("alt")
  valid_580726 = validateParameter(valid_580726, JString, required = false,
                                 default = newJString("json"))
  if valid_580726 != nil:
    section.add "alt", valid_580726
  var valid_580727 = query.getOrDefault("oauth_token")
  valid_580727 = validateParameter(valid_580727, JString, required = false,
                                 default = nil)
  if valid_580727 != nil:
    section.add "oauth_token", valid_580727
  var valid_580728 = query.getOrDefault("userIp")
  valid_580728 = validateParameter(valid_580728, JString, required = false,
                                 default = nil)
  if valid_580728 != nil:
    section.add "userIp", valid_580728
  var valid_580729 = query.getOrDefault("key")
  valid_580729 = validateParameter(valid_580729, JString, required = false,
                                 default = nil)
  if valid_580729 != nil:
    section.add "key", valid_580729
  var valid_580730 = query.getOrDefault("prettyPrint")
  valid_580730 = validateParameter(valid_580730, JBool, required = false,
                                 default = newJBool(true))
  if valid_580730 != nil:
    section.add "prettyPrint", valid_580730
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580732: Call_DfareportingLandingPagesUpdate_580719; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign landing page.
  ## 
  let valid = call_580732.validator(path, query, header, formData, body)
  let scheme = call_580732.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580732.url(scheme.get, call_580732.host, call_580732.base,
                         call_580732.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580732, url, valid)

proc call*(call_580733: Call_DfareportingLandingPagesUpdate_580719;
          profileId: string; campaignId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesUpdate
  ## Updates an existing campaign landing page.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580734 = newJObject()
  var query_580735 = newJObject()
  var body_580736 = newJObject()
  add(path_580734, "profileId", newJString(profileId))
  add(path_580734, "campaignId", newJString(campaignId))
  add(query_580735, "fields", newJString(fields))
  add(query_580735, "quotaUser", newJString(quotaUser))
  add(query_580735, "alt", newJString(alt))
  add(query_580735, "oauth_token", newJString(oauthToken))
  add(query_580735, "userIp", newJString(userIp))
  add(query_580735, "key", newJString(key))
  if body != nil:
    body_580736 = body
  add(query_580735, "prettyPrint", newJBool(prettyPrint))
  result = call_580733.call(path_580734, query_580735, nil, nil, body_580736)

var dfareportingLandingPagesUpdate* = Call_DfareportingLandingPagesUpdate_580719(
    name: "dfareportingLandingPagesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesUpdate_580720,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesUpdate_580721,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesInsert_580737 = ref object of OpenApiRestCall_579437
proc url_DfareportingLandingPagesInsert_580739(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesInsert_580738(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new landing page for the specified campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580740 = path.getOrDefault("profileId")
  valid_580740 = validateParameter(valid_580740, JString, required = true,
                                 default = nil)
  if valid_580740 != nil:
    section.add "profileId", valid_580740
  var valid_580741 = path.getOrDefault("campaignId")
  valid_580741 = validateParameter(valid_580741, JString, required = true,
                                 default = nil)
  if valid_580741 != nil:
    section.add "campaignId", valid_580741
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580742 = query.getOrDefault("fields")
  valid_580742 = validateParameter(valid_580742, JString, required = false,
                                 default = nil)
  if valid_580742 != nil:
    section.add "fields", valid_580742
  var valid_580743 = query.getOrDefault("quotaUser")
  valid_580743 = validateParameter(valid_580743, JString, required = false,
                                 default = nil)
  if valid_580743 != nil:
    section.add "quotaUser", valid_580743
  var valid_580744 = query.getOrDefault("alt")
  valid_580744 = validateParameter(valid_580744, JString, required = false,
                                 default = newJString("json"))
  if valid_580744 != nil:
    section.add "alt", valid_580744
  var valid_580745 = query.getOrDefault("oauth_token")
  valid_580745 = validateParameter(valid_580745, JString, required = false,
                                 default = nil)
  if valid_580745 != nil:
    section.add "oauth_token", valid_580745
  var valid_580746 = query.getOrDefault("userIp")
  valid_580746 = validateParameter(valid_580746, JString, required = false,
                                 default = nil)
  if valid_580746 != nil:
    section.add "userIp", valid_580746
  var valid_580747 = query.getOrDefault("key")
  valid_580747 = validateParameter(valid_580747, JString, required = false,
                                 default = nil)
  if valid_580747 != nil:
    section.add "key", valid_580747
  var valid_580748 = query.getOrDefault("prettyPrint")
  valid_580748 = validateParameter(valid_580748, JBool, required = false,
                                 default = newJBool(true))
  if valid_580748 != nil:
    section.add "prettyPrint", valid_580748
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580750: Call_DfareportingLandingPagesInsert_580737; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new landing page for the specified campaign.
  ## 
  let valid = call_580750.validator(path, query, header, formData, body)
  let scheme = call_580750.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580750.url(scheme.get, call_580750.host, call_580750.base,
                         call_580750.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580750, url, valid)

proc call*(call_580751: Call_DfareportingLandingPagesInsert_580737;
          profileId: string; campaignId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesInsert
  ## Inserts a new landing page for the specified campaign.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580752 = newJObject()
  var query_580753 = newJObject()
  var body_580754 = newJObject()
  add(path_580752, "profileId", newJString(profileId))
  add(path_580752, "campaignId", newJString(campaignId))
  add(query_580753, "fields", newJString(fields))
  add(query_580753, "quotaUser", newJString(quotaUser))
  add(query_580753, "alt", newJString(alt))
  add(query_580753, "oauth_token", newJString(oauthToken))
  add(query_580753, "userIp", newJString(userIp))
  add(query_580753, "key", newJString(key))
  if body != nil:
    body_580754 = body
  add(query_580753, "prettyPrint", newJBool(prettyPrint))
  result = call_580751.call(path_580752, query_580753, nil, nil, body_580754)

var dfareportingLandingPagesInsert* = Call_DfareportingLandingPagesInsert_580737(
    name: "dfareportingLandingPagesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesInsert_580738,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesInsert_580739,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesList_580703 = ref object of OpenApiRestCall_579437
proc url_DfareportingLandingPagesList_580705(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesList_580704(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of landing pages for the specified campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580706 = path.getOrDefault("profileId")
  valid_580706 = validateParameter(valid_580706, JString, required = true,
                                 default = nil)
  if valid_580706 != nil:
    section.add "profileId", valid_580706
  var valid_580707 = path.getOrDefault("campaignId")
  valid_580707 = validateParameter(valid_580707, JString, required = true,
                                 default = nil)
  if valid_580707 != nil:
    section.add "campaignId", valid_580707
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580708 = query.getOrDefault("fields")
  valid_580708 = validateParameter(valid_580708, JString, required = false,
                                 default = nil)
  if valid_580708 != nil:
    section.add "fields", valid_580708
  var valid_580709 = query.getOrDefault("quotaUser")
  valid_580709 = validateParameter(valid_580709, JString, required = false,
                                 default = nil)
  if valid_580709 != nil:
    section.add "quotaUser", valid_580709
  var valid_580710 = query.getOrDefault("alt")
  valid_580710 = validateParameter(valid_580710, JString, required = false,
                                 default = newJString("json"))
  if valid_580710 != nil:
    section.add "alt", valid_580710
  var valid_580711 = query.getOrDefault("oauth_token")
  valid_580711 = validateParameter(valid_580711, JString, required = false,
                                 default = nil)
  if valid_580711 != nil:
    section.add "oauth_token", valid_580711
  var valid_580712 = query.getOrDefault("userIp")
  valid_580712 = validateParameter(valid_580712, JString, required = false,
                                 default = nil)
  if valid_580712 != nil:
    section.add "userIp", valid_580712
  var valid_580713 = query.getOrDefault("key")
  valid_580713 = validateParameter(valid_580713, JString, required = false,
                                 default = nil)
  if valid_580713 != nil:
    section.add "key", valid_580713
  var valid_580714 = query.getOrDefault("prettyPrint")
  valid_580714 = validateParameter(valid_580714, JBool, required = false,
                                 default = newJBool(true))
  if valid_580714 != nil:
    section.add "prettyPrint", valid_580714
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580715: Call_DfareportingLandingPagesList_580703; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves the list of landing pages for the specified campaign.
  ## 
  let valid = call_580715.validator(path, query, header, formData, body)
  let scheme = call_580715.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580715.url(scheme.get, call_580715.host, call_580715.base,
                         call_580715.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580715, url, valid)

proc call*(call_580716: Call_DfareportingLandingPagesList_580703;
          profileId: string; campaignId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesList
  ## Retrieves the list of landing pages for the specified campaign.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580717 = newJObject()
  var query_580718 = newJObject()
  add(path_580717, "profileId", newJString(profileId))
  add(path_580717, "campaignId", newJString(campaignId))
  add(query_580718, "fields", newJString(fields))
  add(query_580718, "quotaUser", newJString(quotaUser))
  add(query_580718, "alt", newJString(alt))
  add(query_580718, "oauth_token", newJString(oauthToken))
  add(query_580718, "userIp", newJString(userIp))
  add(query_580718, "key", newJString(key))
  add(query_580718, "prettyPrint", newJBool(prettyPrint))
  result = call_580716.call(path_580717, query_580718, nil, nil, nil)

var dfareportingLandingPagesList* = Call_DfareportingLandingPagesList_580703(
    name: "dfareportingLandingPagesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesList_580704,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesList_580705,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesPatch_580755 = ref object of OpenApiRestCall_579437
proc url_DfareportingLandingPagesPatch_580757(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesPatch_580756(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign landing page. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580758 = path.getOrDefault("profileId")
  valid_580758 = validateParameter(valid_580758, JString, required = true,
                                 default = nil)
  if valid_580758 != nil:
    section.add "profileId", valid_580758
  var valid_580759 = path.getOrDefault("campaignId")
  valid_580759 = validateParameter(valid_580759, JString, required = true,
                                 default = nil)
  if valid_580759 != nil:
    section.add "campaignId", valid_580759
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Landing page ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580760 = query.getOrDefault("fields")
  valid_580760 = validateParameter(valid_580760, JString, required = false,
                                 default = nil)
  if valid_580760 != nil:
    section.add "fields", valid_580760
  var valid_580761 = query.getOrDefault("quotaUser")
  valid_580761 = validateParameter(valid_580761, JString, required = false,
                                 default = nil)
  if valid_580761 != nil:
    section.add "quotaUser", valid_580761
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580762 = query.getOrDefault("id")
  valid_580762 = validateParameter(valid_580762, JString, required = true,
                                 default = nil)
  if valid_580762 != nil:
    section.add "id", valid_580762
  var valid_580763 = query.getOrDefault("alt")
  valid_580763 = validateParameter(valid_580763, JString, required = false,
                                 default = newJString("json"))
  if valid_580763 != nil:
    section.add "alt", valid_580763
  var valid_580764 = query.getOrDefault("oauth_token")
  valid_580764 = validateParameter(valid_580764, JString, required = false,
                                 default = nil)
  if valid_580764 != nil:
    section.add "oauth_token", valid_580764
  var valid_580765 = query.getOrDefault("userIp")
  valid_580765 = validateParameter(valid_580765, JString, required = false,
                                 default = nil)
  if valid_580765 != nil:
    section.add "userIp", valid_580765
  var valid_580766 = query.getOrDefault("key")
  valid_580766 = validateParameter(valid_580766, JString, required = false,
                                 default = nil)
  if valid_580766 != nil:
    section.add "key", valid_580766
  var valid_580767 = query.getOrDefault("prettyPrint")
  valid_580767 = validateParameter(valid_580767, JBool, required = false,
                                 default = newJBool(true))
  if valid_580767 != nil:
    section.add "prettyPrint", valid_580767
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580769: Call_DfareportingLandingPagesPatch_580755; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign landing page. This method supports patch semantics.
  ## 
  let valid = call_580769.validator(path, query, header, formData, body)
  let scheme = call_580769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580769.url(scheme.get, call_580769.host, call_580769.base,
                         call_580769.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580769, url, valid)

proc call*(call_580770: Call_DfareportingLandingPagesPatch_580755;
          profileId: string; campaignId: string; id: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesPatch
  ## Updates an existing campaign landing page. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Landing page ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580771 = newJObject()
  var query_580772 = newJObject()
  var body_580773 = newJObject()
  add(path_580771, "profileId", newJString(profileId))
  add(path_580771, "campaignId", newJString(campaignId))
  add(query_580772, "fields", newJString(fields))
  add(query_580772, "quotaUser", newJString(quotaUser))
  add(query_580772, "id", newJString(id))
  add(query_580772, "alt", newJString(alt))
  add(query_580772, "oauth_token", newJString(oauthToken))
  add(query_580772, "userIp", newJString(userIp))
  add(query_580772, "key", newJString(key))
  if body != nil:
    body_580773 = body
  add(query_580772, "prettyPrint", newJBool(prettyPrint))
  result = call_580770.call(path_580771, query_580772, nil, nil, body_580773)

var dfareportingLandingPagesPatch* = Call_DfareportingLandingPagesPatch_580755(
    name: "dfareportingLandingPagesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesPatch_580756,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesPatch_580757,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesGet_580774 = ref object of OpenApiRestCall_579437
proc url_DfareportingLandingPagesGet_580776(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesGet_580775(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one campaign landing page by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  ##   id: JString (required)
  ##     : Landing page ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580777 = path.getOrDefault("profileId")
  valid_580777 = validateParameter(valid_580777, JString, required = true,
                                 default = nil)
  if valid_580777 != nil:
    section.add "profileId", valid_580777
  var valid_580778 = path.getOrDefault("campaignId")
  valid_580778 = validateParameter(valid_580778, JString, required = true,
                                 default = nil)
  if valid_580778 != nil:
    section.add "campaignId", valid_580778
  var valid_580779 = path.getOrDefault("id")
  valid_580779 = validateParameter(valid_580779, JString, required = true,
                                 default = nil)
  if valid_580779 != nil:
    section.add "id", valid_580779
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580780 = query.getOrDefault("fields")
  valid_580780 = validateParameter(valid_580780, JString, required = false,
                                 default = nil)
  if valid_580780 != nil:
    section.add "fields", valid_580780
  var valid_580781 = query.getOrDefault("quotaUser")
  valid_580781 = validateParameter(valid_580781, JString, required = false,
                                 default = nil)
  if valid_580781 != nil:
    section.add "quotaUser", valid_580781
  var valid_580782 = query.getOrDefault("alt")
  valid_580782 = validateParameter(valid_580782, JString, required = false,
                                 default = newJString("json"))
  if valid_580782 != nil:
    section.add "alt", valid_580782
  var valid_580783 = query.getOrDefault("oauth_token")
  valid_580783 = validateParameter(valid_580783, JString, required = false,
                                 default = nil)
  if valid_580783 != nil:
    section.add "oauth_token", valid_580783
  var valid_580784 = query.getOrDefault("userIp")
  valid_580784 = validateParameter(valid_580784, JString, required = false,
                                 default = nil)
  if valid_580784 != nil:
    section.add "userIp", valid_580784
  var valid_580785 = query.getOrDefault("key")
  valid_580785 = validateParameter(valid_580785, JString, required = false,
                                 default = nil)
  if valid_580785 != nil:
    section.add "key", valid_580785
  var valid_580786 = query.getOrDefault("prettyPrint")
  valid_580786 = validateParameter(valid_580786, JBool, required = false,
                                 default = newJBool(true))
  if valid_580786 != nil:
    section.add "prettyPrint", valid_580786
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580787: Call_DfareportingLandingPagesGet_580774; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one campaign landing page by ID.
  ## 
  let valid = call_580787.validator(path, query, header, formData, body)
  let scheme = call_580787.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580787.url(scheme.get, call_580787.host, call_580787.base,
                         call_580787.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580787, url, valid)

proc call*(call_580788: Call_DfareportingLandingPagesGet_580774; profileId: string;
          campaignId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesGet
  ## Gets one campaign landing page by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Landing page ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580789 = newJObject()
  var query_580790 = newJObject()
  add(path_580789, "profileId", newJString(profileId))
  add(path_580789, "campaignId", newJString(campaignId))
  add(query_580790, "fields", newJString(fields))
  add(query_580790, "quotaUser", newJString(quotaUser))
  add(query_580790, "alt", newJString(alt))
  add(query_580790, "oauth_token", newJString(oauthToken))
  add(query_580790, "userIp", newJString(userIp))
  add(path_580789, "id", newJString(id))
  add(query_580790, "key", newJString(key))
  add(query_580790, "prettyPrint", newJBool(prettyPrint))
  result = call_580788.call(path_580789, query_580790, nil, nil, nil)

var dfareportingLandingPagesGet* = Call_DfareportingLandingPagesGet_580774(
    name: "dfareportingLandingPagesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages/{id}",
    validator: validate_DfareportingLandingPagesGet_580775,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesGet_580776,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesDelete_580791 = ref object of OpenApiRestCall_579437
proc url_DfareportingLandingPagesDelete_580793(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesDelete_580792(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing campaign landing page.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  ##   id: JString (required)
  ##     : Landing page ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580794 = path.getOrDefault("profileId")
  valid_580794 = validateParameter(valid_580794, JString, required = true,
                                 default = nil)
  if valid_580794 != nil:
    section.add "profileId", valid_580794
  var valid_580795 = path.getOrDefault("campaignId")
  valid_580795 = validateParameter(valid_580795, JString, required = true,
                                 default = nil)
  if valid_580795 != nil:
    section.add "campaignId", valid_580795
  var valid_580796 = path.getOrDefault("id")
  valid_580796 = validateParameter(valid_580796, JString, required = true,
                                 default = nil)
  if valid_580796 != nil:
    section.add "id", valid_580796
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580797 = query.getOrDefault("fields")
  valid_580797 = validateParameter(valid_580797, JString, required = false,
                                 default = nil)
  if valid_580797 != nil:
    section.add "fields", valid_580797
  var valid_580798 = query.getOrDefault("quotaUser")
  valid_580798 = validateParameter(valid_580798, JString, required = false,
                                 default = nil)
  if valid_580798 != nil:
    section.add "quotaUser", valid_580798
  var valid_580799 = query.getOrDefault("alt")
  valid_580799 = validateParameter(valid_580799, JString, required = false,
                                 default = newJString("json"))
  if valid_580799 != nil:
    section.add "alt", valid_580799
  var valid_580800 = query.getOrDefault("oauth_token")
  valid_580800 = validateParameter(valid_580800, JString, required = false,
                                 default = nil)
  if valid_580800 != nil:
    section.add "oauth_token", valid_580800
  var valid_580801 = query.getOrDefault("userIp")
  valid_580801 = validateParameter(valid_580801, JString, required = false,
                                 default = nil)
  if valid_580801 != nil:
    section.add "userIp", valid_580801
  var valid_580802 = query.getOrDefault("key")
  valid_580802 = validateParameter(valid_580802, JString, required = false,
                                 default = nil)
  if valid_580802 != nil:
    section.add "key", valid_580802
  var valid_580803 = query.getOrDefault("prettyPrint")
  valid_580803 = validateParameter(valid_580803, JBool, required = false,
                                 default = newJBool(true))
  if valid_580803 != nil:
    section.add "prettyPrint", valid_580803
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580804: Call_DfareportingLandingPagesDelete_580791; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing campaign landing page.
  ## 
  let valid = call_580804.validator(path, query, header, formData, body)
  let scheme = call_580804.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580804.url(scheme.get, call_580804.host, call_580804.base,
                         call_580804.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580804, url, valid)

proc call*(call_580805: Call_DfareportingLandingPagesDelete_580791;
          profileId: string; campaignId: string; id: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesDelete
  ## Deletes an existing campaign landing page.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Landing page ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580806 = newJObject()
  var query_580807 = newJObject()
  add(path_580806, "profileId", newJString(profileId))
  add(path_580806, "campaignId", newJString(campaignId))
  add(query_580807, "fields", newJString(fields))
  add(query_580807, "quotaUser", newJString(quotaUser))
  add(query_580807, "alt", newJString(alt))
  add(query_580807, "oauth_token", newJString(oauthToken))
  add(query_580807, "userIp", newJString(userIp))
  add(path_580806, "id", newJString(id))
  add(query_580807, "key", newJString(key))
  add(query_580807, "prettyPrint", newJBool(prettyPrint))
  result = call_580805.call(path_580806, query_580807, nil, nil, nil)

var dfareportingLandingPagesDelete* = Call_DfareportingLandingPagesDelete_580791(
    name: "dfareportingLandingPagesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages/{id}",
    validator: validate_DfareportingLandingPagesDelete_580792,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesDelete_580793,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsGet_580808 = ref object of OpenApiRestCall_579437
proc url_DfareportingCampaignsGet_580810(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsGet_580809(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one campaign by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580811 = path.getOrDefault("profileId")
  valid_580811 = validateParameter(valid_580811, JString, required = true,
                                 default = nil)
  if valid_580811 != nil:
    section.add "profileId", valid_580811
  var valid_580812 = path.getOrDefault("id")
  valid_580812 = validateParameter(valid_580812, JString, required = true,
                                 default = nil)
  if valid_580812 != nil:
    section.add "id", valid_580812
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580813 = query.getOrDefault("fields")
  valid_580813 = validateParameter(valid_580813, JString, required = false,
                                 default = nil)
  if valid_580813 != nil:
    section.add "fields", valid_580813
  var valid_580814 = query.getOrDefault("quotaUser")
  valid_580814 = validateParameter(valid_580814, JString, required = false,
                                 default = nil)
  if valid_580814 != nil:
    section.add "quotaUser", valid_580814
  var valid_580815 = query.getOrDefault("alt")
  valid_580815 = validateParameter(valid_580815, JString, required = false,
                                 default = newJString("json"))
  if valid_580815 != nil:
    section.add "alt", valid_580815
  var valid_580816 = query.getOrDefault("oauth_token")
  valid_580816 = validateParameter(valid_580816, JString, required = false,
                                 default = nil)
  if valid_580816 != nil:
    section.add "oauth_token", valid_580816
  var valid_580817 = query.getOrDefault("userIp")
  valid_580817 = validateParameter(valid_580817, JString, required = false,
                                 default = nil)
  if valid_580817 != nil:
    section.add "userIp", valid_580817
  var valid_580818 = query.getOrDefault("key")
  valid_580818 = validateParameter(valid_580818, JString, required = false,
                                 default = nil)
  if valid_580818 != nil:
    section.add "key", valid_580818
  var valid_580819 = query.getOrDefault("prettyPrint")
  valid_580819 = validateParameter(valid_580819, JBool, required = false,
                                 default = newJBool(true))
  if valid_580819 != nil:
    section.add "prettyPrint", valid_580819
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580820: Call_DfareportingCampaignsGet_580808; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one campaign by ID.
  ## 
  let valid = call_580820.validator(path, query, header, formData, body)
  let scheme = call_580820.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580820.url(scheme.get, call_580820.host, call_580820.base,
                         call_580820.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580820, url, valid)

proc call*(call_580821: Call_DfareportingCampaignsGet_580808; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsGet
  ## Gets one campaign by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Campaign ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580822 = newJObject()
  var query_580823 = newJObject()
  add(path_580822, "profileId", newJString(profileId))
  add(query_580823, "fields", newJString(fields))
  add(query_580823, "quotaUser", newJString(quotaUser))
  add(query_580823, "alt", newJString(alt))
  add(query_580823, "oauth_token", newJString(oauthToken))
  add(query_580823, "userIp", newJString(userIp))
  add(path_580822, "id", newJString(id))
  add(query_580823, "key", newJString(key))
  add(query_580823, "prettyPrint", newJBool(prettyPrint))
  result = call_580821.call(path_580822, query_580823, nil, nil, nil)

var dfareportingCampaignsGet* = Call_DfareportingCampaignsGet_580808(
    name: "dfareportingCampaignsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{id}",
    validator: validate_DfareportingCampaignsGet_580809,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsGet_580810,
    schemes: {Scheme.Https})
type
  Call_DfareportingChangeLogsList_580824 = ref object of OpenApiRestCall_579437
proc url_DfareportingChangeLogsList_580826(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/changeLogs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingChangeLogsList_580825(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of change logs. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580827 = path.getOrDefault("profileId")
  valid_580827 = validateParameter(valid_580827, JString, required = true,
                                 default = nil)
  if valid_580827 != nil:
    section.add "profileId", valid_580827
  result.add "path", section
  ## parameters in `query` object:
  ##   action: JString
  ##         : Select only change logs with the specified action.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   minChangeTime: JString
  ##                : Select only change logs whose change time is before the specified minChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Select only change logs whose object ID, user name, old or new values match the search string.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   maxChangeTime: JString
  ##                : Select only change logs whose change time is before the specified maxChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   ids: JArray
  ##      : Select only change logs with these IDs.
  ##   objectType: JString
  ##             : Select only change logs with the specified object type.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   objectIds: JArray
  ##            : Select only change logs with these object IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   userProfileIds: JArray
  ##                 : Select only change logs with these user profile IDs.
  section = newJObject()
  var valid_580828 = query.getOrDefault("action")
  valid_580828 = validateParameter(valid_580828, JString, required = false,
                                 default = newJString("ACTION_ADD"))
  if valid_580828 != nil:
    section.add "action", valid_580828
  var valid_580829 = query.getOrDefault("fields")
  valid_580829 = validateParameter(valid_580829, JString, required = false,
                                 default = nil)
  if valid_580829 != nil:
    section.add "fields", valid_580829
  var valid_580830 = query.getOrDefault("pageToken")
  valid_580830 = validateParameter(valid_580830, JString, required = false,
                                 default = nil)
  if valid_580830 != nil:
    section.add "pageToken", valid_580830
  var valid_580831 = query.getOrDefault("quotaUser")
  valid_580831 = validateParameter(valid_580831, JString, required = false,
                                 default = nil)
  if valid_580831 != nil:
    section.add "quotaUser", valid_580831
  var valid_580832 = query.getOrDefault("minChangeTime")
  valid_580832 = validateParameter(valid_580832, JString, required = false,
                                 default = nil)
  if valid_580832 != nil:
    section.add "minChangeTime", valid_580832
  var valid_580833 = query.getOrDefault("alt")
  valid_580833 = validateParameter(valid_580833, JString, required = false,
                                 default = newJString("json"))
  if valid_580833 != nil:
    section.add "alt", valid_580833
  var valid_580834 = query.getOrDefault("searchString")
  valid_580834 = validateParameter(valid_580834, JString, required = false,
                                 default = nil)
  if valid_580834 != nil:
    section.add "searchString", valid_580834
  var valid_580835 = query.getOrDefault("oauth_token")
  valid_580835 = validateParameter(valid_580835, JString, required = false,
                                 default = nil)
  if valid_580835 != nil:
    section.add "oauth_token", valid_580835
  var valid_580836 = query.getOrDefault("userIp")
  valid_580836 = validateParameter(valid_580836, JString, required = false,
                                 default = nil)
  if valid_580836 != nil:
    section.add "userIp", valid_580836
  var valid_580837 = query.getOrDefault("maxResults")
  valid_580837 = validateParameter(valid_580837, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580837 != nil:
    section.add "maxResults", valid_580837
  var valid_580838 = query.getOrDefault("maxChangeTime")
  valid_580838 = validateParameter(valid_580838, JString, required = false,
                                 default = nil)
  if valid_580838 != nil:
    section.add "maxChangeTime", valid_580838
  var valid_580839 = query.getOrDefault("ids")
  valid_580839 = validateParameter(valid_580839, JArray, required = false,
                                 default = nil)
  if valid_580839 != nil:
    section.add "ids", valid_580839
  var valid_580840 = query.getOrDefault("objectType")
  valid_580840 = validateParameter(valid_580840, JString, required = false,
                                 default = newJString("OBJECT_ACCOUNT"))
  if valid_580840 != nil:
    section.add "objectType", valid_580840
  var valid_580841 = query.getOrDefault("key")
  valid_580841 = validateParameter(valid_580841, JString, required = false,
                                 default = nil)
  if valid_580841 != nil:
    section.add "key", valid_580841
  var valid_580842 = query.getOrDefault("objectIds")
  valid_580842 = validateParameter(valid_580842, JArray, required = false,
                                 default = nil)
  if valid_580842 != nil:
    section.add "objectIds", valid_580842
  var valid_580843 = query.getOrDefault("prettyPrint")
  valid_580843 = validateParameter(valid_580843, JBool, required = false,
                                 default = newJBool(true))
  if valid_580843 != nil:
    section.add "prettyPrint", valid_580843
  var valid_580844 = query.getOrDefault("userProfileIds")
  valid_580844 = validateParameter(valid_580844, JArray, required = false,
                                 default = nil)
  if valid_580844 != nil:
    section.add "userProfileIds", valid_580844
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580845: Call_DfareportingChangeLogsList_580824; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of change logs. This method supports paging.
  ## 
  let valid = call_580845.validator(path, query, header, formData, body)
  let scheme = call_580845.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580845.url(scheme.get, call_580845.host, call_580845.base,
                         call_580845.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580845, url, valid)

proc call*(call_580846: Call_DfareportingChangeLogsList_580824; profileId: string;
          action: string = "ACTION_ADD"; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; minChangeTime: string = ""; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; maxChangeTime: string = ""; ids: JsonNode = nil;
          objectType: string = "OBJECT_ACCOUNT"; key: string = "";
          objectIds: JsonNode = nil; prettyPrint: bool = true;
          userProfileIds: JsonNode = nil): Recallable =
  ## dfareportingChangeLogsList
  ## Retrieves a list of change logs. This method supports paging.
  ##   action: string
  ##         : Select only change logs with the specified action.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   minChangeTime: string
  ##                : Select only change logs whose change time is before the specified minChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Select only change logs whose object ID, user name, old or new values match the search string.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   maxChangeTime: string
  ##                : Select only change logs whose change time is before the specified maxChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   ids: JArray
  ##      : Select only change logs with these IDs.
  ##   objectType: string
  ##             : Select only change logs with the specified object type.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   objectIds: JArray
  ##            : Select only change logs with these object IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userProfileIds: JArray
  ##                 : Select only change logs with these user profile IDs.
  var path_580847 = newJObject()
  var query_580848 = newJObject()
  add(query_580848, "action", newJString(action))
  add(path_580847, "profileId", newJString(profileId))
  add(query_580848, "fields", newJString(fields))
  add(query_580848, "pageToken", newJString(pageToken))
  add(query_580848, "quotaUser", newJString(quotaUser))
  add(query_580848, "minChangeTime", newJString(minChangeTime))
  add(query_580848, "alt", newJString(alt))
  add(query_580848, "searchString", newJString(searchString))
  add(query_580848, "oauth_token", newJString(oauthToken))
  add(query_580848, "userIp", newJString(userIp))
  add(query_580848, "maxResults", newJInt(maxResults))
  add(query_580848, "maxChangeTime", newJString(maxChangeTime))
  if ids != nil:
    query_580848.add "ids", ids
  add(query_580848, "objectType", newJString(objectType))
  add(query_580848, "key", newJString(key))
  if objectIds != nil:
    query_580848.add "objectIds", objectIds
  add(query_580848, "prettyPrint", newJBool(prettyPrint))
  if userProfileIds != nil:
    query_580848.add "userProfileIds", userProfileIds
  result = call_580846.call(path_580847, query_580848, nil, nil, nil)

var dfareportingChangeLogsList* = Call_DfareportingChangeLogsList_580824(
    name: "dfareportingChangeLogsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/changeLogs",
    validator: validate_DfareportingChangeLogsList_580825,
    base: "/dfareporting/v2.7", url: url_DfareportingChangeLogsList_580826,
    schemes: {Scheme.Https})
type
  Call_DfareportingChangeLogsGet_580849 = ref object of OpenApiRestCall_579437
proc url_DfareportingChangeLogsGet_580851(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/changeLogs/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingChangeLogsGet_580850(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one change log by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Change log ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580852 = path.getOrDefault("profileId")
  valid_580852 = validateParameter(valid_580852, JString, required = true,
                                 default = nil)
  if valid_580852 != nil:
    section.add "profileId", valid_580852
  var valid_580853 = path.getOrDefault("id")
  valid_580853 = validateParameter(valid_580853, JString, required = true,
                                 default = nil)
  if valid_580853 != nil:
    section.add "id", valid_580853
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580854 = query.getOrDefault("fields")
  valid_580854 = validateParameter(valid_580854, JString, required = false,
                                 default = nil)
  if valid_580854 != nil:
    section.add "fields", valid_580854
  var valid_580855 = query.getOrDefault("quotaUser")
  valid_580855 = validateParameter(valid_580855, JString, required = false,
                                 default = nil)
  if valid_580855 != nil:
    section.add "quotaUser", valid_580855
  var valid_580856 = query.getOrDefault("alt")
  valid_580856 = validateParameter(valid_580856, JString, required = false,
                                 default = newJString("json"))
  if valid_580856 != nil:
    section.add "alt", valid_580856
  var valid_580857 = query.getOrDefault("oauth_token")
  valid_580857 = validateParameter(valid_580857, JString, required = false,
                                 default = nil)
  if valid_580857 != nil:
    section.add "oauth_token", valid_580857
  var valid_580858 = query.getOrDefault("userIp")
  valid_580858 = validateParameter(valid_580858, JString, required = false,
                                 default = nil)
  if valid_580858 != nil:
    section.add "userIp", valid_580858
  var valid_580859 = query.getOrDefault("key")
  valid_580859 = validateParameter(valid_580859, JString, required = false,
                                 default = nil)
  if valid_580859 != nil:
    section.add "key", valid_580859
  var valid_580860 = query.getOrDefault("prettyPrint")
  valid_580860 = validateParameter(valid_580860, JBool, required = false,
                                 default = newJBool(true))
  if valid_580860 != nil:
    section.add "prettyPrint", valid_580860
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580861: Call_DfareportingChangeLogsGet_580849; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one change log by ID.
  ## 
  let valid = call_580861.validator(path, query, header, formData, body)
  let scheme = call_580861.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580861.url(scheme.get, call_580861.host, call_580861.base,
                         call_580861.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580861, url, valid)

proc call*(call_580862: Call_DfareportingChangeLogsGet_580849; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingChangeLogsGet
  ## Gets one change log by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Change log ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580863 = newJObject()
  var query_580864 = newJObject()
  add(path_580863, "profileId", newJString(profileId))
  add(query_580864, "fields", newJString(fields))
  add(query_580864, "quotaUser", newJString(quotaUser))
  add(query_580864, "alt", newJString(alt))
  add(query_580864, "oauth_token", newJString(oauthToken))
  add(query_580864, "userIp", newJString(userIp))
  add(path_580863, "id", newJString(id))
  add(query_580864, "key", newJString(key))
  add(query_580864, "prettyPrint", newJBool(prettyPrint))
  result = call_580862.call(path_580863, query_580864, nil, nil, nil)

var dfareportingChangeLogsGet* = Call_DfareportingChangeLogsGet_580849(
    name: "dfareportingChangeLogsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/changeLogs/{id}",
    validator: validate_DfareportingChangeLogsGet_580850,
    base: "/dfareporting/v2.7", url: url_DfareportingChangeLogsGet_580851,
    schemes: {Scheme.Https})
type
  Call_DfareportingCitiesList_580865 = ref object of OpenApiRestCall_579437
proc url_DfareportingCitiesList_580867(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/cities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCitiesList_580866(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of cities, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580868 = path.getOrDefault("profileId")
  valid_580868 = validateParameter(valid_580868, JString, required = true,
                                 default = nil)
  if valid_580868 != nil:
    section.add "profileId", valid_580868
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   namePrefix: JString
  ##             : Select only cities with names starting with this prefix.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   countryDartIds: JArray
  ##                 : Select only cities from these countries.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   regionDartIds: JArray
  ##                : Select only cities from these regions.
  ##   dartIds: JArray
  ##          : Select only cities with these DART IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580869 = query.getOrDefault("fields")
  valid_580869 = validateParameter(valid_580869, JString, required = false,
                                 default = nil)
  if valid_580869 != nil:
    section.add "fields", valid_580869
  var valid_580870 = query.getOrDefault("quotaUser")
  valid_580870 = validateParameter(valid_580870, JString, required = false,
                                 default = nil)
  if valid_580870 != nil:
    section.add "quotaUser", valid_580870
  var valid_580871 = query.getOrDefault("alt")
  valid_580871 = validateParameter(valid_580871, JString, required = false,
                                 default = newJString("json"))
  if valid_580871 != nil:
    section.add "alt", valid_580871
  var valid_580872 = query.getOrDefault("namePrefix")
  valid_580872 = validateParameter(valid_580872, JString, required = false,
                                 default = nil)
  if valid_580872 != nil:
    section.add "namePrefix", valid_580872
  var valid_580873 = query.getOrDefault("oauth_token")
  valid_580873 = validateParameter(valid_580873, JString, required = false,
                                 default = nil)
  if valid_580873 != nil:
    section.add "oauth_token", valid_580873
  var valid_580874 = query.getOrDefault("userIp")
  valid_580874 = validateParameter(valid_580874, JString, required = false,
                                 default = nil)
  if valid_580874 != nil:
    section.add "userIp", valid_580874
  var valid_580875 = query.getOrDefault("countryDartIds")
  valid_580875 = validateParameter(valid_580875, JArray, required = false,
                                 default = nil)
  if valid_580875 != nil:
    section.add "countryDartIds", valid_580875
  var valid_580876 = query.getOrDefault("key")
  valid_580876 = validateParameter(valid_580876, JString, required = false,
                                 default = nil)
  if valid_580876 != nil:
    section.add "key", valid_580876
  var valid_580877 = query.getOrDefault("regionDartIds")
  valid_580877 = validateParameter(valid_580877, JArray, required = false,
                                 default = nil)
  if valid_580877 != nil:
    section.add "regionDartIds", valid_580877
  var valid_580878 = query.getOrDefault("dartIds")
  valid_580878 = validateParameter(valid_580878, JArray, required = false,
                                 default = nil)
  if valid_580878 != nil:
    section.add "dartIds", valid_580878
  var valid_580879 = query.getOrDefault("prettyPrint")
  valid_580879 = validateParameter(valid_580879, JBool, required = false,
                                 default = newJBool(true))
  if valid_580879 != nil:
    section.add "prettyPrint", valid_580879
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580880: Call_DfareportingCitiesList_580865; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of cities, possibly filtered.
  ## 
  let valid = call_580880.validator(path, query, header, formData, body)
  let scheme = call_580880.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580880.url(scheme.get, call_580880.host, call_580880.base,
                         call_580880.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580880, url, valid)

proc call*(call_580881: Call_DfareportingCitiesList_580865; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          namePrefix: string = ""; oauthToken: string = ""; userIp: string = "";
          countryDartIds: JsonNode = nil; key: string = "";
          regionDartIds: JsonNode = nil; dartIds: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCitiesList
  ## Retrieves a list of cities, possibly filtered.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   namePrefix: string
  ##             : Select only cities with names starting with this prefix.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   countryDartIds: JArray
  ##                 : Select only cities from these countries.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   regionDartIds: JArray
  ##                : Select only cities from these regions.
  ##   dartIds: JArray
  ##          : Select only cities with these DART IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580882 = newJObject()
  var query_580883 = newJObject()
  add(path_580882, "profileId", newJString(profileId))
  add(query_580883, "fields", newJString(fields))
  add(query_580883, "quotaUser", newJString(quotaUser))
  add(query_580883, "alt", newJString(alt))
  add(query_580883, "namePrefix", newJString(namePrefix))
  add(query_580883, "oauth_token", newJString(oauthToken))
  add(query_580883, "userIp", newJString(userIp))
  if countryDartIds != nil:
    query_580883.add "countryDartIds", countryDartIds
  add(query_580883, "key", newJString(key))
  if regionDartIds != nil:
    query_580883.add "regionDartIds", regionDartIds
  if dartIds != nil:
    query_580883.add "dartIds", dartIds
  add(query_580883, "prettyPrint", newJBool(prettyPrint))
  result = call_580881.call(path_580882, query_580883, nil, nil, nil)

var dfareportingCitiesList* = Call_DfareportingCitiesList_580865(
    name: "dfareportingCitiesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/cities",
    validator: validate_DfareportingCitiesList_580866, base: "/dfareporting/v2.7",
    url: url_DfareportingCitiesList_580867, schemes: {Scheme.Https})
type
  Call_DfareportingConnectionTypesList_580884 = ref object of OpenApiRestCall_579437
proc url_DfareportingConnectionTypesList_580886(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/connectionTypes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingConnectionTypesList_580885(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of connection types.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580887 = path.getOrDefault("profileId")
  valid_580887 = validateParameter(valid_580887, JString, required = true,
                                 default = nil)
  if valid_580887 != nil:
    section.add "profileId", valid_580887
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580888 = query.getOrDefault("fields")
  valid_580888 = validateParameter(valid_580888, JString, required = false,
                                 default = nil)
  if valid_580888 != nil:
    section.add "fields", valid_580888
  var valid_580889 = query.getOrDefault("quotaUser")
  valid_580889 = validateParameter(valid_580889, JString, required = false,
                                 default = nil)
  if valid_580889 != nil:
    section.add "quotaUser", valid_580889
  var valid_580890 = query.getOrDefault("alt")
  valid_580890 = validateParameter(valid_580890, JString, required = false,
                                 default = newJString("json"))
  if valid_580890 != nil:
    section.add "alt", valid_580890
  var valid_580891 = query.getOrDefault("oauth_token")
  valid_580891 = validateParameter(valid_580891, JString, required = false,
                                 default = nil)
  if valid_580891 != nil:
    section.add "oauth_token", valid_580891
  var valid_580892 = query.getOrDefault("userIp")
  valid_580892 = validateParameter(valid_580892, JString, required = false,
                                 default = nil)
  if valid_580892 != nil:
    section.add "userIp", valid_580892
  var valid_580893 = query.getOrDefault("key")
  valid_580893 = validateParameter(valid_580893, JString, required = false,
                                 default = nil)
  if valid_580893 != nil:
    section.add "key", valid_580893
  var valid_580894 = query.getOrDefault("prettyPrint")
  valid_580894 = validateParameter(valid_580894, JBool, required = false,
                                 default = newJBool(true))
  if valid_580894 != nil:
    section.add "prettyPrint", valid_580894
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580895: Call_DfareportingConnectionTypesList_580884;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of connection types.
  ## 
  let valid = call_580895.validator(path, query, header, formData, body)
  let scheme = call_580895.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580895.url(scheme.get, call_580895.host, call_580895.base,
                         call_580895.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580895, url, valid)

proc call*(call_580896: Call_DfareportingConnectionTypesList_580884;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingConnectionTypesList
  ## Retrieves a list of connection types.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580897 = newJObject()
  var query_580898 = newJObject()
  add(path_580897, "profileId", newJString(profileId))
  add(query_580898, "fields", newJString(fields))
  add(query_580898, "quotaUser", newJString(quotaUser))
  add(query_580898, "alt", newJString(alt))
  add(query_580898, "oauth_token", newJString(oauthToken))
  add(query_580898, "userIp", newJString(userIp))
  add(query_580898, "key", newJString(key))
  add(query_580898, "prettyPrint", newJBool(prettyPrint))
  result = call_580896.call(path_580897, query_580898, nil, nil, nil)

var dfareportingConnectionTypesList* = Call_DfareportingConnectionTypesList_580884(
    name: "dfareportingConnectionTypesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/connectionTypes",
    validator: validate_DfareportingConnectionTypesList_580885,
    base: "/dfareporting/v2.7", url: url_DfareportingConnectionTypesList_580886,
    schemes: {Scheme.Https})
type
  Call_DfareportingConnectionTypesGet_580899 = ref object of OpenApiRestCall_579437
proc url_DfareportingConnectionTypesGet_580901(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/connectionTypes/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingConnectionTypesGet_580900(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one connection type by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Connection type ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580902 = path.getOrDefault("profileId")
  valid_580902 = validateParameter(valid_580902, JString, required = true,
                                 default = nil)
  if valid_580902 != nil:
    section.add "profileId", valid_580902
  var valid_580903 = path.getOrDefault("id")
  valid_580903 = validateParameter(valid_580903, JString, required = true,
                                 default = nil)
  if valid_580903 != nil:
    section.add "id", valid_580903
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580904 = query.getOrDefault("fields")
  valid_580904 = validateParameter(valid_580904, JString, required = false,
                                 default = nil)
  if valid_580904 != nil:
    section.add "fields", valid_580904
  var valid_580905 = query.getOrDefault("quotaUser")
  valid_580905 = validateParameter(valid_580905, JString, required = false,
                                 default = nil)
  if valid_580905 != nil:
    section.add "quotaUser", valid_580905
  var valid_580906 = query.getOrDefault("alt")
  valid_580906 = validateParameter(valid_580906, JString, required = false,
                                 default = newJString("json"))
  if valid_580906 != nil:
    section.add "alt", valid_580906
  var valid_580907 = query.getOrDefault("oauth_token")
  valid_580907 = validateParameter(valid_580907, JString, required = false,
                                 default = nil)
  if valid_580907 != nil:
    section.add "oauth_token", valid_580907
  var valid_580908 = query.getOrDefault("userIp")
  valid_580908 = validateParameter(valid_580908, JString, required = false,
                                 default = nil)
  if valid_580908 != nil:
    section.add "userIp", valid_580908
  var valid_580909 = query.getOrDefault("key")
  valid_580909 = validateParameter(valid_580909, JString, required = false,
                                 default = nil)
  if valid_580909 != nil:
    section.add "key", valid_580909
  var valid_580910 = query.getOrDefault("prettyPrint")
  valid_580910 = validateParameter(valid_580910, JBool, required = false,
                                 default = newJBool(true))
  if valid_580910 != nil:
    section.add "prettyPrint", valid_580910
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580911: Call_DfareportingConnectionTypesGet_580899; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one connection type by ID.
  ## 
  let valid = call_580911.validator(path, query, header, formData, body)
  let scheme = call_580911.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580911.url(scheme.get, call_580911.host, call_580911.base,
                         call_580911.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580911, url, valid)

proc call*(call_580912: Call_DfareportingConnectionTypesGet_580899;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingConnectionTypesGet
  ## Gets one connection type by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Connection type ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580913 = newJObject()
  var query_580914 = newJObject()
  add(path_580913, "profileId", newJString(profileId))
  add(query_580914, "fields", newJString(fields))
  add(query_580914, "quotaUser", newJString(quotaUser))
  add(query_580914, "alt", newJString(alt))
  add(query_580914, "oauth_token", newJString(oauthToken))
  add(query_580914, "userIp", newJString(userIp))
  add(path_580913, "id", newJString(id))
  add(query_580914, "key", newJString(key))
  add(query_580914, "prettyPrint", newJBool(prettyPrint))
  result = call_580912.call(path_580913, query_580914, nil, nil, nil)

var dfareportingConnectionTypesGet* = Call_DfareportingConnectionTypesGet_580899(
    name: "dfareportingConnectionTypesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/connectionTypes/{id}",
    validator: validate_DfareportingConnectionTypesGet_580900,
    base: "/dfareporting/v2.7", url: url_DfareportingConnectionTypesGet_580901,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesUpdate_580936 = ref object of OpenApiRestCall_579437
proc url_DfareportingContentCategoriesUpdate_580938(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesUpdate_580937(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing content category.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580939 = path.getOrDefault("profileId")
  valid_580939 = validateParameter(valid_580939, JString, required = true,
                                 default = nil)
  if valid_580939 != nil:
    section.add "profileId", valid_580939
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580940 = query.getOrDefault("fields")
  valid_580940 = validateParameter(valid_580940, JString, required = false,
                                 default = nil)
  if valid_580940 != nil:
    section.add "fields", valid_580940
  var valid_580941 = query.getOrDefault("quotaUser")
  valid_580941 = validateParameter(valid_580941, JString, required = false,
                                 default = nil)
  if valid_580941 != nil:
    section.add "quotaUser", valid_580941
  var valid_580942 = query.getOrDefault("alt")
  valid_580942 = validateParameter(valid_580942, JString, required = false,
                                 default = newJString("json"))
  if valid_580942 != nil:
    section.add "alt", valid_580942
  var valid_580943 = query.getOrDefault("oauth_token")
  valid_580943 = validateParameter(valid_580943, JString, required = false,
                                 default = nil)
  if valid_580943 != nil:
    section.add "oauth_token", valid_580943
  var valid_580944 = query.getOrDefault("userIp")
  valid_580944 = validateParameter(valid_580944, JString, required = false,
                                 default = nil)
  if valid_580944 != nil:
    section.add "userIp", valid_580944
  var valid_580945 = query.getOrDefault("key")
  valid_580945 = validateParameter(valid_580945, JString, required = false,
                                 default = nil)
  if valid_580945 != nil:
    section.add "key", valid_580945
  var valid_580946 = query.getOrDefault("prettyPrint")
  valid_580946 = validateParameter(valid_580946, JBool, required = false,
                                 default = newJBool(true))
  if valid_580946 != nil:
    section.add "prettyPrint", valid_580946
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580948: Call_DfareportingContentCategoriesUpdate_580936;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing content category.
  ## 
  let valid = call_580948.validator(path, query, header, formData, body)
  let scheme = call_580948.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580948.url(scheme.get, call_580948.host, call_580948.base,
                         call_580948.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580948, url, valid)

proc call*(call_580949: Call_DfareportingContentCategoriesUpdate_580936;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesUpdate
  ## Updates an existing content category.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580950 = newJObject()
  var query_580951 = newJObject()
  var body_580952 = newJObject()
  add(path_580950, "profileId", newJString(profileId))
  add(query_580951, "fields", newJString(fields))
  add(query_580951, "quotaUser", newJString(quotaUser))
  add(query_580951, "alt", newJString(alt))
  add(query_580951, "oauth_token", newJString(oauthToken))
  add(query_580951, "userIp", newJString(userIp))
  add(query_580951, "key", newJString(key))
  if body != nil:
    body_580952 = body
  add(query_580951, "prettyPrint", newJBool(prettyPrint))
  result = call_580949.call(path_580950, query_580951, nil, nil, body_580952)

var dfareportingContentCategoriesUpdate* = Call_DfareportingContentCategoriesUpdate_580936(
    name: "dfareportingContentCategoriesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesUpdate_580937,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesUpdate_580938,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesInsert_580953 = ref object of OpenApiRestCall_579437
proc url_DfareportingContentCategoriesInsert_580955(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesInsert_580954(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new content category.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580956 = path.getOrDefault("profileId")
  valid_580956 = validateParameter(valid_580956, JString, required = true,
                                 default = nil)
  if valid_580956 != nil:
    section.add "profileId", valid_580956
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580957 = query.getOrDefault("fields")
  valid_580957 = validateParameter(valid_580957, JString, required = false,
                                 default = nil)
  if valid_580957 != nil:
    section.add "fields", valid_580957
  var valid_580958 = query.getOrDefault("quotaUser")
  valid_580958 = validateParameter(valid_580958, JString, required = false,
                                 default = nil)
  if valid_580958 != nil:
    section.add "quotaUser", valid_580958
  var valid_580959 = query.getOrDefault("alt")
  valid_580959 = validateParameter(valid_580959, JString, required = false,
                                 default = newJString("json"))
  if valid_580959 != nil:
    section.add "alt", valid_580959
  var valid_580960 = query.getOrDefault("oauth_token")
  valid_580960 = validateParameter(valid_580960, JString, required = false,
                                 default = nil)
  if valid_580960 != nil:
    section.add "oauth_token", valid_580960
  var valid_580961 = query.getOrDefault("userIp")
  valid_580961 = validateParameter(valid_580961, JString, required = false,
                                 default = nil)
  if valid_580961 != nil:
    section.add "userIp", valid_580961
  var valid_580962 = query.getOrDefault("key")
  valid_580962 = validateParameter(valid_580962, JString, required = false,
                                 default = nil)
  if valid_580962 != nil:
    section.add "key", valid_580962
  var valid_580963 = query.getOrDefault("prettyPrint")
  valid_580963 = validateParameter(valid_580963, JBool, required = false,
                                 default = newJBool(true))
  if valid_580963 != nil:
    section.add "prettyPrint", valid_580963
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580965: Call_DfareportingContentCategoriesInsert_580953;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new content category.
  ## 
  let valid = call_580965.validator(path, query, header, formData, body)
  let scheme = call_580965.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580965.url(scheme.get, call_580965.host, call_580965.base,
                         call_580965.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580965, url, valid)

proc call*(call_580966: Call_DfareportingContentCategoriesInsert_580953;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesInsert
  ## Inserts a new content category.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580967 = newJObject()
  var query_580968 = newJObject()
  var body_580969 = newJObject()
  add(path_580967, "profileId", newJString(profileId))
  add(query_580968, "fields", newJString(fields))
  add(query_580968, "quotaUser", newJString(quotaUser))
  add(query_580968, "alt", newJString(alt))
  add(query_580968, "oauth_token", newJString(oauthToken))
  add(query_580968, "userIp", newJString(userIp))
  add(query_580968, "key", newJString(key))
  if body != nil:
    body_580969 = body
  add(query_580968, "prettyPrint", newJBool(prettyPrint))
  result = call_580966.call(path_580967, query_580968, nil, nil, body_580969)

var dfareportingContentCategoriesInsert* = Call_DfareportingContentCategoriesInsert_580953(
    name: "dfareportingContentCategoriesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesInsert_580954,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesInsert_580955,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesList_580915 = ref object of OpenApiRestCall_579437
proc url_DfareportingContentCategoriesList_580917(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesList_580916(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of content categories, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580918 = path.getOrDefault("profileId")
  valid_580918 = validateParameter(valid_580918, JString, required = true,
                                 default = nil)
  if valid_580918 != nil:
    section.add "profileId", valid_580918
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "contentcategory*2015" will return objects with names like "contentcategory June 2015", "contentcategory April 2015", or simply "contentcategory 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "contentcategory" will match objects with name "my contentcategory", "contentcategory 2015", or simply "contentcategory".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only content categories with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580919 = query.getOrDefault("fields")
  valid_580919 = validateParameter(valid_580919, JString, required = false,
                                 default = nil)
  if valid_580919 != nil:
    section.add "fields", valid_580919
  var valid_580920 = query.getOrDefault("pageToken")
  valid_580920 = validateParameter(valid_580920, JString, required = false,
                                 default = nil)
  if valid_580920 != nil:
    section.add "pageToken", valid_580920
  var valid_580921 = query.getOrDefault("quotaUser")
  valid_580921 = validateParameter(valid_580921, JString, required = false,
                                 default = nil)
  if valid_580921 != nil:
    section.add "quotaUser", valid_580921
  var valid_580922 = query.getOrDefault("sortField")
  valid_580922 = validateParameter(valid_580922, JString, required = false,
                                 default = newJString("ID"))
  if valid_580922 != nil:
    section.add "sortField", valid_580922
  var valid_580923 = query.getOrDefault("alt")
  valid_580923 = validateParameter(valid_580923, JString, required = false,
                                 default = newJString("json"))
  if valid_580923 != nil:
    section.add "alt", valid_580923
  var valid_580924 = query.getOrDefault("searchString")
  valid_580924 = validateParameter(valid_580924, JString, required = false,
                                 default = nil)
  if valid_580924 != nil:
    section.add "searchString", valid_580924
  var valid_580925 = query.getOrDefault("oauth_token")
  valid_580925 = validateParameter(valid_580925, JString, required = false,
                                 default = nil)
  if valid_580925 != nil:
    section.add "oauth_token", valid_580925
  var valid_580926 = query.getOrDefault("userIp")
  valid_580926 = validateParameter(valid_580926, JString, required = false,
                                 default = nil)
  if valid_580926 != nil:
    section.add "userIp", valid_580926
  var valid_580927 = query.getOrDefault("maxResults")
  valid_580927 = validateParameter(valid_580927, JInt, required = false,
                                 default = newJInt(1000))
  if valid_580927 != nil:
    section.add "maxResults", valid_580927
  var valid_580928 = query.getOrDefault("ids")
  valid_580928 = validateParameter(valid_580928, JArray, required = false,
                                 default = nil)
  if valid_580928 != nil:
    section.add "ids", valid_580928
  var valid_580929 = query.getOrDefault("key")
  valid_580929 = validateParameter(valid_580929, JString, required = false,
                                 default = nil)
  if valid_580929 != nil:
    section.add "key", valid_580929
  var valid_580930 = query.getOrDefault("sortOrder")
  valid_580930 = validateParameter(valid_580930, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_580930 != nil:
    section.add "sortOrder", valid_580930
  var valid_580931 = query.getOrDefault("prettyPrint")
  valid_580931 = validateParameter(valid_580931, JBool, required = false,
                                 default = newJBool(true))
  if valid_580931 != nil:
    section.add "prettyPrint", valid_580931
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_580932: Call_DfareportingContentCategoriesList_580915;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of content categories, possibly filtered. This method supports paging.
  ## 
  let valid = call_580932.validator(path, query, header, formData, body)
  let scheme = call_580932.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580932.url(scheme.get, call_580932.host, call_580932.base,
                         call_580932.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580932, url, valid)

proc call*(call_580933: Call_DfareportingContentCategoriesList_580915;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesList
  ## Retrieves a list of content categories, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "contentcategory*2015" will return objects with names like "contentcategory June 2015", "contentcategory April 2015", or simply "contentcategory 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "contentcategory" will match objects with name "my contentcategory", "contentcategory 2015", or simply "contentcategory".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only content categories with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580934 = newJObject()
  var query_580935 = newJObject()
  add(path_580934, "profileId", newJString(profileId))
  add(query_580935, "fields", newJString(fields))
  add(query_580935, "pageToken", newJString(pageToken))
  add(query_580935, "quotaUser", newJString(quotaUser))
  add(query_580935, "sortField", newJString(sortField))
  add(query_580935, "alt", newJString(alt))
  add(query_580935, "searchString", newJString(searchString))
  add(query_580935, "oauth_token", newJString(oauthToken))
  add(query_580935, "userIp", newJString(userIp))
  add(query_580935, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_580935.add "ids", ids
  add(query_580935, "key", newJString(key))
  add(query_580935, "sortOrder", newJString(sortOrder))
  add(query_580935, "prettyPrint", newJBool(prettyPrint))
  result = call_580933.call(path_580934, query_580935, nil, nil, nil)

var dfareportingContentCategoriesList* = Call_DfareportingContentCategoriesList_580915(
    name: "dfareportingContentCategoriesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesList_580916,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesList_580917,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesPatch_580970 = ref object of OpenApiRestCall_579437
proc url_DfareportingContentCategoriesPatch_580972(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesPatch_580971(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing content category. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580973 = path.getOrDefault("profileId")
  valid_580973 = validateParameter(valid_580973, JString, required = true,
                                 default = nil)
  if valid_580973 != nil:
    section.add "profileId", valid_580973
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Content category ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580974 = query.getOrDefault("fields")
  valid_580974 = validateParameter(valid_580974, JString, required = false,
                                 default = nil)
  if valid_580974 != nil:
    section.add "fields", valid_580974
  var valid_580975 = query.getOrDefault("quotaUser")
  valid_580975 = validateParameter(valid_580975, JString, required = false,
                                 default = nil)
  if valid_580975 != nil:
    section.add "quotaUser", valid_580975
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_580976 = query.getOrDefault("id")
  valid_580976 = validateParameter(valid_580976, JString, required = true,
                                 default = nil)
  if valid_580976 != nil:
    section.add "id", valid_580976
  var valid_580977 = query.getOrDefault("alt")
  valid_580977 = validateParameter(valid_580977, JString, required = false,
                                 default = newJString("json"))
  if valid_580977 != nil:
    section.add "alt", valid_580977
  var valid_580978 = query.getOrDefault("oauth_token")
  valid_580978 = validateParameter(valid_580978, JString, required = false,
                                 default = nil)
  if valid_580978 != nil:
    section.add "oauth_token", valid_580978
  var valid_580979 = query.getOrDefault("userIp")
  valid_580979 = validateParameter(valid_580979, JString, required = false,
                                 default = nil)
  if valid_580979 != nil:
    section.add "userIp", valid_580979
  var valid_580980 = query.getOrDefault("key")
  valid_580980 = validateParameter(valid_580980, JString, required = false,
                                 default = nil)
  if valid_580980 != nil:
    section.add "key", valid_580980
  var valid_580981 = query.getOrDefault("prettyPrint")
  valid_580981 = validateParameter(valid_580981, JBool, required = false,
                                 default = newJBool(true))
  if valid_580981 != nil:
    section.add "prettyPrint", valid_580981
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_580983: Call_DfareportingContentCategoriesPatch_580970;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing content category. This method supports patch semantics.
  ## 
  let valid = call_580983.validator(path, query, header, formData, body)
  let scheme = call_580983.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_580983.url(scheme.get, call_580983.host, call_580983.base,
                         call_580983.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_580983, url, valid)

proc call*(call_580984: Call_DfareportingContentCategoriesPatch_580970;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesPatch
  ## Updates an existing content category. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Content category ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_580985 = newJObject()
  var query_580986 = newJObject()
  var body_580987 = newJObject()
  add(path_580985, "profileId", newJString(profileId))
  add(query_580986, "fields", newJString(fields))
  add(query_580986, "quotaUser", newJString(quotaUser))
  add(query_580986, "id", newJString(id))
  add(query_580986, "alt", newJString(alt))
  add(query_580986, "oauth_token", newJString(oauthToken))
  add(query_580986, "userIp", newJString(userIp))
  add(query_580986, "key", newJString(key))
  if body != nil:
    body_580987 = body
  add(query_580986, "prettyPrint", newJBool(prettyPrint))
  result = call_580984.call(path_580985, query_580986, nil, nil, body_580987)

var dfareportingContentCategoriesPatch* = Call_DfareportingContentCategoriesPatch_580970(
    name: "dfareportingContentCategoriesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesPatch_580971,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesPatch_580972,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesGet_580988 = ref object of OpenApiRestCall_579437
proc url_DfareportingContentCategoriesGet_580990(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesGet_580989(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one content category by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Content category ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_580991 = path.getOrDefault("profileId")
  valid_580991 = validateParameter(valid_580991, JString, required = true,
                                 default = nil)
  if valid_580991 != nil:
    section.add "profileId", valid_580991
  var valid_580992 = path.getOrDefault("id")
  valid_580992 = validateParameter(valid_580992, JString, required = true,
                                 default = nil)
  if valid_580992 != nil:
    section.add "id", valid_580992
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_580993 = query.getOrDefault("fields")
  valid_580993 = validateParameter(valid_580993, JString, required = false,
                                 default = nil)
  if valid_580993 != nil:
    section.add "fields", valid_580993
  var valid_580994 = query.getOrDefault("quotaUser")
  valid_580994 = validateParameter(valid_580994, JString, required = false,
                                 default = nil)
  if valid_580994 != nil:
    section.add "quotaUser", valid_580994
  var valid_580995 = query.getOrDefault("alt")
  valid_580995 = validateParameter(valid_580995, JString, required = false,
                                 default = newJString("json"))
  if valid_580995 != nil:
    section.add "alt", valid_580995
  var valid_580996 = query.getOrDefault("oauth_token")
  valid_580996 = validateParameter(valid_580996, JString, required = false,
                                 default = nil)
  if valid_580996 != nil:
    section.add "oauth_token", valid_580996
  var valid_580997 = query.getOrDefault("userIp")
  valid_580997 = validateParameter(valid_580997, JString, required = false,
                                 default = nil)
  if valid_580997 != nil:
    section.add "userIp", valid_580997
  var valid_580998 = query.getOrDefault("key")
  valid_580998 = validateParameter(valid_580998, JString, required = false,
                                 default = nil)
  if valid_580998 != nil:
    section.add "key", valid_580998
  var valid_580999 = query.getOrDefault("prettyPrint")
  valid_580999 = validateParameter(valid_580999, JBool, required = false,
                                 default = newJBool(true))
  if valid_580999 != nil:
    section.add "prettyPrint", valid_580999
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581000: Call_DfareportingContentCategoriesGet_580988;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one content category by ID.
  ## 
  let valid = call_581000.validator(path, query, header, formData, body)
  let scheme = call_581000.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581000.url(scheme.get, call_581000.host, call_581000.base,
                         call_581000.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581000, url, valid)

proc call*(call_581001: Call_DfareportingContentCategoriesGet_580988;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesGet
  ## Gets one content category by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Content category ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581002 = newJObject()
  var query_581003 = newJObject()
  add(path_581002, "profileId", newJString(profileId))
  add(query_581003, "fields", newJString(fields))
  add(query_581003, "quotaUser", newJString(quotaUser))
  add(query_581003, "alt", newJString(alt))
  add(query_581003, "oauth_token", newJString(oauthToken))
  add(query_581003, "userIp", newJString(userIp))
  add(path_581002, "id", newJString(id))
  add(query_581003, "key", newJString(key))
  add(query_581003, "prettyPrint", newJBool(prettyPrint))
  result = call_581001.call(path_581002, query_581003, nil, nil, nil)

var dfareportingContentCategoriesGet* = Call_DfareportingContentCategoriesGet_580988(
    name: "dfareportingContentCategoriesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories/{id}",
    validator: validate_DfareportingContentCategoriesGet_580989,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesGet_580990,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesDelete_581004 = ref object of OpenApiRestCall_579437
proc url_DfareportingContentCategoriesDelete_581006(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesDelete_581005(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing content category.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Content category ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581007 = path.getOrDefault("profileId")
  valid_581007 = validateParameter(valid_581007, JString, required = true,
                                 default = nil)
  if valid_581007 != nil:
    section.add "profileId", valid_581007
  var valid_581008 = path.getOrDefault("id")
  valid_581008 = validateParameter(valid_581008, JString, required = true,
                                 default = nil)
  if valid_581008 != nil:
    section.add "id", valid_581008
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581009 = query.getOrDefault("fields")
  valid_581009 = validateParameter(valid_581009, JString, required = false,
                                 default = nil)
  if valid_581009 != nil:
    section.add "fields", valid_581009
  var valid_581010 = query.getOrDefault("quotaUser")
  valid_581010 = validateParameter(valid_581010, JString, required = false,
                                 default = nil)
  if valid_581010 != nil:
    section.add "quotaUser", valid_581010
  var valid_581011 = query.getOrDefault("alt")
  valid_581011 = validateParameter(valid_581011, JString, required = false,
                                 default = newJString("json"))
  if valid_581011 != nil:
    section.add "alt", valid_581011
  var valid_581012 = query.getOrDefault("oauth_token")
  valid_581012 = validateParameter(valid_581012, JString, required = false,
                                 default = nil)
  if valid_581012 != nil:
    section.add "oauth_token", valid_581012
  var valid_581013 = query.getOrDefault("userIp")
  valid_581013 = validateParameter(valid_581013, JString, required = false,
                                 default = nil)
  if valid_581013 != nil:
    section.add "userIp", valid_581013
  var valid_581014 = query.getOrDefault("key")
  valid_581014 = validateParameter(valid_581014, JString, required = false,
                                 default = nil)
  if valid_581014 != nil:
    section.add "key", valid_581014
  var valid_581015 = query.getOrDefault("prettyPrint")
  valid_581015 = validateParameter(valid_581015, JBool, required = false,
                                 default = newJBool(true))
  if valid_581015 != nil:
    section.add "prettyPrint", valid_581015
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581016: Call_DfareportingContentCategoriesDelete_581004;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing content category.
  ## 
  let valid = call_581016.validator(path, query, header, formData, body)
  let scheme = call_581016.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581016.url(scheme.get, call_581016.host, call_581016.base,
                         call_581016.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581016, url, valid)

proc call*(call_581017: Call_DfareportingContentCategoriesDelete_581004;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesDelete
  ## Deletes an existing content category.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Content category ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581018 = newJObject()
  var query_581019 = newJObject()
  add(path_581018, "profileId", newJString(profileId))
  add(query_581019, "fields", newJString(fields))
  add(query_581019, "quotaUser", newJString(quotaUser))
  add(query_581019, "alt", newJString(alt))
  add(query_581019, "oauth_token", newJString(oauthToken))
  add(query_581019, "userIp", newJString(userIp))
  add(path_581018, "id", newJString(id))
  add(query_581019, "key", newJString(key))
  add(query_581019, "prettyPrint", newJBool(prettyPrint))
  result = call_581017.call(path_581018, query_581019, nil, nil, nil)

var dfareportingContentCategoriesDelete* = Call_DfareportingContentCategoriesDelete_581004(
    name: "dfareportingContentCategoriesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories/{id}",
    validator: validate_DfareportingContentCategoriesDelete_581005,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesDelete_581006,
    schemes: {Scheme.Https})
type
  Call_DfareportingConversionsBatchinsert_581020 = ref object of OpenApiRestCall_579437
proc url_DfareportingConversionsBatchinsert_581022(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/conversions/batchinsert")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingConversionsBatchinsert_581021(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts conversions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581023 = path.getOrDefault("profileId")
  valid_581023 = validateParameter(valid_581023, JString, required = true,
                                 default = nil)
  if valid_581023 != nil:
    section.add "profileId", valid_581023
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581024 = query.getOrDefault("fields")
  valid_581024 = validateParameter(valid_581024, JString, required = false,
                                 default = nil)
  if valid_581024 != nil:
    section.add "fields", valid_581024
  var valid_581025 = query.getOrDefault("quotaUser")
  valid_581025 = validateParameter(valid_581025, JString, required = false,
                                 default = nil)
  if valid_581025 != nil:
    section.add "quotaUser", valid_581025
  var valid_581026 = query.getOrDefault("alt")
  valid_581026 = validateParameter(valid_581026, JString, required = false,
                                 default = newJString("json"))
  if valid_581026 != nil:
    section.add "alt", valid_581026
  var valid_581027 = query.getOrDefault("oauth_token")
  valid_581027 = validateParameter(valid_581027, JString, required = false,
                                 default = nil)
  if valid_581027 != nil:
    section.add "oauth_token", valid_581027
  var valid_581028 = query.getOrDefault("userIp")
  valid_581028 = validateParameter(valid_581028, JString, required = false,
                                 default = nil)
  if valid_581028 != nil:
    section.add "userIp", valid_581028
  var valid_581029 = query.getOrDefault("key")
  valid_581029 = validateParameter(valid_581029, JString, required = false,
                                 default = nil)
  if valid_581029 != nil:
    section.add "key", valid_581029
  var valid_581030 = query.getOrDefault("prettyPrint")
  valid_581030 = validateParameter(valid_581030, JBool, required = false,
                                 default = newJBool(true))
  if valid_581030 != nil:
    section.add "prettyPrint", valid_581030
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581032: Call_DfareportingConversionsBatchinsert_581020;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts conversions.
  ## 
  let valid = call_581032.validator(path, query, header, formData, body)
  let scheme = call_581032.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581032.url(scheme.get, call_581032.host, call_581032.base,
                         call_581032.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581032, url, valid)

proc call*(call_581033: Call_DfareportingConversionsBatchinsert_581020;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingConversionsBatchinsert
  ## Inserts conversions.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581034 = newJObject()
  var query_581035 = newJObject()
  var body_581036 = newJObject()
  add(path_581034, "profileId", newJString(profileId))
  add(query_581035, "fields", newJString(fields))
  add(query_581035, "quotaUser", newJString(quotaUser))
  add(query_581035, "alt", newJString(alt))
  add(query_581035, "oauth_token", newJString(oauthToken))
  add(query_581035, "userIp", newJString(userIp))
  add(query_581035, "key", newJString(key))
  if body != nil:
    body_581036 = body
  add(query_581035, "prettyPrint", newJBool(prettyPrint))
  result = call_581033.call(path_581034, query_581035, nil, nil, body_581036)

var dfareportingConversionsBatchinsert* = Call_DfareportingConversionsBatchinsert_581020(
    name: "dfareportingConversionsBatchinsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/conversions/batchinsert",
    validator: validate_DfareportingConversionsBatchinsert_581021,
    base: "/dfareporting/v2.7", url: url_DfareportingConversionsBatchinsert_581022,
    schemes: {Scheme.Https})
type
  Call_DfareportingCountriesList_581037 = ref object of OpenApiRestCall_579437
proc url_DfareportingCountriesList_581039(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/countries")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCountriesList_581038(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of countries.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581040 = path.getOrDefault("profileId")
  valid_581040 = validateParameter(valid_581040, JString, required = true,
                                 default = nil)
  if valid_581040 != nil:
    section.add "profileId", valid_581040
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581041 = query.getOrDefault("fields")
  valid_581041 = validateParameter(valid_581041, JString, required = false,
                                 default = nil)
  if valid_581041 != nil:
    section.add "fields", valid_581041
  var valid_581042 = query.getOrDefault("quotaUser")
  valid_581042 = validateParameter(valid_581042, JString, required = false,
                                 default = nil)
  if valid_581042 != nil:
    section.add "quotaUser", valid_581042
  var valid_581043 = query.getOrDefault("alt")
  valid_581043 = validateParameter(valid_581043, JString, required = false,
                                 default = newJString("json"))
  if valid_581043 != nil:
    section.add "alt", valid_581043
  var valid_581044 = query.getOrDefault("oauth_token")
  valid_581044 = validateParameter(valid_581044, JString, required = false,
                                 default = nil)
  if valid_581044 != nil:
    section.add "oauth_token", valid_581044
  var valid_581045 = query.getOrDefault("userIp")
  valid_581045 = validateParameter(valid_581045, JString, required = false,
                                 default = nil)
  if valid_581045 != nil:
    section.add "userIp", valid_581045
  var valid_581046 = query.getOrDefault("key")
  valid_581046 = validateParameter(valid_581046, JString, required = false,
                                 default = nil)
  if valid_581046 != nil:
    section.add "key", valid_581046
  var valid_581047 = query.getOrDefault("prettyPrint")
  valid_581047 = validateParameter(valid_581047, JBool, required = false,
                                 default = newJBool(true))
  if valid_581047 != nil:
    section.add "prettyPrint", valid_581047
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581048: Call_DfareportingCountriesList_581037; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of countries.
  ## 
  let valid = call_581048.validator(path, query, header, formData, body)
  let scheme = call_581048.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581048.url(scheme.get, call_581048.host, call_581048.base,
                         call_581048.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581048, url, valid)

proc call*(call_581049: Call_DfareportingCountriesList_581037; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingCountriesList
  ## Retrieves a list of countries.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581050 = newJObject()
  var query_581051 = newJObject()
  add(path_581050, "profileId", newJString(profileId))
  add(query_581051, "fields", newJString(fields))
  add(query_581051, "quotaUser", newJString(quotaUser))
  add(query_581051, "alt", newJString(alt))
  add(query_581051, "oauth_token", newJString(oauthToken))
  add(query_581051, "userIp", newJString(userIp))
  add(query_581051, "key", newJString(key))
  add(query_581051, "prettyPrint", newJBool(prettyPrint))
  result = call_581049.call(path_581050, query_581051, nil, nil, nil)

var dfareportingCountriesList* = Call_DfareportingCountriesList_581037(
    name: "dfareportingCountriesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/countries",
    validator: validate_DfareportingCountriesList_581038,
    base: "/dfareporting/v2.7", url: url_DfareportingCountriesList_581039,
    schemes: {Scheme.Https})
type
  Call_DfareportingCountriesGet_581052 = ref object of OpenApiRestCall_579437
proc url_DfareportingCountriesGet_581054(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "dartId" in path, "`dartId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/countries/"),
               (kind: VariableSegment, value: "dartId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCountriesGet_581053(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one country by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   dartId: JString (required)
  ##         : Country DART ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581055 = path.getOrDefault("profileId")
  valid_581055 = validateParameter(valid_581055, JString, required = true,
                                 default = nil)
  if valid_581055 != nil:
    section.add "profileId", valid_581055
  var valid_581056 = path.getOrDefault("dartId")
  valid_581056 = validateParameter(valid_581056, JString, required = true,
                                 default = nil)
  if valid_581056 != nil:
    section.add "dartId", valid_581056
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581057 = query.getOrDefault("fields")
  valid_581057 = validateParameter(valid_581057, JString, required = false,
                                 default = nil)
  if valid_581057 != nil:
    section.add "fields", valid_581057
  var valid_581058 = query.getOrDefault("quotaUser")
  valid_581058 = validateParameter(valid_581058, JString, required = false,
                                 default = nil)
  if valid_581058 != nil:
    section.add "quotaUser", valid_581058
  var valid_581059 = query.getOrDefault("alt")
  valid_581059 = validateParameter(valid_581059, JString, required = false,
                                 default = newJString("json"))
  if valid_581059 != nil:
    section.add "alt", valid_581059
  var valid_581060 = query.getOrDefault("oauth_token")
  valid_581060 = validateParameter(valid_581060, JString, required = false,
                                 default = nil)
  if valid_581060 != nil:
    section.add "oauth_token", valid_581060
  var valid_581061 = query.getOrDefault("userIp")
  valid_581061 = validateParameter(valid_581061, JString, required = false,
                                 default = nil)
  if valid_581061 != nil:
    section.add "userIp", valid_581061
  var valid_581062 = query.getOrDefault("key")
  valid_581062 = validateParameter(valid_581062, JString, required = false,
                                 default = nil)
  if valid_581062 != nil:
    section.add "key", valid_581062
  var valid_581063 = query.getOrDefault("prettyPrint")
  valid_581063 = validateParameter(valid_581063, JBool, required = false,
                                 default = newJBool(true))
  if valid_581063 != nil:
    section.add "prettyPrint", valid_581063
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581064: Call_DfareportingCountriesGet_581052; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one country by ID.
  ## 
  let valid = call_581064.validator(path, query, header, formData, body)
  let scheme = call_581064.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581064.url(scheme.get, call_581064.host, call_581064.base,
                         call_581064.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581064, url, valid)

proc call*(call_581065: Call_DfareportingCountriesGet_581052; profileId: string;
          dartId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCountriesGet
  ## Gets one country by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   dartId: string (required)
  ##         : Country DART ID.
  var path_581066 = newJObject()
  var query_581067 = newJObject()
  add(path_581066, "profileId", newJString(profileId))
  add(query_581067, "fields", newJString(fields))
  add(query_581067, "quotaUser", newJString(quotaUser))
  add(query_581067, "alt", newJString(alt))
  add(query_581067, "oauth_token", newJString(oauthToken))
  add(query_581067, "userIp", newJString(userIp))
  add(query_581067, "key", newJString(key))
  add(query_581067, "prettyPrint", newJBool(prettyPrint))
  add(path_581066, "dartId", newJString(dartId))
  result = call_581065.call(path_581066, query_581067, nil, nil, nil)

var dfareportingCountriesGet* = Call_DfareportingCountriesGet_581052(
    name: "dfareportingCountriesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/countries/{dartId}",
    validator: validate_DfareportingCountriesGet_581053,
    base: "/dfareporting/v2.7", url: url_DfareportingCountriesGet_581054,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeAssetsInsert_581068 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeAssetsInsert_581070(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "advertiserId" in path, "`advertiserId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeAssets/"),
               (kind: VariableSegment, value: "advertiserId"),
               (kind: ConstantSegment, value: "/creativeAssets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeAssetsInsert_581069(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative asset.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   advertiserId: JString (required)
  ##               : Advertiser ID of this creative. This is a required field.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581071 = path.getOrDefault("profileId")
  valid_581071 = validateParameter(valid_581071, JString, required = true,
                                 default = nil)
  if valid_581071 != nil:
    section.add "profileId", valid_581071
  var valid_581072 = path.getOrDefault("advertiserId")
  valid_581072 = validateParameter(valid_581072, JString, required = true,
                                 default = nil)
  if valid_581072 != nil:
    section.add "advertiserId", valid_581072
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581073 = query.getOrDefault("fields")
  valid_581073 = validateParameter(valid_581073, JString, required = false,
                                 default = nil)
  if valid_581073 != nil:
    section.add "fields", valid_581073
  var valid_581074 = query.getOrDefault("quotaUser")
  valid_581074 = validateParameter(valid_581074, JString, required = false,
                                 default = nil)
  if valid_581074 != nil:
    section.add "quotaUser", valid_581074
  var valid_581075 = query.getOrDefault("alt")
  valid_581075 = validateParameter(valid_581075, JString, required = false,
                                 default = newJString("json"))
  if valid_581075 != nil:
    section.add "alt", valid_581075
  var valid_581076 = query.getOrDefault("oauth_token")
  valid_581076 = validateParameter(valid_581076, JString, required = false,
                                 default = nil)
  if valid_581076 != nil:
    section.add "oauth_token", valid_581076
  var valid_581077 = query.getOrDefault("userIp")
  valid_581077 = validateParameter(valid_581077, JString, required = false,
                                 default = nil)
  if valid_581077 != nil:
    section.add "userIp", valid_581077
  var valid_581078 = query.getOrDefault("key")
  valid_581078 = validateParameter(valid_581078, JString, required = false,
                                 default = nil)
  if valid_581078 != nil:
    section.add "key", valid_581078
  var valid_581079 = query.getOrDefault("prettyPrint")
  valid_581079 = validateParameter(valid_581079, JBool, required = false,
                                 default = newJBool(true))
  if valid_581079 != nil:
    section.add "prettyPrint", valid_581079
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581081: Call_DfareportingCreativeAssetsInsert_581068;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative asset.
  ## 
  let valid = call_581081.validator(path, query, header, formData, body)
  let scheme = call_581081.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581081.url(scheme.get, call_581081.host, call_581081.base,
                         call_581081.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581081, url, valid)

proc call*(call_581082: Call_DfareportingCreativeAssetsInsert_581068;
          profileId: string; advertiserId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeAssetsInsert
  ## Inserts a new creative asset.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserId: string (required)
  ##               : Advertiser ID of this creative. This is a required field.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581083 = newJObject()
  var query_581084 = newJObject()
  var body_581085 = newJObject()
  add(path_581083, "profileId", newJString(profileId))
  add(query_581084, "fields", newJString(fields))
  add(query_581084, "quotaUser", newJString(quotaUser))
  add(query_581084, "alt", newJString(alt))
  add(query_581084, "oauth_token", newJString(oauthToken))
  add(query_581084, "userIp", newJString(userIp))
  add(query_581084, "key", newJString(key))
  add(path_581083, "advertiserId", newJString(advertiserId))
  if body != nil:
    body_581085 = body
  add(query_581084, "prettyPrint", newJBool(prettyPrint))
  result = call_581082.call(path_581083, query_581084, nil, nil, body_581085)

var dfareportingCreativeAssetsInsert* = Call_DfareportingCreativeAssetsInsert_581068(
    name: "dfareportingCreativeAssetsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeAssets/{advertiserId}/creativeAssets",
    validator: validate_DfareportingCreativeAssetsInsert_581069,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeAssetsInsert_581070,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsUpdate_581108 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeFieldsUpdate_581110(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsUpdate_581109(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581111 = path.getOrDefault("profileId")
  valid_581111 = validateParameter(valid_581111, JString, required = true,
                                 default = nil)
  if valid_581111 != nil:
    section.add "profileId", valid_581111
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581112 = query.getOrDefault("fields")
  valid_581112 = validateParameter(valid_581112, JString, required = false,
                                 default = nil)
  if valid_581112 != nil:
    section.add "fields", valid_581112
  var valid_581113 = query.getOrDefault("quotaUser")
  valid_581113 = validateParameter(valid_581113, JString, required = false,
                                 default = nil)
  if valid_581113 != nil:
    section.add "quotaUser", valid_581113
  var valid_581114 = query.getOrDefault("alt")
  valid_581114 = validateParameter(valid_581114, JString, required = false,
                                 default = newJString("json"))
  if valid_581114 != nil:
    section.add "alt", valid_581114
  var valid_581115 = query.getOrDefault("oauth_token")
  valid_581115 = validateParameter(valid_581115, JString, required = false,
                                 default = nil)
  if valid_581115 != nil:
    section.add "oauth_token", valid_581115
  var valid_581116 = query.getOrDefault("userIp")
  valid_581116 = validateParameter(valid_581116, JString, required = false,
                                 default = nil)
  if valid_581116 != nil:
    section.add "userIp", valid_581116
  var valid_581117 = query.getOrDefault("key")
  valid_581117 = validateParameter(valid_581117, JString, required = false,
                                 default = nil)
  if valid_581117 != nil:
    section.add "key", valid_581117
  var valid_581118 = query.getOrDefault("prettyPrint")
  valid_581118 = validateParameter(valid_581118, JBool, required = false,
                                 default = newJBool(true))
  if valid_581118 != nil:
    section.add "prettyPrint", valid_581118
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581120: Call_DfareportingCreativeFieldsUpdate_581108;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field.
  ## 
  let valid = call_581120.validator(path, query, header, formData, body)
  let scheme = call_581120.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581120.url(scheme.get, call_581120.host, call_581120.base,
                         call_581120.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581120, url, valid)

proc call*(call_581121: Call_DfareportingCreativeFieldsUpdate_581108;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsUpdate
  ## Updates an existing creative field.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581122 = newJObject()
  var query_581123 = newJObject()
  var body_581124 = newJObject()
  add(path_581122, "profileId", newJString(profileId))
  add(query_581123, "fields", newJString(fields))
  add(query_581123, "quotaUser", newJString(quotaUser))
  add(query_581123, "alt", newJString(alt))
  add(query_581123, "oauth_token", newJString(oauthToken))
  add(query_581123, "userIp", newJString(userIp))
  add(query_581123, "key", newJString(key))
  if body != nil:
    body_581124 = body
  add(query_581123, "prettyPrint", newJBool(prettyPrint))
  result = call_581121.call(path_581122, query_581123, nil, nil, body_581124)

var dfareportingCreativeFieldsUpdate* = Call_DfareportingCreativeFieldsUpdate_581108(
    name: "dfareportingCreativeFieldsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsUpdate_581109,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsUpdate_581110,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsInsert_581125 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeFieldsInsert_581127(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsInsert_581126(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative field.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581128 = path.getOrDefault("profileId")
  valid_581128 = validateParameter(valid_581128, JString, required = true,
                                 default = nil)
  if valid_581128 != nil:
    section.add "profileId", valid_581128
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581129 = query.getOrDefault("fields")
  valid_581129 = validateParameter(valid_581129, JString, required = false,
                                 default = nil)
  if valid_581129 != nil:
    section.add "fields", valid_581129
  var valid_581130 = query.getOrDefault("quotaUser")
  valid_581130 = validateParameter(valid_581130, JString, required = false,
                                 default = nil)
  if valid_581130 != nil:
    section.add "quotaUser", valid_581130
  var valid_581131 = query.getOrDefault("alt")
  valid_581131 = validateParameter(valid_581131, JString, required = false,
                                 default = newJString("json"))
  if valid_581131 != nil:
    section.add "alt", valid_581131
  var valid_581132 = query.getOrDefault("oauth_token")
  valid_581132 = validateParameter(valid_581132, JString, required = false,
                                 default = nil)
  if valid_581132 != nil:
    section.add "oauth_token", valid_581132
  var valid_581133 = query.getOrDefault("userIp")
  valid_581133 = validateParameter(valid_581133, JString, required = false,
                                 default = nil)
  if valid_581133 != nil:
    section.add "userIp", valid_581133
  var valid_581134 = query.getOrDefault("key")
  valid_581134 = validateParameter(valid_581134, JString, required = false,
                                 default = nil)
  if valid_581134 != nil:
    section.add "key", valid_581134
  var valid_581135 = query.getOrDefault("prettyPrint")
  valid_581135 = validateParameter(valid_581135, JBool, required = false,
                                 default = newJBool(true))
  if valid_581135 != nil:
    section.add "prettyPrint", valid_581135
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581137: Call_DfareportingCreativeFieldsInsert_581125;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative field.
  ## 
  let valid = call_581137.validator(path, query, header, formData, body)
  let scheme = call_581137.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581137.url(scheme.get, call_581137.host, call_581137.base,
                         call_581137.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581137, url, valid)

proc call*(call_581138: Call_DfareportingCreativeFieldsInsert_581125;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsInsert
  ## Inserts a new creative field.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581139 = newJObject()
  var query_581140 = newJObject()
  var body_581141 = newJObject()
  add(path_581139, "profileId", newJString(profileId))
  add(query_581140, "fields", newJString(fields))
  add(query_581140, "quotaUser", newJString(quotaUser))
  add(query_581140, "alt", newJString(alt))
  add(query_581140, "oauth_token", newJString(oauthToken))
  add(query_581140, "userIp", newJString(userIp))
  add(query_581140, "key", newJString(key))
  if body != nil:
    body_581141 = body
  add(query_581140, "prettyPrint", newJBool(prettyPrint))
  result = call_581138.call(path_581139, query_581140, nil, nil, body_581141)

var dfareportingCreativeFieldsInsert* = Call_DfareportingCreativeFieldsInsert_581125(
    name: "dfareportingCreativeFieldsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsInsert_581126,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsInsert_581127,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsList_581086 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeFieldsList_581088(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsList_581087(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creative fields, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581089 = path.getOrDefault("profileId")
  valid_581089 = validateParameter(valid_581089, JString, required = true,
                                 default = nil)
  if valid_581089 != nil:
    section.add "profileId", valid_581089
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for creative fields by name or ID. Wildcards (*) are allowed. For example, "creativefield*2015" will return creative fields with names like "creativefield June 2015", "creativefield April 2015", or simply "creativefield 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativefield" will match creative fields with the name "my creativefield", "creativefield 2015", or simply "creativefield".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative fields with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only creative fields that belong to these advertisers.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581090 = query.getOrDefault("fields")
  valid_581090 = validateParameter(valid_581090, JString, required = false,
                                 default = nil)
  if valid_581090 != nil:
    section.add "fields", valid_581090
  var valid_581091 = query.getOrDefault("pageToken")
  valid_581091 = validateParameter(valid_581091, JString, required = false,
                                 default = nil)
  if valid_581091 != nil:
    section.add "pageToken", valid_581091
  var valid_581092 = query.getOrDefault("quotaUser")
  valid_581092 = validateParameter(valid_581092, JString, required = false,
                                 default = nil)
  if valid_581092 != nil:
    section.add "quotaUser", valid_581092
  var valid_581093 = query.getOrDefault("sortField")
  valid_581093 = validateParameter(valid_581093, JString, required = false,
                                 default = newJString("ID"))
  if valid_581093 != nil:
    section.add "sortField", valid_581093
  var valid_581094 = query.getOrDefault("alt")
  valid_581094 = validateParameter(valid_581094, JString, required = false,
                                 default = newJString("json"))
  if valid_581094 != nil:
    section.add "alt", valid_581094
  var valid_581095 = query.getOrDefault("searchString")
  valid_581095 = validateParameter(valid_581095, JString, required = false,
                                 default = nil)
  if valid_581095 != nil:
    section.add "searchString", valid_581095
  var valid_581096 = query.getOrDefault("oauth_token")
  valid_581096 = validateParameter(valid_581096, JString, required = false,
                                 default = nil)
  if valid_581096 != nil:
    section.add "oauth_token", valid_581096
  var valid_581097 = query.getOrDefault("userIp")
  valid_581097 = validateParameter(valid_581097, JString, required = false,
                                 default = nil)
  if valid_581097 != nil:
    section.add "userIp", valid_581097
  var valid_581098 = query.getOrDefault("maxResults")
  valid_581098 = validateParameter(valid_581098, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581098 != nil:
    section.add "maxResults", valid_581098
  var valid_581099 = query.getOrDefault("ids")
  valid_581099 = validateParameter(valid_581099, JArray, required = false,
                                 default = nil)
  if valid_581099 != nil:
    section.add "ids", valid_581099
  var valid_581100 = query.getOrDefault("key")
  valid_581100 = validateParameter(valid_581100, JString, required = false,
                                 default = nil)
  if valid_581100 != nil:
    section.add "key", valid_581100
  var valid_581101 = query.getOrDefault("advertiserIds")
  valid_581101 = validateParameter(valid_581101, JArray, required = false,
                                 default = nil)
  if valid_581101 != nil:
    section.add "advertiserIds", valid_581101
  var valid_581102 = query.getOrDefault("sortOrder")
  valid_581102 = validateParameter(valid_581102, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581102 != nil:
    section.add "sortOrder", valid_581102
  var valid_581103 = query.getOrDefault("prettyPrint")
  valid_581103 = validateParameter(valid_581103, JBool, required = false,
                                 default = newJBool(true))
  if valid_581103 != nil:
    section.add "prettyPrint", valid_581103
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581104: Call_DfareportingCreativeFieldsList_581086; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of creative fields, possibly filtered. This method supports paging.
  ## 
  let valid = call_581104.validator(path, query, header, formData, body)
  let scheme = call_581104.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581104.url(scheme.get, call_581104.host, call_581104.base,
                         call_581104.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581104, url, valid)

proc call*(call_581105: Call_DfareportingCreativeFieldsList_581086;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          advertiserIds: JsonNode = nil; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsList
  ## Retrieves a list of creative fields, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for creative fields by name or ID. Wildcards (*) are allowed. For example, "creativefield*2015" will return creative fields with names like "creativefield June 2015", "creativefield April 2015", or simply "creativefield 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativefield" will match creative fields with the name "my creativefield", "creativefield 2015", or simply "creativefield".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative fields with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only creative fields that belong to these advertisers.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581106 = newJObject()
  var query_581107 = newJObject()
  add(path_581106, "profileId", newJString(profileId))
  add(query_581107, "fields", newJString(fields))
  add(query_581107, "pageToken", newJString(pageToken))
  add(query_581107, "quotaUser", newJString(quotaUser))
  add(query_581107, "sortField", newJString(sortField))
  add(query_581107, "alt", newJString(alt))
  add(query_581107, "searchString", newJString(searchString))
  add(query_581107, "oauth_token", newJString(oauthToken))
  add(query_581107, "userIp", newJString(userIp))
  add(query_581107, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_581107.add "ids", ids
  add(query_581107, "key", newJString(key))
  if advertiserIds != nil:
    query_581107.add "advertiserIds", advertiserIds
  add(query_581107, "sortOrder", newJString(sortOrder))
  add(query_581107, "prettyPrint", newJBool(prettyPrint))
  result = call_581105.call(path_581106, query_581107, nil, nil, nil)

var dfareportingCreativeFieldsList* = Call_DfareportingCreativeFieldsList_581086(
    name: "dfareportingCreativeFieldsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsList_581087,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsList_581088,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsPatch_581142 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeFieldsPatch_581144(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsPatch_581143(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581145 = path.getOrDefault("profileId")
  valid_581145 = validateParameter(valid_581145, JString, required = true,
                                 default = nil)
  if valid_581145 != nil:
    section.add "profileId", valid_581145
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative Field ID
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581146 = query.getOrDefault("fields")
  valid_581146 = validateParameter(valid_581146, JString, required = false,
                                 default = nil)
  if valid_581146 != nil:
    section.add "fields", valid_581146
  var valid_581147 = query.getOrDefault("quotaUser")
  valid_581147 = validateParameter(valid_581147, JString, required = false,
                                 default = nil)
  if valid_581147 != nil:
    section.add "quotaUser", valid_581147
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_581148 = query.getOrDefault("id")
  valid_581148 = validateParameter(valid_581148, JString, required = true,
                                 default = nil)
  if valid_581148 != nil:
    section.add "id", valid_581148
  var valid_581149 = query.getOrDefault("alt")
  valid_581149 = validateParameter(valid_581149, JString, required = false,
                                 default = newJString("json"))
  if valid_581149 != nil:
    section.add "alt", valid_581149
  var valid_581150 = query.getOrDefault("oauth_token")
  valid_581150 = validateParameter(valid_581150, JString, required = false,
                                 default = nil)
  if valid_581150 != nil:
    section.add "oauth_token", valid_581150
  var valid_581151 = query.getOrDefault("userIp")
  valid_581151 = validateParameter(valid_581151, JString, required = false,
                                 default = nil)
  if valid_581151 != nil:
    section.add "userIp", valid_581151
  var valid_581152 = query.getOrDefault("key")
  valid_581152 = validateParameter(valid_581152, JString, required = false,
                                 default = nil)
  if valid_581152 != nil:
    section.add "key", valid_581152
  var valid_581153 = query.getOrDefault("prettyPrint")
  valid_581153 = validateParameter(valid_581153, JBool, required = false,
                                 default = newJBool(true))
  if valid_581153 != nil:
    section.add "prettyPrint", valid_581153
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581155: Call_DfareportingCreativeFieldsPatch_581142;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field. This method supports patch semantics.
  ## 
  let valid = call_581155.validator(path, query, header, formData, body)
  let scheme = call_581155.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581155.url(scheme.get, call_581155.host, call_581155.base,
                         call_581155.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581155, url, valid)

proc call*(call_581156: Call_DfareportingCreativeFieldsPatch_581142;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsPatch
  ## Updates an existing creative field. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative Field ID
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581157 = newJObject()
  var query_581158 = newJObject()
  var body_581159 = newJObject()
  add(path_581157, "profileId", newJString(profileId))
  add(query_581158, "fields", newJString(fields))
  add(query_581158, "quotaUser", newJString(quotaUser))
  add(query_581158, "id", newJString(id))
  add(query_581158, "alt", newJString(alt))
  add(query_581158, "oauth_token", newJString(oauthToken))
  add(query_581158, "userIp", newJString(userIp))
  add(query_581158, "key", newJString(key))
  if body != nil:
    body_581159 = body
  add(query_581158, "prettyPrint", newJBool(prettyPrint))
  result = call_581156.call(path_581157, query_581158, nil, nil, body_581159)

var dfareportingCreativeFieldsPatch* = Call_DfareportingCreativeFieldsPatch_581142(
    name: "dfareportingCreativeFieldsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsPatch_581143,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsPatch_581144,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesUpdate_581182 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeFieldValuesUpdate_581184(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesUpdate_581183(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field value.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581185 = path.getOrDefault("profileId")
  valid_581185 = validateParameter(valid_581185, JString, required = true,
                                 default = nil)
  if valid_581185 != nil:
    section.add "profileId", valid_581185
  var valid_581186 = path.getOrDefault("creativeFieldId")
  valid_581186 = validateParameter(valid_581186, JString, required = true,
                                 default = nil)
  if valid_581186 != nil:
    section.add "creativeFieldId", valid_581186
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581187 = query.getOrDefault("fields")
  valid_581187 = validateParameter(valid_581187, JString, required = false,
                                 default = nil)
  if valid_581187 != nil:
    section.add "fields", valid_581187
  var valid_581188 = query.getOrDefault("quotaUser")
  valid_581188 = validateParameter(valid_581188, JString, required = false,
                                 default = nil)
  if valid_581188 != nil:
    section.add "quotaUser", valid_581188
  var valid_581189 = query.getOrDefault("alt")
  valid_581189 = validateParameter(valid_581189, JString, required = false,
                                 default = newJString("json"))
  if valid_581189 != nil:
    section.add "alt", valid_581189
  var valid_581190 = query.getOrDefault("oauth_token")
  valid_581190 = validateParameter(valid_581190, JString, required = false,
                                 default = nil)
  if valid_581190 != nil:
    section.add "oauth_token", valid_581190
  var valid_581191 = query.getOrDefault("userIp")
  valid_581191 = validateParameter(valid_581191, JString, required = false,
                                 default = nil)
  if valid_581191 != nil:
    section.add "userIp", valid_581191
  var valid_581192 = query.getOrDefault("key")
  valid_581192 = validateParameter(valid_581192, JString, required = false,
                                 default = nil)
  if valid_581192 != nil:
    section.add "key", valid_581192
  var valid_581193 = query.getOrDefault("prettyPrint")
  valid_581193 = validateParameter(valid_581193, JBool, required = false,
                                 default = newJBool(true))
  if valid_581193 != nil:
    section.add "prettyPrint", valid_581193
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581195: Call_DfareportingCreativeFieldValuesUpdate_581182;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field value.
  ## 
  let valid = call_581195.validator(path, query, header, formData, body)
  let scheme = call_581195.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581195.url(scheme.get, call_581195.host, call_581195.base,
                         call_581195.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581195, url, valid)

proc call*(call_581196: Call_DfareportingCreativeFieldValuesUpdate_581182;
          profileId: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesUpdate
  ## Updates an existing creative field value.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581197 = newJObject()
  var query_581198 = newJObject()
  var body_581199 = newJObject()
  add(path_581197, "profileId", newJString(profileId))
  add(query_581198, "fields", newJString(fields))
  add(query_581198, "quotaUser", newJString(quotaUser))
  add(query_581198, "alt", newJString(alt))
  add(query_581198, "oauth_token", newJString(oauthToken))
  add(query_581198, "userIp", newJString(userIp))
  add(query_581198, "key", newJString(key))
  add(path_581197, "creativeFieldId", newJString(creativeFieldId))
  if body != nil:
    body_581199 = body
  add(query_581198, "prettyPrint", newJBool(prettyPrint))
  result = call_581196.call(path_581197, query_581198, nil, nil, body_581199)

var dfareportingCreativeFieldValuesUpdate* = Call_DfareportingCreativeFieldValuesUpdate_581182(
    name: "dfareportingCreativeFieldValuesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesUpdate_581183,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesUpdate_581184,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesInsert_581200 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeFieldValuesInsert_581202(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesInsert_581201(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative field value.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581203 = path.getOrDefault("profileId")
  valid_581203 = validateParameter(valid_581203, JString, required = true,
                                 default = nil)
  if valid_581203 != nil:
    section.add "profileId", valid_581203
  var valid_581204 = path.getOrDefault("creativeFieldId")
  valid_581204 = validateParameter(valid_581204, JString, required = true,
                                 default = nil)
  if valid_581204 != nil:
    section.add "creativeFieldId", valid_581204
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581205 = query.getOrDefault("fields")
  valid_581205 = validateParameter(valid_581205, JString, required = false,
                                 default = nil)
  if valid_581205 != nil:
    section.add "fields", valid_581205
  var valid_581206 = query.getOrDefault("quotaUser")
  valid_581206 = validateParameter(valid_581206, JString, required = false,
                                 default = nil)
  if valid_581206 != nil:
    section.add "quotaUser", valid_581206
  var valid_581207 = query.getOrDefault("alt")
  valid_581207 = validateParameter(valid_581207, JString, required = false,
                                 default = newJString("json"))
  if valid_581207 != nil:
    section.add "alt", valid_581207
  var valid_581208 = query.getOrDefault("oauth_token")
  valid_581208 = validateParameter(valid_581208, JString, required = false,
                                 default = nil)
  if valid_581208 != nil:
    section.add "oauth_token", valid_581208
  var valid_581209 = query.getOrDefault("userIp")
  valid_581209 = validateParameter(valid_581209, JString, required = false,
                                 default = nil)
  if valid_581209 != nil:
    section.add "userIp", valid_581209
  var valid_581210 = query.getOrDefault("key")
  valid_581210 = validateParameter(valid_581210, JString, required = false,
                                 default = nil)
  if valid_581210 != nil:
    section.add "key", valid_581210
  var valid_581211 = query.getOrDefault("prettyPrint")
  valid_581211 = validateParameter(valid_581211, JBool, required = false,
                                 default = newJBool(true))
  if valid_581211 != nil:
    section.add "prettyPrint", valid_581211
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581213: Call_DfareportingCreativeFieldValuesInsert_581200;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative field value.
  ## 
  let valid = call_581213.validator(path, query, header, formData, body)
  let scheme = call_581213.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581213.url(scheme.get, call_581213.host, call_581213.base,
                         call_581213.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581213, url, valid)

proc call*(call_581214: Call_DfareportingCreativeFieldValuesInsert_581200;
          profileId: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesInsert
  ## Inserts a new creative field value.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581215 = newJObject()
  var query_581216 = newJObject()
  var body_581217 = newJObject()
  add(path_581215, "profileId", newJString(profileId))
  add(query_581216, "fields", newJString(fields))
  add(query_581216, "quotaUser", newJString(quotaUser))
  add(query_581216, "alt", newJString(alt))
  add(query_581216, "oauth_token", newJString(oauthToken))
  add(query_581216, "userIp", newJString(userIp))
  add(query_581216, "key", newJString(key))
  add(path_581215, "creativeFieldId", newJString(creativeFieldId))
  if body != nil:
    body_581217 = body
  add(query_581216, "prettyPrint", newJBool(prettyPrint))
  result = call_581214.call(path_581215, query_581216, nil, nil, body_581217)

var dfareportingCreativeFieldValuesInsert* = Call_DfareportingCreativeFieldValuesInsert_581200(
    name: "dfareportingCreativeFieldValuesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesInsert_581201,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesInsert_581202,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesList_581160 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeFieldValuesList_581162(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesList_581161(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creative field values, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581163 = path.getOrDefault("profileId")
  valid_581163 = validateParameter(valid_581163, JString, required = true,
                                 default = nil)
  if valid_581163 != nil:
    section.add "profileId", valid_581163
  var valid_581164 = path.getOrDefault("creativeFieldId")
  valid_581164 = validateParameter(valid_581164, JString, required = true,
                                 default = nil)
  if valid_581164 != nil:
    section.add "creativeFieldId", valid_581164
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for creative field values by their values. Wildcards (e.g. *) are not allowed.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative field values with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581165 = query.getOrDefault("fields")
  valid_581165 = validateParameter(valid_581165, JString, required = false,
                                 default = nil)
  if valid_581165 != nil:
    section.add "fields", valid_581165
  var valid_581166 = query.getOrDefault("pageToken")
  valid_581166 = validateParameter(valid_581166, JString, required = false,
                                 default = nil)
  if valid_581166 != nil:
    section.add "pageToken", valid_581166
  var valid_581167 = query.getOrDefault("quotaUser")
  valid_581167 = validateParameter(valid_581167, JString, required = false,
                                 default = nil)
  if valid_581167 != nil:
    section.add "quotaUser", valid_581167
  var valid_581168 = query.getOrDefault("sortField")
  valid_581168 = validateParameter(valid_581168, JString, required = false,
                                 default = newJString("ID"))
  if valid_581168 != nil:
    section.add "sortField", valid_581168
  var valid_581169 = query.getOrDefault("alt")
  valid_581169 = validateParameter(valid_581169, JString, required = false,
                                 default = newJString("json"))
  if valid_581169 != nil:
    section.add "alt", valid_581169
  var valid_581170 = query.getOrDefault("searchString")
  valid_581170 = validateParameter(valid_581170, JString, required = false,
                                 default = nil)
  if valid_581170 != nil:
    section.add "searchString", valid_581170
  var valid_581171 = query.getOrDefault("oauth_token")
  valid_581171 = validateParameter(valid_581171, JString, required = false,
                                 default = nil)
  if valid_581171 != nil:
    section.add "oauth_token", valid_581171
  var valid_581172 = query.getOrDefault("userIp")
  valid_581172 = validateParameter(valid_581172, JString, required = false,
                                 default = nil)
  if valid_581172 != nil:
    section.add "userIp", valid_581172
  var valid_581173 = query.getOrDefault("maxResults")
  valid_581173 = validateParameter(valid_581173, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581173 != nil:
    section.add "maxResults", valid_581173
  var valid_581174 = query.getOrDefault("ids")
  valid_581174 = validateParameter(valid_581174, JArray, required = false,
                                 default = nil)
  if valid_581174 != nil:
    section.add "ids", valid_581174
  var valid_581175 = query.getOrDefault("key")
  valid_581175 = validateParameter(valid_581175, JString, required = false,
                                 default = nil)
  if valid_581175 != nil:
    section.add "key", valid_581175
  var valid_581176 = query.getOrDefault("sortOrder")
  valid_581176 = validateParameter(valid_581176, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581176 != nil:
    section.add "sortOrder", valid_581176
  var valid_581177 = query.getOrDefault("prettyPrint")
  valid_581177 = validateParameter(valid_581177, JBool, required = false,
                                 default = newJBool(true))
  if valid_581177 != nil:
    section.add "prettyPrint", valid_581177
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581178: Call_DfareportingCreativeFieldValuesList_581160;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of creative field values, possibly filtered. This method supports paging.
  ## 
  let valid = call_581178.validator(path, query, header, formData, body)
  let scheme = call_581178.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581178.url(scheme.get, call_581178.host, call_581178.base,
                         call_581178.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581178, url, valid)

proc call*(call_581179: Call_DfareportingCreativeFieldValuesList_581160;
          profileId: string; creativeFieldId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; searchString: string = ""; oauthToken: string = "";
          userIp: string = ""; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesList
  ## Retrieves a list of creative field values, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for creative field values by their values. Wildcards (e.g. *) are not allowed.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative field values with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581180 = newJObject()
  var query_581181 = newJObject()
  add(path_581180, "profileId", newJString(profileId))
  add(query_581181, "fields", newJString(fields))
  add(query_581181, "pageToken", newJString(pageToken))
  add(query_581181, "quotaUser", newJString(quotaUser))
  add(query_581181, "sortField", newJString(sortField))
  add(query_581181, "alt", newJString(alt))
  add(query_581181, "searchString", newJString(searchString))
  add(query_581181, "oauth_token", newJString(oauthToken))
  add(query_581181, "userIp", newJString(userIp))
  add(query_581181, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_581181.add "ids", ids
  add(query_581181, "key", newJString(key))
  add(query_581181, "sortOrder", newJString(sortOrder))
  add(path_581180, "creativeFieldId", newJString(creativeFieldId))
  add(query_581181, "prettyPrint", newJBool(prettyPrint))
  result = call_581179.call(path_581180, query_581181, nil, nil, nil)

var dfareportingCreativeFieldValuesList* = Call_DfareportingCreativeFieldValuesList_581160(
    name: "dfareportingCreativeFieldValuesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesList_581161,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesList_581162,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesPatch_581218 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeFieldValuesPatch_581220(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesPatch_581219(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field value. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581221 = path.getOrDefault("profileId")
  valid_581221 = validateParameter(valid_581221, JString, required = true,
                                 default = nil)
  if valid_581221 != nil:
    section.add "profileId", valid_581221
  var valid_581222 = path.getOrDefault("creativeFieldId")
  valid_581222 = validateParameter(valid_581222, JString, required = true,
                                 default = nil)
  if valid_581222 != nil:
    section.add "creativeFieldId", valid_581222
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative Field Value ID
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581223 = query.getOrDefault("fields")
  valid_581223 = validateParameter(valid_581223, JString, required = false,
                                 default = nil)
  if valid_581223 != nil:
    section.add "fields", valid_581223
  var valid_581224 = query.getOrDefault("quotaUser")
  valid_581224 = validateParameter(valid_581224, JString, required = false,
                                 default = nil)
  if valid_581224 != nil:
    section.add "quotaUser", valid_581224
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_581225 = query.getOrDefault("id")
  valid_581225 = validateParameter(valid_581225, JString, required = true,
                                 default = nil)
  if valid_581225 != nil:
    section.add "id", valid_581225
  var valid_581226 = query.getOrDefault("alt")
  valid_581226 = validateParameter(valid_581226, JString, required = false,
                                 default = newJString("json"))
  if valid_581226 != nil:
    section.add "alt", valid_581226
  var valid_581227 = query.getOrDefault("oauth_token")
  valid_581227 = validateParameter(valid_581227, JString, required = false,
                                 default = nil)
  if valid_581227 != nil:
    section.add "oauth_token", valid_581227
  var valid_581228 = query.getOrDefault("userIp")
  valid_581228 = validateParameter(valid_581228, JString, required = false,
                                 default = nil)
  if valid_581228 != nil:
    section.add "userIp", valid_581228
  var valid_581229 = query.getOrDefault("key")
  valid_581229 = validateParameter(valid_581229, JString, required = false,
                                 default = nil)
  if valid_581229 != nil:
    section.add "key", valid_581229
  var valid_581230 = query.getOrDefault("prettyPrint")
  valid_581230 = validateParameter(valid_581230, JBool, required = false,
                                 default = newJBool(true))
  if valid_581230 != nil:
    section.add "prettyPrint", valid_581230
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581232: Call_DfareportingCreativeFieldValuesPatch_581218;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field value. This method supports patch semantics.
  ## 
  let valid = call_581232.validator(path, query, header, formData, body)
  let scheme = call_581232.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581232.url(scheme.get, call_581232.host, call_581232.base,
                         call_581232.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581232, url, valid)

proc call*(call_581233: Call_DfareportingCreativeFieldValuesPatch_581218;
          profileId: string; id: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesPatch
  ## Updates an existing creative field value. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative Field Value ID
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581234 = newJObject()
  var query_581235 = newJObject()
  var body_581236 = newJObject()
  add(path_581234, "profileId", newJString(profileId))
  add(query_581235, "fields", newJString(fields))
  add(query_581235, "quotaUser", newJString(quotaUser))
  add(query_581235, "id", newJString(id))
  add(query_581235, "alt", newJString(alt))
  add(query_581235, "oauth_token", newJString(oauthToken))
  add(query_581235, "userIp", newJString(userIp))
  add(query_581235, "key", newJString(key))
  add(path_581234, "creativeFieldId", newJString(creativeFieldId))
  if body != nil:
    body_581236 = body
  add(query_581235, "prettyPrint", newJBool(prettyPrint))
  result = call_581233.call(path_581234, query_581235, nil, nil, body_581236)

var dfareportingCreativeFieldValuesPatch* = Call_DfareportingCreativeFieldValuesPatch_581218(
    name: "dfareportingCreativeFieldValuesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesPatch_581219,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesPatch_581220,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesGet_581237 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeFieldValuesGet_581239(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesGet_581238(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative field value by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field Value ID
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581240 = path.getOrDefault("profileId")
  valid_581240 = validateParameter(valid_581240, JString, required = true,
                                 default = nil)
  if valid_581240 != nil:
    section.add "profileId", valid_581240
  var valid_581241 = path.getOrDefault("id")
  valid_581241 = validateParameter(valid_581241, JString, required = true,
                                 default = nil)
  if valid_581241 != nil:
    section.add "id", valid_581241
  var valid_581242 = path.getOrDefault("creativeFieldId")
  valid_581242 = validateParameter(valid_581242, JString, required = true,
                                 default = nil)
  if valid_581242 != nil:
    section.add "creativeFieldId", valid_581242
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581243 = query.getOrDefault("fields")
  valid_581243 = validateParameter(valid_581243, JString, required = false,
                                 default = nil)
  if valid_581243 != nil:
    section.add "fields", valid_581243
  var valid_581244 = query.getOrDefault("quotaUser")
  valid_581244 = validateParameter(valid_581244, JString, required = false,
                                 default = nil)
  if valid_581244 != nil:
    section.add "quotaUser", valid_581244
  var valid_581245 = query.getOrDefault("alt")
  valid_581245 = validateParameter(valid_581245, JString, required = false,
                                 default = newJString("json"))
  if valid_581245 != nil:
    section.add "alt", valid_581245
  var valid_581246 = query.getOrDefault("oauth_token")
  valid_581246 = validateParameter(valid_581246, JString, required = false,
                                 default = nil)
  if valid_581246 != nil:
    section.add "oauth_token", valid_581246
  var valid_581247 = query.getOrDefault("userIp")
  valid_581247 = validateParameter(valid_581247, JString, required = false,
                                 default = nil)
  if valid_581247 != nil:
    section.add "userIp", valid_581247
  var valid_581248 = query.getOrDefault("key")
  valid_581248 = validateParameter(valid_581248, JString, required = false,
                                 default = nil)
  if valid_581248 != nil:
    section.add "key", valid_581248
  var valid_581249 = query.getOrDefault("prettyPrint")
  valid_581249 = validateParameter(valid_581249, JBool, required = false,
                                 default = newJBool(true))
  if valid_581249 != nil:
    section.add "prettyPrint", valid_581249
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581250: Call_DfareportingCreativeFieldValuesGet_581237;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one creative field value by ID.
  ## 
  let valid = call_581250.validator(path, query, header, formData, body)
  let scheme = call_581250.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581250.url(scheme.get, call_581250.host, call_581250.base,
                         call_581250.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581250, url, valid)

proc call*(call_581251: Call_DfareportingCreativeFieldValuesGet_581237;
          profileId: string; id: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesGet
  ## Gets one creative field value by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative Field Value ID
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581252 = newJObject()
  var query_581253 = newJObject()
  add(path_581252, "profileId", newJString(profileId))
  add(query_581253, "fields", newJString(fields))
  add(query_581253, "quotaUser", newJString(quotaUser))
  add(query_581253, "alt", newJString(alt))
  add(query_581253, "oauth_token", newJString(oauthToken))
  add(query_581253, "userIp", newJString(userIp))
  add(path_581252, "id", newJString(id))
  add(query_581253, "key", newJString(key))
  add(path_581252, "creativeFieldId", newJString(creativeFieldId))
  add(query_581253, "prettyPrint", newJBool(prettyPrint))
  result = call_581251.call(path_581252, query_581253, nil, nil, nil)

var dfareportingCreativeFieldValuesGet* = Call_DfareportingCreativeFieldValuesGet_581237(
    name: "dfareportingCreativeFieldValuesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues/{id}",
    validator: validate_DfareportingCreativeFieldValuesGet_581238,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesGet_581239,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesDelete_581254 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeFieldValuesDelete_581256(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesDelete_581255(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing creative field value.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field Value ID
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581257 = path.getOrDefault("profileId")
  valid_581257 = validateParameter(valid_581257, JString, required = true,
                                 default = nil)
  if valid_581257 != nil:
    section.add "profileId", valid_581257
  var valid_581258 = path.getOrDefault("id")
  valid_581258 = validateParameter(valid_581258, JString, required = true,
                                 default = nil)
  if valid_581258 != nil:
    section.add "id", valid_581258
  var valid_581259 = path.getOrDefault("creativeFieldId")
  valid_581259 = validateParameter(valid_581259, JString, required = true,
                                 default = nil)
  if valid_581259 != nil:
    section.add "creativeFieldId", valid_581259
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581260 = query.getOrDefault("fields")
  valid_581260 = validateParameter(valid_581260, JString, required = false,
                                 default = nil)
  if valid_581260 != nil:
    section.add "fields", valid_581260
  var valid_581261 = query.getOrDefault("quotaUser")
  valid_581261 = validateParameter(valid_581261, JString, required = false,
                                 default = nil)
  if valid_581261 != nil:
    section.add "quotaUser", valid_581261
  var valid_581262 = query.getOrDefault("alt")
  valid_581262 = validateParameter(valid_581262, JString, required = false,
                                 default = newJString("json"))
  if valid_581262 != nil:
    section.add "alt", valid_581262
  var valid_581263 = query.getOrDefault("oauth_token")
  valid_581263 = validateParameter(valid_581263, JString, required = false,
                                 default = nil)
  if valid_581263 != nil:
    section.add "oauth_token", valid_581263
  var valid_581264 = query.getOrDefault("userIp")
  valid_581264 = validateParameter(valid_581264, JString, required = false,
                                 default = nil)
  if valid_581264 != nil:
    section.add "userIp", valid_581264
  var valid_581265 = query.getOrDefault("key")
  valid_581265 = validateParameter(valid_581265, JString, required = false,
                                 default = nil)
  if valid_581265 != nil:
    section.add "key", valid_581265
  var valid_581266 = query.getOrDefault("prettyPrint")
  valid_581266 = validateParameter(valid_581266, JBool, required = false,
                                 default = newJBool(true))
  if valid_581266 != nil:
    section.add "prettyPrint", valid_581266
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581267: Call_DfareportingCreativeFieldValuesDelete_581254;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing creative field value.
  ## 
  let valid = call_581267.validator(path, query, header, formData, body)
  let scheme = call_581267.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581267.url(scheme.get, call_581267.host, call_581267.base,
                         call_581267.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581267, url, valid)

proc call*(call_581268: Call_DfareportingCreativeFieldValuesDelete_581254;
          profileId: string; id: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesDelete
  ## Deletes an existing creative field value.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative Field Value ID
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581269 = newJObject()
  var query_581270 = newJObject()
  add(path_581269, "profileId", newJString(profileId))
  add(query_581270, "fields", newJString(fields))
  add(query_581270, "quotaUser", newJString(quotaUser))
  add(query_581270, "alt", newJString(alt))
  add(query_581270, "oauth_token", newJString(oauthToken))
  add(query_581270, "userIp", newJString(userIp))
  add(path_581269, "id", newJString(id))
  add(query_581270, "key", newJString(key))
  add(path_581269, "creativeFieldId", newJString(creativeFieldId))
  add(query_581270, "prettyPrint", newJBool(prettyPrint))
  result = call_581268.call(path_581269, query_581270, nil, nil, nil)

var dfareportingCreativeFieldValuesDelete* = Call_DfareportingCreativeFieldValuesDelete_581254(
    name: "dfareportingCreativeFieldValuesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues/{id}",
    validator: validate_DfareportingCreativeFieldValuesDelete_581255,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesDelete_581256,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsGet_581271 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeFieldsGet_581273(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsGet_581272(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative field by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581274 = path.getOrDefault("profileId")
  valid_581274 = validateParameter(valid_581274, JString, required = true,
                                 default = nil)
  if valid_581274 != nil:
    section.add "profileId", valid_581274
  var valid_581275 = path.getOrDefault("id")
  valid_581275 = validateParameter(valid_581275, JString, required = true,
                                 default = nil)
  if valid_581275 != nil:
    section.add "id", valid_581275
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581276 = query.getOrDefault("fields")
  valid_581276 = validateParameter(valid_581276, JString, required = false,
                                 default = nil)
  if valid_581276 != nil:
    section.add "fields", valid_581276
  var valid_581277 = query.getOrDefault("quotaUser")
  valid_581277 = validateParameter(valid_581277, JString, required = false,
                                 default = nil)
  if valid_581277 != nil:
    section.add "quotaUser", valid_581277
  var valid_581278 = query.getOrDefault("alt")
  valid_581278 = validateParameter(valid_581278, JString, required = false,
                                 default = newJString("json"))
  if valid_581278 != nil:
    section.add "alt", valid_581278
  var valid_581279 = query.getOrDefault("oauth_token")
  valid_581279 = validateParameter(valid_581279, JString, required = false,
                                 default = nil)
  if valid_581279 != nil:
    section.add "oauth_token", valid_581279
  var valid_581280 = query.getOrDefault("userIp")
  valid_581280 = validateParameter(valid_581280, JString, required = false,
                                 default = nil)
  if valid_581280 != nil:
    section.add "userIp", valid_581280
  var valid_581281 = query.getOrDefault("key")
  valid_581281 = validateParameter(valid_581281, JString, required = false,
                                 default = nil)
  if valid_581281 != nil:
    section.add "key", valid_581281
  var valid_581282 = query.getOrDefault("prettyPrint")
  valid_581282 = validateParameter(valid_581282, JBool, required = false,
                                 default = newJBool(true))
  if valid_581282 != nil:
    section.add "prettyPrint", valid_581282
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581283: Call_DfareportingCreativeFieldsGet_581271; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one creative field by ID.
  ## 
  let valid = call_581283.validator(path, query, header, formData, body)
  let scheme = call_581283.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581283.url(scheme.get, call_581283.host, call_581283.base,
                         call_581283.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581283, url, valid)

proc call*(call_581284: Call_DfareportingCreativeFieldsGet_581271;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsGet
  ## Gets one creative field by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative Field ID
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581285 = newJObject()
  var query_581286 = newJObject()
  add(path_581285, "profileId", newJString(profileId))
  add(query_581286, "fields", newJString(fields))
  add(query_581286, "quotaUser", newJString(quotaUser))
  add(query_581286, "alt", newJString(alt))
  add(query_581286, "oauth_token", newJString(oauthToken))
  add(query_581286, "userIp", newJString(userIp))
  add(path_581285, "id", newJString(id))
  add(query_581286, "key", newJString(key))
  add(query_581286, "prettyPrint", newJBool(prettyPrint))
  result = call_581284.call(path_581285, query_581286, nil, nil, nil)

var dfareportingCreativeFieldsGet* = Call_DfareportingCreativeFieldsGet_581271(
    name: "dfareportingCreativeFieldsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/creativeFields/{id}",
    validator: validate_DfareportingCreativeFieldsGet_581272,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsGet_581273,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsDelete_581287 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeFieldsDelete_581289(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsDelete_581288(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing creative field.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581290 = path.getOrDefault("profileId")
  valid_581290 = validateParameter(valid_581290, JString, required = true,
                                 default = nil)
  if valid_581290 != nil:
    section.add "profileId", valid_581290
  var valid_581291 = path.getOrDefault("id")
  valid_581291 = validateParameter(valid_581291, JString, required = true,
                                 default = nil)
  if valid_581291 != nil:
    section.add "id", valid_581291
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581292 = query.getOrDefault("fields")
  valid_581292 = validateParameter(valid_581292, JString, required = false,
                                 default = nil)
  if valid_581292 != nil:
    section.add "fields", valid_581292
  var valid_581293 = query.getOrDefault("quotaUser")
  valid_581293 = validateParameter(valid_581293, JString, required = false,
                                 default = nil)
  if valid_581293 != nil:
    section.add "quotaUser", valid_581293
  var valid_581294 = query.getOrDefault("alt")
  valid_581294 = validateParameter(valid_581294, JString, required = false,
                                 default = newJString("json"))
  if valid_581294 != nil:
    section.add "alt", valid_581294
  var valid_581295 = query.getOrDefault("oauth_token")
  valid_581295 = validateParameter(valid_581295, JString, required = false,
                                 default = nil)
  if valid_581295 != nil:
    section.add "oauth_token", valid_581295
  var valid_581296 = query.getOrDefault("userIp")
  valid_581296 = validateParameter(valid_581296, JString, required = false,
                                 default = nil)
  if valid_581296 != nil:
    section.add "userIp", valid_581296
  var valid_581297 = query.getOrDefault("key")
  valid_581297 = validateParameter(valid_581297, JString, required = false,
                                 default = nil)
  if valid_581297 != nil:
    section.add "key", valid_581297
  var valid_581298 = query.getOrDefault("prettyPrint")
  valid_581298 = validateParameter(valid_581298, JBool, required = false,
                                 default = newJBool(true))
  if valid_581298 != nil:
    section.add "prettyPrint", valid_581298
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581299: Call_DfareportingCreativeFieldsDelete_581287;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing creative field.
  ## 
  let valid = call_581299.validator(path, query, header, formData, body)
  let scheme = call_581299.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581299.url(scheme.get, call_581299.host, call_581299.base,
                         call_581299.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581299, url, valid)

proc call*(call_581300: Call_DfareportingCreativeFieldsDelete_581287;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsDelete
  ## Deletes an existing creative field.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative Field ID
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581301 = newJObject()
  var query_581302 = newJObject()
  add(path_581301, "profileId", newJString(profileId))
  add(query_581302, "fields", newJString(fields))
  add(query_581302, "quotaUser", newJString(quotaUser))
  add(query_581302, "alt", newJString(alt))
  add(query_581302, "oauth_token", newJString(oauthToken))
  add(query_581302, "userIp", newJString(userIp))
  add(path_581301, "id", newJString(id))
  add(query_581302, "key", newJString(key))
  add(query_581302, "prettyPrint", newJBool(prettyPrint))
  result = call_581300.call(path_581301, query_581302, nil, nil, nil)

var dfareportingCreativeFieldsDelete* = Call_DfareportingCreativeFieldsDelete_581287(
    name: "dfareportingCreativeFieldsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/creativeFields/{id}",
    validator: validate_DfareportingCreativeFieldsDelete_581288,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsDelete_581289,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsUpdate_581326 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeGroupsUpdate_581328(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsUpdate_581327(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581329 = path.getOrDefault("profileId")
  valid_581329 = validateParameter(valid_581329, JString, required = true,
                                 default = nil)
  if valid_581329 != nil:
    section.add "profileId", valid_581329
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581330 = query.getOrDefault("fields")
  valid_581330 = validateParameter(valid_581330, JString, required = false,
                                 default = nil)
  if valid_581330 != nil:
    section.add "fields", valid_581330
  var valid_581331 = query.getOrDefault("quotaUser")
  valid_581331 = validateParameter(valid_581331, JString, required = false,
                                 default = nil)
  if valid_581331 != nil:
    section.add "quotaUser", valid_581331
  var valid_581332 = query.getOrDefault("alt")
  valid_581332 = validateParameter(valid_581332, JString, required = false,
                                 default = newJString("json"))
  if valid_581332 != nil:
    section.add "alt", valid_581332
  var valid_581333 = query.getOrDefault("oauth_token")
  valid_581333 = validateParameter(valid_581333, JString, required = false,
                                 default = nil)
  if valid_581333 != nil:
    section.add "oauth_token", valid_581333
  var valid_581334 = query.getOrDefault("userIp")
  valid_581334 = validateParameter(valid_581334, JString, required = false,
                                 default = nil)
  if valid_581334 != nil:
    section.add "userIp", valid_581334
  var valid_581335 = query.getOrDefault("key")
  valid_581335 = validateParameter(valid_581335, JString, required = false,
                                 default = nil)
  if valid_581335 != nil:
    section.add "key", valid_581335
  var valid_581336 = query.getOrDefault("prettyPrint")
  valid_581336 = validateParameter(valid_581336, JBool, required = false,
                                 default = newJBool(true))
  if valid_581336 != nil:
    section.add "prettyPrint", valid_581336
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581338: Call_DfareportingCreativeGroupsUpdate_581326;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative group.
  ## 
  let valid = call_581338.validator(path, query, header, formData, body)
  let scheme = call_581338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581338.url(scheme.get, call_581338.host, call_581338.base,
                         call_581338.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581338, url, valid)

proc call*(call_581339: Call_DfareportingCreativeGroupsUpdate_581326;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsUpdate
  ## Updates an existing creative group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581340 = newJObject()
  var query_581341 = newJObject()
  var body_581342 = newJObject()
  add(path_581340, "profileId", newJString(profileId))
  add(query_581341, "fields", newJString(fields))
  add(query_581341, "quotaUser", newJString(quotaUser))
  add(query_581341, "alt", newJString(alt))
  add(query_581341, "oauth_token", newJString(oauthToken))
  add(query_581341, "userIp", newJString(userIp))
  add(query_581341, "key", newJString(key))
  if body != nil:
    body_581342 = body
  add(query_581341, "prettyPrint", newJBool(prettyPrint))
  result = call_581339.call(path_581340, query_581341, nil, nil, body_581342)

var dfareportingCreativeGroupsUpdate* = Call_DfareportingCreativeGroupsUpdate_581326(
    name: "dfareportingCreativeGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsUpdate_581327,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsUpdate_581328,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsInsert_581343 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeGroupsInsert_581345(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsInsert_581344(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581346 = path.getOrDefault("profileId")
  valid_581346 = validateParameter(valid_581346, JString, required = true,
                                 default = nil)
  if valid_581346 != nil:
    section.add "profileId", valid_581346
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581347 = query.getOrDefault("fields")
  valid_581347 = validateParameter(valid_581347, JString, required = false,
                                 default = nil)
  if valid_581347 != nil:
    section.add "fields", valid_581347
  var valid_581348 = query.getOrDefault("quotaUser")
  valid_581348 = validateParameter(valid_581348, JString, required = false,
                                 default = nil)
  if valid_581348 != nil:
    section.add "quotaUser", valid_581348
  var valid_581349 = query.getOrDefault("alt")
  valid_581349 = validateParameter(valid_581349, JString, required = false,
                                 default = newJString("json"))
  if valid_581349 != nil:
    section.add "alt", valid_581349
  var valid_581350 = query.getOrDefault("oauth_token")
  valid_581350 = validateParameter(valid_581350, JString, required = false,
                                 default = nil)
  if valid_581350 != nil:
    section.add "oauth_token", valid_581350
  var valid_581351 = query.getOrDefault("userIp")
  valid_581351 = validateParameter(valid_581351, JString, required = false,
                                 default = nil)
  if valid_581351 != nil:
    section.add "userIp", valid_581351
  var valid_581352 = query.getOrDefault("key")
  valid_581352 = validateParameter(valid_581352, JString, required = false,
                                 default = nil)
  if valid_581352 != nil:
    section.add "key", valid_581352
  var valid_581353 = query.getOrDefault("prettyPrint")
  valid_581353 = validateParameter(valid_581353, JBool, required = false,
                                 default = newJBool(true))
  if valid_581353 != nil:
    section.add "prettyPrint", valid_581353
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581355: Call_DfareportingCreativeGroupsInsert_581343;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative group.
  ## 
  let valid = call_581355.validator(path, query, header, formData, body)
  let scheme = call_581355.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581355.url(scheme.get, call_581355.host, call_581355.base,
                         call_581355.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581355, url, valid)

proc call*(call_581356: Call_DfareportingCreativeGroupsInsert_581343;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsInsert
  ## Inserts a new creative group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581357 = newJObject()
  var query_581358 = newJObject()
  var body_581359 = newJObject()
  add(path_581357, "profileId", newJString(profileId))
  add(query_581358, "fields", newJString(fields))
  add(query_581358, "quotaUser", newJString(quotaUser))
  add(query_581358, "alt", newJString(alt))
  add(query_581358, "oauth_token", newJString(oauthToken))
  add(query_581358, "userIp", newJString(userIp))
  add(query_581358, "key", newJString(key))
  if body != nil:
    body_581359 = body
  add(query_581358, "prettyPrint", newJBool(prettyPrint))
  result = call_581356.call(path_581357, query_581358, nil, nil, body_581359)

var dfareportingCreativeGroupsInsert* = Call_DfareportingCreativeGroupsInsert_581343(
    name: "dfareportingCreativeGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsInsert_581344,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsInsert_581345,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsList_581303 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeGroupsList_581305(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsList_581304(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creative groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581306 = path.getOrDefault("profileId")
  valid_581306 = validateParameter(valid_581306, JString, required = true,
                                 default = nil)
  if valid_581306 != nil:
    section.add "profileId", valid_581306
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for creative groups by name or ID. Wildcards (*) are allowed. For example, "creativegroup*2015" will return creative groups with names like "creativegroup June 2015", "creativegroup April 2015", or simply "creativegroup 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativegroup" will match creative groups with the name "my creativegroup", "creativegroup 2015", or simply "creativegroup".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative groups with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only creative groups that belong to these advertisers.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   groupNumber: JInt
  ##              : Select only creative groups that belong to this subgroup.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581307 = query.getOrDefault("fields")
  valid_581307 = validateParameter(valid_581307, JString, required = false,
                                 default = nil)
  if valid_581307 != nil:
    section.add "fields", valid_581307
  var valid_581308 = query.getOrDefault("pageToken")
  valid_581308 = validateParameter(valid_581308, JString, required = false,
                                 default = nil)
  if valid_581308 != nil:
    section.add "pageToken", valid_581308
  var valid_581309 = query.getOrDefault("quotaUser")
  valid_581309 = validateParameter(valid_581309, JString, required = false,
                                 default = nil)
  if valid_581309 != nil:
    section.add "quotaUser", valid_581309
  var valid_581310 = query.getOrDefault("sortField")
  valid_581310 = validateParameter(valid_581310, JString, required = false,
                                 default = newJString("ID"))
  if valid_581310 != nil:
    section.add "sortField", valid_581310
  var valid_581311 = query.getOrDefault("alt")
  valid_581311 = validateParameter(valid_581311, JString, required = false,
                                 default = newJString("json"))
  if valid_581311 != nil:
    section.add "alt", valid_581311
  var valid_581312 = query.getOrDefault("searchString")
  valid_581312 = validateParameter(valid_581312, JString, required = false,
                                 default = nil)
  if valid_581312 != nil:
    section.add "searchString", valid_581312
  var valid_581313 = query.getOrDefault("oauth_token")
  valid_581313 = validateParameter(valid_581313, JString, required = false,
                                 default = nil)
  if valid_581313 != nil:
    section.add "oauth_token", valid_581313
  var valid_581314 = query.getOrDefault("userIp")
  valid_581314 = validateParameter(valid_581314, JString, required = false,
                                 default = nil)
  if valid_581314 != nil:
    section.add "userIp", valid_581314
  var valid_581315 = query.getOrDefault("maxResults")
  valid_581315 = validateParameter(valid_581315, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581315 != nil:
    section.add "maxResults", valid_581315
  var valid_581316 = query.getOrDefault("ids")
  valid_581316 = validateParameter(valid_581316, JArray, required = false,
                                 default = nil)
  if valid_581316 != nil:
    section.add "ids", valid_581316
  var valid_581317 = query.getOrDefault("key")
  valid_581317 = validateParameter(valid_581317, JString, required = false,
                                 default = nil)
  if valid_581317 != nil:
    section.add "key", valid_581317
  var valid_581318 = query.getOrDefault("advertiserIds")
  valid_581318 = validateParameter(valid_581318, JArray, required = false,
                                 default = nil)
  if valid_581318 != nil:
    section.add "advertiserIds", valid_581318
  var valid_581319 = query.getOrDefault("sortOrder")
  valid_581319 = validateParameter(valid_581319, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581319 != nil:
    section.add "sortOrder", valid_581319
  var valid_581320 = query.getOrDefault("groupNumber")
  valid_581320 = validateParameter(valid_581320, JInt, required = false, default = nil)
  if valid_581320 != nil:
    section.add "groupNumber", valid_581320
  var valid_581321 = query.getOrDefault("prettyPrint")
  valid_581321 = validateParameter(valid_581321, JBool, required = false,
                                 default = newJBool(true))
  if valid_581321 != nil:
    section.add "prettyPrint", valid_581321
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581322: Call_DfareportingCreativeGroupsList_581303; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of creative groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_581322.validator(path, query, header, formData, body)
  let scheme = call_581322.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581322.url(scheme.get, call_581322.host, call_581322.base,
                         call_581322.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581322, url, valid)

proc call*(call_581323: Call_DfareportingCreativeGroupsList_581303;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          advertiserIds: JsonNode = nil; sortOrder: string = "ASCENDING";
          groupNumber: int = 0; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsList
  ## Retrieves a list of creative groups, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for creative groups by name or ID. Wildcards (*) are allowed. For example, "creativegroup*2015" will return creative groups with names like "creativegroup June 2015", "creativegroup April 2015", or simply "creativegroup 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativegroup" will match creative groups with the name "my creativegroup", "creativegroup 2015", or simply "creativegroup".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative groups with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only creative groups that belong to these advertisers.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   groupNumber: int
  ##              : Select only creative groups that belong to this subgroup.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581324 = newJObject()
  var query_581325 = newJObject()
  add(path_581324, "profileId", newJString(profileId))
  add(query_581325, "fields", newJString(fields))
  add(query_581325, "pageToken", newJString(pageToken))
  add(query_581325, "quotaUser", newJString(quotaUser))
  add(query_581325, "sortField", newJString(sortField))
  add(query_581325, "alt", newJString(alt))
  add(query_581325, "searchString", newJString(searchString))
  add(query_581325, "oauth_token", newJString(oauthToken))
  add(query_581325, "userIp", newJString(userIp))
  add(query_581325, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_581325.add "ids", ids
  add(query_581325, "key", newJString(key))
  if advertiserIds != nil:
    query_581325.add "advertiserIds", advertiserIds
  add(query_581325, "sortOrder", newJString(sortOrder))
  add(query_581325, "groupNumber", newJInt(groupNumber))
  add(query_581325, "prettyPrint", newJBool(prettyPrint))
  result = call_581323.call(path_581324, query_581325, nil, nil, nil)

var dfareportingCreativeGroupsList* = Call_DfareportingCreativeGroupsList_581303(
    name: "dfareportingCreativeGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsList_581304,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsList_581305,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsPatch_581360 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeGroupsPatch_581362(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsPatch_581361(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581363 = path.getOrDefault("profileId")
  valid_581363 = validateParameter(valid_581363, JString, required = true,
                                 default = nil)
  if valid_581363 != nil:
    section.add "profileId", valid_581363
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative group ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581364 = query.getOrDefault("fields")
  valid_581364 = validateParameter(valid_581364, JString, required = false,
                                 default = nil)
  if valid_581364 != nil:
    section.add "fields", valid_581364
  var valid_581365 = query.getOrDefault("quotaUser")
  valid_581365 = validateParameter(valid_581365, JString, required = false,
                                 default = nil)
  if valid_581365 != nil:
    section.add "quotaUser", valid_581365
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_581366 = query.getOrDefault("id")
  valid_581366 = validateParameter(valid_581366, JString, required = true,
                                 default = nil)
  if valid_581366 != nil:
    section.add "id", valid_581366
  var valid_581367 = query.getOrDefault("alt")
  valid_581367 = validateParameter(valid_581367, JString, required = false,
                                 default = newJString("json"))
  if valid_581367 != nil:
    section.add "alt", valid_581367
  var valid_581368 = query.getOrDefault("oauth_token")
  valid_581368 = validateParameter(valid_581368, JString, required = false,
                                 default = nil)
  if valid_581368 != nil:
    section.add "oauth_token", valid_581368
  var valid_581369 = query.getOrDefault("userIp")
  valid_581369 = validateParameter(valid_581369, JString, required = false,
                                 default = nil)
  if valid_581369 != nil:
    section.add "userIp", valid_581369
  var valid_581370 = query.getOrDefault("key")
  valid_581370 = validateParameter(valid_581370, JString, required = false,
                                 default = nil)
  if valid_581370 != nil:
    section.add "key", valid_581370
  var valid_581371 = query.getOrDefault("prettyPrint")
  valid_581371 = validateParameter(valid_581371, JBool, required = false,
                                 default = newJBool(true))
  if valid_581371 != nil:
    section.add "prettyPrint", valid_581371
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581373: Call_DfareportingCreativeGroupsPatch_581360;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative group. This method supports patch semantics.
  ## 
  let valid = call_581373.validator(path, query, header, formData, body)
  let scheme = call_581373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581373.url(scheme.get, call_581373.host, call_581373.base,
                         call_581373.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581373, url, valid)

proc call*(call_581374: Call_DfareportingCreativeGroupsPatch_581360;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsPatch
  ## Updates an existing creative group. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581375 = newJObject()
  var query_581376 = newJObject()
  var body_581377 = newJObject()
  add(path_581375, "profileId", newJString(profileId))
  add(query_581376, "fields", newJString(fields))
  add(query_581376, "quotaUser", newJString(quotaUser))
  add(query_581376, "id", newJString(id))
  add(query_581376, "alt", newJString(alt))
  add(query_581376, "oauth_token", newJString(oauthToken))
  add(query_581376, "userIp", newJString(userIp))
  add(query_581376, "key", newJString(key))
  if body != nil:
    body_581377 = body
  add(query_581376, "prettyPrint", newJBool(prettyPrint))
  result = call_581374.call(path_581375, query_581376, nil, nil, body_581377)

var dfareportingCreativeGroupsPatch* = Call_DfareportingCreativeGroupsPatch_581360(
    name: "dfareportingCreativeGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsPatch_581361,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsPatch_581362,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsGet_581378 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativeGroupsGet_581380(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsGet_581379(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581381 = path.getOrDefault("profileId")
  valid_581381 = validateParameter(valid_581381, JString, required = true,
                                 default = nil)
  if valid_581381 != nil:
    section.add "profileId", valid_581381
  var valid_581382 = path.getOrDefault("id")
  valid_581382 = validateParameter(valid_581382, JString, required = true,
                                 default = nil)
  if valid_581382 != nil:
    section.add "id", valid_581382
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581383 = query.getOrDefault("fields")
  valid_581383 = validateParameter(valid_581383, JString, required = false,
                                 default = nil)
  if valid_581383 != nil:
    section.add "fields", valid_581383
  var valid_581384 = query.getOrDefault("quotaUser")
  valid_581384 = validateParameter(valid_581384, JString, required = false,
                                 default = nil)
  if valid_581384 != nil:
    section.add "quotaUser", valid_581384
  var valid_581385 = query.getOrDefault("alt")
  valid_581385 = validateParameter(valid_581385, JString, required = false,
                                 default = newJString("json"))
  if valid_581385 != nil:
    section.add "alt", valid_581385
  var valid_581386 = query.getOrDefault("oauth_token")
  valid_581386 = validateParameter(valid_581386, JString, required = false,
                                 default = nil)
  if valid_581386 != nil:
    section.add "oauth_token", valid_581386
  var valid_581387 = query.getOrDefault("userIp")
  valid_581387 = validateParameter(valid_581387, JString, required = false,
                                 default = nil)
  if valid_581387 != nil:
    section.add "userIp", valid_581387
  var valid_581388 = query.getOrDefault("key")
  valid_581388 = validateParameter(valid_581388, JString, required = false,
                                 default = nil)
  if valid_581388 != nil:
    section.add "key", valid_581388
  var valid_581389 = query.getOrDefault("prettyPrint")
  valid_581389 = validateParameter(valid_581389, JBool, required = false,
                                 default = newJBool(true))
  if valid_581389 != nil:
    section.add "prettyPrint", valid_581389
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581390: Call_DfareportingCreativeGroupsGet_581378; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one creative group by ID.
  ## 
  let valid = call_581390.validator(path, query, header, formData, body)
  let scheme = call_581390.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581390.url(scheme.get, call_581390.host, call_581390.base,
                         call_581390.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581390, url, valid)

proc call*(call_581391: Call_DfareportingCreativeGroupsGet_581378;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsGet
  ## Gets one creative group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581392 = newJObject()
  var query_581393 = newJObject()
  add(path_581392, "profileId", newJString(profileId))
  add(query_581393, "fields", newJString(fields))
  add(query_581393, "quotaUser", newJString(quotaUser))
  add(query_581393, "alt", newJString(alt))
  add(query_581393, "oauth_token", newJString(oauthToken))
  add(query_581393, "userIp", newJString(userIp))
  add(path_581392, "id", newJString(id))
  add(query_581393, "key", newJString(key))
  add(query_581393, "prettyPrint", newJBool(prettyPrint))
  result = call_581391.call(path_581392, query_581393, nil, nil, nil)

var dfareportingCreativeGroupsGet* = Call_DfareportingCreativeGroupsGet_581378(
    name: "dfareportingCreativeGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/creativeGroups/{id}",
    validator: validate_DfareportingCreativeGroupsGet_581379,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsGet_581380,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesUpdate_581425 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativesUpdate_581427(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesUpdate_581426(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581428 = path.getOrDefault("profileId")
  valid_581428 = validateParameter(valid_581428, JString, required = true,
                                 default = nil)
  if valid_581428 != nil:
    section.add "profileId", valid_581428
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581429 = query.getOrDefault("fields")
  valid_581429 = validateParameter(valid_581429, JString, required = false,
                                 default = nil)
  if valid_581429 != nil:
    section.add "fields", valid_581429
  var valid_581430 = query.getOrDefault("quotaUser")
  valid_581430 = validateParameter(valid_581430, JString, required = false,
                                 default = nil)
  if valid_581430 != nil:
    section.add "quotaUser", valid_581430
  var valid_581431 = query.getOrDefault("alt")
  valid_581431 = validateParameter(valid_581431, JString, required = false,
                                 default = newJString("json"))
  if valid_581431 != nil:
    section.add "alt", valid_581431
  var valid_581432 = query.getOrDefault("oauth_token")
  valid_581432 = validateParameter(valid_581432, JString, required = false,
                                 default = nil)
  if valid_581432 != nil:
    section.add "oauth_token", valid_581432
  var valid_581433 = query.getOrDefault("userIp")
  valid_581433 = validateParameter(valid_581433, JString, required = false,
                                 default = nil)
  if valid_581433 != nil:
    section.add "userIp", valid_581433
  var valid_581434 = query.getOrDefault("key")
  valid_581434 = validateParameter(valid_581434, JString, required = false,
                                 default = nil)
  if valid_581434 != nil:
    section.add "key", valid_581434
  var valid_581435 = query.getOrDefault("prettyPrint")
  valid_581435 = validateParameter(valid_581435, JBool, required = false,
                                 default = newJBool(true))
  if valid_581435 != nil:
    section.add "prettyPrint", valid_581435
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581437: Call_DfareportingCreativesUpdate_581425; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing creative.
  ## 
  let valid = call_581437.validator(path, query, header, formData, body)
  let scheme = call_581437.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581437.url(scheme.get, call_581437.host, call_581437.base,
                         call_581437.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581437, url, valid)

proc call*(call_581438: Call_DfareportingCreativesUpdate_581425; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativesUpdate
  ## Updates an existing creative.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581439 = newJObject()
  var query_581440 = newJObject()
  var body_581441 = newJObject()
  add(path_581439, "profileId", newJString(profileId))
  add(query_581440, "fields", newJString(fields))
  add(query_581440, "quotaUser", newJString(quotaUser))
  add(query_581440, "alt", newJString(alt))
  add(query_581440, "oauth_token", newJString(oauthToken))
  add(query_581440, "userIp", newJString(userIp))
  add(query_581440, "key", newJString(key))
  if body != nil:
    body_581441 = body
  add(query_581440, "prettyPrint", newJBool(prettyPrint))
  result = call_581438.call(path_581439, query_581440, nil, nil, body_581441)

var dfareportingCreativesUpdate* = Call_DfareportingCreativesUpdate_581425(
    name: "dfareportingCreativesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesUpdate_581426,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesUpdate_581427,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesInsert_581442 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativesInsert_581444(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesInsert_581443(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581445 = path.getOrDefault("profileId")
  valid_581445 = validateParameter(valid_581445, JString, required = true,
                                 default = nil)
  if valid_581445 != nil:
    section.add "profileId", valid_581445
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581446 = query.getOrDefault("fields")
  valid_581446 = validateParameter(valid_581446, JString, required = false,
                                 default = nil)
  if valid_581446 != nil:
    section.add "fields", valid_581446
  var valid_581447 = query.getOrDefault("quotaUser")
  valid_581447 = validateParameter(valid_581447, JString, required = false,
                                 default = nil)
  if valid_581447 != nil:
    section.add "quotaUser", valid_581447
  var valid_581448 = query.getOrDefault("alt")
  valid_581448 = validateParameter(valid_581448, JString, required = false,
                                 default = newJString("json"))
  if valid_581448 != nil:
    section.add "alt", valid_581448
  var valid_581449 = query.getOrDefault("oauth_token")
  valid_581449 = validateParameter(valid_581449, JString, required = false,
                                 default = nil)
  if valid_581449 != nil:
    section.add "oauth_token", valid_581449
  var valid_581450 = query.getOrDefault("userIp")
  valid_581450 = validateParameter(valid_581450, JString, required = false,
                                 default = nil)
  if valid_581450 != nil:
    section.add "userIp", valid_581450
  var valid_581451 = query.getOrDefault("key")
  valid_581451 = validateParameter(valid_581451, JString, required = false,
                                 default = nil)
  if valid_581451 != nil:
    section.add "key", valid_581451
  var valid_581452 = query.getOrDefault("prettyPrint")
  valid_581452 = validateParameter(valid_581452, JBool, required = false,
                                 default = newJBool(true))
  if valid_581452 != nil:
    section.add "prettyPrint", valid_581452
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581454: Call_DfareportingCreativesInsert_581442; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new creative.
  ## 
  let valid = call_581454.validator(path, query, header, formData, body)
  let scheme = call_581454.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581454.url(scheme.get, call_581454.host, call_581454.base,
                         call_581454.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581454, url, valid)

proc call*(call_581455: Call_DfareportingCreativesInsert_581442; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativesInsert
  ## Inserts a new creative.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581456 = newJObject()
  var query_581457 = newJObject()
  var body_581458 = newJObject()
  add(path_581456, "profileId", newJString(profileId))
  add(query_581457, "fields", newJString(fields))
  add(query_581457, "quotaUser", newJString(quotaUser))
  add(query_581457, "alt", newJString(alt))
  add(query_581457, "oauth_token", newJString(oauthToken))
  add(query_581457, "userIp", newJString(userIp))
  add(query_581457, "key", newJString(key))
  if body != nil:
    body_581458 = body
  add(query_581457, "prettyPrint", newJBool(prettyPrint))
  result = call_581455.call(path_581456, query_581457, nil, nil, body_581458)

var dfareportingCreativesInsert* = Call_DfareportingCreativesInsert_581442(
    name: "dfareportingCreativesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesInsert_581443,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesInsert_581444,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesList_581394 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativesList_581396(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesList_581395(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creatives, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581397 = path.getOrDefault("profileId")
  valid_581397 = validateParameter(valid_581397, JString, required = true,
                                 default = nil)
  if valid_581397 != nil:
    section.add "profileId", valid_581397
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "creative*2015" will return objects with names like "creative June 2015", "creative April 2015", or simply "creative 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "creative" will match objects with name "my creative", "creative 2015", or simply "creative".
  ##   advertiserId: JString
  ##               : Select only creatives with this advertiser ID.
  ##   types: JArray
  ##        : Select only creatives with these creative types.
  ##   sizeIds: JArray
  ##          : Select only creatives with these size IDs.
  ##   active: JBool
  ##         : Select only active creatives. Leave blank to select active and inactive creatives.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   studioCreativeId: JString
  ##                   : Select only creatives corresponding to this Studio creative ID.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   renderingIds: JArray
  ##               : Select only creatives with these rendering IDs.
  ##   archived: JBool
  ##           : Select only archived creatives. Leave blank to select archived and unarchived creatives.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creatives with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldIds: JArray
  ##                   : Select only creatives with these creative field IDs.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   companionCreativeIds: JArray
  ##                       : Select only in-stream video creatives with these companion IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: JString
  ##             : Select only creatives with this campaign ID.
  section = newJObject()
  var valid_581398 = query.getOrDefault("fields")
  valid_581398 = validateParameter(valid_581398, JString, required = false,
                                 default = nil)
  if valid_581398 != nil:
    section.add "fields", valid_581398
  var valid_581399 = query.getOrDefault("pageToken")
  valid_581399 = validateParameter(valid_581399, JString, required = false,
                                 default = nil)
  if valid_581399 != nil:
    section.add "pageToken", valid_581399
  var valid_581400 = query.getOrDefault("quotaUser")
  valid_581400 = validateParameter(valid_581400, JString, required = false,
                                 default = nil)
  if valid_581400 != nil:
    section.add "quotaUser", valid_581400
  var valid_581401 = query.getOrDefault("sortField")
  valid_581401 = validateParameter(valid_581401, JString, required = false,
                                 default = newJString("ID"))
  if valid_581401 != nil:
    section.add "sortField", valid_581401
  var valid_581402 = query.getOrDefault("alt")
  valid_581402 = validateParameter(valid_581402, JString, required = false,
                                 default = newJString("json"))
  if valid_581402 != nil:
    section.add "alt", valid_581402
  var valid_581403 = query.getOrDefault("searchString")
  valid_581403 = validateParameter(valid_581403, JString, required = false,
                                 default = nil)
  if valid_581403 != nil:
    section.add "searchString", valid_581403
  var valid_581404 = query.getOrDefault("advertiserId")
  valid_581404 = validateParameter(valid_581404, JString, required = false,
                                 default = nil)
  if valid_581404 != nil:
    section.add "advertiserId", valid_581404
  var valid_581405 = query.getOrDefault("types")
  valid_581405 = validateParameter(valid_581405, JArray, required = false,
                                 default = nil)
  if valid_581405 != nil:
    section.add "types", valid_581405
  var valid_581406 = query.getOrDefault("sizeIds")
  valid_581406 = validateParameter(valid_581406, JArray, required = false,
                                 default = nil)
  if valid_581406 != nil:
    section.add "sizeIds", valid_581406
  var valid_581407 = query.getOrDefault("active")
  valid_581407 = validateParameter(valid_581407, JBool, required = false, default = nil)
  if valid_581407 != nil:
    section.add "active", valid_581407
  var valid_581408 = query.getOrDefault("oauth_token")
  valid_581408 = validateParameter(valid_581408, JString, required = false,
                                 default = nil)
  if valid_581408 != nil:
    section.add "oauth_token", valid_581408
  var valid_581409 = query.getOrDefault("studioCreativeId")
  valid_581409 = validateParameter(valid_581409, JString, required = false,
                                 default = nil)
  if valid_581409 != nil:
    section.add "studioCreativeId", valid_581409
  var valid_581410 = query.getOrDefault("userIp")
  valid_581410 = validateParameter(valid_581410, JString, required = false,
                                 default = nil)
  if valid_581410 != nil:
    section.add "userIp", valid_581410
  var valid_581411 = query.getOrDefault("renderingIds")
  valid_581411 = validateParameter(valid_581411, JArray, required = false,
                                 default = nil)
  if valid_581411 != nil:
    section.add "renderingIds", valid_581411
  var valid_581412 = query.getOrDefault("archived")
  valid_581412 = validateParameter(valid_581412, JBool, required = false, default = nil)
  if valid_581412 != nil:
    section.add "archived", valid_581412
  var valid_581413 = query.getOrDefault("maxResults")
  valid_581413 = validateParameter(valid_581413, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581413 != nil:
    section.add "maxResults", valid_581413
  var valid_581414 = query.getOrDefault("ids")
  valid_581414 = validateParameter(valid_581414, JArray, required = false,
                                 default = nil)
  if valid_581414 != nil:
    section.add "ids", valid_581414
  var valid_581415 = query.getOrDefault("key")
  valid_581415 = validateParameter(valid_581415, JString, required = false,
                                 default = nil)
  if valid_581415 != nil:
    section.add "key", valid_581415
  var valid_581416 = query.getOrDefault("creativeFieldIds")
  valid_581416 = validateParameter(valid_581416, JArray, required = false,
                                 default = nil)
  if valid_581416 != nil:
    section.add "creativeFieldIds", valid_581416
  var valid_581417 = query.getOrDefault("sortOrder")
  valid_581417 = validateParameter(valid_581417, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581417 != nil:
    section.add "sortOrder", valid_581417
  var valid_581418 = query.getOrDefault("companionCreativeIds")
  valid_581418 = validateParameter(valid_581418, JArray, required = false,
                                 default = nil)
  if valid_581418 != nil:
    section.add "companionCreativeIds", valid_581418
  var valid_581419 = query.getOrDefault("prettyPrint")
  valid_581419 = validateParameter(valid_581419, JBool, required = false,
                                 default = newJBool(true))
  if valid_581419 != nil:
    section.add "prettyPrint", valid_581419
  var valid_581420 = query.getOrDefault("campaignId")
  valid_581420 = validateParameter(valid_581420, JString, required = false,
                                 default = nil)
  if valid_581420 != nil:
    section.add "campaignId", valid_581420
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581421: Call_DfareportingCreativesList_581394; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of creatives, possibly filtered. This method supports paging.
  ## 
  let valid = call_581421.validator(path, query, header, formData, body)
  let scheme = call_581421.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581421.url(scheme.get, call_581421.host, call_581421.base,
                         call_581421.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581421, url, valid)

proc call*(call_581422: Call_DfareportingCreativesList_581394; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; searchString: string = "";
          advertiserId: string = ""; types: JsonNode = nil; sizeIds: JsonNode = nil;
          active: bool = false; oauthToken: string = ""; studioCreativeId: string = "";
          userIp: string = ""; renderingIds: JsonNode = nil; archived: bool = false;
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          creativeFieldIds: JsonNode = nil; sortOrder: string = "ASCENDING";
          companionCreativeIds: JsonNode = nil; prettyPrint: bool = true;
          campaignId: string = ""): Recallable =
  ## dfareportingCreativesList
  ## Retrieves a list of creatives, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "creative*2015" will return objects with names like "creative June 2015", "creative April 2015", or simply "creative 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "creative" will match objects with name "my creative", "creative 2015", or simply "creative".
  ##   advertiserId: string
  ##               : Select only creatives with this advertiser ID.
  ##   types: JArray
  ##        : Select only creatives with these creative types.
  ##   sizeIds: JArray
  ##          : Select only creatives with these size IDs.
  ##   active: bool
  ##         : Select only active creatives. Leave blank to select active and inactive creatives.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   studioCreativeId: string
  ##                   : Select only creatives corresponding to this Studio creative ID.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   renderingIds: JArray
  ##               : Select only creatives with these rendering IDs.
  ##   archived: bool
  ##           : Select only archived creatives. Leave blank to select archived and unarchived creatives.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creatives with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldIds: JArray
  ##                   : Select only creatives with these creative field IDs.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   companionCreativeIds: JArray
  ##                       : Select only in-stream video creatives with these companion IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: string
  ##             : Select only creatives with this campaign ID.
  var path_581423 = newJObject()
  var query_581424 = newJObject()
  add(path_581423, "profileId", newJString(profileId))
  add(query_581424, "fields", newJString(fields))
  add(query_581424, "pageToken", newJString(pageToken))
  add(query_581424, "quotaUser", newJString(quotaUser))
  add(query_581424, "sortField", newJString(sortField))
  add(query_581424, "alt", newJString(alt))
  add(query_581424, "searchString", newJString(searchString))
  add(query_581424, "advertiserId", newJString(advertiserId))
  if types != nil:
    query_581424.add "types", types
  if sizeIds != nil:
    query_581424.add "sizeIds", sizeIds
  add(query_581424, "active", newJBool(active))
  add(query_581424, "oauth_token", newJString(oauthToken))
  add(query_581424, "studioCreativeId", newJString(studioCreativeId))
  add(query_581424, "userIp", newJString(userIp))
  if renderingIds != nil:
    query_581424.add "renderingIds", renderingIds
  add(query_581424, "archived", newJBool(archived))
  add(query_581424, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_581424.add "ids", ids
  add(query_581424, "key", newJString(key))
  if creativeFieldIds != nil:
    query_581424.add "creativeFieldIds", creativeFieldIds
  add(query_581424, "sortOrder", newJString(sortOrder))
  if companionCreativeIds != nil:
    query_581424.add "companionCreativeIds", companionCreativeIds
  add(query_581424, "prettyPrint", newJBool(prettyPrint))
  add(query_581424, "campaignId", newJString(campaignId))
  result = call_581422.call(path_581423, query_581424, nil, nil, nil)

var dfareportingCreativesList* = Call_DfareportingCreativesList_581394(
    name: "dfareportingCreativesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesList_581395,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesList_581396,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesPatch_581459 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativesPatch_581461(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesPatch_581460(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581462 = path.getOrDefault("profileId")
  valid_581462 = validateParameter(valid_581462, JString, required = true,
                                 default = nil)
  if valid_581462 != nil:
    section.add "profileId", valid_581462
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581463 = query.getOrDefault("fields")
  valid_581463 = validateParameter(valid_581463, JString, required = false,
                                 default = nil)
  if valid_581463 != nil:
    section.add "fields", valid_581463
  var valid_581464 = query.getOrDefault("quotaUser")
  valid_581464 = validateParameter(valid_581464, JString, required = false,
                                 default = nil)
  if valid_581464 != nil:
    section.add "quotaUser", valid_581464
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_581465 = query.getOrDefault("id")
  valid_581465 = validateParameter(valid_581465, JString, required = true,
                                 default = nil)
  if valid_581465 != nil:
    section.add "id", valid_581465
  var valid_581466 = query.getOrDefault("alt")
  valid_581466 = validateParameter(valid_581466, JString, required = false,
                                 default = newJString("json"))
  if valid_581466 != nil:
    section.add "alt", valid_581466
  var valid_581467 = query.getOrDefault("oauth_token")
  valid_581467 = validateParameter(valid_581467, JString, required = false,
                                 default = nil)
  if valid_581467 != nil:
    section.add "oauth_token", valid_581467
  var valid_581468 = query.getOrDefault("userIp")
  valid_581468 = validateParameter(valid_581468, JString, required = false,
                                 default = nil)
  if valid_581468 != nil:
    section.add "userIp", valid_581468
  var valid_581469 = query.getOrDefault("key")
  valid_581469 = validateParameter(valid_581469, JString, required = false,
                                 default = nil)
  if valid_581469 != nil:
    section.add "key", valid_581469
  var valid_581470 = query.getOrDefault("prettyPrint")
  valid_581470 = validateParameter(valid_581470, JBool, required = false,
                                 default = newJBool(true))
  if valid_581470 != nil:
    section.add "prettyPrint", valid_581470
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581472: Call_DfareportingCreativesPatch_581459; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing creative. This method supports patch semantics.
  ## 
  let valid = call_581472.validator(path, query, header, formData, body)
  let scheme = call_581472.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581472.url(scheme.get, call_581472.host, call_581472.base,
                         call_581472.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581472, url, valid)

proc call*(call_581473: Call_DfareportingCreativesPatch_581459; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativesPatch
  ## Updates an existing creative. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581474 = newJObject()
  var query_581475 = newJObject()
  var body_581476 = newJObject()
  add(path_581474, "profileId", newJString(profileId))
  add(query_581475, "fields", newJString(fields))
  add(query_581475, "quotaUser", newJString(quotaUser))
  add(query_581475, "id", newJString(id))
  add(query_581475, "alt", newJString(alt))
  add(query_581475, "oauth_token", newJString(oauthToken))
  add(query_581475, "userIp", newJString(userIp))
  add(query_581475, "key", newJString(key))
  if body != nil:
    body_581476 = body
  add(query_581475, "prettyPrint", newJBool(prettyPrint))
  result = call_581473.call(path_581474, query_581475, nil, nil, body_581476)

var dfareportingCreativesPatch* = Call_DfareportingCreativesPatch_581459(
    name: "dfareportingCreativesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesPatch_581460,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesPatch_581461,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesGet_581477 = ref object of OpenApiRestCall_579437
proc url_DfareportingCreativesGet_581479(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesGet_581478(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581480 = path.getOrDefault("profileId")
  valid_581480 = validateParameter(valid_581480, JString, required = true,
                                 default = nil)
  if valid_581480 != nil:
    section.add "profileId", valid_581480
  var valid_581481 = path.getOrDefault("id")
  valid_581481 = validateParameter(valid_581481, JString, required = true,
                                 default = nil)
  if valid_581481 != nil:
    section.add "id", valid_581481
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581482 = query.getOrDefault("fields")
  valid_581482 = validateParameter(valid_581482, JString, required = false,
                                 default = nil)
  if valid_581482 != nil:
    section.add "fields", valid_581482
  var valid_581483 = query.getOrDefault("quotaUser")
  valid_581483 = validateParameter(valid_581483, JString, required = false,
                                 default = nil)
  if valid_581483 != nil:
    section.add "quotaUser", valid_581483
  var valid_581484 = query.getOrDefault("alt")
  valid_581484 = validateParameter(valid_581484, JString, required = false,
                                 default = newJString("json"))
  if valid_581484 != nil:
    section.add "alt", valid_581484
  var valid_581485 = query.getOrDefault("oauth_token")
  valid_581485 = validateParameter(valid_581485, JString, required = false,
                                 default = nil)
  if valid_581485 != nil:
    section.add "oauth_token", valid_581485
  var valid_581486 = query.getOrDefault("userIp")
  valid_581486 = validateParameter(valid_581486, JString, required = false,
                                 default = nil)
  if valid_581486 != nil:
    section.add "userIp", valid_581486
  var valid_581487 = query.getOrDefault("key")
  valid_581487 = validateParameter(valid_581487, JString, required = false,
                                 default = nil)
  if valid_581487 != nil:
    section.add "key", valid_581487
  var valid_581488 = query.getOrDefault("prettyPrint")
  valid_581488 = validateParameter(valid_581488, JBool, required = false,
                                 default = newJBool(true))
  if valid_581488 != nil:
    section.add "prettyPrint", valid_581488
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581489: Call_DfareportingCreativesGet_581477; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one creative by ID.
  ## 
  let valid = call_581489.validator(path, query, header, formData, body)
  let scheme = call_581489.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581489.url(scheme.get, call_581489.host, call_581489.base,
                         call_581489.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581489, url, valid)

proc call*(call_581490: Call_DfareportingCreativesGet_581477; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativesGet
  ## Gets one creative by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581491 = newJObject()
  var query_581492 = newJObject()
  add(path_581491, "profileId", newJString(profileId))
  add(query_581492, "fields", newJString(fields))
  add(query_581492, "quotaUser", newJString(quotaUser))
  add(query_581492, "alt", newJString(alt))
  add(query_581492, "oauth_token", newJString(oauthToken))
  add(query_581492, "userIp", newJString(userIp))
  add(path_581491, "id", newJString(id))
  add(query_581492, "key", newJString(key))
  add(query_581492, "prettyPrint", newJBool(prettyPrint))
  result = call_581490.call(path_581491, query_581492, nil, nil, nil)

var dfareportingCreativesGet* = Call_DfareportingCreativesGet_581477(
    name: "dfareportingCreativesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives/{id}",
    validator: validate_DfareportingCreativesGet_581478,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesGet_581479,
    schemes: {Scheme.Https})
type
  Call_DfareportingDimensionValuesQuery_581493 = ref object of OpenApiRestCall_579437
proc url_DfareportingDimensionValuesQuery_581495(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dimensionvalues/query")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDimensionValuesQuery_581494(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves list of report dimension values for a list of filters.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581496 = path.getOrDefault("profileId")
  valid_581496 = validateParameter(valid_581496, JString, required = true,
                                 default = nil)
  if valid_581496 != nil:
    section.add "profileId", valid_581496
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581497 = query.getOrDefault("fields")
  valid_581497 = validateParameter(valid_581497, JString, required = false,
                                 default = nil)
  if valid_581497 != nil:
    section.add "fields", valid_581497
  var valid_581498 = query.getOrDefault("pageToken")
  valid_581498 = validateParameter(valid_581498, JString, required = false,
                                 default = nil)
  if valid_581498 != nil:
    section.add "pageToken", valid_581498
  var valid_581499 = query.getOrDefault("quotaUser")
  valid_581499 = validateParameter(valid_581499, JString, required = false,
                                 default = nil)
  if valid_581499 != nil:
    section.add "quotaUser", valid_581499
  var valid_581500 = query.getOrDefault("alt")
  valid_581500 = validateParameter(valid_581500, JString, required = false,
                                 default = newJString("json"))
  if valid_581500 != nil:
    section.add "alt", valid_581500
  var valid_581501 = query.getOrDefault("oauth_token")
  valid_581501 = validateParameter(valid_581501, JString, required = false,
                                 default = nil)
  if valid_581501 != nil:
    section.add "oauth_token", valid_581501
  var valid_581502 = query.getOrDefault("userIp")
  valid_581502 = validateParameter(valid_581502, JString, required = false,
                                 default = nil)
  if valid_581502 != nil:
    section.add "userIp", valid_581502
  var valid_581503 = query.getOrDefault("maxResults")
  valid_581503 = validateParameter(valid_581503, JInt, required = false,
                                 default = newJInt(100))
  if valid_581503 != nil:
    section.add "maxResults", valid_581503
  var valid_581504 = query.getOrDefault("key")
  valid_581504 = validateParameter(valid_581504, JString, required = false,
                                 default = nil)
  if valid_581504 != nil:
    section.add "key", valid_581504
  var valid_581505 = query.getOrDefault("prettyPrint")
  valid_581505 = validateParameter(valid_581505, JBool, required = false,
                                 default = newJBool(true))
  if valid_581505 != nil:
    section.add "prettyPrint", valid_581505
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581507: Call_DfareportingDimensionValuesQuery_581493;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves list of report dimension values for a list of filters.
  ## 
  let valid = call_581507.validator(path, query, header, formData, body)
  let scheme = call_581507.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581507.url(scheme.get, call_581507.host, call_581507.base,
                         call_581507.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581507, url, valid)

proc call*(call_581508: Call_DfareportingDimensionValuesQuery_581493;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; maxResults: int = 100; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingDimensionValuesQuery
  ## Retrieves list of report dimension values for a list of filters.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581509 = newJObject()
  var query_581510 = newJObject()
  var body_581511 = newJObject()
  add(path_581509, "profileId", newJString(profileId))
  add(query_581510, "fields", newJString(fields))
  add(query_581510, "pageToken", newJString(pageToken))
  add(query_581510, "quotaUser", newJString(quotaUser))
  add(query_581510, "alt", newJString(alt))
  add(query_581510, "oauth_token", newJString(oauthToken))
  add(query_581510, "userIp", newJString(userIp))
  add(query_581510, "maxResults", newJInt(maxResults))
  add(query_581510, "key", newJString(key))
  if body != nil:
    body_581511 = body
  add(query_581510, "prettyPrint", newJBool(prettyPrint))
  result = call_581508.call(path_581509, query_581510, nil, nil, body_581511)

var dfareportingDimensionValuesQuery* = Call_DfareportingDimensionValuesQuery_581493(
    name: "dfareportingDimensionValuesQuery", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dimensionvalues/query",
    validator: validate_DfareportingDimensionValuesQuery_581494,
    base: "/dfareporting/v2.7", url: url_DfareportingDimensionValuesQuery_581495,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySiteContactsList_581512 = ref object of OpenApiRestCall_579437
proc url_DfareportingDirectorySiteContactsList_581514(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySiteContacts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySiteContactsList_581513(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of directory site contacts, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581515 = path.getOrDefault("profileId")
  valid_581515 = validateParameter(valid_581515, JString, required = true,
                                 default = nil)
  if valid_581515 != nil:
    section.add "profileId", valid_581515
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "directory site contact*2015" will return objects with names like "directory site contact June 2015", "directory site contact April 2015", or simply "directory site contact 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site contact" will match objects with name "my directory site contact", "directory site contact 2015", or simply "directory site contact".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only directory site contacts with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only directory site contacts with these directory site IDs. This is a required field.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581516 = query.getOrDefault("fields")
  valid_581516 = validateParameter(valid_581516, JString, required = false,
                                 default = nil)
  if valid_581516 != nil:
    section.add "fields", valid_581516
  var valid_581517 = query.getOrDefault("pageToken")
  valid_581517 = validateParameter(valid_581517, JString, required = false,
                                 default = nil)
  if valid_581517 != nil:
    section.add "pageToken", valid_581517
  var valid_581518 = query.getOrDefault("quotaUser")
  valid_581518 = validateParameter(valid_581518, JString, required = false,
                                 default = nil)
  if valid_581518 != nil:
    section.add "quotaUser", valid_581518
  var valid_581519 = query.getOrDefault("sortField")
  valid_581519 = validateParameter(valid_581519, JString, required = false,
                                 default = newJString("ID"))
  if valid_581519 != nil:
    section.add "sortField", valid_581519
  var valid_581520 = query.getOrDefault("alt")
  valid_581520 = validateParameter(valid_581520, JString, required = false,
                                 default = newJString("json"))
  if valid_581520 != nil:
    section.add "alt", valid_581520
  var valid_581521 = query.getOrDefault("searchString")
  valid_581521 = validateParameter(valid_581521, JString, required = false,
                                 default = nil)
  if valid_581521 != nil:
    section.add "searchString", valid_581521
  var valid_581522 = query.getOrDefault("oauth_token")
  valid_581522 = validateParameter(valid_581522, JString, required = false,
                                 default = nil)
  if valid_581522 != nil:
    section.add "oauth_token", valid_581522
  var valid_581523 = query.getOrDefault("userIp")
  valid_581523 = validateParameter(valid_581523, JString, required = false,
                                 default = nil)
  if valid_581523 != nil:
    section.add "userIp", valid_581523
  var valid_581524 = query.getOrDefault("maxResults")
  valid_581524 = validateParameter(valid_581524, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581524 != nil:
    section.add "maxResults", valid_581524
  var valid_581525 = query.getOrDefault("ids")
  valid_581525 = validateParameter(valid_581525, JArray, required = false,
                                 default = nil)
  if valid_581525 != nil:
    section.add "ids", valid_581525
  var valid_581526 = query.getOrDefault("key")
  valid_581526 = validateParameter(valid_581526, JString, required = false,
                                 default = nil)
  if valid_581526 != nil:
    section.add "key", valid_581526
  var valid_581527 = query.getOrDefault("sortOrder")
  valid_581527 = validateParameter(valid_581527, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581527 != nil:
    section.add "sortOrder", valid_581527
  var valid_581528 = query.getOrDefault("directorySiteIds")
  valid_581528 = validateParameter(valid_581528, JArray, required = false,
                                 default = nil)
  if valid_581528 != nil:
    section.add "directorySiteIds", valid_581528
  var valid_581529 = query.getOrDefault("prettyPrint")
  valid_581529 = validateParameter(valid_581529, JBool, required = false,
                                 default = newJBool(true))
  if valid_581529 != nil:
    section.add "prettyPrint", valid_581529
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581530: Call_DfareportingDirectorySiteContactsList_581512;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of directory site contacts, possibly filtered. This method supports paging.
  ## 
  let valid = call_581530.validator(path, query, header, formData, body)
  let scheme = call_581530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581530.url(scheme.get, call_581530.host, call_581530.base,
                         call_581530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581530, url, valid)

proc call*(call_581531: Call_DfareportingDirectorySiteContactsList_581512;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; directorySiteIds: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySiteContactsList
  ## Retrieves a list of directory site contacts, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "directory site contact*2015" will return objects with names like "directory site contact June 2015", "directory site contact April 2015", or simply "directory site contact 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site contact" will match objects with name "my directory site contact", "directory site contact 2015", or simply "directory site contact".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only directory site contacts with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only directory site contacts with these directory site IDs. This is a required field.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581532 = newJObject()
  var query_581533 = newJObject()
  add(path_581532, "profileId", newJString(profileId))
  add(query_581533, "fields", newJString(fields))
  add(query_581533, "pageToken", newJString(pageToken))
  add(query_581533, "quotaUser", newJString(quotaUser))
  add(query_581533, "sortField", newJString(sortField))
  add(query_581533, "alt", newJString(alt))
  add(query_581533, "searchString", newJString(searchString))
  add(query_581533, "oauth_token", newJString(oauthToken))
  add(query_581533, "userIp", newJString(userIp))
  add(query_581533, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_581533.add "ids", ids
  add(query_581533, "key", newJString(key))
  add(query_581533, "sortOrder", newJString(sortOrder))
  if directorySiteIds != nil:
    query_581533.add "directorySiteIds", directorySiteIds
  add(query_581533, "prettyPrint", newJBool(prettyPrint))
  result = call_581531.call(path_581532, query_581533, nil, nil, nil)

var dfareportingDirectorySiteContactsList* = Call_DfareportingDirectorySiteContactsList_581512(
    name: "dfareportingDirectorySiteContactsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/directorySiteContacts",
    validator: validate_DfareportingDirectorySiteContactsList_581513,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySiteContactsList_581514,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySiteContactsGet_581534 = ref object of OpenApiRestCall_579437
proc url_DfareportingDirectorySiteContactsGet_581536(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySiteContacts/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySiteContactsGet_581535(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one directory site contact by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Directory site contact ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581537 = path.getOrDefault("profileId")
  valid_581537 = validateParameter(valid_581537, JString, required = true,
                                 default = nil)
  if valid_581537 != nil:
    section.add "profileId", valid_581537
  var valid_581538 = path.getOrDefault("id")
  valid_581538 = validateParameter(valid_581538, JString, required = true,
                                 default = nil)
  if valid_581538 != nil:
    section.add "id", valid_581538
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581539 = query.getOrDefault("fields")
  valid_581539 = validateParameter(valid_581539, JString, required = false,
                                 default = nil)
  if valid_581539 != nil:
    section.add "fields", valid_581539
  var valid_581540 = query.getOrDefault("quotaUser")
  valid_581540 = validateParameter(valid_581540, JString, required = false,
                                 default = nil)
  if valid_581540 != nil:
    section.add "quotaUser", valid_581540
  var valid_581541 = query.getOrDefault("alt")
  valid_581541 = validateParameter(valid_581541, JString, required = false,
                                 default = newJString("json"))
  if valid_581541 != nil:
    section.add "alt", valid_581541
  var valid_581542 = query.getOrDefault("oauth_token")
  valid_581542 = validateParameter(valid_581542, JString, required = false,
                                 default = nil)
  if valid_581542 != nil:
    section.add "oauth_token", valid_581542
  var valid_581543 = query.getOrDefault("userIp")
  valid_581543 = validateParameter(valid_581543, JString, required = false,
                                 default = nil)
  if valid_581543 != nil:
    section.add "userIp", valid_581543
  var valid_581544 = query.getOrDefault("key")
  valid_581544 = validateParameter(valid_581544, JString, required = false,
                                 default = nil)
  if valid_581544 != nil:
    section.add "key", valid_581544
  var valid_581545 = query.getOrDefault("prettyPrint")
  valid_581545 = validateParameter(valid_581545, JBool, required = false,
                                 default = newJBool(true))
  if valid_581545 != nil:
    section.add "prettyPrint", valid_581545
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581546: Call_DfareportingDirectorySiteContactsGet_581534;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one directory site contact by ID.
  ## 
  let valid = call_581546.validator(path, query, header, formData, body)
  let scheme = call_581546.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581546.url(scheme.get, call_581546.host, call_581546.base,
                         call_581546.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581546, url, valid)

proc call*(call_581547: Call_DfareportingDirectorySiteContactsGet_581534;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySiteContactsGet
  ## Gets one directory site contact by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Directory site contact ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581548 = newJObject()
  var query_581549 = newJObject()
  add(path_581548, "profileId", newJString(profileId))
  add(query_581549, "fields", newJString(fields))
  add(query_581549, "quotaUser", newJString(quotaUser))
  add(query_581549, "alt", newJString(alt))
  add(query_581549, "oauth_token", newJString(oauthToken))
  add(query_581549, "userIp", newJString(userIp))
  add(path_581548, "id", newJString(id))
  add(query_581549, "key", newJString(key))
  add(query_581549, "prettyPrint", newJBool(prettyPrint))
  result = call_581547.call(path_581548, query_581549, nil, nil, nil)

var dfareportingDirectorySiteContactsGet* = Call_DfareportingDirectorySiteContactsGet_581534(
    name: "dfareportingDirectorySiteContactsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/directorySiteContacts/{id}",
    validator: validate_DfareportingDirectorySiteContactsGet_581535,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySiteContactsGet_581536,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySitesInsert_581578 = ref object of OpenApiRestCall_579437
proc url_DfareportingDirectorySitesInsert_581580(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySitesInsert_581579(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new directory site.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581581 = path.getOrDefault("profileId")
  valid_581581 = validateParameter(valid_581581, JString, required = true,
                                 default = nil)
  if valid_581581 != nil:
    section.add "profileId", valid_581581
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581582 = query.getOrDefault("fields")
  valid_581582 = validateParameter(valid_581582, JString, required = false,
                                 default = nil)
  if valid_581582 != nil:
    section.add "fields", valid_581582
  var valid_581583 = query.getOrDefault("quotaUser")
  valid_581583 = validateParameter(valid_581583, JString, required = false,
                                 default = nil)
  if valid_581583 != nil:
    section.add "quotaUser", valid_581583
  var valid_581584 = query.getOrDefault("alt")
  valid_581584 = validateParameter(valid_581584, JString, required = false,
                                 default = newJString("json"))
  if valid_581584 != nil:
    section.add "alt", valid_581584
  var valid_581585 = query.getOrDefault("oauth_token")
  valid_581585 = validateParameter(valid_581585, JString, required = false,
                                 default = nil)
  if valid_581585 != nil:
    section.add "oauth_token", valid_581585
  var valid_581586 = query.getOrDefault("userIp")
  valid_581586 = validateParameter(valid_581586, JString, required = false,
                                 default = nil)
  if valid_581586 != nil:
    section.add "userIp", valid_581586
  var valid_581587 = query.getOrDefault("key")
  valid_581587 = validateParameter(valid_581587, JString, required = false,
                                 default = nil)
  if valid_581587 != nil:
    section.add "key", valid_581587
  var valid_581588 = query.getOrDefault("prettyPrint")
  valid_581588 = validateParameter(valid_581588, JBool, required = false,
                                 default = newJBool(true))
  if valid_581588 != nil:
    section.add "prettyPrint", valid_581588
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581590: Call_DfareportingDirectorySitesInsert_581578;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new directory site.
  ## 
  let valid = call_581590.validator(path, query, header, formData, body)
  let scheme = call_581590.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581590.url(scheme.get, call_581590.host, call_581590.base,
                         call_581590.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581590, url, valid)

proc call*(call_581591: Call_DfareportingDirectorySitesInsert_581578;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySitesInsert
  ## Inserts a new directory site.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581592 = newJObject()
  var query_581593 = newJObject()
  var body_581594 = newJObject()
  add(path_581592, "profileId", newJString(profileId))
  add(query_581593, "fields", newJString(fields))
  add(query_581593, "quotaUser", newJString(quotaUser))
  add(query_581593, "alt", newJString(alt))
  add(query_581593, "oauth_token", newJString(oauthToken))
  add(query_581593, "userIp", newJString(userIp))
  add(query_581593, "key", newJString(key))
  if body != nil:
    body_581594 = body
  add(query_581593, "prettyPrint", newJBool(prettyPrint))
  result = call_581591.call(path_581592, query_581593, nil, nil, body_581594)

var dfareportingDirectorySitesInsert* = Call_DfareportingDirectorySitesInsert_581578(
    name: "dfareportingDirectorySitesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/directorySites",
    validator: validate_DfareportingDirectorySitesInsert_581579,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySitesInsert_581580,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySitesList_581550 = ref object of OpenApiRestCall_579437
proc url_DfareportingDirectorySitesList_581552(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySitesList_581551(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of directory sites, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581553 = path.getOrDefault("profileId")
  valid_581553 = validateParameter(valid_581553, JString, required = true,
                                 default = nil)
  if valid_581553 != nil:
    section.add "profileId", valid_581553
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or URL. Wildcards (*) are allowed. For example, "directory site*2015" will return objects with names like "directory site June 2015", "directory site April 2015", or simply "directory site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site" will match objects with name "my directory site", "directory site 2015" or simply, "directory site".
  ##   countryId: JString
  ##            : Select only directory sites with this country ID.
  ##   active: JBool
  ##         : Select only active directory sites. Leave blank to retrieve both active and inactive directory sites.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   dfp_network_code: JString
  ##                   : Select only directory sites with this DFP network code.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only directory sites with these IDs.
  ##   parentId: JString
  ##           : Select only directory sites with this parent ID.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsInterstitialPlacements: JBool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   acceptsInStreamVideoPlacements: JBool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   acceptsPublisherPaidPlacements: JBool
  ##                                 : Select only directory sites that accept publisher paid placements. This field can be left blank.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581554 = query.getOrDefault("fields")
  valid_581554 = validateParameter(valid_581554, JString, required = false,
                                 default = nil)
  if valid_581554 != nil:
    section.add "fields", valid_581554
  var valid_581555 = query.getOrDefault("pageToken")
  valid_581555 = validateParameter(valid_581555, JString, required = false,
                                 default = nil)
  if valid_581555 != nil:
    section.add "pageToken", valid_581555
  var valid_581556 = query.getOrDefault("quotaUser")
  valid_581556 = validateParameter(valid_581556, JString, required = false,
                                 default = nil)
  if valid_581556 != nil:
    section.add "quotaUser", valid_581556
  var valid_581557 = query.getOrDefault("sortField")
  valid_581557 = validateParameter(valid_581557, JString, required = false,
                                 default = newJString("ID"))
  if valid_581557 != nil:
    section.add "sortField", valid_581557
  var valid_581558 = query.getOrDefault("alt")
  valid_581558 = validateParameter(valid_581558, JString, required = false,
                                 default = newJString("json"))
  if valid_581558 != nil:
    section.add "alt", valid_581558
  var valid_581559 = query.getOrDefault("searchString")
  valid_581559 = validateParameter(valid_581559, JString, required = false,
                                 default = nil)
  if valid_581559 != nil:
    section.add "searchString", valid_581559
  var valid_581560 = query.getOrDefault("countryId")
  valid_581560 = validateParameter(valid_581560, JString, required = false,
                                 default = nil)
  if valid_581560 != nil:
    section.add "countryId", valid_581560
  var valid_581561 = query.getOrDefault("active")
  valid_581561 = validateParameter(valid_581561, JBool, required = false, default = nil)
  if valid_581561 != nil:
    section.add "active", valid_581561
  var valid_581562 = query.getOrDefault("oauth_token")
  valid_581562 = validateParameter(valid_581562, JString, required = false,
                                 default = nil)
  if valid_581562 != nil:
    section.add "oauth_token", valid_581562
  var valid_581563 = query.getOrDefault("userIp")
  valid_581563 = validateParameter(valid_581563, JString, required = false,
                                 default = nil)
  if valid_581563 != nil:
    section.add "userIp", valid_581563
  var valid_581564 = query.getOrDefault("dfp_network_code")
  valid_581564 = validateParameter(valid_581564, JString, required = false,
                                 default = nil)
  if valid_581564 != nil:
    section.add "dfp_network_code", valid_581564
  var valid_581565 = query.getOrDefault("maxResults")
  valid_581565 = validateParameter(valid_581565, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581565 != nil:
    section.add "maxResults", valid_581565
  var valid_581566 = query.getOrDefault("ids")
  valid_581566 = validateParameter(valid_581566, JArray, required = false,
                                 default = nil)
  if valid_581566 != nil:
    section.add "ids", valid_581566
  var valid_581567 = query.getOrDefault("parentId")
  valid_581567 = validateParameter(valid_581567, JString, required = false,
                                 default = nil)
  if valid_581567 != nil:
    section.add "parentId", valid_581567
  var valid_581568 = query.getOrDefault("key")
  valid_581568 = validateParameter(valid_581568, JString, required = false,
                                 default = nil)
  if valid_581568 != nil:
    section.add "key", valid_581568
  var valid_581569 = query.getOrDefault("acceptsInterstitialPlacements")
  valid_581569 = validateParameter(valid_581569, JBool, required = false, default = nil)
  if valid_581569 != nil:
    section.add "acceptsInterstitialPlacements", valid_581569
  var valid_581570 = query.getOrDefault("acceptsInStreamVideoPlacements")
  valid_581570 = validateParameter(valid_581570, JBool, required = false, default = nil)
  if valid_581570 != nil:
    section.add "acceptsInStreamVideoPlacements", valid_581570
  var valid_581571 = query.getOrDefault("sortOrder")
  valid_581571 = validateParameter(valid_581571, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581571 != nil:
    section.add "sortOrder", valid_581571
  var valid_581572 = query.getOrDefault("acceptsPublisherPaidPlacements")
  valid_581572 = validateParameter(valid_581572, JBool, required = false, default = nil)
  if valid_581572 != nil:
    section.add "acceptsPublisherPaidPlacements", valid_581572
  var valid_581573 = query.getOrDefault("prettyPrint")
  valid_581573 = validateParameter(valid_581573, JBool, required = false,
                                 default = newJBool(true))
  if valid_581573 != nil:
    section.add "prettyPrint", valid_581573
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581574: Call_DfareportingDirectorySitesList_581550; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of directory sites, possibly filtered. This method supports paging.
  ## 
  let valid = call_581574.validator(path, query, header, formData, body)
  let scheme = call_581574.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581574.url(scheme.get, call_581574.host, call_581574.base,
                         call_581574.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581574, url, valid)

proc call*(call_581575: Call_DfareportingDirectorySitesList_581550;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; countryId: string = ""; active: bool = false;
          oauthToken: string = ""; userIp: string = ""; dfpNetworkCode: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; parentId: string = "";
          key: string = ""; acceptsInterstitialPlacements: bool = false;
          acceptsInStreamVideoPlacements: bool = false;
          sortOrder: string = "ASCENDING";
          acceptsPublisherPaidPlacements: bool = false; prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySitesList
  ## Retrieves a list of directory sites, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or URL. Wildcards (*) are allowed. For example, "directory site*2015" will return objects with names like "directory site June 2015", "directory site April 2015", or simply "directory site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site" will match objects with name "my directory site", "directory site 2015" or simply, "directory site".
  ##   countryId: string
  ##            : Select only directory sites with this country ID.
  ##   active: bool
  ##         : Select only active directory sites. Leave blank to retrieve both active and inactive directory sites.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   dfpNetworkCode: string
  ##                 : Select only directory sites with this DFP network code.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only directory sites with these IDs.
  ##   parentId: string
  ##           : Select only directory sites with this parent ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsInterstitialPlacements: bool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   acceptsInStreamVideoPlacements: bool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   acceptsPublisherPaidPlacements: bool
  ##                                 : Select only directory sites that accept publisher paid placements. This field can be left blank.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581576 = newJObject()
  var query_581577 = newJObject()
  add(path_581576, "profileId", newJString(profileId))
  add(query_581577, "fields", newJString(fields))
  add(query_581577, "pageToken", newJString(pageToken))
  add(query_581577, "quotaUser", newJString(quotaUser))
  add(query_581577, "sortField", newJString(sortField))
  add(query_581577, "alt", newJString(alt))
  add(query_581577, "searchString", newJString(searchString))
  add(query_581577, "countryId", newJString(countryId))
  add(query_581577, "active", newJBool(active))
  add(query_581577, "oauth_token", newJString(oauthToken))
  add(query_581577, "userIp", newJString(userIp))
  add(query_581577, "dfp_network_code", newJString(dfpNetworkCode))
  add(query_581577, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_581577.add "ids", ids
  add(query_581577, "parentId", newJString(parentId))
  add(query_581577, "key", newJString(key))
  add(query_581577, "acceptsInterstitialPlacements",
      newJBool(acceptsInterstitialPlacements))
  add(query_581577, "acceptsInStreamVideoPlacements",
      newJBool(acceptsInStreamVideoPlacements))
  add(query_581577, "sortOrder", newJString(sortOrder))
  add(query_581577, "acceptsPublisherPaidPlacements",
      newJBool(acceptsPublisherPaidPlacements))
  add(query_581577, "prettyPrint", newJBool(prettyPrint))
  result = call_581575.call(path_581576, query_581577, nil, nil, nil)

var dfareportingDirectorySitesList* = Call_DfareportingDirectorySitesList_581550(
    name: "dfareportingDirectorySitesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/directorySites",
    validator: validate_DfareportingDirectorySitesList_581551,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySitesList_581552,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySitesGet_581595 = ref object of OpenApiRestCall_579437
proc url_DfareportingDirectorySitesGet_581597(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySites/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySitesGet_581596(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one directory site by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Directory site ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581598 = path.getOrDefault("profileId")
  valid_581598 = validateParameter(valid_581598, JString, required = true,
                                 default = nil)
  if valid_581598 != nil:
    section.add "profileId", valid_581598
  var valid_581599 = path.getOrDefault("id")
  valid_581599 = validateParameter(valid_581599, JString, required = true,
                                 default = nil)
  if valid_581599 != nil:
    section.add "id", valid_581599
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581600 = query.getOrDefault("fields")
  valid_581600 = validateParameter(valid_581600, JString, required = false,
                                 default = nil)
  if valid_581600 != nil:
    section.add "fields", valid_581600
  var valid_581601 = query.getOrDefault("quotaUser")
  valid_581601 = validateParameter(valid_581601, JString, required = false,
                                 default = nil)
  if valid_581601 != nil:
    section.add "quotaUser", valid_581601
  var valid_581602 = query.getOrDefault("alt")
  valid_581602 = validateParameter(valid_581602, JString, required = false,
                                 default = newJString("json"))
  if valid_581602 != nil:
    section.add "alt", valid_581602
  var valid_581603 = query.getOrDefault("oauth_token")
  valid_581603 = validateParameter(valid_581603, JString, required = false,
                                 default = nil)
  if valid_581603 != nil:
    section.add "oauth_token", valid_581603
  var valid_581604 = query.getOrDefault("userIp")
  valid_581604 = validateParameter(valid_581604, JString, required = false,
                                 default = nil)
  if valid_581604 != nil:
    section.add "userIp", valid_581604
  var valid_581605 = query.getOrDefault("key")
  valid_581605 = validateParameter(valid_581605, JString, required = false,
                                 default = nil)
  if valid_581605 != nil:
    section.add "key", valid_581605
  var valid_581606 = query.getOrDefault("prettyPrint")
  valid_581606 = validateParameter(valid_581606, JBool, required = false,
                                 default = newJBool(true))
  if valid_581606 != nil:
    section.add "prettyPrint", valid_581606
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581607: Call_DfareportingDirectorySitesGet_581595; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one directory site by ID.
  ## 
  let valid = call_581607.validator(path, query, header, formData, body)
  let scheme = call_581607.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581607.url(scheme.get, call_581607.host, call_581607.base,
                         call_581607.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581607, url, valid)

proc call*(call_581608: Call_DfareportingDirectorySitesGet_581595;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySitesGet
  ## Gets one directory site by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Directory site ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581609 = newJObject()
  var query_581610 = newJObject()
  add(path_581609, "profileId", newJString(profileId))
  add(query_581610, "fields", newJString(fields))
  add(query_581610, "quotaUser", newJString(quotaUser))
  add(query_581610, "alt", newJString(alt))
  add(query_581610, "oauth_token", newJString(oauthToken))
  add(query_581610, "userIp", newJString(userIp))
  add(path_581609, "id", newJString(id))
  add(query_581610, "key", newJString(key))
  add(query_581610, "prettyPrint", newJBool(prettyPrint))
  result = call_581608.call(path_581609, query_581610, nil, nil, nil)

var dfareportingDirectorySitesGet* = Call_DfareportingDirectorySitesGet_581595(
    name: "dfareportingDirectorySitesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/directorySites/{id}",
    validator: validate_DfareportingDirectorySitesGet_581596,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySitesGet_581597,
    schemes: {Scheme.Https})
type
  Call_DfareportingDynamicTargetingKeysInsert_581630 = ref object of OpenApiRestCall_579437
proc url_DfareportingDynamicTargetingKeysInsert_581632(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dynamicTargetingKeys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDynamicTargetingKeysInsert_581631(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new dynamic targeting key. Keys must be created at the advertiser level before being assigned to the advertiser's ads, creatives, or placements. There is a maximum of 1000 keys per advertiser, out of which a maximum of 20 keys can be assigned per ad, creative, or placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581633 = path.getOrDefault("profileId")
  valid_581633 = validateParameter(valid_581633, JString, required = true,
                                 default = nil)
  if valid_581633 != nil:
    section.add "profileId", valid_581633
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581634 = query.getOrDefault("fields")
  valid_581634 = validateParameter(valid_581634, JString, required = false,
                                 default = nil)
  if valid_581634 != nil:
    section.add "fields", valid_581634
  var valid_581635 = query.getOrDefault("quotaUser")
  valid_581635 = validateParameter(valid_581635, JString, required = false,
                                 default = nil)
  if valid_581635 != nil:
    section.add "quotaUser", valid_581635
  var valid_581636 = query.getOrDefault("alt")
  valid_581636 = validateParameter(valid_581636, JString, required = false,
                                 default = newJString("json"))
  if valid_581636 != nil:
    section.add "alt", valid_581636
  var valid_581637 = query.getOrDefault("oauth_token")
  valid_581637 = validateParameter(valid_581637, JString, required = false,
                                 default = nil)
  if valid_581637 != nil:
    section.add "oauth_token", valid_581637
  var valid_581638 = query.getOrDefault("userIp")
  valid_581638 = validateParameter(valid_581638, JString, required = false,
                                 default = nil)
  if valid_581638 != nil:
    section.add "userIp", valid_581638
  var valid_581639 = query.getOrDefault("key")
  valid_581639 = validateParameter(valid_581639, JString, required = false,
                                 default = nil)
  if valid_581639 != nil:
    section.add "key", valid_581639
  var valid_581640 = query.getOrDefault("prettyPrint")
  valid_581640 = validateParameter(valid_581640, JBool, required = false,
                                 default = newJBool(true))
  if valid_581640 != nil:
    section.add "prettyPrint", valid_581640
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581642: Call_DfareportingDynamicTargetingKeysInsert_581630;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new dynamic targeting key. Keys must be created at the advertiser level before being assigned to the advertiser's ads, creatives, or placements. There is a maximum of 1000 keys per advertiser, out of which a maximum of 20 keys can be assigned per ad, creative, or placement.
  ## 
  let valid = call_581642.validator(path, query, header, formData, body)
  let scheme = call_581642.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581642.url(scheme.get, call_581642.host, call_581642.base,
                         call_581642.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581642, url, valid)

proc call*(call_581643: Call_DfareportingDynamicTargetingKeysInsert_581630;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingDynamicTargetingKeysInsert
  ## Inserts a new dynamic targeting key. Keys must be created at the advertiser level before being assigned to the advertiser's ads, creatives, or placements. There is a maximum of 1000 keys per advertiser, out of which a maximum of 20 keys can be assigned per ad, creative, or placement.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581644 = newJObject()
  var query_581645 = newJObject()
  var body_581646 = newJObject()
  add(path_581644, "profileId", newJString(profileId))
  add(query_581645, "fields", newJString(fields))
  add(query_581645, "quotaUser", newJString(quotaUser))
  add(query_581645, "alt", newJString(alt))
  add(query_581645, "oauth_token", newJString(oauthToken))
  add(query_581645, "userIp", newJString(userIp))
  add(query_581645, "key", newJString(key))
  if body != nil:
    body_581646 = body
  add(query_581645, "prettyPrint", newJBool(prettyPrint))
  result = call_581643.call(path_581644, query_581645, nil, nil, body_581646)

var dfareportingDynamicTargetingKeysInsert* = Call_DfareportingDynamicTargetingKeysInsert_581630(
    name: "dfareportingDynamicTargetingKeysInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dynamicTargetingKeys",
    validator: validate_DfareportingDynamicTargetingKeysInsert_581631,
    base: "/dfareporting/v2.7", url: url_DfareportingDynamicTargetingKeysInsert_581632,
    schemes: {Scheme.Https})
type
  Call_DfareportingDynamicTargetingKeysList_581611 = ref object of OpenApiRestCall_579437
proc url_DfareportingDynamicTargetingKeysList_581613(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dynamicTargetingKeys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDynamicTargetingKeysList_581612(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of dynamic targeting keys.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581614 = path.getOrDefault("profileId")
  valid_581614 = validateParameter(valid_581614, JString, required = true,
                                 default = nil)
  if valid_581614 != nil:
    section.add "profileId", valid_581614
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   advertiserId: JString
  ##               : Select only dynamic targeting keys whose object has this advertiser ID.
  ##   names: JArray
  ##        : Select only dynamic targeting keys exactly matching these names.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   objectId: JString
  ##           : Select only dynamic targeting keys with this object ID.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   objectType: JString
  ##             : Select only dynamic targeting keys with this object type.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581615 = query.getOrDefault("fields")
  valid_581615 = validateParameter(valid_581615, JString, required = false,
                                 default = nil)
  if valid_581615 != nil:
    section.add "fields", valid_581615
  var valid_581616 = query.getOrDefault("quotaUser")
  valid_581616 = validateParameter(valid_581616, JString, required = false,
                                 default = nil)
  if valid_581616 != nil:
    section.add "quotaUser", valid_581616
  var valid_581617 = query.getOrDefault("alt")
  valid_581617 = validateParameter(valid_581617, JString, required = false,
                                 default = newJString("json"))
  if valid_581617 != nil:
    section.add "alt", valid_581617
  var valid_581618 = query.getOrDefault("advertiserId")
  valid_581618 = validateParameter(valid_581618, JString, required = false,
                                 default = nil)
  if valid_581618 != nil:
    section.add "advertiserId", valid_581618
  var valid_581619 = query.getOrDefault("names")
  valid_581619 = validateParameter(valid_581619, JArray, required = false,
                                 default = nil)
  if valid_581619 != nil:
    section.add "names", valid_581619
  var valid_581620 = query.getOrDefault("oauth_token")
  valid_581620 = validateParameter(valid_581620, JString, required = false,
                                 default = nil)
  if valid_581620 != nil:
    section.add "oauth_token", valid_581620
  var valid_581621 = query.getOrDefault("objectId")
  valid_581621 = validateParameter(valid_581621, JString, required = false,
                                 default = nil)
  if valid_581621 != nil:
    section.add "objectId", valid_581621
  var valid_581622 = query.getOrDefault("userIp")
  valid_581622 = validateParameter(valid_581622, JString, required = false,
                                 default = nil)
  if valid_581622 != nil:
    section.add "userIp", valid_581622
  var valid_581623 = query.getOrDefault("objectType")
  valid_581623 = validateParameter(valid_581623, JString, required = false,
                                 default = newJString("OBJECT_AD"))
  if valid_581623 != nil:
    section.add "objectType", valid_581623
  var valid_581624 = query.getOrDefault("key")
  valid_581624 = validateParameter(valid_581624, JString, required = false,
                                 default = nil)
  if valid_581624 != nil:
    section.add "key", valid_581624
  var valid_581625 = query.getOrDefault("prettyPrint")
  valid_581625 = validateParameter(valid_581625, JBool, required = false,
                                 default = newJBool(true))
  if valid_581625 != nil:
    section.add "prettyPrint", valid_581625
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581626: Call_DfareportingDynamicTargetingKeysList_581611;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of dynamic targeting keys.
  ## 
  let valid = call_581626.validator(path, query, header, formData, body)
  let scheme = call_581626.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581626.url(scheme.get, call_581626.host, call_581626.base,
                         call_581626.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581626, url, valid)

proc call*(call_581627: Call_DfareportingDynamicTargetingKeysList_581611;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; advertiserId: string = ""; names: JsonNode = nil;
          oauthToken: string = ""; objectId: string = ""; userIp: string = "";
          objectType: string = "OBJECT_AD"; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingDynamicTargetingKeysList
  ## Retrieves a list of dynamic targeting keys.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   advertiserId: string
  ##               : Select only dynamic targeting keys whose object has this advertiser ID.
  ##   names: JArray
  ##        : Select only dynamic targeting keys exactly matching these names.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   objectId: string
  ##           : Select only dynamic targeting keys with this object ID.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   objectType: string
  ##             : Select only dynamic targeting keys with this object type.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581628 = newJObject()
  var query_581629 = newJObject()
  add(path_581628, "profileId", newJString(profileId))
  add(query_581629, "fields", newJString(fields))
  add(query_581629, "quotaUser", newJString(quotaUser))
  add(query_581629, "alt", newJString(alt))
  add(query_581629, "advertiserId", newJString(advertiserId))
  if names != nil:
    query_581629.add "names", names
  add(query_581629, "oauth_token", newJString(oauthToken))
  add(query_581629, "objectId", newJString(objectId))
  add(query_581629, "userIp", newJString(userIp))
  add(query_581629, "objectType", newJString(objectType))
  add(query_581629, "key", newJString(key))
  add(query_581629, "prettyPrint", newJBool(prettyPrint))
  result = call_581627.call(path_581628, query_581629, nil, nil, nil)

var dfareportingDynamicTargetingKeysList* = Call_DfareportingDynamicTargetingKeysList_581611(
    name: "dfareportingDynamicTargetingKeysList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dynamicTargetingKeys",
    validator: validate_DfareportingDynamicTargetingKeysList_581612,
    base: "/dfareporting/v2.7", url: url_DfareportingDynamicTargetingKeysList_581613,
    schemes: {Scheme.Https})
type
  Call_DfareportingDynamicTargetingKeysDelete_581647 = ref object of OpenApiRestCall_579437
proc url_DfareportingDynamicTargetingKeysDelete_581649(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "objectId" in path, "`objectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dynamicTargetingKeys/"),
               (kind: VariableSegment, value: "objectId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDynamicTargetingKeysDelete_581648(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing dynamic targeting key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   objectId: JString (required)
  ##           : ID of the object of this dynamic targeting key. This is a required field.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581650 = path.getOrDefault("profileId")
  valid_581650 = validateParameter(valid_581650, JString, required = true,
                                 default = nil)
  if valid_581650 != nil:
    section.add "profileId", valid_581650
  var valid_581651 = path.getOrDefault("objectId")
  valid_581651 = validateParameter(valid_581651, JString, required = true,
                                 default = nil)
  if valid_581651 != nil:
    section.add "objectId", valid_581651
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   objectType: JString (required)
  ##             : Type of the object of this dynamic targeting key. This is a required field.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: JString (required)
  ##       : Name of this dynamic targeting key. This is a required field. Must be less than 256 characters long and cannot contain commas. All characters are converted to lowercase.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581652 = query.getOrDefault("fields")
  valid_581652 = validateParameter(valid_581652, JString, required = false,
                                 default = nil)
  if valid_581652 != nil:
    section.add "fields", valid_581652
  var valid_581653 = query.getOrDefault("quotaUser")
  valid_581653 = validateParameter(valid_581653, JString, required = false,
                                 default = nil)
  if valid_581653 != nil:
    section.add "quotaUser", valid_581653
  var valid_581654 = query.getOrDefault("alt")
  valid_581654 = validateParameter(valid_581654, JString, required = false,
                                 default = newJString("json"))
  if valid_581654 != nil:
    section.add "alt", valid_581654
  var valid_581655 = query.getOrDefault("oauth_token")
  valid_581655 = validateParameter(valid_581655, JString, required = false,
                                 default = nil)
  if valid_581655 != nil:
    section.add "oauth_token", valid_581655
  var valid_581656 = query.getOrDefault("userIp")
  valid_581656 = validateParameter(valid_581656, JString, required = false,
                                 default = nil)
  if valid_581656 != nil:
    section.add "userIp", valid_581656
  assert query != nil,
        "query argument is necessary due to required `objectType` field"
  var valid_581657 = query.getOrDefault("objectType")
  valid_581657 = validateParameter(valid_581657, JString, required = true,
                                 default = newJString("OBJECT_AD"))
  if valid_581657 != nil:
    section.add "objectType", valid_581657
  var valid_581658 = query.getOrDefault("key")
  valid_581658 = validateParameter(valid_581658, JString, required = false,
                                 default = nil)
  if valid_581658 != nil:
    section.add "key", valid_581658
  var valid_581659 = query.getOrDefault("name")
  valid_581659 = validateParameter(valid_581659, JString, required = true,
                                 default = nil)
  if valid_581659 != nil:
    section.add "name", valid_581659
  var valid_581660 = query.getOrDefault("prettyPrint")
  valid_581660 = validateParameter(valid_581660, JBool, required = false,
                                 default = newJBool(true))
  if valid_581660 != nil:
    section.add "prettyPrint", valid_581660
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581661: Call_DfareportingDynamicTargetingKeysDelete_581647;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing dynamic targeting key.
  ## 
  let valid = call_581661.validator(path, query, header, formData, body)
  let scheme = call_581661.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581661.url(scheme.get, call_581661.host, call_581661.base,
                         call_581661.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581661, url, valid)

proc call*(call_581662: Call_DfareportingDynamicTargetingKeysDelete_581647;
          profileId: string; objectId: string; name: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; objectType: string = "OBJECT_AD"; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingDynamicTargetingKeysDelete
  ## Deletes an existing dynamic targeting key.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   objectId: string (required)
  ##           : ID of the object of this dynamic targeting key. This is a required field.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   objectType: string (required)
  ##             : Type of the object of this dynamic targeting key. This is a required field.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: string (required)
  ##       : Name of this dynamic targeting key. This is a required field. Must be less than 256 characters long and cannot contain commas. All characters are converted to lowercase.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581663 = newJObject()
  var query_581664 = newJObject()
  add(path_581663, "profileId", newJString(profileId))
  add(query_581664, "fields", newJString(fields))
  add(query_581664, "quotaUser", newJString(quotaUser))
  add(query_581664, "alt", newJString(alt))
  add(path_581663, "objectId", newJString(objectId))
  add(query_581664, "oauth_token", newJString(oauthToken))
  add(query_581664, "userIp", newJString(userIp))
  add(query_581664, "objectType", newJString(objectType))
  add(query_581664, "key", newJString(key))
  add(query_581664, "name", newJString(name))
  add(query_581664, "prettyPrint", newJBool(prettyPrint))
  result = call_581662.call(path_581663, query_581664, nil, nil, nil)

var dfareportingDynamicTargetingKeysDelete* = Call_DfareportingDynamicTargetingKeysDelete_581647(
    name: "dfareportingDynamicTargetingKeysDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dynamicTargetingKeys/{objectId}",
    validator: validate_DfareportingDynamicTargetingKeysDelete_581648,
    base: "/dfareporting/v2.7", url: url_DfareportingDynamicTargetingKeysDelete_581649,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsUpdate_581690 = ref object of OpenApiRestCall_579437
proc url_DfareportingEventTagsUpdate_581692(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsUpdate_581691(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing event tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581693 = path.getOrDefault("profileId")
  valid_581693 = validateParameter(valid_581693, JString, required = true,
                                 default = nil)
  if valid_581693 != nil:
    section.add "profileId", valid_581693
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581694 = query.getOrDefault("fields")
  valid_581694 = validateParameter(valid_581694, JString, required = false,
                                 default = nil)
  if valid_581694 != nil:
    section.add "fields", valid_581694
  var valid_581695 = query.getOrDefault("quotaUser")
  valid_581695 = validateParameter(valid_581695, JString, required = false,
                                 default = nil)
  if valid_581695 != nil:
    section.add "quotaUser", valid_581695
  var valid_581696 = query.getOrDefault("alt")
  valid_581696 = validateParameter(valid_581696, JString, required = false,
                                 default = newJString("json"))
  if valid_581696 != nil:
    section.add "alt", valid_581696
  var valid_581697 = query.getOrDefault("oauth_token")
  valid_581697 = validateParameter(valid_581697, JString, required = false,
                                 default = nil)
  if valid_581697 != nil:
    section.add "oauth_token", valid_581697
  var valid_581698 = query.getOrDefault("userIp")
  valid_581698 = validateParameter(valid_581698, JString, required = false,
                                 default = nil)
  if valid_581698 != nil:
    section.add "userIp", valid_581698
  var valid_581699 = query.getOrDefault("key")
  valid_581699 = validateParameter(valid_581699, JString, required = false,
                                 default = nil)
  if valid_581699 != nil:
    section.add "key", valid_581699
  var valid_581700 = query.getOrDefault("prettyPrint")
  valid_581700 = validateParameter(valid_581700, JBool, required = false,
                                 default = newJBool(true))
  if valid_581700 != nil:
    section.add "prettyPrint", valid_581700
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581702: Call_DfareportingEventTagsUpdate_581690; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing event tag.
  ## 
  let valid = call_581702.validator(path, query, header, formData, body)
  let scheme = call_581702.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581702.url(scheme.get, call_581702.host, call_581702.base,
                         call_581702.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581702, url, valid)

proc call*(call_581703: Call_DfareportingEventTagsUpdate_581690; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsUpdate
  ## Updates an existing event tag.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581704 = newJObject()
  var query_581705 = newJObject()
  var body_581706 = newJObject()
  add(path_581704, "profileId", newJString(profileId))
  add(query_581705, "fields", newJString(fields))
  add(query_581705, "quotaUser", newJString(quotaUser))
  add(query_581705, "alt", newJString(alt))
  add(query_581705, "oauth_token", newJString(oauthToken))
  add(query_581705, "userIp", newJString(userIp))
  add(query_581705, "key", newJString(key))
  if body != nil:
    body_581706 = body
  add(query_581705, "prettyPrint", newJBool(prettyPrint))
  result = call_581703.call(path_581704, query_581705, nil, nil, body_581706)

var dfareportingEventTagsUpdate* = Call_DfareportingEventTagsUpdate_581690(
    name: "dfareportingEventTagsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsUpdate_581691,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsUpdate_581692,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsInsert_581707 = ref object of OpenApiRestCall_579437
proc url_DfareportingEventTagsInsert_581709(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsInsert_581708(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new event tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581710 = path.getOrDefault("profileId")
  valid_581710 = validateParameter(valid_581710, JString, required = true,
                                 default = nil)
  if valid_581710 != nil:
    section.add "profileId", valid_581710
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581711 = query.getOrDefault("fields")
  valid_581711 = validateParameter(valid_581711, JString, required = false,
                                 default = nil)
  if valid_581711 != nil:
    section.add "fields", valid_581711
  var valid_581712 = query.getOrDefault("quotaUser")
  valid_581712 = validateParameter(valid_581712, JString, required = false,
                                 default = nil)
  if valid_581712 != nil:
    section.add "quotaUser", valid_581712
  var valid_581713 = query.getOrDefault("alt")
  valid_581713 = validateParameter(valid_581713, JString, required = false,
                                 default = newJString("json"))
  if valid_581713 != nil:
    section.add "alt", valid_581713
  var valid_581714 = query.getOrDefault("oauth_token")
  valid_581714 = validateParameter(valid_581714, JString, required = false,
                                 default = nil)
  if valid_581714 != nil:
    section.add "oauth_token", valid_581714
  var valid_581715 = query.getOrDefault("userIp")
  valid_581715 = validateParameter(valid_581715, JString, required = false,
                                 default = nil)
  if valid_581715 != nil:
    section.add "userIp", valid_581715
  var valid_581716 = query.getOrDefault("key")
  valid_581716 = validateParameter(valid_581716, JString, required = false,
                                 default = nil)
  if valid_581716 != nil:
    section.add "key", valid_581716
  var valid_581717 = query.getOrDefault("prettyPrint")
  valid_581717 = validateParameter(valid_581717, JBool, required = false,
                                 default = newJBool(true))
  if valid_581717 != nil:
    section.add "prettyPrint", valid_581717
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581719: Call_DfareportingEventTagsInsert_581707; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new event tag.
  ## 
  let valid = call_581719.validator(path, query, header, formData, body)
  let scheme = call_581719.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581719.url(scheme.get, call_581719.host, call_581719.base,
                         call_581719.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581719, url, valid)

proc call*(call_581720: Call_DfareportingEventTagsInsert_581707; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsInsert
  ## Inserts a new event tag.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581721 = newJObject()
  var query_581722 = newJObject()
  var body_581723 = newJObject()
  add(path_581721, "profileId", newJString(profileId))
  add(query_581722, "fields", newJString(fields))
  add(query_581722, "quotaUser", newJString(quotaUser))
  add(query_581722, "alt", newJString(alt))
  add(query_581722, "oauth_token", newJString(oauthToken))
  add(query_581722, "userIp", newJString(userIp))
  add(query_581722, "key", newJString(key))
  if body != nil:
    body_581723 = body
  add(query_581722, "prettyPrint", newJBool(prettyPrint))
  result = call_581720.call(path_581721, query_581722, nil, nil, body_581723)

var dfareportingEventTagsInsert* = Call_DfareportingEventTagsInsert_581707(
    name: "dfareportingEventTagsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsInsert_581708,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsInsert_581709,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsList_581665 = ref object of OpenApiRestCall_579437
proc url_DfareportingEventTagsList_581667(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsList_581666(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of event tags, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581668 = path.getOrDefault("profileId")
  valid_581668 = validateParameter(valid_581668, JString, required = true,
                                 default = nil)
  if valid_581668 != nil:
    section.add "profileId", valid_581668
  result.add "path", section
  ## parameters in `query` object:
  ##   enabled: JBool
  ##          : Select only enabled event tags. What is considered enabled or disabled depends on the definitionsOnly parameter. When definitionsOnly is set to true, only the specified advertiser or campaign's event tags' enabledByDefault field is examined. When definitionsOnly is set to false, the specified ad or specified campaign's parent advertiser's or parent campaign's event tags' enabledByDefault and status fields are examined as well.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   definitionsOnly: JBool
  ##                  : Examine only the specified campaign or advertiser's event tags for matching selector criteria. When set to false, the parent advertiser and parent campaign of the specified ad or campaign is examined as well. In addition, when set to false, the status field is examined as well, along with the enabledByDefault field. This parameter can not be set to true when adId is specified as ads do not define their own even tags.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "eventtag*2015" will return objects with names like "eventtag June 2015", "eventtag April 2015", or simply "eventtag 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "eventtag" will match objects with name "my eventtag", "eventtag 2015", or simply "eventtag".
  ##   advertiserId: JString
  ##               : Select only event tags that belong to this advertiser.
  ##   eventTagTypes: JArray
  ##                : Select only event tags with the specified event tag types. Event tag types can be used to specify whether to use a third-party pixel, a third-party JavaScript URL, or a third-party click-through URL for either impression or click tracking.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   adId: JString
  ##       : Select only event tags that belong to this ad.
  ##   ids: JArray
  ##      : Select only event tags with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: JString
  ##             : Select only event tags that belong to this campaign.
  section = newJObject()
  var valid_581669 = query.getOrDefault("enabled")
  valid_581669 = validateParameter(valid_581669, JBool, required = false, default = nil)
  if valid_581669 != nil:
    section.add "enabled", valid_581669
  var valid_581670 = query.getOrDefault("fields")
  valid_581670 = validateParameter(valid_581670, JString, required = false,
                                 default = nil)
  if valid_581670 != nil:
    section.add "fields", valid_581670
  var valid_581671 = query.getOrDefault("quotaUser")
  valid_581671 = validateParameter(valid_581671, JString, required = false,
                                 default = nil)
  if valid_581671 != nil:
    section.add "quotaUser", valid_581671
  var valid_581672 = query.getOrDefault("sortField")
  valid_581672 = validateParameter(valid_581672, JString, required = false,
                                 default = newJString("ID"))
  if valid_581672 != nil:
    section.add "sortField", valid_581672
  var valid_581673 = query.getOrDefault("alt")
  valid_581673 = validateParameter(valid_581673, JString, required = false,
                                 default = newJString("json"))
  if valid_581673 != nil:
    section.add "alt", valid_581673
  var valid_581674 = query.getOrDefault("definitionsOnly")
  valid_581674 = validateParameter(valid_581674, JBool, required = false, default = nil)
  if valid_581674 != nil:
    section.add "definitionsOnly", valid_581674
  var valid_581675 = query.getOrDefault("searchString")
  valid_581675 = validateParameter(valid_581675, JString, required = false,
                                 default = nil)
  if valid_581675 != nil:
    section.add "searchString", valid_581675
  var valid_581676 = query.getOrDefault("advertiserId")
  valid_581676 = validateParameter(valid_581676, JString, required = false,
                                 default = nil)
  if valid_581676 != nil:
    section.add "advertiserId", valid_581676
  var valid_581677 = query.getOrDefault("eventTagTypes")
  valid_581677 = validateParameter(valid_581677, JArray, required = false,
                                 default = nil)
  if valid_581677 != nil:
    section.add "eventTagTypes", valid_581677
  var valid_581678 = query.getOrDefault("oauth_token")
  valid_581678 = validateParameter(valid_581678, JString, required = false,
                                 default = nil)
  if valid_581678 != nil:
    section.add "oauth_token", valid_581678
  var valid_581679 = query.getOrDefault("userIp")
  valid_581679 = validateParameter(valid_581679, JString, required = false,
                                 default = nil)
  if valid_581679 != nil:
    section.add "userIp", valid_581679
  var valid_581680 = query.getOrDefault("adId")
  valid_581680 = validateParameter(valid_581680, JString, required = false,
                                 default = nil)
  if valid_581680 != nil:
    section.add "adId", valid_581680
  var valid_581681 = query.getOrDefault("ids")
  valid_581681 = validateParameter(valid_581681, JArray, required = false,
                                 default = nil)
  if valid_581681 != nil:
    section.add "ids", valid_581681
  var valid_581682 = query.getOrDefault("key")
  valid_581682 = validateParameter(valid_581682, JString, required = false,
                                 default = nil)
  if valid_581682 != nil:
    section.add "key", valid_581682
  var valid_581683 = query.getOrDefault("sortOrder")
  valid_581683 = validateParameter(valid_581683, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581683 != nil:
    section.add "sortOrder", valid_581683
  var valid_581684 = query.getOrDefault("prettyPrint")
  valid_581684 = validateParameter(valid_581684, JBool, required = false,
                                 default = newJBool(true))
  if valid_581684 != nil:
    section.add "prettyPrint", valid_581684
  var valid_581685 = query.getOrDefault("campaignId")
  valid_581685 = validateParameter(valid_581685, JString, required = false,
                                 default = nil)
  if valid_581685 != nil:
    section.add "campaignId", valid_581685
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581686: Call_DfareportingEventTagsList_581665; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of event tags, possibly filtered.
  ## 
  let valid = call_581686.validator(path, query, header, formData, body)
  let scheme = call_581686.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581686.url(scheme.get, call_581686.host, call_581686.base,
                         call_581686.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581686, url, valid)

proc call*(call_581687: Call_DfareportingEventTagsList_581665; profileId: string;
          enabled: bool = false; fields: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; definitionsOnly: bool = false;
          searchString: string = ""; advertiserId: string = "";
          eventTagTypes: JsonNode = nil; oauthToken: string = ""; userIp: string = "";
          adId: string = ""; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true;
          campaignId: string = ""): Recallable =
  ## dfareportingEventTagsList
  ## Retrieves a list of event tags, possibly filtered.
  ##   enabled: bool
  ##          : Select only enabled event tags. What is considered enabled or disabled depends on the definitionsOnly parameter. When definitionsOnly is set to true, only the specified advertiser or campaign's event tags' enabledByDefault field is examined. When definitionsOnly is set to false, the specified ad or specified campaign's parent advertiser's or parent campaign's event tags' enabledByDefault and status fields are examined as well.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   definitionsOnly: bool
  ##                  : Examine only the specified campaign or advertiser's event tags for matching selector criteria. When set to false, the parent advertiser and parent campaign of the specified ad or campaign is examined as well. In addition, when set to false, the status field is examined as well, along with the enabledByDefault field. This parameter can not be set to true when adId is specified as ads do not define their own even tags.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "eventtag*2015" will return objects with names like "eventtag June 2015", "eventtag April 2015", or simply "eventtag 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "eventtag" will match objects with name "my eventtag", "eventtag 2015", or simply "eventtag".
  ##   advertiserId: string
  ##               : Select only event tags that belong to this advertiser.
  ##   eventTagTypes: JArray
  ##                : Select only event tags with the specified event tag types. Event tag types can be used to specify whether to use a third-party pixel, a third-party JavaScript URL, or a third-party click-through URL for either impression or click tracking.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   adId: string
  ##       : Select only event tags that belong to this ad.
  ##   ids: JArray
  ##      : Select only event tags with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: string
  ##             : Select only event tags that belong to this campaign.
  var path_581688 = newJObject()
  var query_581689 = newJObject()
  add(query_581689, "enabled", newJBool(enabled))
  add(path_581688, "profileId", newJString(profileId))
  add(query_581689, "fields", newJString(fields))
  add(query_581689, "quotaUser", newJString(quotaUser))
  add(query_581689, "sortField", newJString(sortField))
  add(query_581689, "alt", newJString(alt))
  add(query_581689, "definitionsOnly", newJBool(definitionsOnly))
  add(query_581689, "searchString", newJString(searchString))
  add(query_581689, "advertiserId", newJString(advertiserId))
  if eventTagTypes != nil:
    query_581689.add "eventTagTypes", eventTagTypes
  add(query_581689, "oauth_token", newJString(oauthToken))
  add(query_581689, "userIp", newJString(userIp))
  add(query_581689, "adId", newJString(adId))
  if ids != nil:
    query_581689.add "ids", ids
  add(query_581689, "key", newJString(key))
  add(query_581689, "sortOrder", newJString(sortOrder))
  add(query_581689, "prettyPrint", newJBool(prettyPrint))
  add(query_581689, "campaignId", newJString(campaignId))
  result = call_581687.call(path_581688, query_581689, nil, nil, nil)

var dfareportingEventTagsList* = Call_DfareportingEventTagsList_581665(
    name: "dfareportingEventTagsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsList_581666,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsList_581667,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsPatch_581724 = ref object of OpenApiRestCall_579437
proc url_DfareportingEventTagsPatch_581726(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsPatch_581725(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing event tag. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581727 = path.getOrDefault("profileId")
  valid_581727 = validateParameter(valid_581727, JString, required = true,
                                 default = nil)
  if valid_581727 != nil:
    section.add "profileId", valid_581727
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Event tag ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581728 = query.getOrDefault("fields")
  valid_581728 = validateParameter(valid_581728, JString, required = false,
                                 default = nil)
  if valid_581728 != nil:
    section.add "fields", valid_581728
  var valid_581729 = query.getOrDefault("quotaUser")
  valid_581729 = validateParameter(valid_581729, JString, required = false,
                                 default = nil)
  if valid_581729 != nil:
    section.add "quotaUser", valid_581729
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_581730 = query.getOrDefault("id")
  valid_581730 = validateParameter(valid_581730, JString, required = true,
                                 default = nil)
  if valid_581730 != nil:
    section.add "id", valid_581730
  var valid_581731 = query.getOrDefault("alt")
  valid_581731 = validateParameter(valid_581731, JString, required = false,
                                 default = newJString("json"))
  if valid_581731 != nil:
    section.add "alt", valid_581731
  var valid_581732 = query.getOrDefault("oauth_token")
  valid_581732 = validateParameter(valid_581732, JString, required = false,
                                 default = nil)
  if valid_581732 != nil:
    section.add "oauth_token", valid_581732
  var valid_581733 = query.getOrDefault("userIp")
  valid_581733 = validateParameter(valid_581733, JString, required = false,
                                 default = nil)
  if valid_581733 != nil:
    section.add "userIp", valid_581733
  var valid_581734 = query.getOrDefault("key")
  valid_581734 = validateParameter(valid_581734, JString, required = false,
                                 default = nil)
  if valid_581734 != nil:
    section.add "key", valid_581734
  var valid_581735 = query.getOrDefault("prettyPrint")
  valid_581735 = validateParameter(valid_581735, JBool, required = false,
                                 default = newJBool(true))
  if valid_581735 != nil:
    section.add "prettyPrint", valid_581735
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581737: Call_DfareportingEventTagsPatch_581724; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing event tag. This method supports patch semantics.
  ## 
  let valid = call_581737.validator(path, query, header, formData, body)
  let scheme = call_581737.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581737.url(scheme.get, call_581737.host, call_581737.base,
                         call_581737.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581737, url, valid)

proc call*(call_581738: Call_DfareportingEventTagsPatch_581724; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsPatch
  ## Updates an existing event tag. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Event tag ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581739 = newJObject()
  var query_581740 = newJObject()
  var body_581741 = newJObject()
  add(path_581739, "profileId", newJString(profileId))
  add(query_581740, "fields", newJString(fields))
  add(query_581740, "quotaUser", newJString(quotaUser))
  add(query_581740, "id", newJString(id))
  add(query_581740, "alt", newJString(alt))
  add(query_581740, "oauth_token", newJString(oauthToken))
  add(query_581740, "userIp", newJString(userIp))
  add(query_581740, "key", newJString(key))
  if body != nil:
    body_581741 = body
  add(query_581740, "prettyPrint", newJBool(prettyPrint))
  result = call_581738.call(path_581739, query_581740, nil, nil, body_581741)

var dfareportingEventTagsPatch* = Call_DfareportingEventTagsPatch_581724(
    name: "dfareportingEventTagsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsPatch_581725,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsPatch_581726,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsGet_581742 = ref object of OpenApiRestCall_579437
proc url_DfareportingEventTagsGet_581744(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsGet_581743(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one event tag by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Event tag ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581745 = path.getOrDefault("profileId")
  valid_581745 = validateParameter(valid_581745, JString, required = true,
                                 default = nil)
  if valid_581745 != nil:
    section.add "profileId", valid_581745
  var valid_581746 = path.getOrDefault("id")
  valid_581746 = validateParameter(valid_581746, JString, required = true,
                                 default = nil)
  if valid_581746 != nil:
    section.add "id", valid_581746
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581747 = query.getOrDefault("fields")
  valid_581747 = validateParameter(valid_581747, JString, required = false,
                                 default = nil)
  if valid_581747 != nil:
    section.add "fields", valid_581747
  var valid_581748 = query.getOrDefault("quotaUser")
  valid_581748 = validateParameter(valid_581748, JString, required = false,
                                 default = nil)
  if valid_581748 != nil:
    section.add "quotaUser", valid_581748
  var valid_581749 = query.getOrDefault("alt")
  valid_581749 = validateParameter(valid_581749, JString, required = false,
                                 default = newJString("json"))
  if valid_581749 != nil:
    section.add "alt", valid_581749
  var valid_581750 = query.getOrDefault("oauth_token")
  valid_581750 = validateParameter(valid_581750, JString, required = false,
                                 default = nil)
  if valid_581750 != nil:
    section.add "oauth_token", valid_581750
  var valid_581751 = query.getOrDefault("userIp")
  valid_581751 = validateParameter(valid_581751, JString, required = false,
                                 default = nil)
  if valid_581751 != nil:
    section.add "userIp", valid_581751
  var valid_581752 = query.getOrDefault("key")
  valid_581752 = validateParameter(valid_581752, JString, required = false,
                                 default = nil)
  if valid_581752 != nil:
    section.add "key", valid_581752
  var valid_581753 = query.getOrDefault("prettyPrint")
  valid_581753 = validateParameter(valid_581753, JBool, required = false,
                                 default = newJBool(true))
  if valid_581753 != nil:
    section.add "prettyPrint", valid_581753
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581754: Call_DfareportingEventTagsGet_581742; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one event tag by ID.
  ## 
  let valid = call_581754.validator(path, query, header, formData, body)
  let scheme = call_581754.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581754.url(scheme.get, call_581754.host, call_581754.base,
                         call_581754.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581754, url, valid)

proc call*(call_581755: Call_DfareportingEventTagsGet_581742; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsGet
  ## Gets one event tag by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Event tag ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581756 = newJObject()
  var query_581757 = newJObject()
  add(path_581756, "profileId", newJString(profileId))
  add(query_581757, "fields", newJString(fields))
  add(query_581757, "quotaUser", newJString(quotaUser))
  add(query_581757, "alt", newJString(alt))
  add(query_581757, "oauth_token", newJString(oauthToken))
  add(query_581757, "userIp", newJString(userIp))
  add(path_581756, "id", newJString(id))
  add(query_581757, "key", newJString(key))
  add(query_581757, "prettyPrint", newJBool(prettyPrint))
  result = call_581755.call(path_581756, query_581757, nil, nil, nil)

var dfareportingEventTagsGet* = Call_DfareportingEventTagsGet_581742(
    name: "dfareportingEventTagsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags/{id}",
    validator: validate_DfareportingEventTagsGet_581743,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsGet_581744,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsDelete_581758 = ref object of OpenApiRestCall_579437
proc url_DfareportingEventTagsDelete_581760(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsDelete_581759(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing event tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Event tag ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581761 = path.getOrDefault("profileId")
  valid_581761 = validateParameter(valid_581761, JString, required = true,
                                 default = nil)
  if valid_581761 != nil:
    section.add "profileId", valid_581761
  var valid_581762 = path.getOrDefault("id")
  valid_581762 = validateParameter(valid_581762, JString, required = true,
                                 default = nil)
  if valid_581762 != nil:
    section.add "id", valid_581762
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581763 = query.getOrDefault("fields")
  valid_581763 = validateParameter(valid_581763, JString, required = false,
                                 default = nil)
  if valid_581763 != nil:
    section.add "fields", valid_581763
  var valid_581764 = query.getOrDefault("quotaUser")
  valid_581764 = validateParameter(valid_581764, JString, required = false,
                                 default = nil)
  if valid_581764 != nil:
    section.add "quotaUser", valid_581764
  var valid_581765 = query.getOrDefault("alt")
  valid_581765 = validateParameter(valid_581765, JString, required = false,
                                 default = newJString("json"))
  if valid_581765 != nil:
    section.add "alt", valid_581765
  var valid_581766 = query.getOrDefault("oauth_token")
  valid_581766 = validateParameter(valid_581766, JString, required = false,
                                 default = nil)
  if valid_581766 != nil:
    section.add "oauth_token", valid_581766
  var valid_581767 = query.getOrDefault("userIp")
  valid_581767 = validateParameter(valid_581767, JString, required = false,
                                 default = nil)
  if valid_581767 != nil:
    section.add "userIp", valid_581767
  var valid_581768 = query.getOrDefault("key")
  valid_581768 = validateParameter(valid_581768, JString, required = false,
                                 default = nil)
  if valid_581768 != nil:
    section.add "key", valid_581768
  var valid_581769 = query.getOrDefault("prettyPrint")
  valid_581769 = validateParameter(valid_581769, JBool, required = false,
                                 default = newJBool(true))
  if valid_581769 != nil:
    section.add "prettyPrint", valid_581769
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581770: Call_DfareportingEventTagsDelete_581758; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing event tag.
  ## 
  let valid = call_581770.validator(path, query, header, formData, body)
  let scheme = call_581770.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581770.url(scheme.get, call_581770.host, call_581770.base,
                         call_581770.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581770, url, valid)

proc call*(call_581771: Call_DfareportingEventTagsDelete_581758; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsDelete
  ## Deletes an existing event tag.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Event tag ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581772 = newJObject()
  var query_581773 = newJObject()
  add(path_581772, "profileId", newJString(profileId))
  add(query_581773, "fields", newJString(fields))
  add(query_581773, "quotaUser", newJString(quotaUser))
  add(query_581773, "alt", newJString(alt))
  add(query_581773, "oauth_token", newJString(oauthToken))
  add(query_581773, "userIp", newJString(userIp))
  add(path_581772, "id", newJString(id))
  add(query_581773, "key", newJString(key))
  add(query_581773, "prettyPrint", newJBool(prettyPrint))
  result = call_581771.call(path_581772, query_581773, nil, nil, nil)

var dfareportingEventTagsDelete* = Call_DfareportingEventTagsDelete_581758(
    name: "dfareportingEventTagsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags/{id}",
    validator: validate_DfareportingEventTagsDelete_581759,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsDelete_581760,
    schemes: {Scheme.Https})
type
  Call_DfareportingFilesList_581774 = ref object of OpenApiRestCall_579437
proc url_DfareportingFilesList_581776(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFilesList_581775(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists files for a user profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581777 = path.getOrDefault("profileId")
  valid_581777 = validateParameter(valid_581777, JString, required = true,
                                 default = nil)
  if valid_581777 != nil:
    section.add "profileId", valid_581777
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : The field by which to sort the list.
  ##   scope: JString
  ##        : The scope that defines which results are returned.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581778 = query.getOrDefault("fields")
  valid_581778 = validateParameter(valid_581778, JString, required = false,
                                 default = nil)
  if valid_581778 != nil:
    section.add "fields", valid_581778
  var valid_581779 = query.getOrDefault("pageToken")
  valid_581779 = validateParameter(valid_581779, JString, required = false,
                                 default = nil)
  if valid_581779 != nil:
    section.add "pageToken", valid_581779
  var valid_581780 = query.getOrDefault("quotaUser")
  valid_581780 = validateParameter(valid_581780, JString, required = false,
                                 default = nil)
  if valid_581780 != nil:
    section.add "quotaUser", valid_581780
  var valid_581781 = query.getOrDefault("sortField")
  valid_581781 = validateParameter(valid_581781, JString, required = false,
                                 default = newJString("LAST_MODIFIED_TIME"))
  if valid_581781 != nil:
    section.add "sortField", valid_581781
  var valid_581782 = query.getOrDefault("scope")
  valid_581782 = validateParameter(valid_581782, JString, required = false,
                                 default = newJString("MINE"))
  if valid_581782 != nil:
    section.add "scope", valid_581782
  var valid_581783 = query.getOrDefault("alt")
  valid_581783 = validateParameter(valid_581783, JString, required = false,
                                 default = newJString("json"))
  if valid_581783 != nil:
    section.add "alt", valid_581783
  var valid_581784 = query.getOrDefault("oauth_token")
  valid_581784 = validateParameter(valid_581784, JString, required = false,
                                 default = nil)
  if valid_581784 != nil:
    section.add "oauth_token", valid_581784
  var valid_581785 = query.getOrDefault("userIp")
  valid_581785 = validateParameter(valid_581785, JString, required = false,
                                 default = nil)
  if valid_581785 != nil:
    section.add "userIp", valid_581785
  var valid_581786 = query.getOrDefault("maxResults")
  valid_581786 = validateParameter(valid_581786, JInt, required = false,
                                 default = newJInt(10))
  if valid_581786 != nil:
    section.add "maxResults", valid_581786
  var valid_581787 = query.getOrDefault("key")
  valid_581787 = validateParameter(valid_581787, JString, required = false,
                                 default = nil)
  if valid_581787 != nil:
    section.add "key", valid_581787
  var valid_581788 = query.getOrDefault("sortOrder")
  valid_581788 = validateParameter(valid_581788, JString, required = false,
                                 default = newJString("DESCENDING"))
  if valid_581788 != nil:
    section.add "sortOrder", valid_581788
  var valid_581789 = query.getOrDefault("prettyPrint")
  valid_581789 = validateParameter(valid_581789, JBool, required = false,
                                 default = newJBool(true))
  if valid_581789 != nil:
    section.add "prettyPrint", valid_581789
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581790: Call_DfareportingFilesList_581774; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists files for a user profile.
  ## 
  let valid = call_581790.validator(path, query, header, formData, body)
  let scheme = call_581790.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581790.url(scheme.get, call_581790.host, call_581790.base,
                         call_581790.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581790, url, valid)

proc call*(call_581791: Call_DfareportingFilesList_581774; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "LAST_MODIFIED_TIME"; scope: string = "MINE";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 10; key: string = ""; sortOrder: string = "DESCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingFilesList
  ## Lists files for a user profile.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : The field by which to sort the list.
  ##   scope: string
  ##        : The scope that defines which results are returned.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581792 = newJObject()
  var query_581793 = newJObject()
  add(path_581792, "profileId", newJString(profileId))
  add(query_581793, "fields", newJString(fields))
  add(query_581793, "pageToken", newJString(pageToken))
  add(query_581793, "quotaUser", newJString(quotaUser))
  add(query_581793, "sortField", newJString(sortField))
  add(query_581793, "scope", newJString(scope))
  add(query_581793, "alt", newJString(alt))
  add(query_581793, "oauth_token", newJString(oauthToken))
  add(query_581793, "userIp", newJString(userIp))
  add(query_581793, "maxResults", newJInt(maxResults))
  add(query_581793, "key", newJString(key))
  add(query_581793, "sortOrder", newJString(sortOrder))
  add(query_581793, "prettyPrint", newJBool(prettyPrint))
  result = call_581791.call(path_581792, query_581793, nil, nil, nil)

var dfareportingFilesList* = Call_DfareportingFilesList_581774(
    name: "dfareportingFilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/files",
    validator: validate_DfareportingFilesList_581775, base: "/dfareporting/v2.7",
    url: url_DfareportingFilesList_581776, schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesUpdate_581822 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightActivitiesUpdate_581824(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesUpdate_581823(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581825 = path.getOrDefault("profileId")
  valid_581825 = validateParameter(valid_581825, JString, required = true,
                                 default = nil)
  if valid_581825 != nil:
    section.add "profileId", valid_581825
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581826 = query.getOrDefault("fields")
  valid_581826 = validateParameter(valid_581826, JString, required = false,
                                 default = nil)
  if valid_581826 != nil:
    section.add "fields", valid_581826
  var valid_581827 = query.getOrDefault("quotaUser")
  valid_581827 = validateParameter(valid_581827, JString, required = false,
                                 default = nil)
  if valid_581827 != nil:
    section.add "quotaUser", valid_581827
  var valid_581828 = query.getOrDefault("alt")
  valid_581828 = validateParameter(valid_581828, JString, required = false,
                                 default = newJString("json"))
  if valid_581828 != nil:
    section.add "alt", valid_581828
  var valid_581829 = query.getOrDefault("oauth_token")
  valid_581829 = validateParameter(valid_581829, JString, required = false,
                                 default = nil)
  if valid_581829 != nil:
    section.add "oauth_token", valid_581829
  var valid_581830 = query.getOrDefault("userIp")
  valid_581830 = validateParameter(valid_581830, JString, required = false,
                                 default = nil)
  if valid_581830 != nil:
    section.add "userIp", valid_581830
  var valid_581831 = query.getOrDefault("key")
  valid_581831 = validateParameter(valid_581831, JString, required = false,
                                 default = nil)
  if valid_581831 != nil:
    section.add "key", valid_581831
  var valid_581832 = query.getOrDefault("prettyPrint")
  valid_581832 = validateParameter(valid_581832, JBool, required = false,
                                 default = newJBool(true))
  if valid_581832 != nil:
    section.add "prettyPrint", valid_581832
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581834: Call_DfareportingFloodlightActivitiesUpdate_581822;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity.
  ## 
  let valid = call_581834.validator(path, query, header, formData, body)
  let scheme = call_581834.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581834.url(scheme.get, call_581834.host, call_581834.base,
                         call_581834.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581834, url, valid)

proc call*(call_581835: Call_DfareportingFloodlightActivitiesUpdate_581822;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesUpdate
  ## Updates an existing floodlight activity.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581836 = newJObject()
  var query_581837 = newJObject()
  var body_581838 = newJObject()
  add(path_581836, "profileId", newJString(profileId))
  add(query_581837, "fields", newJString(fields))
  add(query_581837, "quotaUser", newJString(quotaUser))
  add(query_581837, "alt", newJString(alt))
  add(query_581837, "oauth_token", newJString(oauthToken))
  add(query_581837, "userIp", newJString(userIp))
  add(query_581837, "key", newJString(key))
  if body != nil:
    body_581838 = body
  add(query_581837, "prettyPrint", newJBool(prettyPrint))
  result = call_581835.call(path_581836, query_581837, nil, nil, body_581838)

var dfareportingFloodlightActivitiesUpdate* = Call_DfareportingFloodlightActivitiesUpdate_581822(
    name: "dfareportingFloodlightActivitiesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesUpdate_581823,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesUpdate_581824,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesInsert_581839 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightActivitiesInsert_581841(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesInsert_581840(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581842 = path.getOrDefault("profileId")
  valid_581842 = validateParameter(valid_581842, JString, required = true,
                                 default = nil)
  if valid_581842 != nil:
    section.add "profileId", valid_581842
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581843 = query.getOrDefault("fields")
  valid_581843 = validateParameter(valid_581843, JString, required = false,
                                 default = nil)
  if valid_581843 != nil:
    section.add "fields", valid_581843
  var valid_581844 = query.getOrDefault("quotaUser")
  valid_581844 = validateParameter(valid_581844, JString, required = false,
                                 default = nil)
  if valid_581844 != nil:
    section.add "quotaUser", valid_581844
  var valid_581845 = query.getOrDefault("alt")
  valid_581845 = validateParameter(valid_581845, JString, required = false,
                                 default = newJString("json"))
  if valid_581845 != nil:
    section.add "alt", valid_581845
  var valid_581846 = query.getOrDefault("oauth_token")
  valid_581846 = validateParameter(valid_581846, JString, required = false,
                                 default = nil)
  if valid_581846 != nil:
    section.add "oauth_token", valid_581846
  var valid_581847 = query.getOrDefault("userIp")
  valid_581847 = validateParameter(valid_581847, JString, required = false,
                                 default = nil)
  if valid_581847 != nil:
    section.add "userIp", valid_581847
  var valid_581848 = query.getOrDefault("key")
  valid_581848 = validateParameter(valid_581848, JString, required = false,
                                 default = nil)
  if valid_581848 != nil:
    section.add "key", valid_581848
  var valid_581849 = query.getOrDefault("prettyPrint")
  valid_581849 = validateParameter(valid_581849, JBool, required = false,
                                 default = newJBool(true))
  if valid_581849 != nil:
    section.add "prettyPrint", valid_581849
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581851: Call_DfareportingFloodlightActivitiesInsert_581839;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new floodlight activity.
  ## 
  let valid = call_581851.validator(path, query, header, formData, body)
  let scheme = call_581851.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581851.url(scheme.get, call_581851.host, call_581851.base,
                         call_581851.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581851, url, valid)

proc call*(call_581852: Call_DfareportingFloodlightActivitiesInsert_581839;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesInsert
  ## Inserts a new floodlight activity.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581853 = newJObject()
  var query_581854 = newJObject()
  var body_581855 = newJObject()
  add(path_581853, "profileId", newJString(profileId))
  add(query_581854, "fields", newJString(fields))
  add(query_581854, "quotaUser", newJString(quotaUser))
  add(query_581854, "alt", newJString(alt))
  add(query_581854, "oauth_token", newJString(oauthToken))
  add(query_581854, "userIp", newJString(userIp))
  add(query_581854, "key", newJString(key))
  if body != nil:
    body_581855 = body
  add(query_581854, "prettyPrint", newJBool(prettyPrint))
  result = call_581852.call(path_581853, query_581854, nil, nil, body_581855)

var dfareportingFloodlightActivitiesInsert* = Call_DfareportingFloodlightActivitiesInsert_581839(
    name: "dfareportingFloodlightActivitiesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesInsert_581840,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesInsert_581841,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesList_581794 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightActivitiesList_581796(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesList_581795(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of floodlight activities, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581797 = path.getOrDefault("profileId")
  valid_581797 = validateParameter(valid_581797, JString, required = true,
                                 default = nil)
  if valid_581797 != nil:
    section.add "profileId", valid_581797
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   tagString: JString
  ##            : Select only floodlight activities with the specified tag string.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivity*2015" will return objects with names like "floodlightactivity June 2015", "floodlightactivity April 2015", or simply "floodlightactivity 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivity" will match objects with name "my floodlightactivity activity", "floodlightactivity 2015", or simply "floodlightactivity".
  ##   advertiserId: JString
  ##               : Select only floodlight activities for the specified advertiser ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   floodlightActivityGroupIds: JArray
  ##                             : Select only floodlight activities with the specified floodlight activity group IDs.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   floodlightActivityGroupType: JString
  ##                              : Select only floodlight activities with the specified floodlight activity group type.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   floodlightConfigurationId: JString
  ##                            : Select only floodlight activities for the specified floodlight configuration ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   floodlightActivityGroupTagString: JString
  ##                                   : Select only floodlight activities with the specified floodlight activity group tag string.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only floodlight activities with the specified IDs. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   floodlightActivityGroupName: JString
  ##                              : Select only floodlight activities with the specified floodlight activity group name.
  section = newJObject()
  var valid_581798 = query.getOrDefault("fields")
  valid_581798 = validateParameter(valid_581798, JString, required = false,
                                 default = nil)
  if valid_581798 != nil:
    section.add "fields", valid_581798
  var valid_581799 = query.getOrDefault("pageToken")
  valid_581799 = validateParameter(valid_581799, JString, required = false,
                                 default = nil)
  if valid_581799 != nil:
    section.add "pageToken", valid_581799
  var valid_581800 = query.getOrDefault("quotaUser")
  valid_581800 = validateParameter(valid_581800, JString, required = false,
                                 default = nil)
  if valid_581800 != nil:
    section.add "quotaUser", valid_581800
  var valid_581801 = query.getOrDefault("sortField")
  valid_581801 = validateParameter(valid_581801, JString, required = false,
                                 default = newJString("ID"))
  if valid_581801 != nil:
    section.add "sortField", valid_581801
  var valid_581802 = query.getOrDefault("tagString")
  valid_581802 = validateParameter(valid_581802, JString, required = false,
                                 default = nil)
  if valid_581802 != nil:
    section.add "tagString", valid_581802
  var valid_581803 = query.getOrDefault("alt")
  valid_581803 = validateParameter(valid_581803, JString, required = false,
                                 default = newJString("json"))
  if valid_581803 != nil:
    section.add "alt", valid_581803
  var valid_581804 = query.getOrDefault("searchString")
  valid_581804 = validateParameter(valid_581804, JString, required = false,
                                 default = nil)
  if valid_581804 != nil:
    section.add "searchString", valid_581804
  var valid_581805 = query.getOrDefault("advertiserId")
  valid_581805 = validateParameter(valid_581805, JString, required = false,
                                 default = nil)
  if valid_581805 != nil:
    section.add "advertiserId", valid_581805
  var valid_581806 = query.getOrDefault("floodlightActivityGroupIds")
  valid_581806 = validateParameter(valid_581806, JArray, required = false,
                                 default = nil)
  if valid_581806 != nil:
    section.add "floodlightActivityGroupIds", valid_581806
  var valid_581807 = query.getOrDefault("oauth_token")
  valid_581807 = validateParameter(valid_581807, JString, required = false,
                                 default = nil)
  if valid_581807 != nil:
    section.add "oauth_token", valid_581807
  var valid_581808 = query.getOrDefault("floodlightActivityGroupType")
  valid_581808 = validateParameter(valid_581808, JString, required = false,
                                 default = newJString("COUNTER"))
  if valid_581808 != nil:
    section.add "floodlightActivityGroupType", valid_581808
  var valid_581809 = query.getOrDefault("userIp")
  valid_581809 = validateParameter(valid_581809, JString, required = false,
                                 default = nil)
  if valid_581809 != nil:
    section.add "userIp", valid_581809
  var valid_581810 = query.getOrDefault("floodlightConfigurationId")
  valid_581810 = validateParameter(valid_581810, JString, required = false,
                                 default = nil)
  if valid_581810 != nil:
    section.add "floodlightConfigurationId", valid_581810
  var valid_581811 = query.getOrDefault("floodlightActivityGroupTagString")
  valid_581811 = validateParameter(valid_581811, JString, required = false,
                                 default = nil)
  if valid_581811 != nil:
    section.add "floodlightActivityGroupTagString", valid_581811
  var valid_581812 = query.getOrDefault("maxResults")
  valid_581812 = validateParameter(valid_581812, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581812 != nil:
    section.add "maxResults", valid_581812
  var valid_581813 = query.getOrDefault("ids")
  valid_581813 = validateParameter(valid_581813, JArray, required = false,
                                 default = nil)
  if valid_581813 != nil:
    section.add "ids", valid_581813
  var valid_581814 = query.getOrDefault("key")
  valid_581814 = validateParameter(valid_581814, JString, required = false,
                                 default = nil)
  if valid_581814 != nil:
    section.add "key", valid_581814
  var valid_581815 = query.getOrDefault("sortOrder")
  valid_581815 = validateParameter(valid_581815, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581815 != nil:
    section.add "sortOrder", valid_581815
  var valid_581816 = query.getOrDefault("prettyPrint")
  valid_581816 = validateParameter(valid_581816, JBool, required = false,
                                 default = newJBool(true))
  if valid_581816 != nil:
    section.add "prettyPrint", valid_581816
  var valid_581817 = query.getOrDefault("floodlightActivityGroupName")
  valid_581817 = validateParameter(valid_581817, JString, required = false,
                                 default = nil)
  if valid_581817 != nil:
    section.add "floodlightActivityGroupName", valid_581817
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581818: Call_DfareportingFloodlightActivitiesList_581794;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of floodlight activities, possibly filtered. This method supports paging.
  ## 
  let valid = call_581818.validator(path, query, header, formData, body)
  let scheme = call_581818.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581818.url(scheme.get, call_581818.host, call_581818.base,
                         call_581818.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581818, url, valid)

proc call*(call_581819: Call_DfareportingFloodlightActivitiesList_581794;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; tagString: string = "";
          alt: string = "json"; searchString: string = ""; advertiserId: string = "";
          floodlightActivityGroupIds: JsonNode = nil; oauthToken: string = "";
          floodlightActivityGroupType: string = "COUNTER"; userIp: string = "";
          floodlightConfigurationId: string = "";
          floodlightActivityGroupTagString: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true; floodlightActivityGroupName: string = ""): Recallable =
  ## dfareportingFloodlightActivitiesList
  ## Retrieves a list of floodlight activities, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   tagString: string
  ##            : Select only floodlight activities with the specified tag string.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivity*2015" will return objects with names like "floodlightactivity June 2015", "floodlightactivity April 2015", or simply "floodlightactivity 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivity" will match objects with name "my floodlightactivity activity", "floodlightactivity 2015", or simply "floodlightactivity".
  ##   advertiserId: string
  ##               : Select only floodlight activities for the specified advertiser ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   floodlightActivityGroupIds: JArray
  ##                             : Select only floodlight activities with the specified floodlight activity group IDs.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   floodlightActivityGroupType: string
  ##                              : Select only floodlight activities with the specified floodlight activity group type.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   floodlightConfigurationId: string
  ##                            : Select only floodlight activities for the specified floodlight configuration ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   floodlightActivityGroupTagString: string
  ##                                   : Select only floodlight activities with the specified floodlight activity group tag string.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only floodlight activities with the specified IDs. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   floodlightActivityGroupName: string
  ##                              : Select only floodlight activities with the specified floodlight activity group name.
  var path_581820 = newJObject()
  var query_581821 = newJObject()
  add(path_581820, "profileId", newJString(profileId))
  add(query_581821, "fields", newJString(fields))
  add(query_581821, "pageToken", newJString(pageToken))
  add(query_581821, "quotaUser", newJString(quotaUser))
  add(query_581821, "sortField", newJString(sortField))
  add(query_581821, "tagString", newJString(tagString))
  add(query_581821, "alt", newJString(alt))
  add(query_581821, "searchString", newJString(searchString))
  add(query_581821, "advertiserId", newJString(advertiserId))
  if floodlightActivityGroupIds != nil:
    query_581821.add "floodlightActivityGroupIds", floodlightActivityGroupIds
  add(query_581821, "oauth_token", newJString(oauthToken))
  add(query_581821, "floodlightActivityGroupType",
      newJString(floodlightActivityGroupType))
  add(query_581821, "userIp", newJString(userIp))
  add(query_581821, "floodlightConfigurationId",
      newJString(floodlightConfigurationId))
  add(query_581821, "floodlightActivityGroupTagString",
      newJString(floodlightActivityGroupTagString))
  add(query_581821, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_581821.add "ids", ids
  add(query_581821, "key", newJString(key))
  add(query_581821, "sortOrder", newJString(sortOrder))
  add(query_581821, "prettyPrint", newJBool(prettyPrint))
  add(query_581821, "floodlightActivityGroupName",
      newJString(floodlightActivityGroupName))
  result = call_581819.call(path_581820, query_581821, nil, nil, nil)

var dfareportingFloodlightActivitiesList* = Call_DfareportingFloodlightActivitiesList_581794(
    name: "dfareportingFloodlightActivitiesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesList_581795,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesList_581796,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesPatch_581856 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightActivitiesPatch_581858(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesPatch_581857(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581859 = path.getOrDefault("profileId")
  valid_581859 = validateParameter(valid_581859, JString, required = true,
                                 default = nil)
  if valid_581859 != nil:
    section.add "profileId", valid_581859
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Floodlight activity ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581860 = query.getOrDefault("fields")
  valid_581860 = validateParameter(valid_581860, JString, required = false,
                                 default = nil)
  if valid_581860 != nil:
    section.add "fields", valid_581860
  var valid_581861 = query.getOrDefault("quotaUser")
  valid_581861 = validateParameter(valid_581861, JString, required = false,
                                 default = nil)
  if valid_581861 != nil:
    section.add "quotaUser", valid_581861
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_581862 = query.getOrDefault("id")
  valid_581862 = validateParameter(valid_581862, JString, required = true,
                                 default = nil)
  if valid_581862 != nil:
    section.add "id", valid_581862
  var valid_581863 = query.getOrDefault("alt")
  valid_581863 = validateParameter(valid_581863, JString, required = false,
                                 default = newJString("json"))
  if valid_581863 != nil:
    section.add "alt", valid_581863
  var valid_581864 = query.getOrDefault("oauth_token")
  valid_581864 = validateParameter(valid_581864, JString, required = false,
                                 default = nil)
  if valid_581864 != nil:
    section.add "oauth_token", valid_581864
  var valid_581865 = query.getOrDefault("userIp")
  valid_581865 = validateParameter(valid_581865, JString, required = false,
                                 default = nil)
  if valid_581865 != nil:
    section.add "userIp", valid_581865
  var valid_581866 = query.getOrDefault("key")
  valid_581866 = validateParameter(valid_581866, JString, required = false,
                                 default = nil)
  if valid_581866 != nil:
    section.add "key", valid_581866
  var valid_581867 = query.getOrDefault("prettyPrint")
  valid_581867 = validateParameter(valid_581867, JBool, required = false,
                                 default = newJBool(true))
  if valid_581867 != nil:
    section.add "prettyPrint", valid_581867
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581869: Call_DfareportingFloodlightActivitiesPatch_581856;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity. This method supports patch semantics.
  ## 
  let valid = call_581869.validator(path, query, header, formData, body)
  let scheme = call_581869.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581869.url(scheme.get, call_581869.host, call_581869.base,
                         call_581869.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581869, url, valid)

proc call*(call_581870: Call_DfareportingFloodlightActivitiesPatch_581856;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesPatch
  ## Updates an existing floodlight activity. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Floodlight activity ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581871 = newJObject()
  var query_581872 = newJObject()
  var body_581873 = newJObject()
  add(path_581871, "profileId", newJString(profileId))
  add(query_581872, "fields", newJString(fields))
  add(query_581872, "quotaUser", newJString(quotaUser))
  add(query_581872, "id", newJString(id))
  add(query_581872, "alt", newJString(alt))
  add(query_581872, "oauth_token", newJString(oauthToken))
  add(query_581872, "userIp", newJString(userIp))
  add(query_581872, "key", newJString(key))
  if body != nil:
    body_581873 = body
  add(query_581872, "prettyPrint", newJBool(prettyPrint))
  result = call_581870.call(path_581871, query_581872, nil, nil, body_581873)

var dfareportingFloodlightActivitiesPatch* = Call_DfareportingFloodlightActivitiesPatch_581856(
    name: "dfareportingFloodlightActivitiesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesPatch_581857,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesPatch_581858,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesGeneratetag_581874 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightActivitiesGeneratetag_581876(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"), (kind: ConstantSegment,
        value: "/floodlightActivities/generatetag")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesGeneratetag_581875(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Generates a tag for a floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581877 = path.getOrDefault("profileId")
  valid_581877 = validateParameter(valid_581877, JString, required = true,
                                 default = nil)
  if valid_581877 != nil:
    section.add "profileId", valid_581877
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   floodlightActivityId: JString
  ##                       : Floodlight activity ID for which we want to generate a tag.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581878 = query.getOrDefault("fields")
  valid_581878 = validateParameter(valid_581878, JString, required = false,
                                 default = nil)
  if valid_581878 != nil:
    section.add "fields", valid_581878
  var valid_581879 = query.getOrDefault("quotaUser")
  valid_581879 = validateParameter(valid_581879, JString, required = false,
                                 default = nil)
  if valid_581879 != nil:
    section.add "quotaUser", valid_581879
  var valid_581880 = query.getOrDefault("alt")
  valid_581880 = validateParameter(valid_581880, JString, required = false,
                                 default = newJString("json"))
  if valid_581880 != nil:
    section.add "alt", valid_581880
  var valid_581881 = query.getOrDefault("oauth_token")
  valid_581881 = validateParameter(valid_581881, JString, required = false,
                                 default = nil)
  if valid_581881 != nil:
    section.add "oauth_token", valid_581881
  var valid_581882 = query.getOrDefault("floodlightActivityId")
  valid_581882 = validateParameter(valid_581882, JString, required = false,
                                 default = nil)
  if valid_581882 != nil:
    section.add "floodlightActivityId", valid_581882
  var valid_581883 = query.getOrDefault("userIp")
  valid_581883 = validateParameter(valid_581883, JString, required = false,
                                 default = nil)
  if valid_581883 != nil:
    section.add "userIp", valid_581883
  var valid_581884 = query.getOrDefault("key")
  valid_581884 = validateParameter(valid_581884, JString, required = false,
                                 default = nil)
  if valid_581884 != nil:
    section.add "key", valid_581884
  var valid_581885 = query.getOrDefault("prettyPrint")
  valid_581885 = validateParameter(valid_581885, JBool, required = false,
                                 default = newJBool(true))
  if valid_581885 != nil:
    section.add "prettyPrint", valid_581885
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581886: Call_DfareportingFloodlightActivitiesGeneratetag_581874;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Generates a tag for a floodlight activity.
  ## 
  let valid = call_581886.validator(path, query, header, formData, body)
  let scheme = call_581886.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581886.url(scheme.get, call_581886.host, call_581886.base,
                         call_581886.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581886, url, valid)

proc call*(call_581887: Call_DfareportingFloodlightActivitiesGeneratetag_581874;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = "";
          floodlightActivityId: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesGeneratetag
  ## Generates a tag for a floodlight activity.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   floodlightActivityId: string
  ##                       : Floodlight activity ID for which we want to generate a tag.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581888 = newJObject()
  var query_581889 = newJObject()
  add(path_581888, "profileId", newJString(profileId))
  add(query_581889, "fields", newJString(fields))
  add(query_581889, "quotaUser", newJString(quotaUser))
  add(query_581889, "alt", newJString(alt))
  add(query_581889, "oauth_token", newJString(oauthToken))
  add(query_581889, "floodlightActivityId", newJString(floodlightActivityId))
  add(query_581889, "userIp", newJString(userIp))
  add(query_581889, "key", newJString(key))
  add(query_581889, "prettyPrint", newJBool(prettyPrint))
  result = call_581887.call(path_581888, query_581889, nil, nil, nil)

var dfareportingFloodlightActivitiesGeneratetag* = Call_DfareportingFloodlightActivitiesGeneratetag_581874(
    name: "dfareportingFloodlightActivitiesGeneratetag",
    meth: HttpMethod.HttpPost, host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities/generatetag",
    validator: validate_DfareportingFloodlightActivitiesGeneratetag_581875,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivitiesGeneratetag_581876,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesGet_581890 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightActivitiesGet_581892(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesGet_581891(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one floodlight activity by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight activity ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581893 = path.getOrDefault("profileId")
  valid_581893 = validateParameter(valid_581893, JString, required = true,
                                 default = nil)
  if valid_581893 != nil:
    section.add "profileId", valid_581893
  var valid_581894 = path.getOrDefault("id")
  valid_581894 = validateParameter(valid_581894, JString, required = true,
                                 default = nil)
  if valid_581894 != nil:
    section.add "id", valid_581894
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581895 = query.getOrDefault("fields")
  valid_581895 = validateParameter(valid_581895, JString, required = false,
                                 default = nil)
  if valid_581895 != nil:
    section.add "fields", valid_581895
  var valid_581896 = query.getOrDefault("quotaUser")
  valid_581896 = validateParameter(valid_581896, JString, required = false,
                                 default = nil)
  if valid_581896 != nil:
    section.add "quotaUser", valid_581896
  var valid_581897 = query.getOrDefault("alt")
  valid_581897 = validateParameter(valid_581897, JString, required = false,
                                 default = newJString("json"))
  if valid_581897 != nil:
    section.add "alt", valid_581897
  var valid_581898 = query.getOrDefault("oauth_token")
  valid_581898 = validateParameter(valid_581898, JString, required = false,
                                 default = nil)
  if valid_581898 != nil:
    section.add "oauth_token", valid_581898
  var valid_581899 = query.getOrDefault("userIp")
  valid_581899 = validateParameter(valid_581899, JString, required = false,
                                 default = nil)
  if valid_581899 != nil:
    section.add "userIp", valid_581899
  var valid_581900 = query.getOrDefault("key")
  valid_581900 = validateParameter(valid_581900, JString, required = false,
                                 default = nil)
  if valid_581900 != nil:
    section.add "key", valid_581900
  var valid_581901 = query.getOrDefault("prettyPrint")
  valid_581901 = validateParameter(valid_581901, JBool, required = false,
                                 default = newJBool(true))
  if valid_581901 != nil:
    section.add "prettyPrint", valid_581901
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581902: Call_DfareportingFloodlightActivitiesGet_581890;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one floodlight activity by ID.
  ## 
  let valid = call_581902.validator(path, query, header, formData, body)
  let scheme = call_581902.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581902.url(scheme.get, call_581902.host, call_581902.base,
                         call_581902.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581902, url, valid)

proc call*(call_581903: Call_DfareportingFloodlightActivitiesGet_581890;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesGet
  ## Gets one floodlight activity by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Floodlight activity ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581904 = newJObject()
  var query_581905 = newJObject()
  add(path_581904, "profileId", newJString(profileId))
  add(query_581905, "fields", newJString(fields))
  add(query_581905, "quotaUser", newJString(quotaUser))
  add(query_581905, "alt", newJString(alt))
  add(query_581905, "oauth_token", newJString(oauthToken))
  add(query_581905, "userIp", newJString(userIp))
  add(path_581904, "id", newJString(id))
  add(query_581905, "key", newJString(key))
  add(query_581905, "prettyPrint", newJBool(prettyPrint))
  result = call_581903.call(path_581904, query_581905, nil, nil, nil)

var dfareportingFloodlightActivitiesGet* = Call_DfareportingFloodlightActivitiesGet_581890(
    name: "dfareportingFloodlightActivitiesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities/{id}",
    validator: validate_DfareportingFloodlightActivitiesGet_581891,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesGet_581892,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesDelete_581906 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightActivitiesDelete_581908(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesDelete_581907(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight activity ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581909 = path.getOrDefault("profileId")
  valid_581909 = validateParameter(valid_581909, JString, required = true,
                                 default = nil)
  if valid_581909 != nil:
    section.add "profileId", valid_581909
  var valid_581910 = path.getOrDefault("id")
  valid_581910 = validateParameter(valid_581910, JString, required = true,
                                 default = nil)
  if valid_581910 != nil:
    section.add "id", valid_581910
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581911 = query.getOrDefault("fields")
  valid_581911 = validateParameter(valid_581911, JString, required = false,
                                 default = nil)
  if valid_581911 != nil:
    section.add "fields", valid_581911
  var valid_581912 = query.getOrDefault("quotaUser")
  valid_581912 = validateParameter(valid_581912, JString, required = false,
                                 default = nil)
  if valid_581912 != nil:
    section.add "quotaUser", valid_581912
  var valid_581913 = query.getOrDefault("alt")
  valid_581913 = validateParameter(valid_581913, JString, required = false,
                                 default = newJString("json"))
  if valid_581913 != nil:
    section.add "alt", valid_581913
  var valid_581914 = query.getOrDefault("oauth_token")
  valid_581914 = validateParameter(valid_581914, JString, required = false,
                                 default = nil)
  if valid_581914 != nil:
    section.add "oauth_token", valid_581914
  var valid_581915 = query.getOrDefault("userIp")
  valid_581915 = validateParameter(valid_581915, JString, required = false,
                                 default = nil)
  if valid_581915 != nil:
    section.add "userIp", valid_581915
  var valid_581916 = query.getOrDefault("key")
  valid_581916 = validateParameter(valid_581916, JString, required = false,
                                 default = nil)
  if valid_581916 != nil:
    section.add "key", valid_581916
  var valid_581917 = query.getOrDefault("prettyPrint")
  valid_581917 = validateParameter(valid_581917, JBool, required = false,
                                 default = newJBool(true))
  if valid_581917 != nil:
    section.add "prettyPrint", valid_581917
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581918: Call_DfareportingFloodlightActivitiesDelete_581906;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing floodlight activity.
  ## 
  let valid = call_581918.validator(path, query, header, formData, body)
  let scheme = call_581918.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581918.url(scheme.get, call_581918.host, call_581918.base,
                         call_581918.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581918, url, valid)

proc call*(call_581919: Call_DfareportingFloodlightActivitiesDelete_581906;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesDelete
  ## Deletes an existing floodlight activity.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Floodlight activity ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581920 = newJObject()
  var query_581921 = newJObject()
  add(path_581920, "profileId", newJString(profileId))
  add(query_581921, "fields", newJString(fields))
  add(query_581921, "quotaUser", newJString(quotaUser))
  add(query_581921, "alt", newJString(alt))
  add(query_581921, "oauth_token", newJString(oauthToken))
  add(query_581921, "userIp", newJString(userIp))
  add(path_581920, "id", newJString(id))
  add(query_581921, "key", newJString(key))
  add(query_581921, "prettyPrint", newJBool(prettyPrint))
  result = call_581919.call(path_581920, query_581921, nil, nil, nil)

var dfareportingFloodlightActivitiesDelete* = Call_DfareportingFloodlightActivitiesDelete_581906(
    name: "dfareportingFloodlightActivitiesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities/{id}",
    validator: validate_DfareportingFloodlightActivitiesDelete_581907,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesDelete_581908,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsUpdate_581946 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightActivityGroupsUpdate_581948(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsUpdate_581947(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581949 = path.getOrDefault("profileId")
  valid_581949 = validateParameter(valid_581949, JString, required = true,
                                 default = nil)
  if valid_581949 != nil:
    section.add "profileId", valid_581949
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581950 = query.getOrDefault("fields")
  valid_581950 = validateParameter(valid_581950, JString, required = false,
                                 default = nil)
  if valid_581950 != nil:
    section.add "fields", valid_581950
  var valid_581951 = query.getOrDefault("quotaUser")
  valid_581951 = validateParameter(valid_581951, JString, required = false,
                                 default = nil)
  if valid_581951 != nil:
    section.add "quotaUser", valid_581951
  var valid_581952 = query.getOrDefault("alt")
  valid_581952 = validateParameter(valid_581952, JString, required = false,
                                 default = newJString("json"))
  if valid_581952 != nil:
    section.add "alt", valid_581952
  var valid_581953 = query.getOrDefault("oauth_token")
  valid_581953 = validateParameter(valid_581953, JString, required = false,
                                 default = nil)
  if valid_581953 != nil:
    section.add "oauth_token", valid_581953
  var valid_581954 = query.getOrDefault("userIp")
  valid_581954 = validateParameter(valid_581954, JString, required = false,
                                 default = nil)
  if valid_581954 != nil:
    section.add "userIp", valid_581954
  var valid_581955 = query.getOrDefault("key")
  valid_581955 = validateParameter(valid_581955, JString, required = false,
                                 default = nil)
  if valid_581955 != nil:
    section.add "key", valid_581955
  var valid_581956 = query.getOrDefault("prettyPrint")
  valid_581956 = validateParameter(valid_581956, JBool, required = false,
                                 default = newJBool(true))
  if valid_581956 != nil:
    section.add "prettyPrint", valid_581956
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581958: Call_DfareportingFloodlightActivityGroupsUpdate_581946;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity group.
  ## 
  let valid = call_581958.validator(path, query, header, formData, body)
  let scheme = call_581958.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581958.url(scheme.get, call_581958.host, call_581958.base,
                         call_581958.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581958, url, valid)

proc call*(call_581959: Call_DfareportingFloodlightActivityGroupsUpdate_581946;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsUpdate
  ## Updates an existing floodlight activity group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581960 = newJObject()
  var query_581961 = newJObject()
  var body_581962 = newJObject()
  add(path_581960, "profileId", newJString(profileId))
  add(query_581961, "fields", newJString(fields))
  add(query_581961, "quotaUser", newJString(quotaUser))
  add(query_581961, "alt", newJString(alt))
  add(query_581961, "oauth_token", newJString(oauthToken))
  add(query_581961, "userIp", newJString(userIp))
  add(query_581961, "key", newJString(key))
  if body != nil:
    body_581962 = body
  add(query_581961, "prettyPrint", newJBool(prettyPrint))
  result = call_581959.call(path_581960, query_581961, nil, nil, body_581962)

var dfareportingFloodlightActivityGroupsUpdate* = Call_DfareportingFloodlightActivityGroupsUpdate_581946(
    name: "dfareportingFloodlightActivityGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsUpdate_581947,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivityGroupsUpdate_581948,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsInsert_581963 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightActivityGroupsInsert_581965(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsInsert_581964(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new floodlight activity group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581966 = path.getOrDefault("profileId")
  valid_581966 = validateParameter(valid_581966, JString, required = true,
                                 default = nil)
  if valid_581966 != nil:
    section.add "profileId", valid_581966
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581967 = query.getOrDefault("fields")
  valid_581967 = validateParameter(valid_581967, JString, required = false,
                                 default = nil)
  if valid_581967 != nil:
    section.add "fields", valid_581967
  var valid_581968 = query.getOrDefault("quotaUser")
  valid_581968 = validateParameter(valid_581968, JString, required = false,
                                 default = nil)
  if valid_581968 != nil:
    section.add "quotaUser", valid_581968
  var valid_581969 = query.getOrDefault("alt")
  valid_581969 = validateParameter(valid_581969, JString, required = false,
                                 default = newJString("json"))
  if valid_581969 != nil:
    section.add "alt", valid_581969
  var valid_581970 = query.getOrDefault("oauth_token")
  valid_581970 = validateParameter(valid_581970, JString, required = false,
                                 default = nil)
  if valid_581970 != nil:
    section.add "oauth_token", valid_581970
  var valid_581971 = query.getOrDefault("userIp")
  valid_581971 = validateParameter(valid_581971, JString, required = false,
                                 default = nil)
  if valid_581971 != nil:
    section.add "userIp", valid_581971
  var valid_581972 = query.getOrDefault("key")
  valid_581972 = validateParameter(valid_581972, JString, required = false,
                                 default = nil)
  if valid_581972 != nil:
    section.add "key", valid_581972
  var valid_581973 = query.getOrDefault("prettyPrint")
  valid_581973 = validateParameter(valid_581973, JBool, required = false,
                                 default = newJBool(true))
  if valid_581973 != nil:
    section.add "prettyPrint", valid_581973
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581975: Call_DfareportingFloodlightActivityGroupsInsert_581963;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new floodlight activity group.
  ## 
  let valid = call_581975.validator(path, query, header, formData, body)
  let scheme = call_581975.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581975.url(scheme.get, call_581975.host, call_581975.base,
                         call_581975.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581975, url, valid)

proc call*(call_581976: Call_DfareportingFloodlightActivityGroupsInsert_581963;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsInsert
  ## Inserts a new floodlight activity group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581977 = newJObject()
  var query_581978 = newJObject()
  var body_581979 = newJObject()
  add(path_581977, "profileId", newJString(profileId))
  add(query_581978, "fields", newJString(fields))
  add(query_581978, "quotaUser", newJString(quotaUser))
  add(query_581978, "alt", newJString(alt))
  add(query_581978, "oauth_token", newJString(oauthToken))
  add(query_581978, "userIp", newJString(userIp))
  add(query_581978, "key", newJString(key))
  if body != nil:
    body_581979 = body
  add(query_581978, "prettyPrint", newJBool(prettyPrint))
  result = call_581976.call(path_581977, query_581978, nil, nil, body_581979)

var dfareportingFloodlightActivityGroupsInsert* = Call_DfareportingFloodlightActivityGroupsInsert_581963(
    name: "dfareportingFloodlightActivityGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsInsert_581964,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivityGroupsInsert_581965,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsList_581922 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightActivityGroupsList_581924(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsList_581923(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of floodlight activity groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581925 = path.getOrDefault("profileId")
  valid_581925 = validateParameter(valid_581925, JString, required = true,
                                 default = nil)
  if valid_581925 != nil:
    section.add "profileId", valid_581925
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivitygroup*2015" will return objects with names like "floodlightactivitygroup June 2015", "floodlightactivitygroup April 2015", or simply "floodlightactivitygroup 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivitygroup" will match objects with name "my floodlightactivitygroup activity", "floodlightactivitygroup 2015", or simply "floodlightactivitygroup".
  ##   advertiserId: JString
  ##               : Select only floodlight activity groups with the specified advertiser ID. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   type: JString
  ##       : Select only floodlight activity groups with the specified floodlight activity group type.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   floodlightConfigurationId: JString
  ##                            : Select only floodlight activity groups with the specified floodlight configuration ID. Must specify either advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only floodlight activity groups with the specified IDs. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581926 = query.getOrDefault("fields")
  valid_581926 = validateParameter(valid_581926, JString, required = false,
                                 default = nil)
  if valid_581926 != nil:
    section.add "fields", valid_581926
  var valid_581927 = query.getOrDefault("pageToken")
  valid_581927 = validateParameter(valid_581927, JString, required = false,
                                 default = nil)
  if valid_581927 != nil:
    section.add "pageToken", valid_581927
  var valid_581928 = query.getOrDefault("quotaUser")
  valid_581928 = validateParameter(valid_581928, JString, required = false,
                                 default = nil)
  if valid_581928 != nil:
    section.add "quotaUser", valid_581928
  var valid_581929 = query.getOrDefault("sortField")
  valid_581929 = validateParameter(valid_581929, JString, required = false,
                                 default = newJString("ID"))
  if valid_581929 != nil:
    section.add "sortField", valid_581929
  var valid_581930 = query.getOrDefault("alt")
  valid_581930 = validateParameter(valid_581930, JString, required = false,
                                 default = newJString("json"))
  if valid_581930 != nil:
    section.add "alt", valid_581930
  var valid_581931 = query.getOrDefault("searchString")
  valid_581931 = validateParameter(valid_581931, JString, required = false,
                                 default = nil)
  if valid_581931 != nil:
    section.add "searchString", valid_581931
  var valid_581932 = query.getOrDefault("advertiserId")
  valid_581932 = validateParameter(valid_581932, JString, required = false,
                                 default = nil)
  if valid_581932 != nil:
    section.add "advertiserId", valid_581932
  var valid_581933 = query.getOrDefault("type")
  valid_581933 = validateParameter(valid_581933, JString, required = false,
                                 default = newJString("COUNTER"))
  if valid_581933 != nil:
    section.add "type", valid_581933
  var valid_581934 = query.getOrDefault("oauth_token")
  valid_581934 = validateParameter(valid_581934, JString, required = false,
                                 default = nil)
  if valid_581934 != nil:
    section.add "oauth_token", valid_581934
  var valid_581935 = query.getOrDefault("userIp")
  valid_581935 = validateParameter(valid_581935, JString, required = false,
                                 default = nil)
  if valid_581935 != nil:
    section.add "userIp", valid_581935
  var valid_581936 = query.getOrDefault("floodlightConfigurationId")
  valid_581936 = validateParameter(valid_581936, JString, required = false,
                                 default = nil)
  if valid_581936 != nil:
    section.add "floodlightConfigurationId", valid_581936
  var valid_581937 = query.getOrDefault("maxResults")
  valid_581937 = validateParameter(valid_581937, JInt, required = false,
                                 default = newJInt(1000))
  if valid_581937 != nil:
    section.add "maxResults", valid_581937
  var valid_581938 = query.getOrDefault("ids")
  valid_581938 = validateParameter(valid_581938, JArray, required = false,
                                 default = nil)
  if valid_581938 != nil:
    section.add "ids", valid_581938
  var valid_581939 = query.getOrDefault("key")
  valid_581939 = validateParameter(valid_581939, JString, required = false,
                                 default = nil)
  if valid_581939 != nil:
    section.add "key", valid_581939
  var valid_581940 = query.getOrDefault("sortOrder")
  valid_581940 = validateParameter(valid_581940, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_581940 != nil:
    section.add "sortOrder", valid_581940
  var valid_581941 = query.getOrDefault("prettyPrint")
  valid_581941 = validateParameter(valid_581941, JBool, required = false,
                                 default = newJBool(true))
  if valid_581941 != nil:
    section.add "prettyPrint", valid_581941
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_581942: Call_DfareportingFloodlightActivityGroupsList_581922;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of floodlight activity groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_581942.validator(path, query, header, formData, body)
  let scheme = call_581942.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581942.url(scheme.get, call_581942.host, call_581942.base,
                         call_581942.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581942, url, valid)

proc call*(call_581943: Call_DfareportingFloodlightActivityGroupsList_581922;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; advertiserId: string = "";
          `type`: string = "COUNTER"; oauthToken: string = ""; userIp: string = "";
          floodlightConfigurationId: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsList
  ## Retrieves a list of floodlight activity groups, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivitygroup*2015" will return objects with names like "floodlightactivitygroup June 2015", "floodlightactivitygroup April 2015", or simply "floodlightactivitygroup 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivitygroup" will match objects with name "my floodlightactivitygroup activity", "floodlightactivitygroup 2015", or simply "floodlightactivitygroup".
  ##   advertiserId: string
  ##               : Select only floodlight activity groups with the specified advertiser ID. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   type: string
  ##       : Select only floodlight activity groups with the specified floodlight activity group type.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   floodlightConfigurationId: string
  ##                            : Select only floodlight activity groups with the specified floodlight configuration ID. Must specify either advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only floodlight activity groups with the specified IDs. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581944 = newJObject()
  var query_581945 = newJObject()
  add(path_581944, "profileId", newJString(profileId))
  add(query_581945, "fields", newJString(fields))
  add(query_581945, "pageToken", newJString(pageToken))
  add(query_581945, "quotaUser", newJString(quotaUser))
  add(query_581945, "sortField", newJString(sortField))
  add(query_581945, "alt", newJString(alt))
  add(query_581945, "searchString", newJString(searchString))
  add(query_581945, "advertiserId", newJString(advertiserId))
  add(query_581945, "type", newJString(`type`))
  add(query_581945, "oauth_token", newJString(oauthToken))
  add(query_581945, "userIp", newJString(userIp))
  add(query_581945, "floodlightConfigurationId",
      newJString(floodlightConfigurationId))
  add(query_581945, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_581945.add "ids", ids
  add(query_581945, "key", newJString(key))
  add(query_581945, "sortOrder", newJString(sortOrder))
  add(query_581945, "prettyPrint", newJBool(prettyPrint))
  result = call_581943.call(path_581944, query_581945, nil, nil, nil)

var dfareportingFloodlightActivityGroupsList* = Call_DfareportingFloodlightActivityGroupsList_581922(
    name: "dfareportingFloodlightActivityGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsList_581923,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivityGroupsList_581924,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsPatch_581980 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightActivityGroupsPatch_581982(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsPatch_581981(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_581983 = path.getOrDefault("profileId")
  valid_581983 = validateParameter(valid_581983, JString, required = true,
                                 default = nil)
  if valid_581983 != nil:
    section.add "profileId", valid_581983
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Floodlight activity Group ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_581984 = query.getOrDefault("fields")
  valid_581984 = validateParameter(valid_581984, JString, required = false,
                                 default = nil)
  if valid_581984 != nil:
    section.add "fields", valid_581984
  var valid_581985 = query.getOrDefault("quotaUser")
  valid_581985 = validateParameter(valid_581985, JString, required = false,
                                 default = nil)
  if valid_581985 != nil:
    section.add "quotaUser", valid_581985
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_581986 = query.getOrDefault("id")
  valid_581986 = validateParameter(valid_581986, JString, required = true,
                                 default = nil)
  if valid_581986 != nil:
    section.add "id", valid_581986
  var valid_581987 = query.getOrDefault("alt")
  valid_581987 = validateParameter(valid_581987, JString, required = false,
                                 default = newJString("json"))
  if valid_581987 != nil:
    section.add "alt", valid_581987
  var valid_581988 = query.getOrDefault("oauth_token")
  valid_581988 = validateParameter(valid_581988, JString, required = false,
                                 default = nil)
  if valid_581988 != nil:
    section.add "oauth_token", valid_581988
  var valid_581989 = query.getOrDefault("userIp")
  valid_581989 = validateParameter(valid_581989, JString, required = false,
                                 default = nil)
  if valid_581989 != nil:
    section.add "userIp", valid_581989
  var valid_581990 = query.getOrDefault("key")
  valid_581990 = validateParameter(valid_581990, JString, required = false,
                                 default = nil)
  if valid_581990 != nil:
    section.add "key", valid_581990
  var valid_581991 = query.getOrDefault("prettyPrint")
  valid_581991 = validateParameter(valid_581991, JBool, required = false,
                                 default = newJBool(true))
  if valid_581991 != nil:
    section.add "prettyPrint", valid_581991
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_581993: Call_DfareportingFloodlightActivityGroupsPatch_581980;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity group. This method supports patch semantics.
  ## 
  let valid = call_581993.validator(path, query, header, formData, body)
  let scheme = call_581993.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_581993.url(scheme.get, call_581993.host, call_581993.base,
                         call_581993.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_581993, url, valid)

proc call*(call_581994: Call_DfareportingFloodlightActivityGroupsPatch_581980;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsPatch
  ## Updates an existing floodlight activity group. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Floodlight activity Group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_581995 = newJObject()
  var query_581996 = newJObject()
  var body_581997 = newJObject()
  add(path_581995, "profileId", newJString(profileId))
  add(query_581996, "fields", newJString(fields))
  add(query_581996, "quotaUser", newJString(quotaUser))
  add(query_581996, "id", newJString(id))
  add(query_581996, "alt", newJString(alt))
  add(query_581996, "oauth_token", newJString(oauthToken))
  add(query_581996, "userIp", newJString(userIp))
  add(query_581996, "key", newJString(key))
  if body != nil:
    body_581997 = body
  add(query_581996, "prettyPrint", newJBool(prettyPrint))
  result = call_581994.call(path_581995, query_581996, nil, nil, body_581997)

var dfareportingFloodlightActivityGroupsPatch* = Call_DfareportingFloodlightActivityGroupsPatch_581980(
    name: "dfareportingFloodlightActivityGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsPatch_581981,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivityGroupsPatch_581982,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsGet_581998 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightActivityGroupsGet_582000(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsGet_581999(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one floodlight activity group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight activity Group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582001 = path.getOrDefault("profileId")
  valid_582001 = validateParameter(valid_582001, JString, required = true,
                                 default = nil)
  if valid_582001 != nil:
    section.add "profileId", valid_582001
  var valid_582002 = path.getOrDefault("id")
  valid_582002 = validateParameter(valid_582002, JString, required = true,
                                 default = nil)
  if valid_582002 != nil:
    section.add "id", valid_582002
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582003 = query.getOrDefault("fields")
  valid_582003 = validateParameter(valid_582003, JString, required = false,
                                 default = nil)
  if valid_582003 != nil:
    section.add "fields", valid_582003
  var valid_582004 = query.getOrDefault("quotaUser")
  valid_582004 = validateParameter(valid_582004, JString, required = false,
                                 default = nil)
  if valid_582004 != nil:
    section.add "quotaUser", valid_582004
  var valid_582005 = query.getOrDefault("alt")
  valid_582005 = validateParameter(valid_582005, JString, required = false,
                                 default = newJString("json"))
  if valid_582005 != nil:
    section.add "alt", valid_582005
  var valid_582006 = query.getOrDefault("oauth_token")
  valid_582006 = validateParameter(valid_582006, JString, required = false,
                                 default = nil)
  if valid_582006 != nil:
    section.add "oauth_token", valid_582006
  var valid_582007 = query.getOrDefault("userIp")
  valid_582007 = validateParameter(valid_582007, JString, required = false,
                                 default = nil)
  if valid_582007 != nil:
    section.add "userIp", valid_582007
  var valid_582008 = query.getOrDefault("key")
  valid_582008 = validateParameter(valid_582008, JString, required = false,
                                 default = nil)
  if valid_582008 != nil:
    section.add "key", valid_582008
  var valid_582009 = query.getOrDefault("prettyPrint")
  valid_582009 = validateParameter(valid_582009, JBool, required = false,
                                 default = newJBool(true))
  if valid_582009 != nil:
    section.add "prettyPrint", valid_582009
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582010: Call_DfareportingFloodlightActivityGroupsGet_581998;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one floodlight activity group by ID.
  ## 
  let valid = call_582010.validator(path, query, header, formData, body)
  let scheme = call_582010.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582010.url(scheme.get, call_582010.host, call_582010.base,
                         call_582010.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582010, url, valid)

proc call*(call_582011: Call_DfareportingFloodlightActivityGroupsGet_581998;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsGet
  ## Gets one floodlight activity group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Floodlight activity Group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582012 = newJObject()
  var query_582013 = newJObject()
  add(path_582012, "profileId", newJString(profileId))
  add(query_582013, "fields", newJString(fields))
  add(query_582013, "quotaUser", newJString(quotaUser))
  add(query_582013, "alt", newJString(alt))
  add(query_582013, "oauth_token", newJString(oauthToken))
  add(query_582013, "userIp", newJString(userIp))
  add(path_582012, "id", newJString(id))
  add(query_582013, "key", newJString(key))
  add(query_582013, "prettyPrint", newJBool(prettyPrint))
  result = call_582011.call(path_582012, query_582013, nil, nil, nil)

var dfareportingFloodlightActivityGroupsGet* = Call_DfareportingFloodlightActivityGroupsGet_581998(
    name: "dfareportingFloodlightActivityGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups/{id}",
    validator: validate_DfareportingFloodlightActivityGroupsGet_581999,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivityGroupsGet_582000,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsUpdate_582030 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightConfigurationsUpdate_582032(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsUpdate_582031(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582033 = path.getOrDefault("profileId")
  valid_582033 = validateParameter(valid_582033, JString, required = true,
                                 default = nil)
  if valid_582033 != nil:
    section.add "profileId", valid_582033
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582034 = query.getOrDefault("fields")
  valid_582034 = validateParameter(valid_582034, JString, required = false,
                                 default = nil)
  if valid_582034 != nil:
    section.add "fields", valid_582034
  var valid_582035 = query.getOrDefault("quotaUser")
  valid_582035 = validateParameter(valid_582035, JString, required = false,
                                 default = nil)
  if valid_582035 != nil:
    section.add "quotaUser", valid_582035
  var valid_582036 = query.getOrDefault("alt")
  valid_582036 = validateParameter(valid_582036, JString, required = false,
                                 default = newJString("json"))
  if valid_582036 != nil:
    section.add "alt", valid_582036
  var valid_582037 = query.getOrDefault("oauth_token")
  valid_582037 = validateParameter(valid_582037, JString, required = false,
                                 default = nil)
  if valid_582037 != nil:
    section.add "oauth_token", valid_582037
  var valid_582038 = query.getOrDefault("userIp")
  valid_582038 = validateParameter(valid_582038, JString, required = false,
                                 default = nil)
  if valid_582038 != nil:
    section.add "userIp", valid_582038
  var valid_582039 = query.getOrDefault("key")
  valid_582039 = validateParameter(valid_582039, JString, required = false,
                                 default = nil)
  if valid_582039 != nil:
    section.add "key", valid_582039
  var valid_582040 = query.getOrDefault("prettyPrint")
  valid_582040 = validateParameter(valid_582040, JBool, required = false,
                                 default = newJBool(true))
  if valid_582040 != nil:
    section.add "prettyPrint", valid_582040
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582042: Call_DfareportingFloodlightConfigurationsUpdate_582030;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight configuration.
  ## 
  let valid = call_582042.validator(path, query, header, formData, body)
  let scheme = call_582042.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582042.url(scheme.get, call_582042.host, call_582042.base,
                         call_582042.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582042, url, valid)

proc call*(call_582043: Call_DfareportingFloodlightConfigurationsUpdate_582030;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightConfigurationsUpdate
  ## Updates an existing floodlight configuration.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582044 = newJObject()
  var query_582045 = newJObject()
  var body_582046 = newJObject()
  add(path_582044, "profileId", newJString(profileId))
  add(query_582045, "fields", newJString(fields))
  add(query_582045, "quotaUser", newJString(quotaUser))
  add(query_582045, "alt", newJString(alt))
  add(query_582045, "oauth_token", newJString(oauthToken))
  add(query_582045, "userIp", newJString(userIp))
  add(query_582045, "key", newJString(key))
  if body != nil:
    body_582046 = body
  add(query_582045, "prettyPrint", newJBool(prettyPrint))
  result = call_582043.call(path_582044, query_582045, nil, nil, body_582046)

var dfareportingFloodlightConfigurationsUpdate* = Call_DfareportingFloodlightConfigurationsUpdate_582030(
    name: "dfareportingFloodlightConfigurationsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations",
    validator: validate_DfareportingFloodlightConfigurationsUpdate_582031,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightConfigurationsUpdate_582032,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsList_582014 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightConfigurationsList_582016(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsList_582015(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of floodlight configurations, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582017 = path.getOrDefault("profileId")
  valid_582017 = validateParameter(valid_582017, JString, required = true,
                                 default = nil)
  if valid_582017 != nil:
    section.add "profileId", valid_582017
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Set of IDs of floodlight configurations to retrieve. Required field; otherwise an empty list will be returned.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582018 = query.getOrDefault("fields")
  valid_582018 = validateParameter(valid_582018, JString, required = false,
                                 default = nil)
  if valid_582018 != nil:
    section.add "fields", valid_582018
  var valid_582019 = query.getOrDefault("quotaUser")
  valid_582019 = validateParameter(valid_582019, JString, required = false,
                                 default = nil)
  if valid_582019 != nil:
    section.add "quotaUser", valid_582019
  var valid_582020 = query.getOrDefault("alt")
  valid_582020 = validateParameter(valid_582020, JString, required = false,
                                 default = newJString("json"))
  if valid_582020 != nil:
    section.add "alt", valid_582020
  var valid_582021 = query.getOrDefault("oauth_token")
  valid_582021 = validateParameter(valid_582021, JString, required = false,
                                 default = nil)
  if valid_582021 != nil:
    section.add "oauth_token", valid_582021
  var valid_582022 = query.getOrDefault("userIp")
  valid_582022 = validateParameter(valid_582022, JString, required = false,
                                 default = nil)
  if valid_582022 != nil:
    section.add "userIp", valid_582022
  var valid_582023 = query.getOrDefault("ids")
  valid_582023 = validateParameter(valid_582023, JArray, required = false,
                                 default = nil)
  if valid_582023 != nil:
    section.add "ids", valid_582023
  var valid_582024 = query.getOrDefault("key")
  valid_582024 = validateParameter(valid_582024, JString, required = false,
                                 default = nil)
  if valid_582024 != nil:
    section.add "key", valid_582024
  var valid_582025 = query.getOrDefault("prettyPrint")
  valid_582025 = validateParameter(valid_582025, JBool, required = false,
                                 default = newJBool(true))
  if valid_582025 != nil:
    section.add "prettyPrint", valid_582025
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582026: Call_DfareportingFloodlightConfigurationsList_582014;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of floodlight configurations, possibly filtered.
  ## 
  let valid = call_582026.validator(path, query, header, formData, body)
  let scheme = call_582026.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582026.url(scheme.get, call_582026.host, call_582026.base,
                         call_582026.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582026, url, valid)

proc call*(call_582027: Call_DfareportingFloodlightConfigurationsList_582014;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          ids: JsonNode = nil; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightConfigurationsList
  ## Retrieves a list of floodlight configurations, possibly filtered.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Set of IDs of floodlight configurations to retrieve. Required field; otherwise an empty list will be returned.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582028 = newJObject()
  var query_582029 = newJObject()
  add(path_582028, "profileId", newJString(profileId))
  add(query_582029, "fields", newJString(fields))
  add(query_582029, "quotaUser", newJString(quotaUser))
  add(query_582029, "alt", newJString(alt))
  add(query_582029, "oauth_token", newJString(oauthToken))
  add(query_582029, "userIp", newJString(userIp))
  if ids != nil:
    query_582029.add "ids", ids
  add(query_582029, "key", newJString(key))
  add(query_582029, "prettyPrint", newJBool(prettyPrint))
  result = call_582027.call(path_582028, query_582029, nil, nil, nil)

var dfareportingFloodlightConfigurationsList* = Call_DfareportingFloodlightConfigurationsList_582014(
    name: "dfareportingFloodlightConfigurationsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations",
    validator: validate_DfareportingFloodlightConfigurationsList_582015,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightConfigurationsList_582016,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsPatch_582047 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightConfigurationsPatch_582049(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsPatch_582048(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight configuration. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582050 = path.getOrDefault("profileId")
  valid_582050 = validateParameter(valid_582050, JString, required = true,
                                 default = nil)
  if valid_582050 != nil:
    section.add "profileId", valid_582050
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Floodlight configuration ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582051 = query.getOrDefault("fields")
  valid_582051 = validateParameter(valid_582051, JString, required = false,
                                 default = nil)
  if valid_582051 != nil:
    section.add "fields", valid_582051
  var valid_582052 = query.getOrDefault("quotaUser")
  valid_582052 = validateParameter(valid_582052, JString, required = false,
                                 default = nil)
  if valid_582052 != nil:
    section.add "quotaUser", valid_582052
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_582053 = query.getOrDefault("id")
  valid_582053 = validateParameter(valid_582053, JString, required = true,
                                 default = nil)
  if valid_582053 != nil:
    section.add "id", valid_582053
  var valid_582054 = query.getOrDefault("alt")
  valid_582054 = validateParameter(valid_582054, JString, required = false,
                                 default = newJString("json"))
  if valid_582054 != nil:
    section.add "alt", valid_582054
  var valid_582055 = query.getOrDefault("oauth_token")
  valid_582055 = validateParameter(valid_582055, JString, required = false,
                                 default = nil)
  if valid_582055 != nil:
    section.add "oauth_token", valid_582055
  var valid_582056 = query.getOrDefault("userIp")
  valid_582056 = validateParameter(valid_582056, JString, required = false,
                                 default = nil)
  if valid_582056 != nil:
    section.add "userIp", valid_582056
  var valid_582057 = query.getOrDefault("key")
  valid_582057 = validateParameter(valid_582057, JString, required = false,
                                 default = nil)
  if valid_582057 != nil:
    section.add "key", valid_582057
  var valid_582058 = query.getOrDefault("prettyPrint")
  valid_582058 = validateParameter(valid_582058, JBool, required = false,
                                 default = newJBool(true))
  if valid_582058 != nil:
    section.add "prettyPrint", valid_582058
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582060: Call_DfareportingFloodlightConfigurationsPatch_582047;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight configuration. This method supports patch semantics.
  ## 
  let valid = call_582060.validator(path, query, header, formData, body)
  let scheme = call_582060.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582060.url(scheme.get, call_582060.host, call_582060.base,
                         call_582060.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582060, url, valid)

proc call*(call_582061: Call_DfareportingFloodlightConfigurationsPatch_582047;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightConfigurationsPatch
  ## Updates an existing floodlight configuration. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Floodlight configuration ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582062 = newJObject()
  var query_582063 = newJObject()
  var body_582064 = newJObject()
  add(path_582062, "profileId", newJString(profileId))
  add(query_582063, "fields", newJString(fields))
  add(query_582063, "quotaUser", newJString(quotaUser))
  add(query_582063, "id", newJString(id))
  add(query_582063, "alt", newJString(alt))
  add(query_582063, "oauth_token", newJString(oauthToken))
  add(query_582063, "userIp", newJString(userIp))
  add(query_582063, "key", newJString(key))
  if body != nil:
    body_582064 = body
  add(query_582063, "prettyPrint", newJBool(prettyPrint))
  result = call_582061.call(path_582062, query_582063, nil, nil, body_582064)

var dfareportingFloodlightConfigurationsPatch* = Call_DfareportingFloodlightConfigurationsPatch_582047(
    name: "dfareportingFloodlightConfigurationsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations",
    validator: validate_DfareportingFloodlightConfigurationsPatch_582048,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightConfigurationsPatch_582049,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsGet_582065 = ref object of OpenApiRestCall_579437
proc url_DfareportingFloodlightConfigurationsGet_582067(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsGet_582066(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one floodlight configuration by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight configuration ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582068 = path.getOrDefault("profileId")
  valid_582068 = validateParameter(valid_582068, JString, required = true,
                                 default = nil)
  if valid_582068 != nil:
    section.add "profileId", valid_582068
  var valid_582069 = path.getOrDefault("id")
  valid_582069 = validateParameter(valid_582069, JString, required = true,
                                 default = nil)
  if valid_582069 != nil:
    section.add "id", valid_582069
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582070 = query.getOrDefault("fields")
  valid_582070 = validateParameter(valid_582070, JString, required = false,
                                 default = nil)
  if valid_582070 != nil:
    section.add "fields", valid_582070
  var valid_582071 = query.getOrDefault("quotaUser")
  valid_582071 = validateParameter(valid_582071, JString, required = false,
                                 default = nil)
  if valid_582071 != nil:
    section.add "quotaUser", valid_582071
  var valid_582072 = query.getOrDefault("alt")
  valid_582072 = validateParameter(valid_582072, JString, required = false,
                                 default = newJString("json"))
  if valid_582072 != nil:
    section.add "alt", valid_582072
  var valid_582073 = query.getOrDefault("oauth_token")
  valid_582073 = validateParameter(valid_582073, JString, required = false,
                                 default = nil)
  if valid_582073 != nil:
    section.add "oauth_token", valid_582073
  var valid_582074 = query.getOrDefault("userIp")
  valid_582074 = validateParameter(valid_582074, JString, required = false,
                                 default = nil)
  if valid_582074 != nil:
    section.add "userIp", valid_582074
  var valid_582075 = query.getOrDefault("key")
  valid_582075 = validateParameter(valid_582075, JString, required = false,
                                 default = nil)
  if valid_582075 != nil:
    section.add "key", valid_582075
  var valid_582076 = query.getOrDefault("prettyPrint")
  valid_582076 = validateParameter(valid_582076, JBool, required = false,
                                 default = newJBool(true))
  if valid_582076 != nil:
    section.add "prettyPrint", valid_582076
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582077: Call_DfareportingFloodlightConfigurationsGet_582065;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one floodlight configuration by ID.
  ## 
  let valid = call_582077.validator(path, query, header, formData, body)
  let scheme = call_582077.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582077.url(scheme.get, call_582077.host, call_582077.base,
                         call_582077.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582077, url, valid)

proc call*(call_582078: Call_DfareportingFloodlightConfigurationsGet_582065;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightConfigurationsGet
  ## Gets one floodlight configuration by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Floodlight configuration ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582079 = newJObject()
  var query_582080 = newJObject()
  add(path_582079, "profileId", newJString(profileId))
  add(query_582080, "fields", newJString(fields))
  add(query_582080, "quotaUser", newJString(quotaUser))
  add(query_582080, "alt", newJString(alt))
  add(query_582080, "oauth_token", newJString(oauthToken))
  add(query_582080, "userIp", newJString(userIp))
  add(path_582079, "id", newJString(id))
  add(query_582080, "key", newJString(key))
  add(query_582080, "prettyPrint", newJBool(prettyPrint))
  result = call_582078.call(path_582079, query_582080, nil, nil, nil)

var dfareportingFloodlightConfigurationsGet* = Call_DfareportingFloodlightConfigurationsGet_582065(
    name: "dfareportingFloodlightConfigurationsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations/{id}",
    validator: validate_DfareportingFloodlightConfigurationsGet_582066,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightConfigurationsGet_582067,
    schemes: {Scheme.Https})
type
  Call_DfareportingLanguagesList_582081 = ref object of OpenApiRestCall_579437
proc url_DfareportingLanguagesList_582083(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/languages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLanguagesList_582082(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of languages.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582084 = path.getOrDefault("profileId")
  valid_582084 = validateParameter(valid_582084, JString, required = true,
                                 default = nil)
  if valid_582084 != nil:
    section.add "profileId", valid_582084
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582085 = query.getOrDefault("fields")
  valid_582085 = validateParameter(valid_582085, JString, required = false,
                                 default = nil)
  if valid_582085 != nil:
    section.add "fields", valid_582085
  var valid_582086 = query.getOrDefault("quotaUser")
  valid_582086 = validateParameter(valid_582086, JString, required = false,
                                 default = nil)
  if valid_582086 != nil:
    section.add "quotaUser", valid_582086
  var valid_582087 = query.getOrDefault("alt")
  valid_582087 = validateParameter(valid_582087, JString, required = false,
                                 default = newJString("json"))
  if valid_582087 != nil:
    section.add "alt", valid_582087
  var valid_582088 = query.getOrDefault("oauth_token")
  valid_582088 = validateParameter(valid_582088, JString, required = false,
                                 default = nil)
  if valid_582088 != nil:
    section.add "oauth_token", valid_582088
  var valid_582089 = query.getOrDefault("userIp")
  valid_582089 = validateParameter(valid_582089, JString, required = false,
                                 default = nil)
  if valid_582089 != nil:
    section.add "userIp", valid_582089
  var valid_582090 = query.getOrDefault("key")
  valid_582090 = validateParameter(valid_582090, JString, required = false,
                                 default = nil)
  if valid_582090 != nil:
    section.add "key", valid_582090
  var valid_582091 = query.getOrDefault("prettyPrint")
  valid_582091 = validateParameter(valid_582091, JBool, required = false,
                                 default = newJBool(true))
  if valid_582091 != nil:
    section.add "prettyPrint", valid_582091
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582092: Call_DfareportingLanguagesList_582081; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of languages.
  ## 
  let valid = call_582092.validator(path, query, header, formData, body)
  let scheme = call_582092.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582092.url(scheme.get, call_582092.host, call_582092.base,
                         call_582092.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582092, url, valid)

proc call*(call_582093: Call_DfareportingLanguagesList_582081; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingLanguagesList
  ## Retrieves a list of languages.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582094 = newJObject()
  var query_582095 = newJObject()
  add(path_582094, "profileId", newJString(profileId))
  add(query_582095, "fields", newJString(fields))
  add(query_582095, "quotaUser", newJString(quotaUser))
  add(query_582095, "alt", newJString(alt))
  add(query_582095, "oauth_token", newJString(oauthToken))
  add(query_582095, "userIp", newJString(userIp))
  add(query_582095, "key", newJString(key))
  add(query_582095, "prettyPrint", newJBool(prettyPrint))
  result = call_582093.call(path_582094, query_582095, nil, nil, nil)

var dfareportingLanguagesList* = Call_DfareportingLanguagesList_582081(
    name: "dfareportingLanguagesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/languages",
    validator: validate_DfareportingLanguagesList_582082,
    base: "/dfareporting/v2.7", url: url_DfareportingLanguagesList_582083,
    schemes: {Scheme.Https})
type
  Call_DfareportingMetrosList_582096 = ref object of OpenApiRestCall_579437
proc url_DfareportingMetrosList_582098(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/metros")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingMetrosList_582097(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of metros.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582099 = path.getOrDefault("profileId")
  valid_582099 = validateParameter(valid_582099, JString, required = true,
                                 default = nil)
  if valid_582099 != nil:
    section.add "profileId", valid_582099
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582100 = query.getOrDefault("fields")
  valid_582100 = validateParameter(valid_582100, JString, required = false,
                                 default = nil)
  if valid_582100 != nil:
    section.add "fields", valid_582100
  var valid_582101 = query.getOrDefault("quotaUser")
  valid_582101 = validateParameter(valid_582101, JString, required = false,
                                 default = nil)
  if valid_582101 != nil:
    section.add "quotaUser", valid_582101
  var valid_582102 = query.getOrDefault("alt")
  valid_582102 = validateParameter(valid_582102, JString, required = false,
                                 default = newJString("json"))
  if valid_582102 != nil:
    section.add "alt", valid_582102
  var valid_582103 = query.getOrDefault("oauth_token")
  valid_582103 = validateParameter(valid_582103, JString, required = false,
                                 default = nil)
  if valid_582103 != nil:
    section.add "oauth_token", valid_582103
  var valid_582104 = query.getOrDefault("userIp")
  valid_582104 = validateParameter(valid_582104, JString, required = false,
                                 default = nil)
  if valid_582104 != nil:
    section.add "userIp", valid_582104
  var valid_582105 = query.getOrDefault("key")
  valid_582105 = validateParameter(valid_582105, JString, required = false,
                                 default = nil)
  if valid_582105 != nil:
    section.add "key", valid_582105
  var valid_582106 = query.getOrDefault("prettyPrint")
  valid_582106 = validateParameter(valid_582106, JBool, required = false,
                                 default = newJBool(true))
  if valid_582106 != nil:
    section.add "prettyPrint", valid_582106
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582107: Call_DfareportingMetrosList_582096; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of metros.
  ## 
  let valid = call_582107.validator(path, query, header, formData, body)
  let scheme = call_582107.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582107.url(scheme.get, call_582107.host, call_582107.base,
                         call_582107.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582107, url, valid)

proc call*(call_582108: Call_DfareportingMetrosList_582096; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingMetrosList
  ## Retrieves a list of metros.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582109 = newJObject()
  var query_582110 = newJObject()
  add(path_582109, "profileId", newJString(profileId))
  add(query_582110, "fields", newJString(fields))
  add(query_582110, "quotaUser", newJString(quotaUser))
  add(query_582110, "alt", newJString(alt))
  add(query_582110, "oauth_token", newJString(oauthToken))
  add(query_582110, "userIp", newJString(userIp))
  add(query_582110, "key", newJString(key))
  add(query_582110, "prettyPrint", newJBool(prettyPrint))
  result = call_582108.call(path_582109, query_582110, nil, nil, nil)

var dfareportingMetrosList* = Call_DfareportingMetrosList_582096(
    name: "dfareportingMetrosList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/metros",
    validator: validate_DfareportingMetrosList_582097, base: "/dfareporting/v2.7",
    url: url_DfareportingMetrosList_582098, schemes: {Scheme.Https})
type
  Call_DfareportingMobileCarriersList_582111 = ref object of OpenApiRestCall_579437
proc url_DfareportingMobileCarriersList_582113(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/mobileCarriers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingMobileCarriersList_582112(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of mobile carriers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582114 = path.getOrDefault("profileId")
  valid_582114 = validateParameter(valid_582114, JString, required = true,
                                 default = nil)
  if valid_582114 != nil:
    section.add "profileId", valid_582114
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582115 = query.getOrDefault("fields")
  valid_582115 = validateParameter(valid_582115, JString, required = false,
                                 default = nil)
  if valid_582115 != nil:
    section.add "fields", valid_582115
  var valid_582116 = query.getOrDefault("quotaUser")
  valid_582116 = validateParameter(valid_582116, JString, required = false,
                                 default = nil)
  if valid_582116 != nil:
    section.add "quotaUser", valid_582116
  var valid_582117 = query.getOrDefault("alt")
  valid_582117 = validateParameter(valid_582117, JString, required = false,
                                 default = newJString("json"))
  if valid_582117 != nil:
    section.add "alt", valid_582117
  var valid_582118 = query.getOrDefault("oauth_token")
  valid_582118 = validateParameter(valid_582118, JString, required = false,
                                 default = nil)
  if valid_582118 != nil:
    section.add "oauth_token", valid_582118
  var valid_582119 = query.getOrDefault("userIp")
  valid_582119 = validateParameter(valid_582119, JString, required = false,
                                 default = nil)
  if valid_582119 != nil:
    section.add "userIp", valid_582119
  var valid_582120 = query.getOrDefault("key")
  valid_582120 = validateParameter(valid_582120, JString, required = false,
                                 default = nil)
  if valid_582120 != nil:
    section.add "key", valid_582120
  var valid_582121 = query.getOrDefault("prettyPrint")
  valid_582121 = validateParameter(valid_582121, JBool, required = false,
                                 default = newJBool(true))
  if valid_582121 != nil:
    section.add "prettyPrint", valid_582121
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582122: Call_DfareportingMobileCarriersList_582111; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of mobile carriers.
  ## 
  let valid = call_582122.validator(path, query, header, formData, body)
  let scheme = call_582122.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582122.url(scheme.get, call_582122.host, call_582122.base,
                         call_582122.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582122, url, valid)

proc call*(call_582123: Call_DfareportingMobileCarriersList_582111;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingMobileCarriersList
  ## Retrieves a list of mobile carriers.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582124 = newJObject()
  var query_582125 = newJObject()
  add(path_582124, "profileId", newJString(profileId))
  add(query_582125, "fields", newJString(fields))
  add(query_582125, "quotaUser", newJString(quotaUser))
  add(query_582125, "alt", newJString(alt))
  add(query_582125, "oauth_token", newJString(oauthToken))
  add(query_582125, "userIp", newJString(userIp))
  add(query_582125, "key", newJString(key))
  add(query_582125, "prettyPrint", newJBool(prettyPrint))
  result = call_582123.call(path_582124, query_582125, nil, nil, nil)

var dfareportingMobileCarriersList* = Call_DfareportingMobileCarriersList_582111(
    name: "dfareportingMobileCarriersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/mobileCarriers",
    validator: validate_DfareportingMobileCarriersList_582112,
    base: "/dfareporting/v2.7", url: url_DfareportingMobileCarriersList_582113,
    schemes: {Scheme.Https})
type
  Call_DfareportingMobileCarriersGet_582126 = ref object of OpenApiRestCall_579437
proc url_DfareportingMobileCarriersGet_582128(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/mobileCarriers/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingMobileCarriersGet_582127(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one mobile carrier by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Mobile carrier ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582129 = path.getOrDefault("profileId")
  valid_582129 = validateParameter(valid_582129, JString, required = true,
                                 default = nil)
  if valid_582129 != nil:
    section.add "profileId", valid_582129
  var valid_582130 = path.getOrDefault("id")
  valid_582130 = validateParameter(valid_582130, JString, required = true,
                                 default = nil)
  if valid_582130 != nil:
    section.add "id", valid_582130
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582131 = query.getOrDefault("fields")
  valid_582131 = validateParameter(valid_582131, JString, required = false,
                                 default = nil)
  if valid_582131 != nil:
    section.add "fields", valid_582131
  var valid_582132 = query.getOrDefault("quotaUser")
  valid_582132 = validateParameter(valid_582132, JString, required = false,
                                 default = nil)
  if valid_582132 != nil:
    section.add "quotaUser", valid_582132
  var valid_582133 = query.getOrDefault("alt")
  valid_582133 = validateParameter(valid_582133, JString, required = false,
                                 default = newJString("json"))
  if valid_582133 != nil:
    section.add "alt", valid_582133
  var valid_582134 = query.getOrDefault("oauth_token")
  valid_582134 = validateParameter(valid_582134, JString, required = false,
                                 default = nil)
  if valid_582134 != nil:
    section.add "oauth_token", valid_582134
  var valid_582135 = query.getOrDefault("userIp")
  valid_582135 = validateParameter(valid_582135, JString, required = false,
                                 default = nil)
  if valid_582135 != nil:
    section.add "userIp", valid_582135
  var valid_582136 = query.getOrDefault("key")
  valid_582136 = validateParameter(valid_582136, JString, required = false,
                                 default = nil)
  if valid_582136 != nil:
    section.add "key", valid_582136
  var valid_582137 = query.getOrDefault("prettyPrint")
  valid_582137 = validateParameter(valid_582137, JBool, required = false,
                                 default = newJBool(true))
  if valid_582137 != nil:
    section.add "prettyPrint", valid_582137
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582138: Call_DfareportingMobileCarriersGet_582126; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one mobile carrier by ID.
  ## 
  let valid = call_582138.validator(path, query, header, formData, body)
  let scheme = call_582138.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582138.url(scheme.get, call_582138.host, call_582138.base,
                         call_582138.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582138, url, valid)

proc call*(call_582139: Call_DfareportingMobileCarriersGet_582126;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingMobileCarriersGet
  ## Gets one mobile carrier by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Mobile carrier ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582140 = newJObject()
  var query_582141 = newJObject()
  add(path_582140, "profileId", newJString(profileId))
  add(query_582141, "fields", newJString(fields))
  add(query_582141, "quotaUser", newJString(quotaUser))
  add(query_582141, "alt", newJString(alt))
  add(query_582141, "oauth_token", newJString(oauthToken))
  add(query_582141, "userIp", newJString(userIp))
  add(path_582140, "id", newJString(id))
  add(query_582141, "key", newJString(key))
  add(query_582141, "prettyPrint", newJBool(prettyPrint))
  result = call_582139.call(path_582140, query_582141, nil, nil, nil)

var dfareportingMobileCarriersGet* = Call_DfareportingMobileCarriersGet_582126(
    name: "dfareportingMobileCarriersGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/mobileCarriers/{id}",
    validator: validate_DfareportingMobileCarriersGet_582127,
    base: "/dfareporting/v2.7", url: url_DfareportingMobileCarriersGet_582128,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemVersionsList_582142 = ref object of OpenApiRestCall_579437
proc url_DfareportingOperatingSystemVersionsList_582144(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystemVersions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemVersionsList_582143(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of operating system versions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582145 = path.getOrDefault("profileId")
  valid_582145 = validateParameter(valid_582145, JString, required = true,
                                 default = nil)
  if valid_582145 != nil:
    section.add "profileId", valid_582145
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582146 = query.getOrDefault("fields")
  valid_582146 = validateParameter(valid_582146, JString, required = false,
                                 default = nil)
  if valid_582146 != nil:
    section.add "fields", valid_582146
  var valid_582147 = query.getOrDefault("quotaUser")
  valid_582147 = validateParameter(valid_582147, JString, required = false,
                                 default = nil)
  if valid_582147 != nil:
    section.add "quotaUser", valid_582147
  var valid_582148 = query.getOrDefault("alt")
  valid_582148 = validateParameter(valid_582148, JString, required = false,
                                 default = newJString("json"))
  if valid_582148 != nil:
    section.add "alt", valid_582148
  var valid_582149 = query.getOrDefault("oauth_token")
  valid_582149 = validateParameter(valid_582149, JString, required = false,
                                 default = nil)
  if valid_582149 != nil:
    section.add "oauth_token", valid_582149
  var valid_582150 = query.getOrDefault("userIp")
  valid_582150 = validateParameter(valid_582150, JString, required = false,
                                 default = nil)
  if valid_582150 != nil:
    section.add "userIp", valid_582150
  var valid_582151 = query.getOrDefault("key")
  valid_582151 = validateParameter(valid_582151, JString, required = false,
                                 default = nil)
  if valid_582151 != nil:
    section.add "key", valid_582151
  var valid_582152 = query.getOrDefault("prettyPrint")
  valid_582152 = validateParameter(valid_582152, JBool, required = false,
                                 default = newJBool(true))
  if valid_582152 != nil:
    section.add "prettyPrint", valid_582152
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582153: Call_DfareportingOperatingSystemVersionsList_582142;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of operating system versions.
  ## 
  let valid = call_582153.validator(path, query, header, formData, body)
  let scheme = call_582153.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582153.url(scheme.get, call_582153.host, call_582153.base,
                         call_582153.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582153, url, valid)

proc call*(call_582154: Call_DfareportingOperatingSystemVersionsList_582142;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOperatingSystemVersionsList
  ## Retrieves a list of operating system versions.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582155 = newJObject()
  var query_582156 = newJObject()
  add(path_582155, "profileId", newJString(profileId))
  add(query_582156, "fields", newJString(fields))
  add(query_582156, "quotaUser", newJString(quotaUser))
  add(query_582156, "alt", newJString(alt))
  add(query_582156, "oauth_token", newJString(oauthToken))
  add(query_582156, "userIp", newJString(userIp))
  add(query_582156, "key", newJString(key))
  add(query_582156, "prettyPrint", newJBool(prettyPrint))
  result = call_582154.call(path_582155, query_582156, nil, nil, nil)

var dfareportingOperatingSystemVersionsList* = Call_DfareportingOperatingSystemVersionsList_582142(
    name: "dfareportingOperatingSystemVersionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystemVersions",
    validator: validate_DfareportingOperatingSystemVersionsList_582143,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemVersionsList_582144,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemVersionsGet_582157 = ref object of OpenApiRestCall_579437
proc url_DfareportingOperatingSystemVersionsGet_582159(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystemVersions/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemVersionsGet_582158(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one operating system version by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Operating system version ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582160 = path.getOrDefault("profileId")
  valid_582160 = validateParameter(valid_582160, JString, required = true,
                                 default = nil)
  if valid_582160 != nil:
    section.add "profileId", valid_582160
  var valid_582161 = path.getOrDefault("id")
  valid_582161 = validateParameter(valid_582161, JString, required = true,
                                 default = nil)
  if valid_582161 != nil:
    section.add "id", valid_582161
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582162 = query.getOrDefault("fields")
  valid_582162 = validateParameter(valid_582162, JString, required = false,
                                 default = nil)
  if valid_582162 != nil:
    section.add "fields", valid_582162
  var valid_582163 = query.getOrDefault("quotaUser")
  valid_582163 = validateParameter(valid_582163, JString, required = false,
                                 default = nil)
  if valid_582163 != nil:
    section.add "quotaUser", valid_582163
  var valid_582164 = query.getOrDefault("alt")
  valid_582164 = validateParameter(valid_582164, JString, required = false,
                                 default = newJString("json"))
  if valid_582164 != nil:
    section.add "alt", valid_582164
  var valid_582165 = query.getOrDefault("oauth_token")
  valid_582165 = validateParameter(valid_582165, JString, required = false,
                                 default = nil)
  if valid_582165 != nil:
    section.add "oauth_token", valid_582165
  var valid_582166 = query.getOrDefault("userIp")
  valid_582166 = validateParameter(valid_582166, JString, required = false,
                                 default = nil)
  if valid_582166 != nil:
    section.add "userIp", valid_582166
  var valid_582167 = query.getOrDefault("key")
  valid_582167 = validateParameter(valid_582167, JString, required = false,
                                 default = nil)
  if valid_582167 != nil:
    section.add "key", valid_582167
  var valid_582168 = query.getOrDefault("prettyPrint")
  valid_582168 = validateParameter(valid_582168, JBool, required = false,
                                 default = newJBool(true))
  if valid_582168 != nil:
    section.add "prettyPrint", valid_582168
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582169: Call_DfareportingOperatingSystemVersionsGet_582157;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one operating system version by ID.
  ## 
  let valid = call_582169.validator(path, query, header, formData, body)
  let scheme = call_582169.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582169.url(scheme.get, call_582169.host, call_582169.base,
                         call_582169.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582169, url, valid)

proc call*(call_582170: Call_DfareportingOperatingSystemVersionsGet_582157;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOperatingSystemVersionsGet
  ## Gets one operating system version by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Operating system version ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582171 = newJObject()
  var query_582172 = newJObject()
  add(path_582171, "profileId", newJString(profileId))
  add(query_582172, "fields", newJString(fields))
  add(query_582172, "quotaUser", newJString(quotaUser))
  add(query_582172, "alt", newJString(alt))
  add(query_582172, "oauth_token", newJString(oauthToken))
  add(query_582172, "userIp", newJString(userIp))
  add(path_582171, "id", newJString(id))
  add(query_582172, "key", newJString(key))
  add(query_582172, "prettyPrint", newJBool(prettyPrint))
  result = call_582170.call(path_582171, query_582172, nil, nil, nil)

var dfareportingOperatingSystemVersionsGet* = Call_DfareportingOperatingSystemVersionsGet_582157(
    name: "dfareportingOperatingSystemVersionsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystemVersions/{id}",
    validator: validate_DfareportingOperatingSystemVersionsGet_582158,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemVersionsGet_582159,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemsList_582173 = ref object of OpenApiRestCall_579437
proc url_DfareportingOperatingSystemsList_582175(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystems")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemsList_582174(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of operating systems.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582176 = path.getOrDefault("profileId")
  valid_582176 = validateParameter(valid_582176, JString, required = true,
                                 default = nil)
  if valid_582176 != nil:
    section.add "profileId", valid_582176
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582177 = query.getOrDefault("fields")
  valid_582177 = validateParameter(valid_582177, JString, required = false,
                                 default = nil)
  if valid_582177 != nil:
    section.add "fields", valid_582177
  var valid_582178 = query.getOrDefault("quotaUser")
  valid_582178 = validateParameter(valid_582178, JString, required = false,
                                 default = nil)
  if valid_582178 != nil:
    section.add "quotaUser", valid_582178
  var valid_582179 = query.getOrDefault("alt")
  valid_582179 = validateParameter(valid_582179, JString, required = false,
                                 default = newJString("json"))
  if valid_582179 != nil:
    section.add "alt", valid_582179
  var valid_582180 = query.getOrDefault("oauth_token")
  valid_582180 = validateParameter(valid_582180, JString, required = false,
                                 default = nil)
  if valid_582180 != nil:
    section.add "oauth_token", valid_582180
  var valid_582181 = query.getOrDefault("userIp")
  valid_582181 = validateParameter(valid_582181, JString, required = false,
                                 default = nil)
  if valid_582181 != nil:
    section.add "userIp", valid_582181
  var valid_582182 = query.getOrDefault("key")
  valid_582182 = validateParameter(valid_582182, JString, required = false,
                                 default = nil)
  if valid_582182 != nil:
    section.add "key", valid_582182
  var valid_582183 = query.getOrDefault("prettyPrint")
  valid_582183 = validateParameter(valid_582183, JBool, required = false,
                                 default = newJBool(true))
  if valid_582183 != nil:
    section.add "prettyPrint", valid_582183
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582184: Call_DfareportingOperatingSystemsList_582173;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of operating systems.
  ## 
  let valid = call_582184.validator(path, query, header, formData, body)
  let scheme = call_582184.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582184.url(scheme.get, call_582184.host, call_582184.base,
                         call_582184.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582184, url, valid)

proc call*(call_582185: Call_DfareportingOperatingSystemsList_582173;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOperatingSystemsList
  ## Retrieves a list of operating systems.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582186 = newJObject()
  var query_582187 = newJObject()
  add(path_582186, "profileId", newJString(profileId))
  add(query_582187, "fields", newJString(fields))
  add(query_582187, "quotaUser", newJString(quotaUser))
  add(query_582187, "alt", newJString(alt))
  add(query_582187, "oauth_token", newJString(oauthToken))
  add(query_582187, "userIp", newJString(userIp))
  add(query_582187, "key", newJString(key))
  add(query_582187, "prettyPrint", newJBool(prettyPrint))
  result = call_582185.call(path_582186, query_582187, nil, nil, nil)

var dfareportingOperatingSystemsList* = Call_DfareportingOperatingSystemsList_582173(
    name: "dfareportingOperatingSystemsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystems",
    validator: validate_DfareportingOperatingSystemsList_582174,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemsList_582175,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemsGet_582188 = ref object of OpenApiRestCall_579437
proc url_DfareportingOperatingSystemsGet_582190(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "dartId" in path, "`dartId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystems/"),
               (kind: VariableSegment, value: "dartId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemsGet_582189(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one operating system by DART ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   dartId: JString (required)
  ##         : Operating system DART ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582191 = path.getOrDefault("profileId")
  valid_582191 = validateParameter(valid_582191, JString, required = true,
                                 default = nil)
  if valid_582191 != nil:
    section.add "profileId", valid_582191
  var valid_582192 = path.getOrDefault("dartId")
  valid_582192 = validateParameter(valid_582192, JString, required = true,
                                 default = nil)
  if valid_582192 != nil:
    section.add "dartId", valid_582192
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582193 = query.getOrDefault("fields")
  valid_582193 = validateParameter(valid_582193, JString, required = false,
                                 default = nil)
  if valid_582193 != nil:
    section.add "fields", valid_582193
  var valid_582194 = query.getOrDefault("quotaUser")
  valid_582194 = validateParameter(valid_582194, JString, required = false,
                                 default = nil)
  if valid_582194 != nil:
    section.add "quotaUser", valid_582194
  var valid_582195 = query.getOrDefault("alt")
  valid_582195 = validateParameter(valid_582195, JString, required = false,
                                 default = newJString("json"))
  if valid_582195 != nil:
    section.add "alt", valid_582195
  var valid_582196 = query.getOrDefault("oauth_token")
  valid_582196 = validateParameter(valid_582196, JString, required = false,
                                 default = nil)
  if valid_582196 != nil:
    section.add "oauth_token", valid_582196
  var valid_582197 = query.getOrDefault("userIp")
  valid_582197 = validateParameter(valid_582197, JString, required = false,
                                 default = nil)
  if valid_582197 != nil:
    section.add "userIp", valid_582197
  var valid_582198 = query.getOrDefault("key")
  valid_582198 = validateParameter(valid_582198, JString, required = false,
                                 default = nil)
  if valid_582198 != nil:
    section.add "key", valid_582198
  var valid_582199 = query.getOrDefault("prettyPrint")
  valid_582199 = validateParameter(valid_582199, JBool, required = false,
                                 default = newJBool(true))
  if valid_582199 != nil:
    section.add "prettyPrint", valid_582199
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582200: Call_DfareportingOperatingSystemsGet_582188;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one operating system by DART ID.
  ## 
  let valid = call_582200.validator(path, query, header, formData, body)
  let scheme = call_582200.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582200.url(scheme.get, call_582200.host, call_582200.base,
                         call_582200.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582200, url, valid)

proc call*(call_582201: Call_DfareportingOperatingSystemsGet_582188;
          profileId: string; dartId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOperatingSystemsGet
  ## Gets one operating system by DART ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   dartId: string (required)
  ##         : Operating system DART ID.
  var path_582202 = newJObject()
  var query_582203 = newJObject()
  add(path_582202, "profileId", newJString(profileId))
  add(query_582203, "fields", newJString(fields))
  add(query_582203, "quotaUser", newJString(quotaUser))
  add(query_582203, "alt", newJString(alt))
  add(query_582203, "oauth_token", newJString(oauthToken))
  add(query_582203, "userIp", newJString(userIp))
  add(query_582203, "key", newJString(key))
  add(query_582203, "prettyPrint", newJBool(prettyPrint))
  add(path_582202, "dartId", newJString(dartId))
  result = call_582201.call(path_582202, query_582203, nil, nil, nil)

var dfareportingOperatingSystemsGet* = Call_DfareportingOperatingSystemsGet_582188(
    name: "dfareportingOperatingSystemsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystems/{dartId}",
    validator: validate_DfareportingOperatingSystemsGet_582189,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemsGet_582190,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsUpdate_582238 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementGroupsUpdate_582240(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsUpdate_582239(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582241 = path.getOrDefault("profileId")
  valid_582241 = validateParameter(valid_582241, JString, required = true,
                                 default = nil)
  if valid_582241 != nil:
    section.add "profileId", valid_582241
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582242 = query.getOrDefault("fields")
  valid_582242 = validateParameter(valid_582242, JString, required = false,
                                 default = nil)
  if valid_582242 != nil:
    section.add "fields", valid_582242
  var valid_582243 = query.getOrDefault("quotaUser")
  valid_582243 = validateParameter(valid_582243, JString, required = false,
                                 default = nil)
  if valid_582243 != nil:
    section.add "quotaUser", valid_582243
  var valid_582244 = query.getOrDefault("alt")
  valid_582244 = validateParameter(valid_582244, JString, required = false,
                                 default = newJString("json"))
  if valid_582244 != nil:
    section.add "alt", valid_582244
  var valid_582245 = query.getOrDefault("oauth_token")
  valid_582245 = validateParameter(valid_582245, JString, required = false,
                                 default = nil)
  if valid_582245 != nil:
    section.add "oauth_token", valid_582245
  var valid_582246 = query.getOrDefault("userIp")
  valid_582246 = validateParameter(valid_582246, JString, required = false,
                                 default = nil)
  if valid_582246 != nil:
    section.add "userIp", valid_582246
  var valid_582247 = query.getOrDefault("key")
  valid_582247 = validateParameter(valid_582247, JString, required = false,
                                 default = nil)
  if valid_582247 != nil:
    section.add "key", valid_582247
  var valid_582248 = query.getOrDefault("prettyPrint")
  valid_582248 = validateParameter(valid_582248, JBool, required = false,
                                 default = newJBool(true))
  if valid_582248 != nil:
    section.add "prettyPrint", valid_582248
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582250: Call_DfareportingPlacementGroupsUpdate_582238;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement group.
  ## 
  let valid = call_582250.validator(path, query, header, formData, body)
  let scheme = call_582250.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582250.url(scheme.get, call_582250.host, call_582250.base,
                         call_582250.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582250, url, valid)

proc call*(call_582251: Call_DfareportingPlacementGroupsUpdate_582238;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementGroupsUpdate
  ## Updates an existing placement group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582252 = newJObject()
  var query_582253 = newJObject()
  var body_582254 = newJObject()
  add(path_582252, "profileId", newJString(profileId))
  add(query_582253, "fields", newJString(fields))
  add(query_582253, "quotaUser", newJString(quotaUser))
  add(query_582253, "alt", newJString(alt))
  add(query_582253, "oauth_token", newJString(oauthToken))
  add(query_582253, "userIp", newJString(userIp))
  add(query_582253, "key", newJString(key))
  if body != nil:
    body_582254 = body
  add(query_582253, "prettyPrint", newJBool(prettyPrint))
  result = call_582251.call(path_582252, query_582253, nil, nil, body_582254)

var dfareportingPlacementGroupsUpdate* = Call_DfareportingPlacementGroupsUpdate_582238(
    name: "dfareportingPlacementGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsUpdate_582239,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsUpdate_582240,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsInsert_582255 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementGroupsInsert_582257(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsInsert_582256(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new placement group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582258 = path.getOrDefault("profileId")
  valid_582258 = validateParameter(valid_582258, JString, required = true,
                                 default = nil)
  if valid_582258 != nil:
    section.add "profileId", valid_582258
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582259 = query.getOrDefault("fields")
  valid_582259 = validateParameter(valid_582259, JString, required = false,
                                 default = nil)
  if valid_582259 != nil:
    section.add "fields", valid_582259
  var valid_582260 = query.getOrDefault("quotaUser")
  valid_582260 = validateParameter(valid_582260, JString, required = false,
                                 default = nil)
  if valid_582260 != nil:
    section.add "quotaUser", valid_582260
  var valid_582261 = query.getOrDefault("alt")
  valid_582261 = validateParameter(valid_582261, JString, required = false,
                                 default = newJString("json"))
  if valid_582261 != nil:
    section.add "alt", valid_582261
  var valid_582262 = query.getOrDefault("oauth_token")
  valid_582262 = validateParameter(valid_582262, JString, required = false,
                                 default = nil)
  if valid_582262 != nil:
    section.add "oauth_token", valid_582262
  var valid_582263 = query.getOrDefault("userIp")
  valid_582263 = validateParameter(valid_582263, JString, required = false,
                                 default = nil)
  if valid_582263 != nil:
    section.add "userIp", valid_582263
  var valid_582264 = query.getOrDefault("key")
  valid_582264 = validateParameter(valid_582264, JString, required = false,
                                 default = nil)
  if valid_582264 != nil:
    section.add "key", valid_582264
  var valid_582265 = query.getOrDefault("prettyPrint")
  valid_582265 = validateParameter(valid_582265, JBool, required = false,
                                 default = newJBool(true))
  if valid_582265 != nil:
    section.add "prettyPrint", valid_582265
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582267: Call_DfareportingPlacementGroupsInsert_582255;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new placement group.
  ## 
  let valid = call_582267.validator(path, query, header, formData, body)
  let scheme = call_582267.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582267.url(scheme.get, call_582267.host, call_582267.base,
                         call_582267.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582267, url, valid)

proc call*(call_582268: Call_DfareportingPlacementGroupsInsert_582255;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementGroupsInsert
  ## Inserts a new placement group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582269 = newJObject()
  var query_582270 = newJObject()
  var body_582271 = newJObject()
  add(path_582269, "profileId", newJString(profileId))
  add(query_582270, "fields", newJString(fields))
  add(query_582270, "quotaUser", newJString(quotaUser))
  add(query_582270, "alt", newJString(alt))
  add(query_582270, "oauth_token", newJString(oauthToken))
  add(query_582270, "userIp", newJString(userIp))
  add(query_582270, "key", newJString(key))
  if body != nil:
    body_582271 = body
  add(query_582270, "prettyPrint", newJBool(prettyPrint))
  result = call_582268.call(path_582269, query_582270, nil, nil, body_582271)

var dfareportingPlacementGroupsInsert* = Call_DfareportingPlacementGroupsInsert_582255(
    name: "dfareportingPlacementGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsInsert_582256,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsInsert_582257,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsList_582204 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementGroupsList_582206(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsList_582205(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of placement groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582207 = path.getOrDefault("profileId")
  valid_582207 = validateParameter(valid_582207, JString, required = true,
                                 default = nil)
  if valid_582207 != nil:
    section.add "profileId", valid_582207
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placement groups that are associated with these content categories.
  ##   alt: JString
  ##      : Data format for the response.
  ##   placementGroupType: JString
  ##                     : Select only placement groups belonging with this group type. A package is a simple group of placements that acts as a single pricing point for a group of tags. A roadblock is a group of placements that not only acts as a single pricing point but also assumes that all the tags in it will be served at the same time. A roadblock requires one of its assigned placements to be marked as primary for reporting.
  ##   searchString: JString
  ##               : Allows searching for placement groups by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placement groups with names like "placement group June 2015", "placement group May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementgroup" will match placement groups with name "my placementgroup", "placementgroup 2015", or simply "placementgroup".
  ##   minEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   siteIds: JArray
  ##          : Select only placement groups that are associated with these sites.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   maxStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   campaignIds: JArray
  ##              : Select only placement groups that belong to these campaigns.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: JBool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   maxEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placement groups with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only placement groups that belong to these advertisers.
  ##   minStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only placement groups that are associated with these directory sites.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   placementStrategyIds: JArray
  ##                       : Select only placement groups that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placement groups with these pricing types.
  section = newJObject()
  var valid_582208 = query.getOrDefault("fields")
  valid_582208 = validateParameter(valid_582208, JString, required = false,
                                 default = nil)
  if valid_582208 != nil:
    section.add "fields", valid_582208
  var valid_582209 = query.getOrDefault("pageToken")
  valid_582209 = validateParameter(valid_582209, JString, required = false,
                                 default = nil)
  if valid_582209 != nil:
    section.add "pageToken", valid_582209
  var valid_582210 = query.getOrDefault("quotaUser")
  valid_582210 = validateParameter(valid_582210, JString, required = false,
                                 default = nil)
  if valid_582210 != nil:
    section.add "quotaUser", valid_582210
  var valid_582211 = query.getOrDefault("sortField")
  valid_582211 = validateParameter(valid_582211, JString, required = false,
                                 default = newJString("ID"))
  if valid_582211 != nil:
    section.add "sortField", valid_582211
  var valid_582212 = query.getOrDefault("contentCategoryIds")
  valid_582212 = validateParameter(valid_582212, JArray, required = false,
                                 default = nil)
  if valid_582212 != nil:
    section.add "contentCategoryIds", valid_582212
  var valid_582213 = query.getOrDefault("alt")
  valid_582213 = validateParameter(valid_582213, JString, required = false,
                                 default = newJString("json"))
  if valid_582213 != nil:
    section.add "alt", valid_582213
  var valid_582214 = query.getOrDefault("placementGroupType")
  valid_582214 = validateParameter(valid_582214, JString, required = false,
                                 default = newJString("PLACEMENT_PACKAGE"))
  if valid_582214 != nil:
    section.add "placementGroupType", valid_582214
  var valid_582215 = query.getOrDefault("searchString")
  valid_582215 = validateParameter(valid_582215, JString, required = false,
                                 default = nil)
  if valid_582215 != nil:
    section.add "searchString", valid_582215
  var valid_582216 = query.getOrDefault("minEndDate")
  valid_582216 = validateParameter(valid_582216, JString, required = false,
                                 default = nil)
  if valid_582216 != nil:
    section.add "minEndDate", valid_582216
  var valid_582217 = query.getOrDefault("siteIds")
  valid_582217 = validateParameter(valid_582217, JArray, required = false,
                                 default = nil)
  if valid_582217 != nil:
    section.add "siteIds", valid_582217
  var valid_582218 = query.getOrDefault("oauth_token")
  valid_582218 = validateParameter(valid_582218, JString, required = false,
                                 default = nil)
  if valid_582218 != nil:
    section.add "oauth_token", valid_582218
  var valid_582219 = query.getOrDefault("maxStartDate")
  valid_582219 = validateParameter(valid_582219, JString, required = false,
                                 default = nil)
  if valid_582219 != nil:
    section.add "maxStartDate", valid_582219
  var valid_582220 = query.getOrDefault("campaignIds")
  valid_582220 = validateParameter(valid_582220, JArray, required = false,
                                 default = nil)
  if valid_582220 != nil:
    section.add "campaignIds", valid_582220
  var valid_582221 = query.getOrDefault("userIp")
  valid_582221 = validateParameter(valid_582221, JString, required = false,
                                 default = nil)
  if valid_582221 != nil:
    section.add "userIp", valid_582221
  var valid_582222 = query.getOrDefault("archived")
  valid_582222 = validateParameter(valid_582222, JBool, required = false, default = nil)
  if valid_582222 != nil:
    section.add "archived", valid_582222
  var valid_582223 = query.getOrDefault("maxEndDate")
  valid_582223 = validateParameter(valid_582223, JString, required = false,
                                 default = nil)
  if valid_582223 != nil:
    section.add "maxEndDate", valid_582223
  var valid_582224 = query.getOrDefault("maxResults")
  valid_582224 = validateParameter(valid_582224, JInt, required = false,
                                 default = newJInt(800))
  if valid_582224 != nil:
    section.add "maxResults", valid_582224
  var valid_582225 = query.getOrDefault("ids")
  valid_582225 = validateParameter(valid_582225, JArray, required = false,
                                 default = nil)
  if valid_582225 != nil:
    section.add "ids", valid_582225
  var valid_582226 = query.getOrDefault("key")
  valid_582226 = validateParameter(valid_582226, JString, required = false,
                                 default = nil)
  if valid_582226 != nil:
    section.add "key", valid_582226
  var valid_582227 = query.getOrDefault("advertiserIds")
  valid_582227 = validateParameter(valid_582227, JArray, required = false,
                                 default = nil)
  if valid_582227 != nil:
    section.add "advertiserIds", valid_582227
  var valid_582228 = query.getOrDefault("minStartDate")
  valid_582228 = validateParameter(valid_582228, JString, required = false,
                                 default = nil)
  if valid_582228 != nil:
    section.add "minStartDate", valid_582228
  var valid_582229 = query.getOrDefault("sortOrder")
  valid_582229 = validateParameter(valid_582229, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_582229 != nil:
    section.add "sortOrder", valid_582229
  var valid_582230 = query.getOrDefault("directorySiteIds")
  valid_582230 = validateParameter(valid_582230, JArray, required = false,
                                 default = nil)
  if valid_582230 != nil:
    section.add "directorySiteIds", valid_582230
  var valid_582231 = query.getOrDefault("prettyPrint")
  valid_582231 = validateParameter(valid_582231, JBool, required = false,
                                 default = newJBool(true))
  if valid_582231 != nil:
    section.add "prettyPrint", valid_582231
  var valid_582232 = query.getOrDefault("placementStrategyIds")
  valid_582232 = validateParameter(valid_582232, JArray, required = false,
                                 default = nil)
  if valid_582232 != nil:
    section.add "placementStrategyIds", valid_582232
  var valid_582233 = query.getOrDefault("pricingTypes")
  valid_582233 = validateParameter(valid_582233, JArray, required = false,
                                 default = nil)
  if valid_582233 != nil:
    section.add "pricingTypes", valid_582233
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582234: Call_DfareportingPlacementGroupsList_582204;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of placement groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_582234.validator(path, query, header, formData, body)
  let scheme = call_582234.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582234.url(scheme.get, call_582234.host, call_582234.base,
                         call_582234.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582234, url, valid)

proc call*(call_582235: Call_DfareportingPlacementGroupsList_582204;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID";
          contentCategoryIds: JsonNode = nil; alt: string = "json";
          placementGroupType: string = "PLACEMENT_PACKAGE";
          searchString: string = ""; minEndDate: string = ""; siteIds: JsonNode = nil;
          oauthToken: string = ""; maxStartDate: string = "";
          campaignIds: JsonNode = nil; userIp: string = ""; archived: bool = false;
          maxEndDate: string = ""; maxResults: int = 800; ids: JsonNode = nil;
          key: string = ""; advertiserIds: JsonNode = nil; minStartDate: string = "";
          sortOrder: string = "ASCENDING"; directorySiteIds: JsonNode = nil;
          prettyPrint: bool = true; placementStrategyIds: JsonNode = nil;
          pricingTypes: JsonNode = nil): Recallable =
  ## dfareportingPlacementGroupsList
  ## Retrieves a list of placement groups, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placement groups that are associated with these content categories.
  ##   alt: string
  ##      : Data format for the response.
  ##   placementGroupType: string
  ##                     : Select only placement groups belonging with this group type. A package is a simple group of placements that acts as a single pricing point for a group of tags. A roadblock is a group of placements that not only acts as a single pricing point but also assumes that all the tags in it will be served at the same time. A roadblock requires one of its assigned placements to be marked as primary for reporting.
  ##   searchString: string
  ##               : Allows searching for placement groups by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placement groups with names like "placement group June 2015", "placement group May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementgroup" will match placement groups with name "my placementgroup", "placementgroup 2015", or simply "placementgroup".
  ##   minEndDate: string
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   siteIds: JArray
  ##          : Select only placement groups that are associated with these sites.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   maxStartDate: string
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   campaignIds: JArray
  ##              : Select only placement groups that belong to these campaigns.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: bool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   maxEndDate: string
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placement groups with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only placement groups that belong to these advertisers.
  ##   minStartDate: string
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only placement groups that are associated with these directory sites.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   placementStrategyIds: JArray
  ##                       : Select only placement groups that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placement groups with these pricing types.
  var path_582236 = newJObject()
  var query_582237 = newJObject()
  add(path_582236, "profileId", newJString(profileId))
  add(query_582237, "fields", newJString(fields))
  add(query_582237, "pageToken", newJString(pageToken))
  add(query_582237, "quotaUser", newJString(quotaUser))
  add(query_582237, "sortField", newJString(sortField))
  if contentCategoryIds != nil:
    query_582237.add "contentCategoryIds", contentCategoryIds
  add(query_582237, "alt", newJString(alt))
  add(query_582237, "placementGroupType", newJString(placementGroupType))
  add(query_582237, "searchString", newJString(searchString))
  add(query_582237, "minEndDate", newJString(minEndDate))
  if siteIds != nil:
    query_582237.add "siteIds", siteIds
  add(query_582237, "oauth_token", newJString(oauthToken))
  add(query_582237, "maxStartDate", newJString(maxStartDate))
  if campaignIds != nil:
    query_582237.add "campaignIds", campaignIds
  add(query_582237, "userIp", newJString(userIp))
  add(query_582237, "archived", newJBool(archived))
  add(query_582237, "maxEndDate", newJString(maxEndDate))
  add(query_582237, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_582237.add "ids", ids
  add(query_582237, "key", newJString(key))
  if advertiserIds != nil:
    query_582237.add "advertiserIds", advertiserIds
  add(query_582237, "minStartDate", newJString(minStartDate))
  add(query_582237, "sortOrder", newJString(sortOrder))
  if directorySiteIds != nil:
    query_582237.add "directorySiteIds", directorySiteIds
  add(query_582237, "prettyPrint", newJBool(prettyPrint))
  if placementStrategyIds != nil:
    query_582237.add "placementStrategyIds", placementStrategyIds
  if pricingTypes != nil:
    query_582237.add "pricingTypes", pricingTypes
  result = call_582235.call(path_582236, query_582237, nil, nil, nil)

var dfareportingPlacementGroupsList* = Call_DfareportingPlacementGroupsList_582204(
    name: "dfareportingPlacementGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsList_582205,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsList_582206,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsPatch_582272 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementGroupsPatch_582274(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsPatch_582273(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582275 = path.getOrDefault("profileId")
  valid_582275 = validateParameter(valid_582275, JString, required = true,
                                 default = nil)
  if valid_582275 != nil:
    section.add "profileId", valid_582275
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Placement group ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582276 = query.getOrDefault("fields")
  valid_582276 = validateParameter(valid_582276, JString, required = false,
                                 default = nil)
  if valid_582276 != nil:
    section.add "fields", valid_582276
  var valid_582277 = query.getOrDefault("quotaUser")
  valid_582277 = validateParameter(valid_582277, JString, required = false,
                                 default = nil)
  if valid_582277 != nil:
    section.add "quotaUser", valid_582277
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_582278 = query.getOrDefault("id")
  valid_582278 = validateParameter(valid_582278, JString, required = true,
                                 default = nil)
  if valid_582278 != nil:
    section.add "id", valid_582278
  var valid_582279 = query.getOrDefault("alt")
  valid_582279 = validateParameter(valid_582279, JString, required = false,
                                 default = newJString("json"))
  if valid_582279 != nil:
    section.add "alt", valid_582279
  var valid_582280 = query.getOrDefault("oauth_token")
  valid_582280 = validateParameter(valid_582280, JString, required = false,
                                 default = nil)
  if valid_582280 != nil:
    section.add "oauth_token", valid_582280
  var valid_582281 = query.getOrDefault("userIp")
  valid_582281 = validateParameter(valid_582281, JString, required = false,
                                 default = nil)
  if valid_582281 != nil:
    section.add "userIp", valid_582281
  var valid_582282 = query.getOrDefault("key")
  valid_582282 = validateParameter(valid_582282, JString, required = false,
                                 default = nil)
  if valid_582282 != nil:
    section.add "key", valid_582282
  var valid_582283 = query.getOrDefault("prettyPrint")
  valid_582283 = validateParameter(valid_582283, JBool, required = false,
                                 default = newJBool(true))
  if valid_582283 != nil:
    section.add "prettyPrint", valid_582283
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582285: Call_DfareportingPlacementGroupsPatch_582272;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement group. This method supports patch semantics.
  ## 
  let valid = call_582285.validator(path, query, header, formData, body)
  let scheme = call_582285.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582285.url(scheme.get, call_582285.host, call_582285.base,
                         call_582285.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582285, url, valid)

proc call*(call_582286: Call_DfareportingPlacementGroupsPatch_582272;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementGroupsPatch
  ## Updates an existing placement group. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Placement group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582287 = newJObject()
  var query_582288 = newJObject()
  var body_582289 = newJObject()
  add(path_582287, "profileId", newJString(profileId))
  add(query_582288, "fields", newJString(fields))
  add(query_582288, "quotaUser", newJString(quotaUser))
  add(query_582288, "id", newJString(id))
  add(query_582288, "alt", newJString(alt))
  add(query_582288, "oauth_token", newJString(oauthToken))
  add(query_582288, "userIp", newJString(userIp))
  add(query_582288, "key", newJString(key))
  if body != nil:
    body_582289 = body
  add(query_582288, "prettyPrint", newJBool(prettyPrint))
  result = call_582286.call(path_582287, query_582288, nil, nil, body_582289)

var dfareportingPlacementGroupsPatch* = Call_DfareportingPlacementGroupsPatch_582272(
    name: "dfareportingPlacementGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsPatch_582273,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsPatch_582274,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsGet_582290 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementGroupsGet_582292(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsGet_582291(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one placement group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582293 = path.getOrDefault("profileId")
  valid_582293 = validateParameter(valid_582293, JString, required = true,
                                 default = nil)
  if valid_582293 != nil:
    section.add "profileId", valid_582293
  var valid_582294 = path.getOrDefault("id")
  valid_582294 = validateParameter(valid_582294, JString, required = true,
                                 default = nil)
  if valid_582294 != nil:
    section.add "id", valid_582294
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582295 = query.getOrDefault("fields")
  valid_582295 = validateParameter(valid_582295, JString, required = false,
                                 default = nil)
  if valid_582295 != nil:
    section.add "fields", valid_582295
  var valid_582296 = query.getOrDefault("quotaUser")
  valid_582296 = validateParameter(valid_582296, JString, required = false,
                                 default = nil)
  if valid_582296 != nil:
    section.add "quotaUser", valid_582296
  var valid_582297 = query.getOrDefault("alt")
  valid_582297 = validateParameter(valid_582297, JString, required = false,
                                 default = newJString("json"))
  if valid_582297 != nil:
    section.add "alt", valid_582297
  var valid_582298 = query.getOrDefault("oauth_token")
  valid_582298 = validateParameter(valid_582298, JString, required = false,
                                 default = nil)
  if valid_582298 != nil:
    section.add "oauth_token", valid_582298
  var valid_582299 = query.getOrDefault("userIp")
  valid_582299 = validateParameter(valid_582299, JString, required = false,
                                 default = nil)
  if valid_582299 != nil:
    section.add "userIp", valid_582299
  var valid_582300 = query.getOrDefault("key")
  valid_582300 = validateParameter(valid_582300, JString, required = false,
                                 default = nil)
  if valid_582300 != nil:
    section.add "key", valid_582300
  var valid_582301 = query.getOrDefault("prettyPrint")
  valid_582301 = validateParameter(valid_582301, JBool, required = false,
                                 default = newJBool(true))
  if valid_582301 != nil:
    section.add "prettyPrint", valid_582301
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582302: Call_DfareportingPlacementGroupsGet_582290; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one placement group by ID.
  ## 
  let valid = call_582302.validator(path, query, header, formData, body)
  let scheme = call_582302.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582302.url(scheme.get, call_582302.host, call_582302.base,
                         call_582302.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582302, url, valid)

proc call*(call_582303: Call_DfareportingPlacementGroupsGet_582290;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementGroupsGet
  ## Gets one placement group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Placement group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582304 = newJObject()
  var query_582305 = newJObject()
  add(path_582304, "profileId", newJString(profileId))
  add(query_582305, "fields", newJString(fields))
  add(query_582305, "quotaUser", newJString(quotaUser))
  add(query_582305, "alt", newJString(alt))
  add(query_582305, "oauth_token", newJString(oauthToken))
  add(query_582305, "userIp", newJString(userIp))
  add(path_582304, "id", newJString(id))
  add(query_582305, "key", newJString(key))
  add(query_582305, "prettyPrint", newJBool(prettyPrint))
  result = call_582303.call(path_582304, query_582305, nil, nil, nil)

var dfareportingPlacementGroupsGet* = Call_DfareportingPlacementGroupsGet_582290(
    name: "dfareportingPlacementGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups/{id}",
    validator: validate_DfareportingPlacementGroupsGet_582291,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsGet_582292,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesUpdate_582327 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementStrategiesUpdate_582329(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesUpdate_582328(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement strategy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582330 = path.getOrDefault("profileId")
  valid_582330 = validateParameter(valid_582330, JString, required = true,
                                 default = nil)
  if valid_582330 != nil:
    section.add "profileId", valid_582330
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582331 = query.getOrDefault("fields")
  valid_582331 = validateParameter(valid_582331, JString, required = false,
                                 default = nil)
  if valid_582331 != nil:
    section.add "fields", valid_582331
  var valid_582332 = query.getOrDefault("quotaUser")
  valid_582332 = validateParameter(valid_582332, JString, required = false,
                                 default = nil)
  if valid_582332 != nil:
    section.add "quotaUser", valid_582332
  var valid_582333 = query.getOrDefault("alt")
  valid_582333 = validateParameter(valid_582333, JString, required = false,
                                 default = newJString("json"))
  if valid_582333 != nil:
    section.add "alt", valid_582333
  var valid_582334 = query.getOrDefault("oauth_token")
  valid_582334 = validateParameter(valid_582334, JString, required = false,
                                 default = nil)
  if valid_582334 != nil:
    section.add "oauth_token", valid_582334
  var valid_582335 = query.getOrDefault("userIp")
  valid_582335 = validateParameter(valid_582335, JString, required = false,
                                 default = nil)
  if valid_582335 != nil:
    section.add "userIp", valid_582335
  var valid_582336 = query.getOrDefault("key")
  valid_582336 = validateParameter(valid_582336, JString, required = false,
                                 default = nil)
  if valid_582336 != nil:
    section.add "key", valid_582336
  var valid_582337 = query.getOrDefault("prettyPrint")
  valid_582337 = validateParameter(valid_582337, JBool, required = false,
                                 default = newJBool(true))
  if valid_582337 != nil:
    section.add "prettyPrint", valid_582337
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582339: Call_DfareportingPlacementStrategiesUpdate_582327;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement strategy.
  ## 
  let valid = call_582339.validator(path, query, header, formData, body)
  let scheme = call_582339.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582339.url(scheme.get, call_582339.host, call_582339.base,
                         call_582339.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582339, url, valid)

proc call*(call_582340: Call_DfareportingPlacementStrategiesUpdate_582327;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesUpdate
  ## Updates an existing placement strategy.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582341 = newJObject()
  var query_582342 = newJObject()
  var body_582343 = newJObject()
  add(path_582341, "profileId", newJString(profileId))
  add(query_582342, "fields", newJString(fields))
  add(query_582342, "quotaUser", newJString(quotaUser))
  add(query_582342, "alt", newJString(alt))
  add(query_582342, "oauth_token", newJString(oauthToken))
  add(query_582342, "userIp", newJString(userIp))
  add(query_582342, "key", newJString(key))
  if body != nil:
    body_582343 = body
  add(query_582342, "prettyPrint", newJBool(prettyPrint))
  result = call_582340.call(path_582341, query_582342, nil, nil, body_582343)

var dfareportingPlacementStrategiesUpdate* = Call_DfareportingPlacementStrategiesUpdate_582327(
    name: "dfareportingPlacementStrategiesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesUpdate_582328,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesUpdate_582329,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesInsert_582344 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementStrategiesInsert_582346(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesInsert_582345(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new placement strategy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582347 = path.getOrDefault("profileId")
  valid_582347 = validateParameter(valid_582347, JString, required = true,
                                 default = nil)
  if valid_582347 != nil:
    section.add "profileId", valid_582347
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582348 = query.getOrDefault("fields")
  valid_582348 = validateParameter(valid_582348, JString, required = false,
                                 default = nil)
  if valid_582348 != nil:
    section.add "fields", valid_582348
  var valid_582349 = query.getOrDefault("quotaUser")
  valid_582349 = validateParameter(valid_582349, JString, required = false,
                                 default = nil)
  if valid_582349 != nil:
    section.add "quotaUser", valid_582349
  var valid_582350 = query.getOrDefault("alt")
  valid_582350 = validateParameter(valid_582350, JString, required = false,
                                 default = newJString("json"))
  if valid_582350 != nil:
    section.add "alt", valid_582350
  var valid_582351 = query.getOrDefault("oauth_token")
  valid_582351 = validateParameter(valid_582351, JString, required = false,
                                 default = nil)
  if valid_582351 != nil:
    section.add "oauth_token", valid_582351
  var valid_582352 = query.getOrDefault("userIp")
  valid_582352 = validateParameter(valid_582352, JString, required = false,
                                 default = nil)
  if valid_582352 != nil:
    section.add "userIp", valid_582352
  var valid_582353 = query.getOrDefault("key")
  valid_582353 = validateParameter(valid_582353, JString, required = false,
                                 default = nil)
  if valid_582353 != nil:
    section.add "key", valid_582353
  var valid_582354 = query.getOrDefault("prettyPrint")
  valid_582354 = validateParameter(valid_582354, JBool, required = false,
                                 default = newJBool(true))
  if valid_582354 != nil:
    section.add "prettyPrint", valid_582354
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582356: Call_DfareportingPlacementStrategiesInsert_582344;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new placement strategy.
  ## 
  let valid = call_582356.validator(path, query, header, formData, body)
  let scheme = call_582356.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582356.url(scheme.get, call_582356.host, call_582356.base,
                         call_582356.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582356, url, valid)

proc call*(call_582357: Call_DfareportingPlacementStrategiesInsert_582344;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesInsert
  ## Inserts a new placement strategy.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582358 = newJObject()
  var query_582359 = newJObject()
  var body_582360 = newJObject()
  add(path_582358, "profileId", newJString(profileId))
  add(query_582359, "fields", newJString(fields))
  add(query_582359, "quotaUser", newJString(quotaUser))
  add(query_582359, "alt", newJString(alt))
  add(query_582359, "oauth_token", newJString(oauthToken))
  add(query_582359, "userIp", newJString(userIp))
  add(query_582359, "key", newJString(key))
  if body != nil:
    body_582360 = body
  add(query_582359, "prettyPrint", newJBool(prettyPrint))
  result = call_582357.call(path_582358, query_582359, nil, nil, body_582360)

var dfareportingPlacementStrategiesInsert* = Call_DfareportingPlacementStrategiesInsert_582344(
    name: "dfareportingPlacementStrategiesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesInsert_582345,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesInsert_582346,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesList_582306 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementStrategiesList_582308(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesList_582307(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of placement strategies, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582309 = path.getOrDefault("profileId")
  valid_582309 = validateParameter(valid_582309, JString, required = true,
                                 default = nil)
  if valid_582309 != nil:
    section.add "profileId", valid_582309
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "placementstrategy*2015" will return objects with names like "placementstrategy June 2015", "placementstrategy April 2015", or simply "placementstrategy 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementstrategy" will match objects with name "my placementstrategy", "placementstrategy 2015", or simply "placementstrategy".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placement strategies with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582310 = query.getOrDefault("fields")
  valid_582310 = validateParameter(valid_582310, JString, required = false,
                                 default = nil)
  if valid_582310 != nil:
    section.add "fields", valid_582310
  var valid_582311 = query.getOrDefault("pageToken")
  valid_582311 = validateParameter(valid_582311, JString, required = false,
                                 default = nil)
  if valid_582311 != nil:
    section.add "pageToken", valid_582311
  var valid_582312 = query.getOrDefault("quotaUser")
  valid_582312 = validateParameter(valid_582312, JString, required = false,
                                 default = nil)
  if valid_582312 != nil:
    section.add "quotaUser", valid_582312
  var valid_582313 = query.getOrDefault("sortField")
  valid_582313 = validateParameter(valid_582313, JString, required = false,
                                 default = newJString("ID"))
  if valid_582313 != nil:
    section.add "sortField", valid_582313
  var valid_582314 = query.getOrDefault("alt")
  valid_582314 = validateParameter(valid_582314, JString, required = false,
                                 default = newJString("json"))
  if valid_582314 != nil:
    section.add "alt", valid_582314
  var valid_582315 = query.getOrDefault("searchString")
  valid_582315 = validateParameter(valid_582315, JString, required = false,
                                 default = nil)
  if valid_582315 != nil:
    section.add "searchString", valid_582315
  var valid_582316 = query.getOrDefault("oauth_token")
  valid_582316 = validateParameter(valid_582316, JString, required = false,
                                 default = nil)
  if valid_582316 != nil:
    section.add "oauth_token", valid_582316
  var valid_582317 = query.getOrDefault("userIp")
  valid_582317 = validateParameter(valid_582317, JString, required = false,
                                 default = nil)
  if valid_582317 != nil:
    section.add "userIp", valid_582317
  var valid_582318 = query.getOrDefault("maxResults")
  valid_582318 = validateParameter(valid_582318, JInt, required = false,
                                 default = newJInt(1000))
  if valid_582318 != nil:
    section.add "maxResults", valid_582318
  var valid_582319 = query.getOrDefault("ids")
  valid_582319 = validateParameter(valid_582319, JArray, required = false,
                                 default = nil)
  if valid_582319 != nil:
    section.add "ids", valid_582319
  var valid_582320 = query.getOrDefault("key")
  valid_582320 = validateParameter(valid_582320, JString, required = false,
                                 default = nil)
  if valid_582320 != nil:
    section.add "key", valid_582320
  var valid_582321 = query.getOrDefault("sortOrder")
  valid_582321 = validateParameter(valid_582321, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_582321 != nil:
    section.add "sortOrder", valid_582321
  var valid_582322 = query.getOrDefault("prettyPrint")
  valid_582322 = validateParameter(valid_582322, JBool, required = false,
                                 default = newJBool(true))
  if valid_582322 != nil:
    section.add "prettyPrint", valid_582322
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582323: Call_DfareportingPlacementStrategiesList_582306;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of placement strategies, possibly filtered. This method supports paging.
  ## 
  let valid = call_582323.validator(path, query, header, formData, body)
  let scheme = call_582323.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582323.url(scheme.get, call_582323.host, call_582323.base,
                         call_582323.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582323, url, valid)

proc call*(call_582324: Call_DfareportingPlacementStrategiesList_582306;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesList
  ## Retrieves a list of placement strategies, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "placementstrategy*2015" will return objects with names like "placementstrategy June 2015", "placementstrategy April 2015", or simply "placementstrategy 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementstrategy" will match objects with name "my placementstrategy", "placementstrategy 2015", or simply "placementstrategy".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placement strategies with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582325 = newJObject()
  var query_582326 = newJObject()
  add(path_582325, "profileId", newJString(profileId))
  add(query_582326, "fields", newJString(fields))
  add(query_582326, "pageToken", newJString(pageToken))
  add(query_582326, "quotaUser", newJString(quotaUser))
  add(query_582326, "sortField", newJString(sortField))
  add(query_582326, "alt", newJString(alt))
  add(query_582326, "searchString", newJString(searchString))
  add(query_582326, "oauth_token", newJString(oauthToken))
  add(query_582326, "userIp", newJString(userIp))
  add(query_582326, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_582326.add "ids", ids
  add(query_582326, "key", newJString(key))
  add(query_582326, "sortOrder", newJString(sortOrder))
  add(query_582326, "prettyPrint", newJBool(prettyPrint))
  result = call_582324.call(path_582325, query_582326, nil, nil, nil)

var dfareportingPlacementStrategiesList* = Call_DfareportingPlacementStrategiesList_582306(
    name: "dfareportingPlacementStrategiesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesList_582307,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesList_582308,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesPatch_582361 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementStrategiesPatch_582363(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesPatch_582362(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement strategy. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582364 = path.getOrDefault("profileId")
  valid_582364 = validateParameter(valid_582364, JString, required = true,
                                 default = nil)
  if valid_582364 != nil:
    section.add "profileId", valid_582364
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Placement strategy ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582365 = query.getOrDefault("fields")
  valid_582365 = validateParameter(valid_582365, JString, required = false,
                                 default = nil)
  if valid_582365 != nil:
    section.add "fields", valid_582365
  var valid_582366 = query.getOrDefault("quotaUser")
  valid_582366 = validateParameter(valid_582366, JString, required = false,
                                 default = nil)
  if valid_582366 != nil:
    section.add "quotaUser", valid_582366
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_582367 = query.getOrDefault("id")
  valid_582367 = validateParameter(valid_582367, JString, required = true,
                                 default = nil)
  if valid_582367 != nil:
    section.add "id", valid_582367
  var valid_582368 = query.getOrDefault("alt")
  valid_582368 = validateParameter(valid_582368, JString, required = false,
                                 default = newJString("json"))
  if valid_582368 != nil:
    section.add "alt", valid_582368
  var valid_582369 = query.getOrDefault("oauth_token")
  valid_582369 = validateParameter(valid_582369, JString, required = false,
                                 default = nil)
  if valid_582369 != nil:
    section.add "oauth_token", valid_582369
  var valid_582370 = query.getOrDefault("userIp")
  valid_582370 = validateParameter(valid_582370, JString, required = false,
                                 default = nil)
  if valid_582370 != nil:
    section.add "userIp", valid_582370
  var valid_582371 = query.getOrDefault("key")
  valid_582371 = validateParameter(valid_582371, JString, required = false,
                                 default = nil)
  if valid_582371 != nil:
    section.add "key", valid_582371
  var valid_582372 = query.getOrDefault("prettyPrint")
  valid_582372 = validateParameter(valid_582372, JBool, required = false,
                                 default = newJBool(true))
  if valid_582372 != nil:
    section.add "prettyPrint", valid_582372
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582374: Call_DfareportingPlacementStrategiesPatch_582361;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement strategy. This method supports patch semantics.
  ## 
  let valid = call_582374.validator(path, query, header, formData, body)
  let scheme = call_582374.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582374.url(scheme.get, call_582374.host, call_582374.base,
                         call_582374.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582374, url, valid)

proc call*(call_582375: Call_DfareportingPlacementStrategiesPatch_582361;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesPatch
  ## Updates an existing placement strategy. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Placement strategy ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582376 = newJObject()
  var query_582377 = newJObject()
  var body_582378 = newJObject()
  add(path_582376, "profileId", newJString(profileId))
  add(query_582377, "fields", newJString(fields))
  add(query_582377, "quotaUser", newJString(quotaUser))
  add(query_582377, "id", newJString(id))
  add(query_582377, "alt", newJString(alt))
  add(query_582377, "oauth_token", newJString(oauthToken))
  add(query_582377, "userIp", newJString(userIp))
  add(query_582377, "key", newJString(key))
  if body != nil:
    body_582378 = body
  add(query_582377, "prettyPrint", newJBool(prettyPrint))
  result = call_582375.call(path_582376, query_582377, nil, nil, body_582378)

var dfareportingPlacementStrategiesPatch* = Call_DfareportingPlacementStrategiesPatch_582361(
    name: "dfareportingPlacementStrategiesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesPatch_582362,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesPatch_582363,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesGet_582379 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementStrategiesGet_582381(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesGet_582380(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one placement strategy by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement strategy ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582382 = path.getOrDefault("profileId")
  valid_582382 = validateParameter(valid_582382, JString, required = true,
                                 default = nil)
  if valid_582382 != nil:
    section.add "profileId", valid_582382
  var valid_582383 = path.getOrDefault("id")
  valid_582383 = validateParameter(valid_582383, JString, required = true,
                                 default = nil)
  if valid_582383 != nil:
    section.add "id", valid_582383
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582384 = query.getOrDefault("fields")
  valid_582384 = validateParameter(valid_582384, JString, required = false,
                                 default = nil)
  if valid_582384 != nil:
    section.add "fields", valid_582384
  var valid_582385 = query.getOrDefault("quotaUser")
  valid_582385 = validateParameter(valid_582385, JString, required = false,
                                 default = nil)
  if valid_582385 != nil:
    section.add "quotaUser", valid_582385
  var valid_582386 = query.getOrDefault("alt")
  valid_582386 = validateParameter(valid_582386, JString, required = false,
                                 default = newJString("json"))
  if valid_582386 != nil:
    section.add "alt", valid_582386
  var valid_582387 = query.getOrDefault("oauth_token")
  valid_582387 = validateParameter(valid_582387, JString, required = false,
                                 default = nil)
  if valid_582387 != nil:
    section.add "oauth_token", valid_582387
  var valid_582388 = query.getOrDefault("userIp")
  valid_582388 = validateParameter(valid_582388, JString, required = false,
                                 default = nil)
  if valid_582388 != nil:
    section.add "userIp", valid_582388
  var valid_582389 = query.getOrDefault("key")
  valid_582389 = validateParameter(valid_582389, JString, required = false,
                                 default = nil)
  if valid_582389 != nil:
    section.add "key", valid_582389
  var valid_582390 = query.getOrDefault("prettyPrint")
  valid_582390 = validateParameter(valid_582390, JBool, required = false,
                                 default = newJBool(true))
  if valid_582390 != nil:
    section.add "prettyPrint", valid_582390
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582391: Call_DfareportingPlacementStrategiesGet_582379;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one placement strategy by ID.
  ## 
  let valid = call_582391.validator(path, query, header, formData, body)
  let scheme = call_582391.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582391.url(scheme.get, call_582391.host, call_582391.base,
                         call_582391.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582391, url, valid)

proc call*(call_582392: Call_DfareportingPlacementStrategiesGet_582379;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesGet
  ## Gets one placement strategy by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Placement strategy ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582393 = newJObject()
  var query_582394 = newJObject()
  add(path_582393, "profileId", newJString(profileId))
  add(query_582394, "fields", newJString(fields))
  add(query_582394, "quotaUser", newJString(quotaUser))
  add(query_582394, "alt", newJString(alt))
  add(query_582394, "oauth_token", newJString(oauthToken))
  add(query_582394, "userIp", newJString(userIp))
  add(path_582393, "id", newJString(id))
  add(query_582394, "key", newJString(key))
  add(query_582394, "prettyPrint", newJBool(prettyPrint))
  result = call_582392.call(path_582393, query_582394, nil, nil, nil)

var dfareportingPlacementStrategiesGet* = Call_DfareportingPlacementStrategiesGet_582379(
    name: "dfareportingPlacementStrategiesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies/{id}",
    validator: validate_DfareportingPlacementStrategiesGet_582380,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesGet_582381,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesDelete_582395 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementStrategiesDelete_582397(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesDelete_582396(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing placement strategy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement strategy ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582398 = path.getOrDefault("profileId")
  valid_582398 = validateParameter(valid_582398, JString, required = true,
                                 default = nil)
  if valid_582398 != nil:
    section.add "profileId", valid_582398
  var valid_582399 = path.getOrDefault("id")
  valid_582399 = validateParameter(valid_582399, JString, required = true,
                                 default = nil)
  if valid_582399 != nil:
    section.add "id", valid_582399
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582400 = query.getOrDefault("fields")
  valid_582400 = validateParameter(valid_582400, JString, required = false,
                                 default = nil)
  if valid_582400 != nil:
    section.add "fields", valid_582400
  var valid_582401 = query.getOrDefault("quotaUser")
  valid_582401 = validateParameter(valid_582401, JString, required = false,
                                 default = nil)
  if valid_582401 != nil:
    section.add "quotaUser", valid_582401
  var valid_582402 = query.getOrDefault("alt")
  valid_582402 = validateParameter(valid_582402, JString, required = false,
                                 default = newJString("json"))
  if valid_582402 != nil:
    section.add "alt", valid_582402
  var valid_582403 = query.getOrDefault("oauth_token")
  valid_582403 = validateParameter(valid_582403, JString, required = false,
                                 default = nil)
  if valid_582403 != nil:
    section.add "oauth_token", valid_582403
  var valid_582404 = query.getOrDefault("userIp")
  valid_582404 = validateParameter(valid_582404, JString, required = false,
                                 default = nil)
  if valid_582404 != nil:
    section.add "userIp", valid_582404
  var valid_582405 = query.getOrDefault("key")
  valid_582405 = validateParameter(valid_582405, JString, required = false,
                                 default = nil)
  if valid_582405 != nil:
    section.add "key", valid_582405
  var valid_582406 = query.getOrDefault("prettyPrint")
  valid_582406 = validateParameter(valid_582406, JBool, required = false,
                                 default = newJBool(true))
  if valid_582406 != nil:
    section.add "prettyPrint", valid_582406
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582407: Call_DfareportingPlacementStrategiesDelete_582395;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing placement strategy.
  ## 
  let valid = call_582407.validator(path, query, header, formData, body)
  let scheme = call_582407.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582407.url(scheme.get, call_582407.host, call_582407.base,
                         call_582407.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582407, url, valid)

proc call*(call_582408: Call_DfareportingPlacementStrategiesDelete_582395;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesDelete
  ## Deletes an existing placement strategy.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Placement strategy ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582409 = newJObject()
  var query_582410 = newJObject()
  add(path_582409, "profileId", newJString(profileId))
  add(query_582410, "fields", newJString(fields))
  add(query_582410, "quotaUser", newJString(quotaUser))
  add(query_582410, "alt", newJString(alt))
  add(query_582410, "oauth_token", newJString(oauthToken))
  add(query_582410, "userIp", newJString(userIp))
  add(path_582409, "id", newJString(id))
  add(query_582410, "key", newJString(key))
  add(query_582410, "prettyPrint", newJBool(prettyPrint))
  result = call_582408.call(path_582409, query_582410, nil, nil, nil)

var dfareportingPlacementStrategiesDelete* = Call_DfareportingPlacementStrategiesDelete_582395(
    name: "dfareportingPlacementStrategiesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies/{id}",
    validator: validate_DfareportingPlacementStrategiesDelete_582396,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesDelete_582397,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsUpdate_582448 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementsUpdate_582450(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsUpdate_582449(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582451 = path.getOrDefault("profileId")
  valid_582451 = validateParameter(valid_582451, JString, required = true,
                                 default = nil)
  if valid_582451 != nil:
    section.add "profileId", valid_582451
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582452 = query.getOrDefault("fields")
  valid_582452 = validateParameter(valid_582452, JString, required = false,
                                 default = nil)
  if valid_582452 != nil:
    section.add "fields", valid_582452
  var valid_582453 = query.getOrDefault("quotaUser")
  valid_582453 = validateParameter(valid_582453, JString, required = false,
                                 default = nil)
  if valid_582453 != nil:
    section.add "quotaUser", valid_582453
  var valid_582454 = query.getOrDefault("alt")
  valid_582454 = validateParameter(valid_582454, JString, required = false,
                                 default = newJString("json"))
  if valid_582454 != nil:
    section.add "alt", valid_582454
  var valid_582455 = query.getOrDefault("oauth_token")
  valid_582455 = validateParameter(valid_582455, JString, required = false,
                                 default = nil)
  if valid_582455 != nil:
    section.add "oauth_token", valid_582455
  var valid_582456 = query.getOrDefault("userIp")
  valid_582456 = validateParameter(valid_582456, JString, required = false,
                                 default = nil)
  if valid_582456 != nil:
    section.add "userIp", valid_582456
  var valid_582457 = query.getOrDefault("key")
  valid_582457 = validateParameter(valid_582457, JString, required = false,
                                 default = nil)
  if valid_582457 != nil:
    section.add "key", valid_582457
  var valid_582458 = query.getOrDefault("prettyPrint")
  valid_582458 = validateParameter(valid_582458, JBool, required = false,
                                 default = newJBool(true))
  if valid_582458 != nil:
    section.add "prettyPrint", valid_582458
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582460: Call_DfareportingPlacementsUpdate_582448; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing placement.
  ## 
  let valid = call_582460.validator(path, query, header, formData, body)
  let scheme = call_582460.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582460.url(scheme.get, call_582460.host, call_582460.base,
                         call_582460.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582460, url, valid)

proc call*(call_582461: Call_DfareportingPlacementsUpdate_582448;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementsUpdate
  ## Updates an existing placement.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582462 = newJObject()
  var query_582463 = newJObject()
  var body_582464 = newJObject()
  add(path_582462, "profileId", newJString(profileId))
  add(query_582463, "fields", newJString(fields))
  add(query_582463, "quotaUser", newJString(quotaUser))
  add(query_582463, "alt", newJString(alt))
  add(query_582463, "oauth_token", newJString(oauthToken))
  add(query_582463, "userIp", newJString(userIp))
  add(query_582463, "key", newJString(key))
  if body != nil:
    body_582464 = body
  add(query_582463, "prettyPrint", newJBool(prettyPrint))
  result = call_582461.call(path_582462, query_582463, nil, nil, body_582464)

var dfareportingPlacementsUpdate* = Call_DfareportingPlacementsUpdate_582448(
    name: "dfareportingPlacementsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsUpdate_582449,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsUpdate_582450,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsInsert_582465 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementsInsert_582467(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsInsert_582466(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582468 = path.getOrDefault("profileId")
  valid_582468 = validateParameter(valid_582468, JString, required = true,
                                 default = nil)
  if valid_582468 != nil:
    section.add "profileId", valid_582468
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582469 = query.getOrDefault("fields")
  valid_582469 = validateParameter(valid_582469, JString, required = false,
                                 default = nil)
  if valid_582469 != nil:
    section.add "fields", valid_582469
  var valid_582470 = query.getOrDefault("quotaUser")
  valid_582470 = validateParameter(valid_582470, JString, required = false,
                                 default = nil)
  if valid_582470 != nil:
    section.add "quotaUser", valid_582470
  var valid_582471 = query.getOrDefault("alt")
  valid_582471 = validateParameter(valid_582471, JString, required = false,
                                 default = newJString("json"))
  if valid_582471 != nil:
    section.add "alt", valid_582471
  var valid_582472 = query.getOrDefault("oauth_token")
  valid_582472 = validateParameter(valid_582472, JString, required = false,
                                 default = nil)
  if valid_582472 != nil:
    section.add "oauth_token", valid_582472
  var valid_582473 = query.getOrDefault("userIp")
  valid_582473 = validateParameter(valid_582473, JString, required = false,
                                 default = nil)
  if valid_582473 != nil:
    section.add "userIp", valid_582473
  var valid_582474 = query.getOrDefault("key")
  valid_582474 = validateParameter(valid_582474, JString, required = false,
                                 default = nil)
  if valid_582474 != nil:
    section.add "key", valid_582474
  var valid_582475 = query.getOrDefault("prettyPrint")
  valid_582475 = validateParameter(valid_582475, JBool, required = false,
                                 default = newJBool(true))
  if valid_582475 != nil:
    section.add "prettyPrint", valid_582475
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582477: Call_DfareportingPlacementsInsert_582465; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new placement.
  ## 
  let valid = call_582477.validator(path, query, header, formData, body)
  let scheme = call_582477.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582477.url(scheme.get, call_582477.host, call_582477.base,
                         call_582477.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582477, url, valid)

proc call*(call_582478: Call_DfareportingPlacementsInsert_582465;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementsInsert
  ## Inserts a new placement.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582479 = newJObject()
  var query_582480 = newJObject()
  var body_582481 = newJObject()
  add(path_582479, "profileId", newJString(profileId))
  add(query_582480, "fields", newJString(fields))
  add(query_582480, "quotaUser", newJString(quotaUser))
  add(query_582480, "alt", newJString(alt))
  add(query_582480, "oauth_token", newJString(oauthToken))
  add(query_582480, "userIp", newJString(userIp))
  add(query_582480, "key", newJString(key))
  if body != nil:
    body_582481 = body
  add(query_582480, "prettyPrint", newJBool(prettyPrint))
  result = call_582478.call(path_582479, query_582480, nil, nil, body_582481)

var dfareportingPlacementsInsert* = Call_DfareportingPlacementsInsert_582465(
    name: "dfareportingPlacementsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsInsert_582466,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsInsert_582467,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsList_582411 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementsList_582413(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsList_582412(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of placements, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582414 = path.getOrDefault("profileId")
  valid_582414 = validateParameter(valid_582414, JString, required = true,
                                 default = nil)
  if valid_582414 != nil:
    section.add "profileId", valid_582414
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placements that are associated with these content categories.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for placements by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placements with names like "placement June 2015", "placement May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placement" will match placements with name "my placement", "placement 2015", or simply "placement".
  ##   minEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   sizeIds: JArray
  ##          : Select only placements that are associated with these sizes.
  ##   siteIds: JArray
  ##          : Select only placements that are associated with these sites.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   maxStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   campaignIds: JArray
  ##              : Select only placements that belong to these campaigns.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: JBool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   maxEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placements with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only placements that belong to these advertisers.
  ##   minStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   paymentSource: JString
  ##                : Select only placements with this payment source.
  ##   compatibilities: JArray
  ##                  : Select only placements that are associated with these compatibilities. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering in in-stream video ads developed with the VAST standard.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only placements that are associated with these directory sites.
  ##   groupIds: JArray
  ##           : Select only placements that belong to these placement groups.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   placementStrategyIds: JArray
  ##                       : Select only placements that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placements with these pricing types.
  section = newJObject()
  var valid_582415 = query.getOrDefault("fields")
  valid_582415 = validateParameter(valid_582415, JString, required = false,
                                 default = nil)
  if valid_582415 != nil:
    section.add "fields", valid_582415
  var valid_582416 = query.getOrDefault("pageToken")
  valid_582416 = validateParameter(valid_582416, JString, required = false,
                                 default = nil)
  if valid_582416 != nil:
    section.add "pageToken", valid_582416
  var valid_582417 = query.getOrDefault("quotaUser")
  valid_582417 = validateParameter(valid_582417, JString, required = false,
                                 default = nil)
  if valid_582417 != nil:
    section.add "quotaUser", valid_582417
  var valid_582418 = query.getOrDefault("sortField")
  valid_582418 = validateParameter(valid_582418, JString, required = false,
                                 default = newJString("ID"))
  if valid_582418 != nil:
    section.add "sortField", valid_582418
  var valid_582419 = query.getOrDefault("contentCategoryIds")
  valid_582419 = validateParameter(valid_582419, JArray, required = false,
                                 default = nil)
  if valid_582419 != nil:
    section.add "contentCategoryIds", valid_582419
  var valid_582420 = query.getOrDefault("alt")
  valid_582420 = validateParameter(valid_582420, JString, required = false,
                                 default = newJString("json"))
  if valid_582420 != nil:
    section.add "alt", valid_582420
  var valid_582421 = query.getOrDefault("searchString")
  valid_582421 = validateParameter(valid_582421, JString, required = false,
                                 default = nil)
  if valid_582421 != nil:
    section.add "searchString", valid_582421
  var valid_582422 = query.getOrDefault("minEndDate")
  valid_582422 = validateParameter(valid_582422, JString, required = false,
                                 default = nil)
  if valid_582422 != nil:
    section.add "minEndDate", valid_582422
  var valid_582423 = query.getOrDefault("sizeIds")
  valid_582423 = validateParameter(valid_582423, JArray, required = false,
                                 default = nil)
  if valid_582423 != nil:
    section.add "sizeIds", valid_582423
  var valid_582424 = query.getOrDefault("siteIds")
  valid_582424 = validateParameter(valid_582424, JArray, required = false,
                                 default = nil)
  if valid_582424 != nil:
    section.add "siteIds", valid_582424
  var valid_582425 = query.getOrDefault("oauth_token")
  valid_582425 = validateParameter(valid_582425, JString, required = false,
                                 default = nil)
  if valid_582425 != nil:
    section.add "oauth_token", valid_582425
  var valid_582426 = query.getOrDefault("maxStartDate")
  valid_582426 = validateParameter(valid_582426, JString, required = false,
                                 default = nil)
  if valid_582426 != nil:
    section.add "maxStartDate", valid_582426
  var valid_582427 = query.getOrDefault("campaignIds")
  valid_582427 = validateParameter(valid_582427, JArray, required = false,
                                 default = nil)
  if valid_582427 != nil:
    section.add "campaignIds", valid_582427
  var valid_582428 = query.getOrDefault("userIp")
  valid_582428 = validateParameter(valid_582428, JString, required = false,
                                 default = nil)
  if valid_582428 != nil:
    section.add "userIp", valid_582428
  var valid_582429 = query.getOrDefault("archived")
  valid_582429 = validateParameter(valid_582429, JBool, required = false, default = nil)
  if valid_582429 != nil:
    section.add "archived", valid_582429
  var valid_582430 = query.getOrDefault("maxEndDate")
  valid_582430 = validateParameter(valid_582430, JString, required = false,
                                 default = nil)
  if valid_582430 != nil:
    section.add "maxEndDate", valid_582430
  var valid_582431 = query.getOrDefault("maxResults")
  valid_582431 = validateParameter(valid_582431, JInt, required = false,
                                 default = newJInt(1000))
  if valid_582431 != nil:
    section.add "maxResults", valid_582431
  var valid_582432 = query.getOrDefault("ids")
  valid_582432 = validateParameter(valid_582432, JArray, required = false,
                                 default = nil)
  if valid_582432 != nil:
    section.add "ids", valid_582432
  var valid_582433 = query.getOrDefault("key")
  valid_582433 = validateParameter(valid_582433, JString, required = false,
                                 default = nil)
  if valid_582433 != nil:
    section.add "key", valid_582433
  var valid_582434 = query.getOrDefault("advertiserIds")
  valid_582434 = validateParameter(valid_582434, JArray, required = false,
                                 default = nil)
  if valid_582434 != nil:
    section.add "advertiserIds", valid_582434
  var valid_582435 = query.getOrDefault("minStartDate")
  valid_582435 = validateParameter(valid_582435, JString, required = false,
                                 default = nil)
  if valid_582435 != nil:
    section.add "minStartDate", valid_582435
  var valid_582436 = query.getOrDefault("paymentSource")
  valid_582436 = validateParameter(valid_582436, JString, required = false,
                                 default = newJString("PLACEMENT_AGENCY_PAID"))
  if valid_582436 != nil:
    section.add "paymentSource", valid_582436
  var valid_582437 = query.getOrDefault("compatibilities")
  valid_582437 = validateParameter(valid_582437, JArray, required = false,
                                 default = nil)
  if valid_582437 != nil:
    section.add "compatibilities", valid_582437
  var valid_582438 = query.getOrDefault("sortOrder")
  valid_582438 = validateParameter(valid_582438, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_582438 != nil:
    section.add "sortOrder", valid_582438
  var valid_582439 = query.getOrDefault("directorySiteIds")
  valid_582439 = validateParameter(valid_582439, JArray, required = false,
                                 default = nil)
  if valid_582439 != nil:
    section.add "directorySiteIds", valid_582439
  var valid_582440 = query.getOrDefault("groupIds")
  valid_582440 = validateParameter(valid_582440, JArray, required = false,
                                 default = nil)
  if valid_582440 != nil:
    section.add "groupIds", valid_582440
  var valid_582441 = query.getOrDefault("prettyPrint")
  valid_582441 = validateParameter(valid_582441, JBool, required = false,
                                 default = newJBool(true))
  if valid_582441 != nil:
    section.add "prettyPrint", valid_582441
  var valid_582442 = query.getOrDefault("placementStrategyIds")
  valid_582442 = validateParameter(valid_582442, JArray, required = false,
                                 default = nil)
  if valid_582442 != nil:
    section.add "placementStrategyIds", valid_582442
  var valid_582443 = query.getOrDefault("pricingTypes")
  valid_582443 = validateParameter(valid_582443, JArray, required = false,
                                 default = nil)
  if valid_582443 != nil:
    section.add "pricingTypes", valid_582443
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582444: Call_DfareportingPlacementsList_582411; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of placements, possibly filtered. This method supports paging.
  ## 
  let valid = call_582444.validator(path, query, header, formData, body)
  let scheme = call_582444.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582444.url(scheme.get, call_582444.host, call_582444.base,
                         call_582444.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582444, url, valid)

proc call*(call_582445: Call_DfareportingPlacementsList_582411; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; contentCategoryIds: JsonNode = nil;
          alt: string = "json"; searchString: string = ""; minEndDate: string = "";
          sizeIds: JsonNode = nil; siteIds: JsonNode = nil; oauthToken: string = "";
          maxStartDate: string = ""; campaignIds: JsonNode = nil; userIp: string = "";
          archived: bool = false; maxEndDate: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; advertiserIds: JsonNode = nil;
          minStartDate: string = "";
          paymentSource: string = "PLACEMENT_AGENCY_PAID";
          compatibilities: JsonNode = nil; sortOrder: string = "ASCENDING";
          directorySiteIds: JsonNode = nil; groupIds: JsonNode = nil;
          prettyPrint: bool = true; placementStrategyIds: JsonNode = nil;
          pricingTypes: JsonNode = nil): Recallable =
  ## dfareportingPlacementsList
  ## Retrieves a list of placements, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placements that are associated with these content categories.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for placements by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placements with names like "placement June 2015", "placement May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placement" will match placements with name "my placement", "placement 2015", or simply "placement".
  ##   minEndDate: string
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   sizeIds: JArray
  ##          : Select only placements that are associated with these sizes.
  ##   siteIds: JArray
  ##          : Select only placements that are associated with these sites.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   maxStartDate: string
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   campaignIds: JArray
  ##              : Select only placements that belong to these campaigns.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: bool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   maxEndDate: string
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placements with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only placements that belong to these advertisers.
  ##   minStartDate: string
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   paymentSource: string
  ##                : Select only placements with this payment source.
  ##   compatibilities: JArray
  ##                  : Select only placements that are associated with these compatibilities. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering in in-stream video ads developed with the VAST standard.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only placements that are associated with these directory sites.
  ##   groupIds: JArray
  ##           : Select only placements that belong to these placement groups.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   placementStrategyIds: JArray
  ##                       : Select only placements that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placements with these pricing types.
  var path_582446 = newJObject()
  var query_582447 = newJObject()
  add(path_582446, "profileId", newJString(profileId))
  add(query_582447, "fields", newJString(fields))
  add(query_582447, "pageToken", newJString(pageToken))
  add(query_582447, "quotaUser", newJString(quotaUser))
  add(query_582447, "sortField", newJString(sortField))
  if contentCategoryIds != nil:
    query_582447.add "contentCategoryIds", contentCategoryIds
  add(query_582447, "alt", newJString(alt))
  add(query_582447, "searchString", newJString(searchString))
  add(query_582447, "minEndDate", newJString(minEndDate))
  if sizeIds != nil:
    query_582447.add "sizeIds", sizeIds
  if siteIds != nil:
    query_582447.add "siteIds", siteIds
  add(query_582447, "oauth_token", newJString(oauthToken))
  add(query_582447, "maxStartDate", newJString(maxStartDate))
  if campaignIds != nil:
    query_582447.add "campaignIds", campaignIds
  add(query_582447, "userIp", newJString(userIp))
  add(query_582447, "archived", newJBool(archived))
  add(query_582447, "maxEndDate", newJString(maxEndDate))
  add(query_582447, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_582447.add "ids", ids
  add(query_582447, "key", newJString(key))
  if advertiserIds != nil:
    query_582447.add "advertiserIds", advertiserIds
  add(query_582447, "minStartDate", newJString(minStartDate))
  add(query_582447, "paymentSource", newJString(paymentSource))
  if compatibilities != nil:
    query_582447.add "compatibilities", compatibilities
  add(query_582447, "sortOrder", newJString(sortOrder))
  if directorySiteIds != nil:
    query_582447.add "directorySiteIds", directorySiteIds
  if groupIds != nil:
    query_582447.add "groupIds", groupIds
  add(query_582447, "prettyPrint", newJBool(prettyPrint))
  if placementStrategyIds != nil:
    query_582447.add "placementStrategyIds", placementStrategyIds
  if pricingTypes != nil:
    query_582447.add "pricingTypes", pricingTypes
  result = call_582445.call(path_582446, query_582447, nil, nil, nil)

var dfareportingPlacementsList* = Call_DfareportingPlacementsList_582411(
    name: "dfareportingPlacementsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsList_582412,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsList_582413,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsPatch_582482 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementsPatch_582484(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsPatch_582483(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582485 = path.getOrDefault("profileId")
  valid_582485 = validateParameter(valid_582485, JString, required = true,
                                 default = nil)
  if valid_582485 != nil:
    section.add "profileId", valid_582485
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Placement ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582486 = query.getOrDefault("fields")
  valid_582486 = validateParameter(valid_582486, JString, required = false,
                                 default = nil)
  if valid_582486 != nil:
    section.add "fields", valid_582486
  var valid_582487 = query.getOrDefault("quotaUser")
  valid_582487 = validateParameter(valid_582487, JString, required = false,
                                 default = nil)
  if valid_582487 != nil:
    section.add "quotaUser", valid_582487
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_582488 = query.getOrDefault("id")
  valid_582488 = validateParameter(valid_582488, JString, required = true,
                                 default = nil)
  if valid_582488 != nil:
    section.add "id", valid_582488
  var valid_582489 = query.getOrDefault("alt")
  valid_582489 = validateParameter(valid_582489, JString, required = false,
                                 default = newJString("json"))
  if valid_582489 != nil:
    section.add "alt", valid_582489
  var valid_582490 = query.getOrDefault("oauth_token")
  valid_582490 = validateParameter(valid_582490, JString, required = false,
                                 default = nil)
  if valid_582490 != nil:
    section.add "oauth_token", valid_582490
  var valid_582491 = query.getOrDefault("userIp")
  valid_582491 = validateParameter(valid_582491, JString, required = false,
                                 default = nil)
  if valid_582491 != nil:
    section.add "userIp", valid_582491
  var valid_582492 = query.getOrDefault("key")
  valid_582492 = validateParameter(valid_582492, JString, required = false,
                                 default = nil)
  if valid_582492 != nil:
    section.add "key", valid_582492
  var valid_582493 = query.getOrDefault("prettyPrint")
  valid_582493 = validateParameter(valid_582493, JBool, required = false,
                                 default = newJBool(true))
  if valid_582493 != nil:
    section.add "prettyPrint", valid_582493
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582495: Call_DfareportingPlacementsPatch_582482; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing placement. This method supports patch semantics.
  ## 
  let valid = call_582495.validator(path, query, header, formData, body)
  let scheme = call_582495.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582495.url(scheme.get, call_582495.host, call_582495.base,
                         call_582495.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582495, url, valid)

proc call*(call_582496: Call_DfareportingPlacementsPatch_582482; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementsPatch
  ## Updates an existing placement. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Placement ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582497 = newJObject()
  var query_582498 = newJObject()
  var body_582499 = newJObject()
  add(path_582497, "profileId", newJString(profileId))
  add(query_582498, "fields", newJString(fields))
  add(query_582498, "quotaUser", newJString(quotaUser))
  add(query_582498, "id", newJString(id))
  add(query_582498, "alt", newJString(alt))
  add(query_582498, "oauth_token", newJString(oauthToken))
  add(query_582498, "userIp", newJString(userIp))
  add(query_582498, "key", newJString(key))
  if body != nil:
    body_582499 = body
  add(query_582498, "prettyPrint", newJBool(prettyPrint))
  result = call_582496.call(path_582497, query_582498, nil, nil, body_582499)

var dfareportingPlacementsPatch* = Call_DfareportingPlacementsPatch_582482(
    name: "dfareportingPlacementsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsPatch_582483,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsPatch_582484,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsGeneratetags_582500 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementsGeneratetags_582502(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements/generatetags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsGeneratetags_582501(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Generates tags for a placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582503 = path.getOrDefault("profileId")
  valid_582503 = validateParameter(valid_582503, JString, required = true,
                                 default = nil)
  if valid_582503 != nil:
    section.add "profileId", valid_582503
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: JString
  ##             : Generate placements belonging to this campaign. This is a required field.
  ##   tagFormats: JArray
  ##             : Tag formats to generate for these placements.
  ## 
  ## Note: PLACEMENT_TAG_STANDARD can only be generated for 1x1 placements.
  ##   placementIds: JArray
  ##               : Generate tags for these placements.
  section = newJObject()
  var valid_582504 = query.getOrDefault("fields")
  valid_582504 = validateParameter(valid_582504, JString, required = false,
                                 default = nil)
  if valid_582504 != nil:
    section.add "fields", valid_582504
  var valid_582505 = query.getOrDefault("quotaUser")
  valid_582505 = validateParameter(valid_582505, JString, required = false,
                                 default = nil)
  if valid_582505 != nil:
    section.add "quotaUser", valid_582505
  var valid_582506 = query.getOrDefault("alt")
  valid_582506 = validateParameter(valid_582506, JString, required = false,
                                 default = newJString("json"))
  if valid_582506 != nil:
    section.add "alt", valid_582506
  var valid_582507 = query.getOrDefault("oauth_token")
  valid_582507 = validateParameter(valid_582507, JString, required = false,
                                 default = nil)
  if valid_582507 != nil:
    section.add "oauth_token", valid_582507
  var valid_582508 = query.getOrDefault("userIp")
  valid_582508 = validateParameter(valid_582508, JString, required = false,
                                 default = nil)
  if valid_582508 != nil:
    section.add "userIp", valid_582508
  var valid_582509 = query.getOrDefault("key")
  valid_582509 = validateParameter(valid_582509, JString, required = false,
                                 default = nil)
  if valid_582509 != nil:
    section.add "key", valid_582509
  var valid_582510 = query.getOrDefault("prettyPrint")
  valid_582510 = validateParameter(valid_582510, JBool, required = false,
                                 default = newJBool(true))
  if valid_582510 != nil:
    section.add "prettyPrint", valid_582510
  var valid_582511 = query.getOrDefault("campaignId")
  valid_582511 = validateParameter(valid_582511, JString, required = false,
                                 default = nil)
  if valid_582511 != nil:
    section.add "campaignId", valid_582511
  var valid_582512 = query.getOrDefault("tagFormats")
  valid_582512 = validateParameter(valid_582512, JArray, required = false,
                                 default = nil)
  if valid_582512 != nil:
    section.add "tagFormats", valid_582512
  var valid_582513 = query.getOrDefault("placementIds")
  valid_582513 = validateParameter(valid_582513, JArray, required = false,
                                 default = nil)
  if valid_582513 != nil:
    section.add "placementIds", valid_582513
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582514: Call_DfareportingPlacementsGeneratetags_582500;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Generates tags for a placement.
  ## 
  let valid = call_582514.validator(path, query, header, formData, body)
  let scheme = call_582514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582514.url(scheme.get, call_582514.host, call_582514.base,
                         call_582514.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582514, url, valid)

proc call*(call_582515: Call_DfareportingPlacementsGeneratetags_582500;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true; campaignId: string = "";
          tagFormats: JsonNode = nil; placementIds: JsonNode = nil): Recallable =
  ## dfareportingPlacementsGeneratetags
  ## Generates tags for a placement.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: string
  ##             : Generate placements belonging to this campaign. This is a required field.
  ##   tagFormats: JArray
  ##             : Tag formats to generate for these placements.
  ## 
  ## Note: PLACEMENT_TAG_STANDARD can only be generated for 1x1 placements.
  ##   placementIds: JArray
  ##               : Generate tags for these placements.
  var path_582516 = newJObject()
  var query_582517 = newJObject()
  add(path_582516, "profileId", newJString(profileId))
  add(query_582517, "fields", newJString(fields))
  add(query_582517, "quotaUser", newJString(quotaUser))
  add(query_582517, "alt", newJString(alt))
  add(query_582517, "oauth_token", newJString(oauthToken))
  add(query_582517, "userIp", newJString(userIp))
  add(query_582517, "key", newJString(key))
  add(query_582517, "prettyPrint", newJBool(prettyPrint))
  add(query_582517, "campaignId", newJString(campaignId))
  if tagFormats != nil:
    query_582517.add "tagFormats", tagFormats
  if placementIds != nil:
    query_582517.add "placementIds", placementIds
  result = call_582515.call(path_582516, query_582517, nil, nil, nil)

var dfareportingPlacementsGeneratetags* = Call_DfareportingPlacementsGeneratetags_582500(
    name: "dfareportingPlacementsGeneratetags", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placements/generatetags",
    validator: validate_DfareportingPlacementsGeneratetags_582501,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsGeneratetags_582502,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsGet_582518 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlacementsGet_582520(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsGet_582519(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one placement by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582521 = path.getOrDefault("profileId")
  valid_582521 = validateParameter(valid_582521, JString, required = true,
                                 default = nil)
  if valid_582521 != nil:
    section.add "profileId", valid_582521
  var valid_582522 = path.getOrDefault("id")
  valid_582522 = validateParameter(valid_582522, JString, required = true,
                                 default = nil)
  if valid_582522 != nil:
    section.add "id", valid_582522
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582523 = query.getOrDefault("fields")
  valid_582523 = validateParameter(valid_582523, JString, required = false,
                                 default = nil)
  if valid_582523 != nil:
    section.add "fields", valid_582523
  var valid_582524 = query.getOrDefault("quotaUser")
  valid_582524 = validateParameter(valid_582524, JString, required = false,
                                 default = nil)
  if valid_582524 != nil:
    section.add "quotaUser", valid_582524
  var valid_582525 = query.getOrDefault("alt")
  valid_582525 = validateParameter(valid_582525, JString, required = false,
                                 default = newJString("json"))
  if valid_582525 != nil:
    section.add "alt", valid_582525
  var valid_582526 = query.getOrDefault("oauth_token")
  valid_582526 = validateParameter(valid_582526, JString, required = false,
                                 default = nil)
  if valid_582526 != nil:
    section.add "oauth_token", valid_582526
  var valid_582527 = query.getOrDefault("userIp")
  valid_582527 = validateParameter(valid_582527, JString, required = false,
                                 default = nil)
  if valid_582527 != nil:
    section.add "userIp", valid_582527
  var valid_582528 = query.getOrDefault("key")
  valid_582528 = validateParameter(valid_582528, JString, required = false,
                                 default = nil)
  if valid_582528 != nil:
    section.add "key", valid_582528
  var valid_582529 = query.getOrDefault("prettyPrint")
  valid_582529 = validateParameter(valid_582529, JBool, required = false,
                                 default = newJBool(true))
  if valid_582529 != nil:
    section.add "prettyPrint", valid_582529
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582530: Call_DfareportingPlacementsGet_582518; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one placement by ID.
  ## 
  let valid = call_582530.validator(path, query, header, formData, body)
  let scheme = call_582530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582530.url(scheme.get, call_582530.host, call_582530.base,
                         call_582530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582530, url, valid)

proc call*(call_582531: Call_DfareportingPlacementsGet_582518; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementsGet
  ## Gets one placement by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Placement ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582532 = newJObject()
  var query_582533 = newJObject()
  add(path_582532, "profileId", newJString(profileId))
  add(query_582533, "fields", newJString(fields))
  add(query_582533, "quotaUser", newJString(quotaUser))
  add(query_582533, "alt", newJString(alt))
  add(query_582533, "oauth_token", newJString(oauthToken))
  add(query_582533, "userIp", newJString(userIp))
  add(path_582532, "id", newJString(id))
  add(query_582533, "key", newJString(key))
  add(query_582533, "prettyPrint", newJBool(prettyPrint))
  result = call_582531.call(path_582532, query_582533, nil, nil, nil)

var dfareportingPlacementsGet* = Call_DfareportingPlacementsGet_582518(
    name: "dfareportingPlacementsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placements/{id}",
    validator: validate_DfareportingPlacementsGet_582519,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsGet_582520,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlatformTypesList_582534 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlatformTypesList_582536(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/platformTypes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlatformTypesList_582535(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of platform types.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582537 = path.getOrDefault("profileId")
  valid_582537 = validateParameter(valid_582537, JString, required = true,
                                 default = nil)
  if valid_582537 != nil:
    section.add "profileId", valid_582537
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582538 = query.getOrDefault("fields")
  valid_582538 = validateParameter(valid_582538, JString, required = false,
                                 default = nil)
  if valid_582538 != nil:
    section.add "fields", valid_582538
  var valid_582539 = query.getOrDefault("quotaUser")
  valid_582539 = validateParameter(valid_582539, JString, required = false,
                                 default = nil)
  if valid_582539 != nil:
    section.add "quotaUser", valid_582539
  var valid_582540 = query.getOrDefault("alt")
  valid_582540 = validateParameter(valid_582540, JString, required = false,
                                 default = newJString("json"))
  if valid_582540 != nil:
    section.add "alt", valid_582540
  var valid_582541 = query.getOrDefault("oauth_token")
  valid_582541 = validateParameter(valid_582541, JString, required = false,
                                 default = nil)
  if valid_582541 != nil:
    section.add "oauth_token", valid_582541
  var valid_582542 = query.getOrDefault("userIp")
  valid_582542 = validateParameter(valid_582542, JString, required = false,
                                 default = nil)
  if valid_582542 != nil:
    section.add "userIp", valid_582542
  var valid_582543 = query.getOrDefault("key")
  valid_582543 = validateParameter(valid_582543, JString, required = false,
                                 default = nil)
  if valid_582543 != nil:
    section.add "key", valid_582543
  var valid_582544 = query.getOrDefault("prettyPrint")
  valid_582544 = validateParameter(valid_582544, JBool, required = false,
                                 default = newJBool(true))
  if valid_582544 != nil:
    section.add "prettyPrint", valid_582544
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582545: Call_DfareportingPlatformTypesList_582534; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of platform types.
  ## 
  let valid = call_582545.validator(path, query, header, formData, body)
  let scheme = call_582545.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582545.url(scheme.get, call_582545.host, call_582545.base,
                         call_582545.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582545, url, valid)

proc call*(call_582546: Call_DfareportingPlatformTypesList_582534;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlatformTypesList
  ## Retrieves a list of platform types.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582547 = newJObject()
  var query_582548 = newJObject()
  add(path_582547, "profileId", newJString(profileId))
  add(query_582548, "fields", newJString(fields))
  add(query_582548, "quotaUser", newJString(quotaUser))
  add(query_582548, "alt", newJString(alt))
  add(query_582548, "oauth_token", newJString(oauthToken))
  add(query_582548, "userIp", newJString(userIp))
  add(query_582548, "key", newJString(key))
  add(query_582548, "prettyPrint", newJBool(prettyPrint))
  result = call_582546.call(path_582547, query_582548, nil, nil, nil)

var dfareportingPlatformTypesList* = Call_DfareportingPlatformTypesList_582534(
    name: "dfareportingPlatformTypesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/platformTypes",
    validator: validate_DfareportingPlatformTypesList_582535,
    base: "/dfareporting/v2.7", url: url_DfareportingPlatformTypesList_582536,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlatformTypesGet_582549 = ref object of OpenApiRestCall_579437
proc url_DfareportingPlatformTypesGet_582551(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/platformTypes/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlatformTypesGet_582550(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one platform type by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Platform type ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582552 = path.getOrDefault("profileId")
  valid_582552 = validateParameter(valid_582552, JString, required = true,
                                 default = nil)
  if valid_582552 != nil:
    section.add "profileId", valid_582552
  var valid_582553 = path.getOrDefault("id")
  valid_582553 = validateParameter(valid_582553, JString, required = true,
                                 default = nil)
  if valid_582553 != nil:
    section.add "id", valid_582553
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582554 = query.getOrDefault("fields")
  valid_582554 = validateParameter(valid_582554, JString, required = false,
                                 default = nil)
  if valid_582554 != nil:
    section.add "fields", valid_582554
  var valid_582555 = query.getOrDefault("quotaUser")
  valid_582555 = validateParameter(valid_582555, JString, required = false,
                                 default = nil)
  if valid_582555 != nil:
    section.add "quotaUser", valid_582555
  var valid_582556 = query.getOrDefault("alt")
  valid_582556 = validateParameter(valid_582556, JString, required = false,
                                 default = newJString("json"))
  if valid_582556 != nil:
    section.add "alt", valid_582556
  var valid_582557 = query.getOrDefault("oauth_token")
  valid_582557 = validateParameter(valid_582557, JString, required = false,
                                 default = nil)
  if valid_582557 != nil:
    section.add "oauth_token", valid_582557
  var valid_582558 = query.getOrDefault("userIp")
  valid_582558 = validateParameter(valid_582558, JString, required = false,
                                 default = nil)
  if valid_582558 != nil:
    section.add "userIp", valid_582558
  var valid_582559 = query.getOrDefault("key")
  valid_582559 = validateParameter(valid_582559, JString, required = false,
                                 default = nil)
  if valid_582559 != nil:
    section.add "key", valid_582559
  var valid_582560 = query.getOrDefault("prettyPrint")
  valid_582560 = validateParameter(valid_582560, JBool, required = false,
                                 default = newJBool(true))
  if valid_582560 != nil:
    section.add "prettyPrint", valid_582560
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582561: Call_DfareportingPlatformTypesGet_582549; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one platform type by ID.
  ## 
  let valid = call_582561.validator(path, query, header, formData, body)
  let scheme = call_582561.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582561.url(scheme.get, call_582561.host, call_582561.base,
                         call_582561.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582561, url, valid)

proc call*(call_582562: Call_DfareportingPlatformTypesGet_582549;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlatformTypesGet
  ## Gets one platform type by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Platform type ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582563 = newJObject()
  var query_582564 = newJObject()
  add(path_582563, "profileId", newJString(profileId))
  add(query_582564, "fields", newJString(fields))
  add(query_582564, "quotaUser", newJString(quotaUser))
  add(query_582564, "alt", newJString(alt))
  add(query_582564, "oauth_token", newJString(oauthToken))
  add(query_582564, "userIp", newJString(userIp))
  add(path_582563, "id", newJString(id))
  add(query_582564, "key", newJString(key))
  add(query_582564, "prettyPrint", newJBool(prettyPrint))
  result = call_582562.call(path_582563, query_582564, nil, nil, nil)

var dfareportingPlatformTypesGet* = Call_DfareportingPlatformTypesGet_582549(
    name: "dfareportingPlatformTypesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/platformTypes/{id}",
    validator: validate_DfareportingPlatformTypesGet_582550,
    base: "/dfareporting/v2.7", url: url_DfareportingPlatformTypesGet_582551,
    schemes: {Scheme.Https})
type
  Call_DfareportingPostalCodesList_582565 = ref object of OpenApiRestCall_579437
proc url_DfareportingPostalCodesList_582567(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/postalCodes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPostalCodesList_582566(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of postal codes.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582568 = path.getOrDefault("profileId")
  valid_582568 = validateParameter(valid_582568, JString, required = true,
                                 default = nil)
  if valid_582568 != nil:
    section.add "profileId", valid_582568
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582569 = query.getOrDefault("fields")
  valid_582569 = validateParameter(valid_582569, JString, required = false,
                                 default = nil)
  if valid_582569 != nil:
    section.add "fields", valid_582569
  var valid_582570 = query.getOrDefault("quotaUser")
  valid_582570 = validateParameter(valid_582570, JString, required = false,
                                 default = nil)
  if valid_582570 != nil:
    section.add "quotaUser", valid_582570
  var valid_582571 = query.getOrDefault("alt")
  valid_582571 = validateParameter(valid_582571, JString, required = false,
                                 default = newJString("json"))
  if valid_582571 != nil:
    section.add "alt", valid_582571
  var valid_582572 = query.getOrDefault("oauth_token")
  valid_582572 = validateParameter(valid_582572, JString, required = false,
                                 default = nil)
  if valid_582572 != nil:
    section.add "oauth_token", valid_582572
  var valid_582573 = query.getOrDefault("userIp")
  valid_582573 = validateParameter(valid_582573, JString, required = false,
                                 default = nil)
  if valid_582573 != nil:
    section.add "userIp", valid_582573
  var valid_582574 = query.getOrDefault("key")
  valid_582574 = validateParameter(valid_582574, JString, required = false,
                                 default = nil)
  if valid_582574 != nil:
    section.add "key", valid_582574
  var valid_582575 = query.getOrDefault("prettyPrint")
  valid_582575 = validateParameter(valid_582575, JBool, required = false,
                                 default = newJBool(true))
  if valid_582575 != nil:
    section.add "prettyPrint", valid_582575
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582576: Call_DfareportingPostalCodesList_582565; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of postal codes.
  ## 
  let valid = call_582576.validator(path, query, header, formData, body)
  let scheme = call_582576.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582576.url(scheme.get, call_582576.host, call_582576.base,
                         call_582576.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582576, url, valid)

proc call*(call_582577: Call_DfareportingPostalCodesList_582565; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingPostalCodesList
  ## Retrieves a list of postal codes.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582578 = newJObject()
  var query_582579 = newJObject()
  add(path_582578, "profileId", newJString(profileId))
  add(query_582579, "fields", newJString(fields))
  add(query_582579, "quotaUser", newJString(quotaUser))
  add(query_582579, "alt", newJString(alt))
  add(query_582579, "oauth_token", newJString(oauthToken))
  add(query_582579, "userIp", newJString(userIp))
  add(query_582579, "key", newJString(key))
  add(query_582579, "prettyPrint", newJBool(prettyPrint))
  result = call_582577.call(path_582578, query_582579, nil, nil, nil)

var dfareportingPostalCodesList* = Call_DfareportingPostalCodesList_582565(
    name: "dfareportingPostalCodesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/postalCodes",
    validator: validate_DfareportingPostalCodesList_582566,
    base: "/dfareporting/v2.7", url: url_DfareportingPostalCodesList_582567,
    schemes: {Scheme.Https})
type
  Call_DfareportingPostalCodesGet_582580 = ref object of OpenApiRestCall_579437
proc url_DfareportingPostalCodesGet_582582(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "code" in path, "`code` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/postalCodes/"),
               (kind: VariableSegment, value: "code")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPostalCodesGet_582581(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one postal code by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   code: JString (required)
  ##       : Postal code ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582583 = path.getOrDefault("profileId")
  valid_582583 = validateParameter(valid_582583, JString, required = true,
                                 default = nil)
  if valid_582583 != nil:
    section.add "profileId", valid_582583
  var valid_582584 = path.getOrDefault("code")
  valid_582584 = validateParameter(valid_582584, JString, required = true,
                                 default = nil)
  if valid_582584 != nil:
    section.add "code", valid_582584
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582585 = query.getOrDefault("fields")
  valid_582585 = validateParameter(valid_582585, JString, required = false,
                                 default = nil)
  if valid_582585 != nil:
    section.add "fields", valid_582585
  var valid_582586 = query.getOrDefault("quotaUser")
  valid_582586 = validateParameter(valid_582586, JString, required = false,
                                 default = nil)
  if valid_582586 != nil:
    section.add "quotaUser", valid_582586
  var valid_582587 = query.getOrDefault("alt")
  valid_582587 = validateParameter(valid_582587, JString, required = false,
                                 default = newJString("json"))
  if valid_582587 != nil:
    section.add "alt", valid_582587
  var valid_582588 = query.getOrDefault("oauth_token")
  valid_582588 = validateParameter(valid_582588, JString, required = false,
                                 default = nil)
  if valid_582588 != nil:
    section.add "oauth_token", valid_582588
  var valid_582589 = query.getOrDefault("userIp")
  valid_582589 = validateParameter(valid_582589, JString, required = false,
                                 default = nil)
  if valid_582589 != nil:
    section.add "userIp", valid_582589
  var valid_582590 = query.getOrDefault("key")
  valid_582590 = validateParameter(valid_582590, JString, required = false,
                                 default = nil)
  if valid_582590 != nil:
    section.add "key", valid_582590
  var valid_582591 = query.getOrDefault("prettyPrint")
  valid_582591 = validateParameter(valid_582591, JBool, required = false,
                                 default = newJBool(true))
  if valid_582591 != nil:
    section.add "prettyPrint", valid_582591
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582592: Call_DfareportingPostalCodesGet_582580; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one postal code by ID.
  ## 
  let valid = call_582592.validator(path, query, header, formData, body)
  let scheme = call_582592.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582592.url(scheme.get, call_582592.host, call_582592.base,
                         call_582592.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582592, url, valid)

proc call*(call_582593: Call_DfareportingPostalCodesGet_582580; profileId: string;
          code: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingPostalCodesGet
  ## Gets one postal code by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   code: string (required)
  ##       : Postal code ID.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582594 = newJObject()
  var query_582595 = newJObject()
  add(path_582594, "profileId", newJString(profileId))
  add(query_582595, "fields", newJString(fields))
  add(query_582595, "quotaUser", newJString(quotaUser))
  add(query_582595, "alt", newJString(alt))
  add(query_582595, "oauth_token", newJString(oauthToken))
  add(query_582595, "userIp", newJString(userIp))
  add(query_582595, "key", newJString(key))
  add(path_582594, "code", newJString(code))
  add(query_582595, "prettyPrint", newJBool(prettyPrint))
  result = call_582593.call(path_582594, query_582595, nil, nil, nil)

var dfareportingPostalCodesGet* = Call_DfareportingPostalCodesGet_582580(
    name: "dfareportingPostalCodesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/postalCodes/{code}",
    validator: validate_DfareportingPostalCodesGet_582581,
    base: "/dfareporting/v2.7", url: url_DfareportingPostalCodesGet_582582,
    schemes: {Scheme.Https})
type
  Call_DfareportingProjectsList_582596 = ref object of OpenApiRestCall_579437
proc url_DfareportingProjectsList_582598(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingProjectsList_582597(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of projects, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582599 = path.getOrDefault("profileId")
  valid_582599 = validateParameter(valid_582599, JString, required = true,
                                 default = nil)
  if valid_582599 != nil:
    section.add "profileId", valid_582599
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for projects by name or ID. Wildcards (*) are allowed. For example, "project*2015" will return projects with names like "project June 2015", "project April 2015", or simply "project 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "project" will match projects with name "my project", "project 2015", or simply "project".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only projects with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only projects with these advertiser IDs.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582600 = query.getOrDefault("fields")
  valid_582600 = validateParameter(valid_582600, JString, required = false,
                                 default = nil)
  if valid_582600 != nil:
    section.add "fields", valid_582600
  var valid_582601 = query.getOrDefault("pageToken")
  valid_582601 = validateParameter(valid_582601, JString, required = false,
                                 default = nil)
  if valid_582601 != nil:
    section.add "pageToken", valid_582601
  var valid_582602 = query.getOrDefault("quotaUser")
  valid_582602 = validateParameter(valid_582602, JString, required = false,
                                 default = nil)
  if valid_582602 != nil:
    section.add "quotaUser", valid_582602
  var valid_582603 = query.getOrDefault("sortField")
  valid_582603 = validateParameter(valid_582603, JString, required = false,
                                 default = newJString("ID"))
  if valid_582603 != nil:
    section.add "sortField", valid_582603
  var valid_582604 = query.getOrDefault("alt")
  valid_582604 = validateParameter(valid_582604, JString, required = false,
                                 default = newJString("json"))
  if valid_582604 != nil:
    section.add "alt", valid_582604
  var valid_582605 = query.getOrDefault("searchString")
  valid_582605 = validateParameter(valid_582605, JString, required = false,
                                 default = nil)
  if valid_582605 != nil:
    section.add "searchString", valid_582605
  var valid_582606 = query.getOrDefault("oauth_token")
  valid_582606 = validateParameter(valid_582606, JString, required = false,
                                 default = nil)
  if valid_582606 != nil:
    section.add "oauth_token", valid_582606
  var valid_582607 = query.getOrDefault("userIp")
  valid_582607 = validateParameter(valid_582607, JString, required = false,
                                 default = nil)
  if valid_582607 != nil:
    section.add "userIp", valid_582607
  var valid_582608 = query.getOrDefault("maxResults")
  valid_582608 = validateParameter(valid_582608, JInt, required = false,
                                 default = newJInt(1000))
  if valid_582608 != nil:
    section.add "maxResults", valid_582608
  var valid_582609 = query.getOrDefault("ids")
  valid_582609 = validateParameter(valid_582609, JArray, required = false,
                                 default = nil)
  if valid_582609 != nil:
    section.add "ids", valid_582609
  var valid_582610 = query.getOrDefault("key")
  valid_582610 = validateParameter(valid_582610, JString, required = false,
                                 default = nil)
  if valid_582610 != nil:
    section.add "key", valid_582610
  var valid_582611 = query.getOrDefault("advertiserIds")
  valid_582611 = validateParameter(valid_582611, JArray, required = false,
                                 default = nil)
  if valid_582611 != nil:
    section.add "advertiserIds", valid_582611
  var valid_582612 = query.getOrDefault("sortOrder")
  valid_582612 = validateParameter(valid_582612, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_582612 != nil:
    section.add "sortOrder", valid_582612
  var valid_582613 = query.getOrDefault("prettyPrint")
  valid_582613 = validateParameter(valid_582613, JBool, required = false,
                                 default = newJBool(true))
  if valid_582613 != nil:
    section.add "prettyPrint", valid_582613
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582614: Call_DfareportingProjectsList_582596; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of projects, possibly filtered. This method supports paging.
  ## 
  let valid = call_582614.validator(path, query, header, formData, body)
  let scheme = call_582614.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582614.url(scheme.get, call_582614.host, call_582614.base,
                         call_582614.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582614, url, valid)

proc call*(call_582615: Call_DfareportingProjectsList_582596; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; searchString: string = "";
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; advertiserIds: JsonNode = nil;
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingProjectsList
  ## Retrieves a list of projects, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for projects by name or ID. Wildcards (*) are allowed. For example, "project*2015" will return projects with names like "project June 2015", "project April 2015", or simply "project 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "project" will match projects with name "my project", "project 2015", or simply "project".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only projects with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only projects with these advertiser IDs.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582616 = newJObject()
  var query_582617 = newJObject()
  add(path_582616, "profileId", newJString(profileId))
  add(query_582617, "fields", newJString(fields))
  add(query_582617, "pageToken", newJString(pageToken))
  add(query_582617, "quotaUser", newJString(quotaUser))
  add(query_582617, "sortField", newJString(sortField))
  add(query_582617, "alt", newJString(alt))
  add(query_582617, "searchString", newJString(searchString))
  add(query_582617, "oauth_token", newJString(oauthToken))
  add(query_582617, "userIp", newJString(userIp))
  add(query_582617, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_582617.add "ids", ids
  add(query_582617, "key", newJString(key))
  if advertiserIds != nil:
    query_582617.add "advertiserIds", advertiserIds
  add(query_582617, "sortOrder", newJString(sortOrder))
  add(query_582617, "prettyPrint", newJBool(prettyPrint))
  result = call_582615.call(path_582616, query_582617, nil, nil, nil)

var dfareportingProjectsList* = Call_DfareportingProjectsList_582596(
    name: "dfareportingProjectsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects",
    validator: validate_DfareportingProjectsList_582597,
    base: "/dfareporting/v2.7", url: url_DfareportingProjectsList_582598,
    schemes: {Scheme.Https})
type
  Call_DfareportingProjectsGet_582618 = ref object of OpenApiRestCall_579437
proc url_DfareportingProjectsGet_582620(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingProjectsGet_582619(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one project by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Project ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582621 = path.getOrDefault("profileId")
  valid_582621 = validateParameter(valid_582621, JString, required = true,
                                 default = nil)
  if valid_582621 != nil:
    section.add "profileId", valid_582621
  var valid_582622 = path.getOrDefault("id")
  valid_582622 = validateParameter(valid_582622, JString, required = true,
                                 default = nil)
  if valid_582622 != nil:
    section.add "id", valid_582622
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582623 = query.getOrDefault("fields")
  valid_582623 = validateParameter(valid_582623, JString, required = false,
                                 default = nil)
  if valid_582623 != nil:
    section.add "fields", valid_582623
  var valid_582624 = query.getOrDefault("quotaUser")
  valid_582624 = validateParameter(valid_582624, JString, required = false,
                                 default = nil)
  if valid_582624 != nil:
    section.add "quotaUser", valid_582624
  var valid_582625 = query.getOrDefault("alt")
  valid_582625 = validateParameter(valid_582625, JString, required = false,
                                 default = newJString("json"))
  if valid_582625 != nil:
    section.add "alt", valid_582625
  var valid_582626 = query.getOrDefault("oauth_token")
  valid_582626 = validateParameter(valid_582626, JString, required = false,
                                 default = nil)
  if valid_582626 != nil:
    section.add "oauth_token", valid_582626
  var valid_582627 = query.getOrDefault("userIp")
  valid_582627 = validateParameter(valid_582627, JString, required = false,
                                 default = nil)
  if valid_582627 != nil:
    section.add "userIp", valid_582627
  var valid_582628 = query.getOrDefault("key")
  valid_582628 = validateParameter(valid_582628, JString, required = false,
                                 default = nil)
  if valid_582628 != nil:
    section.add "key", valid_582628
  var valid_582629 = query.getOrDefault("prettyPrint")
  valid_582629 = validateParameter(valid_582629, JBool, required = false,
                                 default = newJBool(true))
  if valid_582629 != nil:
    section.add "prettyPrint", valid_582629
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582630: Call_DfareportingProjectsGet_582618; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one project by ID.
  ## 
  let valid = call_582630.validator(path, query, header, formData, body)
  let scheme = call_582630.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582630.url(scheme.get, call_582630.host, call_582630.base,
                         call_582630.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582630, url, valid)

proc call*(call_582631: Call_DfareportingProjectsGet_582618; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingProjectsGet
  ## Gets one project by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Project ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582632 = newJObject()
  var query_582633 = newJObject()
  add(path_582632, "profileId", newJString(profileId))
  add(query_582633, "fields", newJString(fields))
  add(query_582633, "quotaUser", newJString(quotaUser))
  add(query_582633, "alt", newJString(alt))
  add(query_582633, "oauth_token", newJString(oauthToken))
  add(query_582633, "userIp", newJString(userIp))
  add(path_582632, "id", newJString(id))
  add(query_582633, "key", newJString(key))
  add(query_582633, "prettyPrint", newJBool(prettyPrint))
  result = call_582631.call(path_582632, query_582633, nil, nil, nil)

var dfareportingProjectsGet* = Call_DfareportingProjectsGet_582618(
    name: "dfareportingProjectsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects/{id}",
    validator: validate_DfareportingProjectsGet_582619,
    base: "/dfareporting/v2.7", url: url_DfareportingProjectsGet_582620,
    schemes: {Scheme.Https})
type
  Call_DfareportingInventoryItemsList_582634 = ref object of OpenApiRestCall_579437
proc url_DfareportingInventoryItemsList_582636(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/inventoryItems")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingInventoryItemsList_582635(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of inventory items, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582637 = path.getOrDefault("profileId")
  valid_582637 = validateParameter(valid_582637, JString, required = true,
                                 default = nil)
  if valid_582637 != nil:
    section.add "profileId", valid_582637
  var valid_582638 = path.getOrDefault("projectId")
  valid_582638 = validateParameter(valid_582638, JString, required = true,
                                 default = nil)
  if valid_582638 != nil:
    section.add "projectId", valid_582638
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   inPlan: JBool
  ##         : Select only inventory items that are in plan.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   orderId: JArray
  ##          : Select only inventory items that belong to specified orders.
  ##   type: JString
  ##       : Select only inventory items with this type.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only inventory items that are associated with these sites.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only inventory items with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582639 = query.getOrDefault("fields")
  valid_582639 = validateParameter(valid_582639, JString, required = false,
                                 default = nil)
  if valid_582639 != nil:
    section.add "fields", valid_582639
  var valid_582640 = query.getOrDefault("inPlan")
  valid_582640 = validateParameter(valid_582640, JBool, required = false, default = nil)
  if valid_582640 != nil:
    section.add "inPlan", valid_582640
  var valid_582641 = query.getOrDefault("quotaUser")
  valid_582641 = validateParameter(valid_582641, JString, required = false,
                                 default = nil)
  if valid_582641 != nil:
    section.add "quotaUser", valid_582641
  var valid_582642 = query.getOrDefault("pageToken")
  valid_582642 = validateParameter(valid_582642, JString, required = false,
                                 default = nil)
  if valid_582642 != nil:
    section.add "pageToken", valid_582642
  var valid_582643 = query.getOrDefault("sortField")
  valid_582643 = validateParameter(valid_582643, JString, required = false,
                                 default = newJString("ID"))
  if valid_582643 != nil:
    section.add "sortField", valid_582643
  var valid_582644 = query.getOrDefault("alt")
  valid_582644 = validateParameter(valid_582644, JString, required = false,
                                 default = newJString("json"))
  if valid_582644 != nil:
    section.add "alt", valid_582644
  var valid_582645 = query.getOrDefault("orderId")
  valid_582645 = validateParameter(valid_582645, JArray, required = false,
                                 default = nil)
  if valid_582645 != nil:
    section.add "orderId", valid_582645
  var valid_582646 = query.getOrDefault("type")
  valid_582646 = validateParameter(valid_582646, JString, required = false, default = newJString(
      "PLANNING_PLACEMENT_TYPE_CREDIT"))
  if valid_582646 != nil:
    section.add "type", valid_582646
  var valid_582647 = query.getOrDefault("oauth_token")
  valid_582647 = validateParameter(valid_582647, JString, required = false,
                                 default = nil)
  if valid_582647 != nil:
    section.add "oauth_token", valid_582647
  var valid_582648 = query.getOrDefault("userIp")
  valid_582648 = validateParameter(valid_582648, JString, required = false,
                                 default = nil)
  if valid_582648 != nil:
    section.add "userIp", valid_582648
  var valid_582649 = query.getOrDefault("siteId")
  valid_582649 = validateParameter(valid_582649, JArray, required = false,
                                 default = nil)
  if valid_582649 != nil:
    section.add "siteId", valid_582649
  var valid_582650 = query.getOrDefault("maxResults")
  valid_582650 = validateParameter(valid_582650, JInt, required = false,
                                 default = newJInt(1000))
  if valid_582650 != nil:
    section.add "maxResults", valid_582650
  var valid_582651 = query.getOrDefault("ids")
  valid_582651 = validateParameter(valid_582651, JArray, required = false,
                                 default = nil)
  if valid_582651 != nil:
    section.add "ids", valid_582651
  var valid_582652 = query.getOrDefault("key")
  valid_582652 = validateParameter(valid_582652, JString, required = false,
                                 default = nil)
  if valid_582652 != nil:
    section.add "key", valid_582652
  var valid_582653 = query.getOrDefault("sortOrder")
  valid_582653 = validateParameter(valid_582653, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_582653 != nil:
    section.add "sortOrder", valid_582653
  var valid_582654 = query.getOrDefault("prettyPrint")
  valid_582654 = validateParameter(valid_582654, JBool, required = false,
                                 default = newJBool(true))
  if valid_582654 != nil:
    section.add "prettyPrint", valid_582654
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582655: Call_DfareportingInventoryItemsList_582634; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of inventory items, possibly filtered. This method supports paging.
  ## 
  let valid = call_582655.validator(path, query, header, formData, body)
  let scheme = call_582655.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582655.url(scheme.get, call_582655.host, call_582655.base,
                         call_582655.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582655, url, valid)

proc call*(call_582656: Call_DfareportingInventoryItemsList_582634;
          profileId: string; projectId: string; fields: string = "";
          inPlan: bool = false; quotaUser: string = ""; pageToken: string = "";
          sortField: string = "ID"; alt: string = "json"; orderId: JsonNode = nil;
          `type`: string = "PLANNING_PLACEMENT_TYPE_CREDIT";
          oauthToken: string = ""; userIp: string = ""; siteId: JsonNode = nil;
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingInventoryItemsList
  ## Retrieves a list of inventory items, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   inPlan: bool
  ##         : Select only inventory items that are in plan.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   orderId: JArray
  ##          : Select only inventory items that belong to specified orders.
  ##   type: string
  ##       : Select only inventory items with this type.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only inventory items that are associated with these sites.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only inventory items with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582657 = newJObject()
  var query_582658 = newJObject()
  add(path_582657, "profileId", newJString(profileId))
  add(query_582658, "fields", newJString(fields))
  add(query_582658, "inPlan", newJBool(inPlan))
  add(query_582658, "quotaUser", newJString(quotaUser))
  add(query_582658, "pageToken", newJString(pageToken))
  add(query_582658, "sortField", newJString(sortField))
  add(query_582658, "alt", newJString(alt))
  if orderId != nil:
    query_582658.add "orderId", orderId
  add(query_582658, "type", newJString(`type`))
  add(query_582658, "oauth_token", newJString(oauthToken))
  add(query_582658, "userIp", newJString(userIp))
  if siteId != nil:
    query_582658.add "siteId", siteId
  add(query_582658, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_582658.add "ids", ids
  add(query_582658, "key", newJString(key))
  add(path_582657, "projectId", newJString(projectId))
  add(query_582658, "sortOrder", newJString(sortOrder))
  add(query_582658, "prettyPrint", newJBool(prettyPrint))
  result = call_582656.call(path_582657, query_582658, nil, nil, nil)

var dfareportingInventoryItemsList* = Call_DfareportingInventoryItemsList_582634(
    name: "dfareportingInventoryItemsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/inventoryItems",
    validator: validate_DfareportingInventoryItemsList_582635,
    base: "/dfareporting/v2.7", url: url_DfareportingInventoryItemsList_582636,
    schemes: {Scheme.Https})
type
  Call_DfareportingInventoryItemsGet_582659 = ref object of OpenApiRestCall_579437
proc url_DfareportingInventoryItemsGet_582661(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/inventoryItems/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingInventoryItemsGet_582660(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one inventory item by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Inventory item ID.
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582662 = path.getOrDefault("profileId")
  valid_582662 = validateParameter(valid_582662, JString, required = true,
                                 default = nil)
  if valid_582662 != nil:
    section.add "profileId", valid_582662
  var valid_582663 = path.getOrDefault("id")
  valid_582663 = validateParameter(valid_582663, JString, required = true,
                                 default = nil)
  if valid_582663 != nil:
    section.add "id", valid_582663
  var valid_582664 = path.getOrDefault("projectId")
  valid_582664 = validateParameter(valid_582664, JString, required = true,
                                 default = nil)
  if valid_582664 != nil:
    section.add "projectId", valid_582664
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582665 = query.getOrDefault("fields")
  valid_582665 = validateParameter(valid_582665, JString, required = false,
                                 default = nil)
  if valid_582665 != nil:
    section.add "fields", valid_582665
  var valid_582666 = query.getOrDefault("quotaUser")
  valid_582666 = validateParameter(valid_582666, JString, required = false,
                                 default = nil)
  if valid_582666 != nil:
    section.add "quotaUser", valid_582666
  var valid_582667 = query.getOrDefault("alt")
  valid_582667 = validateParameter(valid_582667, JString, required = false,
                                 default = newJString("json"))
  if valid_582667 != nil:
    section.add "alt", valid_582667
  var valid_582668 = query.getOrDefault("oauth_token")
  valid_582668 = validateParameter(valid_582668, JString, required = false,
                                 default = nil)
  if valid_582668 != nil:
    section.add "oauth_token", valid_582668
  var valid_582669 = query.getOrDefault("userIp")
  valid_582669 = validateParameter(valid_582669, JString, required = false,
                                 default = nil)
  if valid_582669 != nil:
    section.add "userIp", valid_582669
  var valid_582670 = query.getOrDefault("key")
  valid_582670 = validateParameter(valid_582670, JString, required = false,
                                 default = nil)
  if valid_582670 != nil:
    section.add "key", valid_582670
  var valid_582671 = query.getOrDefault("prettyPrint")
  valid_582671 = validateParameter(valid_582671, JBool, required = false,
                                 default = newJBool(true))
  if valid_582671 != nil:
    section.add "prettyPrint", valid_582671
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582672: Call_DfareportingInventoryItemsGet_582659; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one inventory item by ID.
  ## 
  let valid = call_582672.validator(path, query, header, formData, body)
  let scheme = call_582672.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582672.url(scheme.get, call_582672.host, call_582672.base,
                         call_582672.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582672, url, valid)

proc call*(call_582673: Call_DfareportingInventoryItemsGet_582659;
          profileId: string; id: string; projectId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingInventoryItemsGet
  ## Gets one inventory item by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Inventory item ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582674 = newJObject()
  var query_582675 = newJObject()
  add(path_582674, "profileId", newJString(profileId))
  add(query_582675, "fields", newJString(fields))
  add(query_582675, "quotaUser", newJString(quotaUser))
  add(query_582675, "alt", newJString(alt))
  add(query_582675, "oauth_token", newJString(oauthToken))
  add(query_582675, "userIp", newJString(userIp))
  add(path_582674, "id", newJString(id))
  add(query_582675, "key", newJString(key))
  add(path_582674, "projectId", newJString(projectId))
  add(query_582675, "prettyPrint", newJBool(prettyPrint))
  result = call_582673.call(path_582674, query_582675, nil, nil, nil)

var dfareportingInventoryItemsGet* = Call_DfareportingInventoryItemsGet_582659(
    name: "dfareportingInventoryItemsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects/{projectId}/inventoryItems/{id}",
    validator: validate_DfareportingInventoryItemsGet_582660,
    base: "/dfareporting/v2.7", url: url_DfareportingInventoryItemsGet_582661,
    schemes: {Scheme.Https})
type
  Call_DfareportingOrderDocumentsList_582676 = ref object of OpenApiRestCall_579437
proc url_DfareportingOrderDocumentsList_582678(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orderDocuments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrderDocumentsList_582677(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of order documents, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582679 = path.getOrDefault("profileId")
  valid_582679 = validateParameter(valid_582679, JString, required = true,
                                 default = nil)
  if valid_582679 != nil:
    section.add "profileId", valid_582679
  var valid_582680 = path.getOrDefault("projectId")
  valid_582680 = validateParameter(valid_582680, JString, required = true,
                                 default = nil)
  if valid_582680 != nil:
    section.add "projectId", valid_582680
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for order documents by name or ID. Wildcards (*) are allowed. For example, "orderdocument*2015" will return order documents with names like "orderdocument June 2015", "orderdocument April 2015", or simply "orderdocument 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "orderdocument" will match order documents with name "my orderdocument", "orderdocument 2015", or simply "orderdocument".
  ##   orderId: JArray
  ##          : Select only order documents for specified orders.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only order documents that are associated with these sites.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only order documents with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   approved: JBool
  ##           : Select only order documents that have been approved by at least one user.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582681 = query.getOrDefault("fields")
  valid_582681 = validateParameter(valid_582681, JString, required = false,
                                 default = nil)
  if valid_582681 != nil:
    section.add "fields", valid_582681
  var valid_582682 = query.getOrDefault("pageToken")
  valid_582682 = validateParameter(valid_582682, JString, required = false,
                                 default = nil)
  if valid_582682 != nil:
    section.add "pageToken", valid_582682
  var valid_582683 = query.getOrDefault("quotaUser")
  valid_582683 = validateParameter(valid_582683, JString, required = false,
                                 default = nil)
  if valid_582683 != nil:
    section.add "quotaUser", valid_582683
  var valid_582684 = query.getOrDefault("sortField")
  valid_582684 = validateParameter(valid_582684, JString, required = false,
                                 default = newJString("ID"))
  if valid_582684 != nil:
    section.add "sortField", valid_582684
  var valid_582685 = query.getOrDefault("alt")
  valid_582685 = validateParameter(valid_582685, JString, required = false,
                                 default = newJString("json"))
  if valid_582685 != nil:
    section.add "alt", valid_582685
  var valid_582686 = query.getOrDefault("searchString")
  valid_582686 = validateParameter(valid_582686, JString, required = false,
                                 default = nil)
  if valid_582686 != nil:
    section.add "searchString", valid_582686
  var valid_582687 = query.getOrDefault("orderId")
  valid_582687 = validateParameter(valid_582687, JArray, required = false,
                                 default = nil)
  if valid_582687 != nil:
    section.add "orderId", valid_582687
  var valid_582688 = query.getOrDefault("oauth_token")
  valid_582688 = validateParameter(valid_582688, JString, required = false,
                                 default = nil)
  if valid_582688 != nil:
    section.add "oauth_token", valid_582688
  var valid_582689 = query.getOrDefault("userIp")
  valid_582689 = validateParameter(valid_582689, JString, required = false,
                                 default = nil)
  if valid_582689 != nil:
    section.add "userIp", valid_582689
  var valid_582690 = query.getOrDefault("siteId")
  valid_582690 = validateParameter(valid_582690, JArray, required = false,
                                 default = nil)
  if valid_582690 != nil:
    section.add "siteId", valid_582690
  var valid_582691 = query.getOrDefault("maxResults")
  valid_582691 = validateParameter(valid_582691, JInt, required = false,
                                 default = newJInt(1000))
  if valid_582691 != nil:
    section.add "maxResults", valid_582691
  var valid_582692 = query.getOrDefault("ids")
  valid_582692 = validateParameter(valid_582692, JArray, required = false,
                                 default = nil)
  if valid_582692 != nil:
    section.add "ids", valid_582692
  var valid_582693 = query.getOrDefault("key")
  valid_582693 = validateParameter(valid_582693, JString, required = false,
                                 default = nil)
  if valid_582693 != nil:
    section.add "key", valid_582693
  var valid_582694 = query.getOrDefault("sortOrder")
  valid_582694 = validateParameter(valid_582694, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_582694 != nil:
    section.add "sortOrder", valid_582694
  var valid_582695 = query.getOrDefault("approved")
  valid_582695 = validateParameter(valid_582695, JBool, required = false, default = nil)
  if valid_582695 != nil:
    section.add "approved", valid_582695
  var valid_582696 = query.getOrDefault("prettyPrint")
  valid_582696 = validateParameter(valid_582696, JBool, required = false,
                                 default = newJBool(true))
  if valid_582696 != nil:
    section.add "prettyPrint", valid_582696
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582697: Call_DfareportingOrderDocumentsList_582676; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of order documents, possibly filtered. This method supports paging.
  ## 
  let valid = call_582697.validator(path, query, header, formData, body)
  let scheme = call_582697.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582697.url(scheme.get, call_582697.host, call_582697.base,
                         call_582697.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582697, url, valid)

proc call*(call_582698: Call_DfareportingOrderDocumentsList_582676;
          profileId: string; projectId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; searchString: string = ""; orderId: JsonNode = nil;
          oauthToken: string = ""; userIp: string = ""; siteId: JsonNode = nil;
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; approved: bool = false;
          prettyPrint: bool = true): Recallable =
  ## dfareportingOrderDocumentsList
  ## Retrieves a list of order documents, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for order documents by name or ID. Wildcards (*) are allowed. For example, "orderdocument*2015" will return order documents with names like "orderdocument June 2015", "orderdocument April 2015", or simply "orderdocument 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "orderdocument" will match order documents with name "my orderdocument", "orderdocument 2015", or simply "orderdocument".
  ##   orderId: JArray
  ##          : Select only order documents for specified orders.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only order documents that are associated with these sites.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only order documents with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   approved: bool
  ##           : Select only order documents that have been approved by at least one user.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582699 = newJObject()
  var query_582700 = newJObject()
  add(path_582699, "profileId", newJString(profileId))
  add(query_582700, "fields", newJString(fields))
  add(query_582700, "pageToken", newJString(pageToken))
  add(query_582700, "quotaUser", newJString(quotaUser))
  add(query_582700, "sortField", newJString(sortField))
  add(query_582700, "alt", newJString(alt))
  add(query_582700, "searchString", newJString(searchString))
  if orderId != nil:
    query_582700.add "orderId", orderId
  add(query_582700, "oauth_token", newJString(oauthToken))
  add(query_582700, "userIp", newJString(userIp))
  if siteId != nil:
    query_582700.add "siteId", siteId
  add(query_582700, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_582700.add "ids", ids
  add(query_582700, "key", newJString(key))
  add(path_582699, "projectId", newJString(projectId))
  add(query_582700, "sortOrder", newJString(sortOrder))
  add(query_582700, "approved", newJBool(approved))
  add(query_582700, "prettyPrint", newJBool(prettyPrint))
  result = call_582698.call(path_582699, query_582700, nil, nil, nil)

var dfareportingOrderDocumentsList* = Call_DfareportingOrderDocumentsList_582676(
    name: "dfareportingOrderDocumentsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/orderDocuments",
    validator: validate_DfareportingOrderDocumentsList_582677,
    base: "/dfareporting/v2.7", url: url_DfareportingOrderDocumentsList_582678,
    schemes: {Scheme.Https})
type
  Call_DfareportingOrderDocumentsGet_582701 = ref object of OpenApiRestCall_579437
proc url_DfareportingOrderDocumentsGet_582703(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orderDocuments/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrderDocumentsGet_582702(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one order document by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Order document ID.
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582704 = path.getOrDefault("profileId")
  valid_582704 = validateParameter(valid_582704, JString, required = true,
                                 default = nil)
  if valid_582704 != nil:
    section.add "profileId", valid_582704
  var valid_582705 = path.getOrDefault("id")
  valid_582705 = validateParameter(valid_582705, JString, required = true,
                                 default = nil)
  if valid_582705 != nil:
    section.add "id", valid_582705
  var valid_582706 = path.getOrDefault("projectId")
  valid_582706 = validateParameter(valid_582706, JString, required = true,
                                 default = nil)
  if valid_582706 != nil:
    section.add "projectId", valid_582706
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582707 = query.getOrDefault("fields")
  valid_582707 = validateParameter(valid_582707, JString, required = false,
                                 default = nil)
  if valid_582707 != nil:
    section.add "fields", valid_582707
  var valid_582708 = query.getOrDefault("quotaUser")
  valid_582708 = validateParameter(valid_582708, JString, required = false,
                                 default = nil)
  if valid_582708 != nil:
    section.add "quotaUser", valid_582708
  var valid_582709 = query.getOrDefault("alt")
  valid_582709 = validateParameter(valid_582709, JString, required = false,
                                 default = newJString("json"))
  if valid_582709 != nil:
    section.add "alt", valid_582709
  var valid_582710 = query.getOrDefault("oauth_token")
  valid_582710 = validateParameter(valid_582710, JString, required = false,
                                 default = nil)
  if valid_582710 != nil:
    section.add "oauth_token", valid_582710
  var valid_582711 = query.getOrDefault("userIp")
  valid_582711 = validateParameter(valid_582711, JString, required = false,
                                 default = nil)
  if valid_582711 != nil:
    section.add "userIp", valid_582711
  var valid_582712 = query.getOrDefault("key")
  valid_582712 = validateParameter(valid_582712, JString, required = false,
                                 default = nil)
  if valid_582712 != nil:
    section.add "key", valid_582712
  var valid_582713 = query.getOrDefault("prettyPrint")
  valid_582713 = validateParameter(valid_582713, JBool, required = false,
                                 default = newJBool(true))
  if valid_582713 != nil:
    section.add "prettyPrint", valid_582713
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582714: Call_DfareportingOrderDocumentsGet_582701; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one order document by ID.
  ## 
  let valid = call_582714.validator(path, query, header, formData, body)
  let scheme = call_582714.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582714.url(scheme.get, call_582714.host, call_582714.base,
                         call_582714.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582714, url, valid)

proc call*(call_582715: Call_DfareportingOrderDocumentsGet_582701;
          profileId: string; id: string; projectId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOrderDocumentsGet
  ## Gets one order document by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Order document ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582716 = newJObject()
  var query_582717 = newJObject()
  add(path_582716, "profileId", newJString(profileId))
  add(query_582717, "fields", newJString(fields))
  add(query_582717, "quotaUser", newJString(quotaUser))
  add(query_582717, "alt", newJString(alt))
  add(query_582717, "oauth_token", newJString(oauthToken))
  add(query_582717, "userIp", newJString(userIp))
  add(path_582716, "id", newJString(id))
  add(query_582717, "key", newJString(key))
  add(path_582716, "projectId", newJString(projectId))
  add(query_582717, "prettyPrint", newJBool(prettyPrint))
  result = call_582715.call(path_582716, query_582717, nil, nil, nil)

var dfareportingOrderDocumentsGet* = Call_DfareportingOrderDocumentsGet_582701(
    name: "dfareportingOrderDocumentsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects/{projectId}/orderDocuments/{id}",
    validator: validate_DfareportingOrderDocumentsGet_582702,
    base: "/dfareporting/v2.7", url: url_DfareportingOrderDocumentsGet_582703,
    schemes: {Scheme.Https})
type
  Call_DfareportingOrdersList_582718 = ref object of OpenApiRestCall_579437
proc url_DfareportingOrdersList_582720(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orders")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrdersList_582719(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of orders, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   projectId: JString (required)
  ##            : Project ID for orders.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582721 = path.getOrDefault("profileId")
  valid_582721 = validateParameter(valid_582721, JString, required = true,
                                 default = nil)
  if valid_582721 != nil:
    section.add "profileId", valid_582721
  var valid_582722 = path.getOrDefault("projectId")
  valid_582722 = validateParameter(valid_582722, JString, required = true,
                                 default = nil)
  if valid_582722 != nil:
    section.add "projectId", valid_582722
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for orders by name or ID. Wildcards (*) are allowed. For example, "order*2015" will return orders with names like "order June 2015", "order April 2015", or simply "order 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "order" will match orders with name "my order", "order 2015", or simply "order".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only orders that are associated with these site IDs.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only orders with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582723 = query.getOrDefault("fields")
  valid_582723 = validateParameter(valid_582723, JString, required = false,
                                 default = nil)
  if valid_582723 != nil:
    section.add "fields", valid_582723
  var valid_582724 = query.getOrDefault("pageToken")
  valid_582724 = validateParameter(valid_582724, JString, required = false,
                                 default = nil)
  if valid_582724 != nil:
    section.add "pageToken", valid_582724
  var valid_582725 = query.getOrDefault("quotaUser")
  valid_582725 = validateParameter(valid_582725, JString, required = false,
                                 default = nil)
  if valid_582725 != nil:
    section.add "quotaUser", valid_582725
  var valid_582726 = query.getOrDefault("sortField")
  valid_582726 = validateParameter(valid_582726, JString, required = false,
                                 default = newJString("ID"))
  if valid_582726 != nil:
    section.add "sortField", valid_582726
  var valid_582727 = query.getOrDefault("alt")
  valid_582727 = validateParameter(valid_582727, JString, required = false,
                                 default = newJString("json"))
  if valid_582727 != nil:
    section.add "alt", valid_582727
  var valid_582728 = query.getOrDefault("searchString")
  valid_582728 = validateParameter(valid_582728, JString, required = false,
                                 default = nil)
  if valid_582728 != nil:
    section.add "searchString", valid_582728
  var valid_582729 = query.getOrDefault("oauth_token")
  valid_582729 = validateParameter(valid_582729, JString, required = false,
                                 default = nil)
  if valid_582729 != nil:
    section.add "oauth_token", valid_582729
  var valid_582730 = query.getOrDefault("userIp")
  valid_582730 = validateParameter(valid_582730, JString, required = false,
                                 default = nil)
  if valid_582730 != nil:
    section.add "userIp", valid_582730
  var valid_582731 = query.getOrDefault("siteId")
  valid_582731 = validateParameter(valid_582731, JArray, required = false,
                                 default = nil)
  if valid_582731 != nil:
    section.add "siteId", valid_582731
  var valid_582732 = query.getOrDefault("maxResults")
  valid_582732 = validateParameter(valid_582732, JInt, required = false,
                                 default = newJInt(1000))
  if valid_582732 != nil:
    section.add "maxResults", valid_582732
  var valid_582733 = query.getOrDefault("ids")
  valid_582733 = validateParameter(valid_582733, JArray, required = false,
                                 default = nil)
  if valid_582733 != nil:
    section.add "ids", valid_582733
  var valid_582734 = query.getOrDefault("key")
  valid_582734 = validateParameter(valid_582734, JString, required = false,
                                 default = nil)
  if valid_582734 != nil:
    section.add "key", valid_582734
  var valid_582735 = query.getOrDefault("sortOrder")
  valid_582735 = validateParameter(valid_582735, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_582735 != nil:
    section.add "sortOrder", valid_582735
  var valid_582736 = query.getOrDefault("prettyPrint")
  valid_582736 = validateParameter(valid_582736, JBool, required = false,
                                 default = newJBool(true))
  if valid_582736 != nil:
    section.add "prettyPrint", valid_582736
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582737: Call_DfareportingOrdersList_582718; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of orders, possibly filtered. This method supports paging.
  ## 
  let valid = call_582737.validator(path, query, header, formData, body)
  let scheme = call_582737.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582737.url(scheme.get, call_582737.host, call_582737.base,
                         call_582737.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582737, url, valid)

proc call*(call_582738: Call_DfareportingOrdersList_582718; profileId: string;
          projectId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          siteId: JsonNode = nil; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingOrdersList
  ## Retrieves a list of orders, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for orders by name or ID. Wildcards (*) are allowed. For example, "order*2015" will return orders with names like "order June 2015", "order April 2015", or simply "order 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "order" will match orders with name "my order", "order 2015", or simply "order".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only orders that are associated with these site IDs.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only orders with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for orders.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582739 = newJObject()
  var query_582740 = newJObject()
  add(path_582739, "profileId", newJString(profileId))
  add(query_582740, "fields", newJString(fields))
  add(query_582740, "pageToken", newJString(pageToken))
  add(query_582740, "quotaUser", newJString(quotaUser))
  add(query_582740, "sortField", newJString(sortField))
  add(query_582740, "alt", newJString(alt))
  add(query_582740, "searchString", newJString(searchString))
  add(query_582740, "oauth_token", newJString(oauthToken))
  add(query_582740, "userIp", newJString(userIp))
  if siteId != nil:
    query_582740.add "siteId", siteId
  add(query_582740, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_582740.add "ids", ids
  add(query_582740, "key", newJString(key))
  add(path_582739, "projectId", newJString(projectId))
  add(query_582740, "sortOrder", newJString(sortOrder))
  add(query_582740, "prettyPrint", newJBool(prettyPrint))
  result = call_582738.call(path_582739, query_582740, nil, nil, nil)

var dfareportingOrdersList* = Call_DfareportingOrdersList_582718(
    name: "dfareportingOrdersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/orders",
    validator: validate_DfareportingOrdersList_582719, base: "/dfareporting/v2.7",
    url: url_DfareportingOrdersList_582720, schemes: {Scheme.Https})
type
  Call_DfareportingOrdersGet_582741 = ref object of OpenApiRestCall_579437
proc url_DfareportingOrdersGet_582743(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orders/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrdersGet_582742(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one order by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Order ID.
  ##   projectId: JString (required)
  ##            : Project ID for orders.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582744 = path.getOrDefault("profileId")
  valid_582744 = validateParameter(valid_582744, JString, required = true,
                                 default = nil)
  if valid_582744 != nil:
    section.add "profileId", valid_582744
  var valid_582745 = path.getOrDefault("id")
  valid_582745 = validateParameter(valid_582745, JString, required = true,
                                 default = nil)
  if valid_582745 != nil:
    section.add "id", valid_582745
  var valid_582746 = path.getOrDefault("projectId")
  valid_582746 = validateParameter(valid_582746, JString, required = true,
                                 default = nil)
  if valid_582746 != nil:
    section.add "projectId", valid_582746
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582747 = query.getOrDefault("fields")
  valid_582747 = validateParameter(valid_582747, JString, required = false,
                                 default = nil)
  if valid_582747 != nil:
    section.add "fields", valid_582747
  var valid_582748 = query.getOrDefault("quotaUser")
  valid_582748 = validateParameter(valid_582748, JString, required = false,
                                 default = nil)
  if valid_582748 != nil:
    section.add "quotaUser", valid_582748
  var valid_582749 = query.getOrDefault("alt")
  valid_582749 = validateParameter(valid_582749, JString, required = false,
                                 default = newJString("json"))
  if valid_582749 != nil:
    section.add "alt", valid_582749
  var valid_582750 = query.getOrDefault("oauth_token")
  valid_582750 = validateParameter(valid_582750, JString, required = false,
                                 default = nil)
  if valid_582750 != nil:
    section.add "oauth_token", valid_582750
  var valid_582751 = query.getOrDefault("userIp")
  valid_582751 = validateParameter(valid_582751, JString, required = false,
                                 default = nil)
  if valid_582751 != nil:
    section.add "userIp", valid_582751
  var valid_582752 = query.getOrDefault("key")
  valid_582752 = validateParameter(valid_582752, JString, required = false,
                                 default = nil)
  if valid_582752 != nil:
    section.add "key", valid_582752
  var valid_582753 = query.getOrDefault("prettyPrint")
  valid_582753 = validateParameter(valid_582753, JBool, required = false,
                                 default = newJBool(true))
  if valid_582753 != nil:
    section.add "prettyPrint", valid_582753
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582754: Call_DfareportingOrdersGet_582741; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one order by ID.
  ## 
  let valid = call_582754.validator(path, query, header, formData, body)
  let scheme = call_582754.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582754.url(scheme.get, call_582754.host, call_582754.base,
                         call_582754.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582754, url, valid)

proc call*(call_582755: Call_DfareportingOrdersGet_582741; profileId: string;
          id: string; projectId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOrdersGet
  ## Gets one order by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Order ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for orders.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582756 = newJObject()
  var query_582757 = newJObject()
  add(path_582756, "profileId", newJString(profileId))
  add(query_582757, "fields", newJString(fields))
  add(query_582757, "quotaUser", newJString(quotaUser))
  add(query_582757, "alt", newJString(alt))
  add(query_582757, "oauth_token", newJString(oauthToken))
  add(query_582757, "userIp", newJString(userIp))
  add(path_582756, "id", newJString(id))
  add(query_582757, "key", newJString(key))
  add(path_582756, "projectId", newJString(projectId))
  add(query_582757, "prettyPrint", newJBool(prettyPrint))
  result = call_582755.call(path_582756, query_582757, nil, nil, nil)

var dfareportingOrdersGet* = Call_DfareportingOrdersGet_582741(
    name: "dfareportingOrdersGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/orders/{id}",
    validator: validate_DfareportingOrdersGet_582742, base: "/dfareporting/v2.7",
    url: url_DfareportingOrdersGet_582743, schemes: {Scheme.Https})
type
  Call_DfareportingRegionsList_582758 = ref object of OpenApiRestCall_579437
proc url_DfareportingRegionsList_582760(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/regions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRegionsList_582759(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of regions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582761 = path.getOrDefault("profileId")
  valid_582761 = validateParameter(valid_582761, JString, required = true,
                                 default = nil)
  if valid_582761 != nil:
    section.add "profileId", valid_582761
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582762 = query.getOrDefault("fields")
  valid_582762 = validateParameter(valid_582762, JString, required = false,
                                 default = nil)
  if valid_582762 != nil:
    section.add "fields", valid_582762
  var valid_582763 = query.getOrDefault("quotaUser")
  valid_582763 = validateParameter(valid_582763, JString, required = false,
                                 default = nil)
  if valid_582763 != nil:
    section.add "quotaUser", valid_582763
  var valid_582764 = query.getOrDefault("alt")
  valid_582764 = validateParameter(valid_582764, JString, required = false,
                                 default = newJString("json"))
  if valid_582764 != nil:
    section.add "alt", valid_582764
  var valid_582765 = query.getOrDefault("oauth_token")
  valid_582765 = validateParameter(valid_582765, JString, required = false,
                                 default = nil)
  if valid_582765 != nil:
    section.add "oauth_token", valid_582765
  var valid_582766 = query.getOrDefault("userIp")
  valid_582766 = validateParameter(valid_582766, JString, required = false,
                                 default = nil)
  if valid_582766 != nil:
    section.add "userIp", valid_582766
  var valid_582767 = query.getOrDefault("key")
  valid_582767 = validateParameter(valid_582767, JString, required = false,
                                 default = nil)
  if valid_582767 != nil:
    section.add "key", valid_582767
  var valid_582768 = query.getOrDefault("prettyPrint")
  valid_582768 = validateParameter(valid_582768, JBool, required = false,
                                 default = newJBool(true))
  if valid_582768 != nil:
    section.add "prettyPrint", valid_582768
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582769: Call_DfareportingRegionsList_582758; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of regions.
  ## 
  let valid = call_582769.validator(path, query, header, formData, body)
  let scheme = call_582769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582769.url(scheme.get, call_582769.host, call_582769.base,
                         call_582769.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582769, url, valid)

proc call*(call_582770: Call_DfareportingRegionsList_582758; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingRegionsList
  ## Retrieves a list of regions.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582771 = newJObject()
  var query_582772 = newJObject()
  add(path_582771, "profileId", newJString(profileId))
  add(query_582772, "fields", newJString(fields))
  add(query_582772, "quotaUser", newJString(quotaUser))
  add(query_582772, "alt", newJString(alt))
  add(query_582772, "oauth_token", newJString(oauthToken))
  add(query_582772, "userIp", newJString(userIp))
  add(query_582772, "key", newJString(key))
  add(query_582772, "prettyPrint", newJBool(prettyPrint))
  result = call_582770.call(path_582771, query_582772, nil, nil, nil)

var dfareportingRegionsList* = Call_DfareportingRegionsList_582758(
    name: "dfareportingRegionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/regions",
    validator: validate_DfareportingRegionsList_582759,
    base: "/dfareporting/v2.7", url: url_DfareportingRegionsList_582760,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListSharesUpdate_582773 = ref object of OpenApiRestCall_579437
proc url_DfareportingRemarketingListSharesUpdate_582775(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingListShares")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListSharesUpdate_582774(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list share.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582776 = path.getOrDefault("profileId")
  valid_582776 = validateParameter(valid_582776, JString, required = true,
                                 default = nil)
  if valid_582776 != nil:
    section.add "profileId", valid_582776
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582777 = query.getOrDefault("fields")
  valid_582777 = validateParameter(valid_582777, JString, required = false,
                                 default = nil)
  if valid_582777 != nil:
    section.add "fields", valid_582777
  var valid_582778 = query.getOrDefault("quotaUser")
  valid_582778 = validateParameter(valid_582778, JString, required = false,
                                 default = nil)
  if valid_582778 != nil:
    section.add "quotaUser", valid_582778
  var valid_582779 = query.getOrDefault("alt")
  valid_582779 = validateParameter(valid_582779, JString, required = false,
                                 default = newJString("json"))
  if valid_582779 != nil:
    section.add "alt", valid_582779
  var valid_582780 = query.getOrDefault("oauth_token")
  valid_582780 = validateParameter(valid_582780, JString, required = false,
                                 default = nil)
  if valid_582780 != nil:
    section.add "oauth_token", valid_582780
  var valid_582781 = query.getOrDefault("userIp")
  valid_582781 = validateParameter(valid_582781, JString, required = false,
                                 default = nil)
  if valid_582781 != nil:
    section.add "userIp", valid_582781
  var valid_582782 = query.getOrDefault("key")
  valid_582782 = validateParameter(valid_582782, JString, required = false,
                                 default = nil)
  if valid_582782 != nil:
    section.add "key", valid_582782
  var valid_582783 = query.getOrDefault("prettyPrint")
  valid_582783 = validateParameter(valid_582783, JBool, required = false,
                                 default = newJBool(true))
  if valid_582783 != nil:
    section.add "prettyPrint", valid_582783
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582785: Call_DfareportingRemarketingListSharesUpdate_582773;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list share.
  ## 
  let valid = call_582785.validator(path, query, header, formData, body)
  let scheme = call_582785.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582785.url(scheme.get, call_582785.host, call_582785.base,
                         call_582785.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582785, url, valid)

proc call*(call_582786: Call_DfareportingRemarketingListSharesUpdate_582773;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListSharesUpdate
  ## Updates an existing remarketing list share.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582787 = newJObject()
  var query_582788 = newJObject()
  var body_582789 = newJObject()
  add(path_582787, "profileId", newJString(profileId))
  add(query_582788, "fields", newJString(fields))
  add(query_582788, "quotaUser", newJString(quotaUser))
  add(query_582788, "alt", newJString(alt))
  add(query_582788, "oauth_token", newJString(oauthToken))
  add(query_582788, "userIp", newJString(userIp))
  add(query_582788, "key", newJString(key))
  if body != nil:
    body_582789 = body
  add(query_582788, "prettyPrint", newJBool(prettyPrint))
  result = call_582786.call(path_582787, query_582788, nil, nil, body_582789)

var dfareportingRemarketingListSharesUpdate* = Call_DfareportingRemarketingListSharesUpdate_582773(
    name: "dfareportingRemarketingListSharesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingListShares",
    validator: validate_DfareportingRemarketingListSharesUpdate_582774,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListSharesUpdate_582775,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListSharesPatch_582790 = ref object of OpenApiRestCall_579437
proc url_DfareportingRemarketingListSharesPatch_582792(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingListShares")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListSharesPatch_582791(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list share. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582793 = path.getOrDefault("profileId")
  valid_582793 = validateParameter(valid_582793, JString, required = true,
                                 default = nil)
  if valid_582793 != nil:
    section.add "profileId", valid_582793
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   remarketingListId: JString (required)
  ##                    : Remarketing list ID.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582794 = query.getOrDefault("fields")
  valid_582794 = validateParameter(valid_582794, JString, required = false,
                                 default = nil)
  if valid_582794 != nil:
    section.add "fields", valid_582794
  var valid_582795 = query.getOrDefault("quotaUser")
  valid_582795 = validateParameter(valid_582795, JString, required = false,
                                 default = nil)
  if valid_582795 != nil:
    section.add "quotaUser", valid_582795
  var valid_582796 = query.getOrDefault("alt")
  valid_582796 = validateParameter(valid_582796, JString, required = false,
                                 default = newJString("json"))
  if valid_582796 != nil:
    section.add "alt", valid_582796
  var valid_582797 = query.getOrDefault("oauth_token")
  valid_582797 = validateParameter(valid_582797, JString, required = false,
                                 default = nil)
  if valid_582797 != nil:
    section.add "oauth_token", valid_582797
  var valid_582798 = query.getOrDefault("userIp")
  valid_582798 = validateParameter(valid_582798, JString, required = false,
                                 default = nil)
  if valid_582798 != nil:
    section.add "userIp", valid_582798
  var valid_582799 = query.getOrDefault("key")
  valid_582799 = validateParameter(valid_582799, JString, required = false,
                                 default = nil)
  if valid_582799 != nil:
    section.add "key", valid_582799
  assert query != nil,
        "query argument is necessary due to required `remarketingListId` field"
  var valid_582800 = query.getOrDefault("remarketingListId")
  valid_582800 = validateParameter(valid_582800, JString, required = true,
                                 default = nil)
  if valid_582800 != nil:
    section.add "remarketingListId", valid_582800
  var valid_582801 = query.getOrDefault("prettyPrint")
  valid_582801 = validateParameter(valid_582801, JBool, required = false,
                                 default = newJBool(true))
  if valid_582801 != nil:
    section.add "prettyPrint", valid_582801
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582803: Call_DfareportingRemarketingListSharesPatch_582790;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list share. This method supports patch semantics.
  ## 
  let valid = call_582803.validator(path, query, header, formData, body)
  let scheme = call_582803.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582803.url(scheme.get, call_582803.host, call_582803.base,
                         call_582803.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582803, url, valid)

proc call*(call_582804: Call_DfareportingRemarketingListSharesPatch_582790;
          profileId: string; remarketingListId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListSharesPatch
  ## Updates an existing remarketing list share. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   remarketingListId: string (required)
  ##                    : Remarketing list ID.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582805 = newJObject()
  var query_582806 = newJObject()
  var body_582807 = newJObject()
  add(path_582805, "profileId", newJString(profileId))
  add(query_582806, "fields", newJString(fields))
  add(query_582806, "quotaUser", newJString(quotaUser))
  add(query_582806, "alt", newJString(alt))
  add(query_582806, "oauth_token", newJString(oauthToken))
  add(query_582806, "userIp", newJString(userIp))
  add(query_582806, "key", newJString(key))
  add(query_582806, "remarketingListId", newJString(remarketingListId))
  if body != nil:
    body_582807 = body
  add(query_582806, "prettyPrint", newJBool(prettyPrint))
  result = call_582804.call(path_582805, query_582806, nil, nil, body_582807)

var dfareportingRemarketingListSharesPatch* = Call_DfareportingRemarketingListSharesPatch_582790(
    name: "dfareportingRemarketingListSharesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingListShares",
    validator: validate_DfareportingRemarketingListSharesPatch_582791,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListSharesPatch_582792,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListSharesGet_582808 = ref object of OpenApiRestCall_579437
proc url_DfareportingRemarketingListSharesGet_582810(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "remarketingListId" in path,
        "`remarketingListId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingListShares/"),
               (kind: VariableSegment, value: "remarketingListId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListSharesGet_582809(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one remarketing list share by remarketing list ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   remarketingListId: JString (required)
  ##                    : Remarketing list ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582811 = path.getOrDefault("profileId")
  valid_582811 = validateParameter(valid_582811, JString, required = true,
                                 default = nil)
  if valid_582811 != nil:
    section.add "profileId", valid_582811
  var valid_582812 = path.getOrDefault("remarketingListId")
  valid_582812 = validateParameter(valid_582812, JString, required = true,
                                 default = nil)
  if valid_582812 != nil:
    section.add "remarketingListId", valid_582812
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582813 = query.getOrDefault("fields")
  valid_582813 = validateParameter(valid_582813, JString, required = false,
                                 default = nil)
  if valid_582813 != nil:
    section.add "fields", valid_582813
  var valid_582814 = query.getOrDefault("quotaUser")
  valid_582814 = validateParameter(valid_582814, JString, required = false,
                                 default = nil)
  if valid_582814 != nil:
    section.add "quotaUser", valid_582814
  var valid_582815 = query.getOrDefault("alt")
  valid_582815 = validateParameter(valid_582815, JString, required = false,
                                 default = newJString("json"))
  if valid_582815 != nil:
    section.add "alt", valid_582815
  var valid_582816 = query.getOrDefault("oauth_token")
  valid_582816 = validateParameter(valid_582816, JString, required = false,
                                 default = nil)
  if valid_582816 != nil:
    section.add "oauth_token", valid_582816
  var valid_582817 = query.getOrDefault("userIp")
  valid_582817 = validateParameter(valid_582817, JString, required = false,
                                 default = nil)
  if valid_582817 != nil:
    section.add "userIp", valid_582817
  var valid_582818 = query.getOrDefault("key")
  valid_582818 = validateParameter(valid_582818, JString, required = false,
                                 default = nil)
  if valid_582818 != nil:
    section.add "key", valid_582818
  var valid_582819 = query.getOrDefault("prettyPrint")
  valid_582819 = validateParameter(valid_582819, JBool, required = false,
                                 default = newJBool(true))
  if valid_582819 != nil:
    section.add "prettyPrint", valid_582819
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582820: Call_DfareportingRemarketingListSharesGet_582808;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one remarketing list share by remarketing list ID.
  ## 
  let valid = call_582820.validator(path, query, header, formData, body)
  let scheme = call_582820.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582820.url(scheme.get, call_582820.host, call_582820.base,
                         call_582820.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582820, url, valid)

proc call*(call_582821: Call_DfareportingRemarketingListSharesGet_582808;
          profileId: string; remarketingListId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListSharesGet
  ## Gets one remarketing list share by remarketing list ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   remarketingListId: string (required)
  ##                    : Remarketing list ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582822 = newJObject()
  var query_582823 = newJObject()
  add(path_582822, "profileId", newJString(profileId))
  add(query_582823, "fields", newJString(fields))
  add(query_582823, "quotaUser", newJString(quotaUser))
  add(query_582823, "alt", newJString(alt))
  add(query_582823, "oauth_token", newJString(oauthToken))
  add(query_582823, "userIp", newJString(userIp))
  add(path_582822, "remarketingListId", newJString(remarketingListId))
  add(query_582823, "key", newJString(key))
  add(query_582823, "prettyPrint", newJBool(prettyPrint))
  result = call_582821.call(path_582822, query_582823, nil, nil, nil)

var dfareportingRemarketingListSharesGet* = Call_DfareportingRemarketingListSharesGet_582808(
    name: "dfareportingRemarketingListSharesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/remarketingListShares/{remarketingListId}",
    validator: validate_DfareportingRemarketingListSharesGet_582809,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListSharesGet_582810,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsUpdate_582847 = ref object of OpenApiRestCall_579437
proc url_DfareportingRemarketingListsUpdate_582849(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsUpdate_582848(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582850 = path.getOrDefault("profileId")
  valid_582850 = validateParameter(valid_582850, JString, required = true,
                                 default = nil)
  if valid_582850 != nil:
    section.add "profileId", valid_582850
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582851 = query.getOrDefault("fields")
  valid_582851 = validateParameter(valid_582851, JString, required = false,
                                 default = nil)
  if valid_582851 != nil:
    section.add "fields", valid_582851
  var valid_582852 = query.getOrDefault("quotaUser")
  valid_582852 = validateParameter(valid_582852, JString, required = false,
                                 default = nil)
  if valid_582852 != nil:
    section.add "quotaUser", valid_582852
  var valid_582853 = query.getOrDefault("alt")
  valid_582853 = validateParameter(valid_582853, JString, required = false,
                                 default = newJString("json"))
  if valid_582853 != nil:
    section.add "alt", valid_582853
  var valid_582854 = query.getOrDefault("oauth_token")
  valid_582854 = validateParameter(valid_582854, JString, required = false,
                                 default = nil)
  if valid_582854 != nil:
    section.add "oauth_token", valid_582854
  var valid_582855 = query.getOrDefault("userIp")
  valid_582855 = validateParameter(valid_582855, JString, required = false,
                                 default = nil)
  if valid_582855 != nil:
    section.add "userIp", valid_582855
  var valid_582856 = query.getOrDefault("key")
  valid_582856 = validateParameter(valid_582856, JString, required = false,
                                 default = nil)
  if valid_582856 != nil:
    section.add "key", valid_582856
  var valid_582857 = query.getOrDefault("prettyPrint")
  valid_582857 = validateParameter(valid_582857, JBool, required = false,
                                 default = newJBool(true))
  if valid_582857 != nil:
    section.add "prettyPrint", valid_582857
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582859: Call_DfareportingRemarketingListsUpdate_582847;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list.
  ## 
  let valid = call_582859.validator(path, query, header, formData, body)
  let scheme = call_582859.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582859.url(scheme.get, call_582859.host, call_582859.base,
                         call_582859.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582859, url, valid)

proc call*(call_582860: Call_DfareportingRemarketingListsUpdate_582847;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsUpdate
  ## Updates an existing remarketing list.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582861 = newJObject()
  var query_582862 = newJObject()
  var body_582863 = newJObject()
  add(path_582861, "profileId", newJString(profileId))
  add(query_582862, "fields", newJString(fields))
  add(query_582862, "quotaUser", newJString(quotaUser))
  add(query_582862, "alt", newJString(alt))
  add(query_582862, "oauth_token", newJString(oauthToken))
  add(query_582862, "userIp", newJString(userIp))
  add(query_582862, "key", newJString(key))
  if body != nil:
    body_582863 = body
  add(query_582862, "prettyPrint", newJBool(prettyPrint))
  result = call_582860.call(path_582861, query_582862, nil, nil, body_582863)

var dfareportingRemarketingListsUpdate* = Call_DfareportingRemarketingListsUpdate_582847(
    name: "dfareportingRemarketingListsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsUpdate_582848,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsUpdate_582849,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsInsert_582864 = ref object of OpenApiRestCall_579437
proc url_DfareportingRemarketingListsInsert_582866(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsInsert_582865(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new remarketing list.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582867 = path.getOrDefault("profileId")
  valid_582867 = validateParameter(valid_582867, JString, required = true,
                                 default = nil)
  if valid_582867 != nil:
    section.add "profileId", valid_582867
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582868 = query.getOrDefault("fields")
  valid_582868 = validateParameter(valid_582868, JString, required = false,
                                 default = nil)
  if valid_582868 != nil:
    section.add "fields", valid_582868
  var valid_582869 = query.getOrDefault("quotaUser")
  valid_582869 = validateParameter(valid_582869, JString, required = false,
                                 default = nil)
  if valid_582869 != nil:
    section.add "quotaUser", valid_582869
  var valid_582870 = query.getOrDefault("alt")
  valid_582870 = validateParameter(valid_582870, JString, required = false,
                                 default = newJString("json"))
  if valid_582870 != nil:
    section.add "alt", valid_582870
  var valid_582871 = query.getOrDefault("oauth_token")
  valid_582871 = validateParameter(valid_582871, JString, required = false,
                                 default = nil)
  if valid_582871 != nil:
    section.add "oauth_token", valid_582871
  var valid_582872 = query.getOrDefault("userIp")
  valid_582872 = validateParameter(valid_582872, JString, required = false,
                                 default = nil)
  if valid_582872 != nil:
    section.add "userIp", valid_582872
  var valid_582873 = query.getOrDefault("key")
  valid_582873 = validateParameter(valid_582873, JString, required = false,
                                 default = nil)
  if valid_582873 != nil:
    section.add "key", valid_582873
  var valid_582874 = query.getOrDefault("prettyPrint")
  valid_582874 = validateParameter(valid_582874, JBool, required = false,
                                 default = newJBool(true))
  if valid_582874 != nil:
    section.add "prettyPrint", valid_582874
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582876: Call_DfareportingRemarketingListsInsert_582864;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new remarketing list.
  ## 
  let valid = call_582876.validator(path, query, header, formData, body)
  let scheme = call_582876.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582876.url(scheme.get, call_582876.host, call_582876.base,
                         call_582876.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582876, url, valid)

proc call*(call_582877: Call_DfareportingRemarketingListsInsert_582864;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsInsert
  ## Inserts a new remarketing list.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582878 = newJObject()
  var query_582879 = newJObject()
  var body_582880 = newJObject()
  add(path_582878, "profileId", newJString(profileId))
  add(query_582879, "fields", newJString(fields))
  add(query_582879, "quotaUser", newJString(quotaUser))
  add(query_582879, "alt", newJString(alt))
  add(query_582879, "oauth_token", newJString(oauthToken))
  add(query_582879, "userIp", newJString(userIp))
  add(query_582879, "key", newJString(key))
  if body != nil:
    body_582880 = body
  add(query_582879, "prettyPrint", newJBool(prettyPrint))
  result = call_582877.call(path_582878, query_582879, nil, nil, body_582880)

var dfareportingRemarketingListsInsert* = Call_DfareportingRemarketingListsInsert_582864(
    name: "dfareportingRemarketingListsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsInsert_582865,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsInsert_582866,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsList_582824 = ref object of OpenApiRestCall_579437
proc url_DfareportingRemarketingListsList_582826(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsList_582825(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of remarketing lists, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582827 = path.getOrDefault("profileId")
  valid_582827 = validateParameter(valid_582827, JString, required = true,
                                 default = nil)
  if valid_582827 != nil:
    section.add "profileId", valid_582827
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   advertiserId: JString (required)
  ##               : Select only remarketing lists owned by this advertiser.
  ##   active: JBool
  ##         : Select only active or only inactive remarketing lists.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   floodlightActivityId: JString
  ##                       : Select only remarketing lists that have this floodlight activity ID.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: JString
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582828 = query.getOrDefault("fields")
  valid_582828 = validateParameter(valid_582828, JString, required = false,
                                 default = nil)
  if valid_582828 != nil:
    section.add "fields", valid_582828
  var valid_582829 = query.getOrDefault("pageToken")
  valid_582829 = validateParameter(valid_582829, JString, required = false,
                                 default = nil)
  if valid_582829 != nil:
    section.add "pageToken", valid_582829
  var valid_582830 = query.getOrDefault("quotaUser")
  valid_582830 = validateParameter(valid_582830, JString, required = false,
                                 default = nil)
  if valid_582830 != nil:
    section.add "quotaUser", valid_582830
  var valid_582831 = query.getOrDefault("sortField")
  valid_582831 = validateParameter(valid_582831, JString, required = false,
                                 default = newJString("ID"))
  if valid_582831 != nil:
    section.add "sortField", valid_582831
  var valid_582832 = query.getOrDefault("alt")
  valid_582832 = validateParameter(valid_582832, JString, required = false,
                                 default = newJString("json"))
  if valid_582832 != nil:
    section.add "alt", valid_582832
  assert query != nil,
        "query argument is necessary due to required `advertiserId` field"
  var valid_582833 = query.getOrDefault("advertiserId")
  valid_582833 = validateParameter(valid_582833, JString, required = true,
                                 default = nil)
  if valid_582833 != nil:
    section.add "advertiserId", valid_582833
  var valid_582834 = query.getOrDefault("active")
  valid_582834 = validateParameter(valid_582834, JBool, required = false, default = nil)
  if valid_582834 != nil:
    section.add "active", valid_582834
  var valid_582835 = query.getOrDefault("oauth_token")
  valid_582835 = validateParameter(valid_582835, JString, required = false,
                                 default = nil)
  if valid_582835 != nil:
    section.add "oauth_token", valid_582835
  var valid_582836 = query.getOrDefault("floodlightActivityId")
  valid_582836 = validateParameter(valid_582836, JString, required = false,
                                 default = nil)
  if valid_582836 != nil:
    section.add "floodlightActivityId", valid_582836
  var valid_582837 = query.getOrDefault("userIp")
  valid_582837 = validateParameter(valid_582837, JString, required = false,
                                 default = nil)
  if valid_582837 != nil:
    section.add "userIp", valid_582837
  var valid_582838 = query.getOrDefault("maxResults")
  valid_582838 = validateParameter(valid_582838, JInt, required = false,
                                 default = newJInt(1000))
  if valid_582838 != nil:
    section.add "maxResults", valid_582838
  var valid_582839 = query.getOrDefault("key")
  valid_582839 = validateParameter(valid_582839, JString, required = false,
                                 default = nil)
  if valid_582839 != nil:
    section.add "key", valid_582839
  var valid_582840 = query.getOrDefault("name")
  valid_582840 = validateParameter(valid_582840, JString, required = false,
                                 default = nil)
  if valid_582840 != nil:
    section.add "name", valid_582840
  var valid_582841 = query.getOrDefault("sortOrder")
  valid_582841 = validateParameter(valid_582841, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_582841 != nil:
    section.add "sortOrder", valid_582841
  var valid_582842 = query.getOrDefault("prettyPrint")
  valid_582842 = validateParameter(valid_582842, JBool, required = false,
                                 default = newJBool(true))
  if valid_582842 != nil:
    section.add "prettyPrint", valid_582842
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582843: Call_DfareportingRemarketingListsList_582824;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of remarketing lists, possibly filtered. This method supports paging.
  ## 
  let valid = call_582843.validator(path, query, header, formData, body)
  let scheme = call_582843.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582843.url(scheme.get, call_582843.host, call_582843.base,
                         call_582843.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582843, url, valid)

proc call*(call_582844: Call_DfareportingRemarketingListsList_582824;
          profileId: string; advertiserId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; active: bool = false; oauthToken: string = "";
          floodlightActivityId: string = ""; userIp: string = "";
          maxResults: int = 1000; key: string = ""; name: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsList
  ## Retrieves a list of remarketing lists, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   advertiserId: string (required)
  ##               : Select only remarketing lists owned by this advertiser.
  ##   active: bool
  ##         : Select only active or only inactive remarketing lists.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   floodlightActivityId: string
  ##                       : Select only remarketing lists that have this floodlight activity ID.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: string
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582845 = newJObject()
  var query_582846 = newJObject()
  add(path_582845, "profileId", newJString(profileId))
  add(query_582846, "fields", newJString(fields))
  add(query_582846, "pageToken", newJString(pageToken))
  add(query_582846, "quotaUser", newJString(quotaUser))
  add(query_582846, "sortField", newJString(sortField))
  add(query_582846, "alt", newJString(alt))
  add(query_582846, "advertiserId", newJString(advertiserId))
  add(query_582846, "active", newJBool(active))
  add(query_582846, "oauth_token", newJString(oauthToken))
  add(query_582846, "floodlightActivityId", newJString(floodlightActivityId))
  add(query_582846, "userIp", newJString(userIp))
  add(query_582846, "maxResults", newJInt(maxResults))
  add(query_582846, "key", newJString(key))
  add(query_582846, "name", newJString(name))
  add(query_582846, "sortOrder", newJString(sortOrder))
  add(query_582846, "prettyPrint", newJBool(prettyPrint))
  result = call_582844.call(path_582845, query_582846, nil, nil, nil)

var dfareportingRemarketingListsList* = Call_DfareportingRemarketingListsList_582824(
    name: "dfareportingRemarketingListsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsList_582825,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsList_582826,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsPatch_582881 = ref object of OpenApiRestCall_579437
proc url_DfareportingRemarketingListsPatch_582883(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsPatch_582882(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582884 = path.getOrDefault("profileId")
  valid_582884 = validateParameter(valid_582884, JString, required = true,
                                 default = nil)
  if valid_582884 != nil:
    section.add "profileId", valid_582884
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Remarketing list ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582885 = query.getOrDefault("fields")
  valid_582885 = validateParameter(valid_582885, JString, required = false,
                                 default = nil)
  if valid_582885 != nil:
    section.add "fields", valid_582885
  var valid_582886 = query.getOrDefault("quotaUser")
  valid_582886 = validateParameter(valid_582886, JString, required = false,
                                 default = nil)
  if valid_582886 != nil:
    section.add "quotaUser", valid_582886
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_582887 = query.getOrDefault("id")
  valid_582887 = validateParameter(valid_582887, JString, required = true,
                                 default = nil)
  if valid_582887 != nil:
    section.add "id", valid_582887
  var valid_582888 = query.getOrDefault("alt")
  valid_582888 = validateParameter(valid_582888, JString, required = false,
                                 default = newJString("json"))
  if valid_582888 != nil:
    section.add "alt", valid_582888
  var valid_582889 = query.getOrDefault("oauth_token")
  valid_582889 = validateParameter(valid_582889, JString, required = false,
                                 default = nil)
  if valid_582889 != nil:
    section.add "oauth_token", valid_582889
  var valid_582890 = query.getOrDefault("userIp")
  valid_582890 = validateParameter(valid_582890, JString, required = false,
                                 default = nil)
  if valid_582890 != nil:
    section.add "userIp", valid_582890
  var valid_582891 = query.getOrDefault("key")
  valid_582891 = validateParameter(valid_582891, JString, required = false,
                                 default = nil)
  if valid_582891 != nil:
    section.add "key", valid_582891
  var valid_582892 = query.getOrDefault("prettyPrint")
  valid_582892 = validateParameter(valid_582892, JBool, required = false,
                                 default = newJBool(true))
  if valid_582892 != nil:
    section.add "prettyPrint", valid_582892
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582894: Call_DfareportingRemarketingListsPatch_582881;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list. This method supports patch semantics.
  ## 
  let valid = call_582894.validator(path, query, header, formData, body)
  let scheme = call_582894.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582894.url(scheme.get, call_582894.host, call_582894.base,
                         call_582894.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582894, url, valid)

proc call*(call_582895: Call_DfareportingRemarketingListsPatch_582881;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsPatch
  ## Updates an existing remarketing list. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Remarketing list ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582896 = newJObject()
  var query_582897 = newJObject()
  var body_582898 = newJObject()
  add(path_582896, "profileId", newJString(profileId))
  add(query_582897, "fields", newJString(fields))
  add(query_582897, "quotaUser", newJString(quotaUser))
  add(query_582897, "id", newJString(id))
  add(query_582897, "alt", newJString(alt))
  add(query_582897, "oauth_token", newJString(oauthToken))
  add(query_582897, "userIp", newJString(userIp))
  add(query_582897, "key", newJString(key))
  if body != nil:
    body_582898 = body
  add(query_582897, "prettyPrint", newJBool(prettyPrint))
  result = call_582895.call(path_582896, query_582897, nil, nil, body_582898)

var dfareportingRemarketingListsPatch* = Call_DfareportingRemarketingListsPatch_582881(
    name: "dfareportingRemarketingListsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsPatch_582882,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsPatch_582883,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsGet_582899 = ref object of OpenApiRestCall_579437
proc url_DfareportingRemarketingListsGet_582901(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsGet_582900(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one remarketing list by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Remarketing list ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582902 = path.getOrDefault("profileId")
  valid_582902 = validateParameter(valid_582902, JString, required = true,
                                 default = nil)
  if valid_582902 != nil:
    section.add "profileId", valid_582902
  var valid_582903 = path.getOrDefault("id")
  valid_582903 = validateParameter(valid_582903, JString, required = true,
                                 default = nil)
  if valid_582903 != nil:
    section.add "id", valid_582903
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582904 = query.getOrDefault("fields")
  valid_582904 = validateParameter(valid_582904, JString, required = false,
                                 default = nil)
  if valid_582904 != nil:
    section.add "fields", valid_582904
  var valid_582905 = query.getOrDefault("quotaUser")
  valid_582905 = validateParameter(valid_582905, JString, required = false,
                                 default = nil)
  if valid_582905 != nil:
    section.add "quotaUser", valid_582905
  var valid_582906 = query.getOrDefault("alt")
  valid_582906 = validateParameter(valid_582906, JString, required = false,
                                 default = newJString("json"))
  if valid_582906 != nil:
    section.add "alt", valid_582906
  var valid_582907 = query.getOrDefault("oauth_token")
  valid_582907 = validateParameter(valid_582907, JString, required = false,
                                 default = nil)
  if valid_582907 != nil:
    section.add "oauth_token", valid_582907
  var valid_582908 = query.getOrDefault("userIp")
  valid_582908 = validateParameter(valid_582908, JString, required = false,
                                 default = nil)
  if valid_582908 != nil:
    section.add "userIp", valid_582908
  var valid_582909 = query.getOrDefault("key")
  valid_582909 = validateParameter(valid_582909, JString, required = false,
                                 default = nil)
  if valid_582909 != nil:
    section.add "key", valid_582909
  var valid_582910 = query.getOrDefault("prettyPrint")
  valid_582910 = validateParameter(valid_582910, JBool, required = false,
                                 default = newJBool(true))
  if valid_582910 != nil:
    section.add "prettyPrint", valid_582910
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582911: Call_DfareportingRemarketingListsGet_582899;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one remarketing list by ID.
  ## 
  let valid = call_582911.validator(path, query, header, formData, body)
  let scheme = call_582911.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582911.url(scheme.get, call_582911.host, call_582911.base,
                         call_582911.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582911, url, valid)

proc call*(call_582912: Call_DfareportingRemarketingListsGet_582899;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsGet
  ## Gets one remarketing list by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Remarketing list ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582913 = newJObject()
  var query_582914 = newJObject()
  add(path_582913, "profileId", newJString(profileId))
  add(query_582914, "fields", newJString(fields))
  add(query_582914, "quotaUser", newJString(quotaUser))
  add(query_582914, "alt", newJString(alt))
  add(query_582914, "oauth_token", newJString(oauthToken))
  add(query_582914, "userIp", newJString(userIp))
  add(path_582913, "id", newJString(id))
  add(query_582914, "key", newJString(key))
  add(query_582914, "prettyPrint", newJBool(prettyPrint))
  result = call_582912.call(path_582913, query_582914, nil, nil, nil)

var dfareportingRemarketingListsGet* = Call_DfareportingRemarketingListsGet_582899(
    name: "dfareportingRemarketingListsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists/{id}",
    validator: validate_DfareportingRemarketingListsGet_582900,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsGet_582901,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsInsert_582935 = ref object of OpenApiRestCall_579437
proc url_DfareportingReportsInsert_582937(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsInsert_582936(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582938 = path.getOrDefault("profileId")
  valid_582938 = validateParameter(valid_582938, JString, required = true,
                                 default = nil)
  if valid_582938 != nil:
    section.add "profileId", valid_582938
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582939 = query.getOrDefault("fields")
  valid_582939 = validateParameter(valid_582939, JString, required = false,
                                 default = nil)
  if valid_582939 != nil:
    section.add "fields", valid_582939
  var valid_582940 = query.getOrDefault("quotaUser")
  valid_582940 = validateParameter(valid_582940, JString, required = false,
                                 default = nil)
  if valid_582940 != nil:
    section.add "quotaUser", valid_582940
  var valid_582941 = query.getOrDefault("alt")
  valid_582941 = validateParameter(valid_582941, JString, required = false,
                                 default = newJString("json"))
  if valid_582941 != nil:
    section.add "alt", valid_582941
  var valid_582942 = query.getOrDefault("oauth_token")
  valid_582942 = validateParameter(valid_582942, JString, required = false,
                                 default = nil)
  if valid_582942 != nil:
    section.add "oauth_token", valid_582942
  var valid_582943 = query.getOrDefault("userIp")
  valid_582943 = validateParameter(valid_582943, JString, required = false,
                                 default = nil)
  if valid_582943 != nil:
    section.add "userIp", valid_582943
  var valid_582944 = query.getOrDefault("key")
  valid_582944 = validateParameter(valid_582944, JString, required = false,
                                 default = nil)
  if valid_582944 != nil:
    section.add "key", valid_582944
  var valid_582945 = query.getOrDefault("prettyPrint")
  valid_582945 = validateParameter(valid_582945, JBool, required = false,
                                 default = newJBool(true))
  if valid_582945 != nil:
    section.add "prettyPrint", valid_582945
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582947: Call_DfareportingReportsInsert_582935; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a report.
  ## 
  let valid = call_582947.validator(path, query, header, formData, body)
  let scheme = call_582947.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582947.url(scheme.get, call_582947.host, call_582947.base,
                         call_582947.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582947, url, valid)

proc call*(call_582948: Call_DfareportingReportsInsert_582935; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsInsert
  ## Creates a report.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582949 = newJObject()
  var query_582950 = newJObject()
  var body_582951 = newJObject()
  add(path_582949, "profileId", newJString(profileId))
  add(query_582950, "fields", newJString(fields))
  add(query_582950, "quotaUser", newJString(quotaUser))
  add(query_582950, "alt", newJString(alt))
  add(query_582950, "oauth_token", newJString(oauthToken))
  add(query_582950, "userIp", newJString(userIp))
  add(query_582950, "key", newJString(key))
  if body != nil:
    body_582951 = body
  add(query_582950, "prettyPrint", newJBool(prettyPrint))
  result = call_582948.call(path_582949, query_582950, nil, nil, body_582951)

var dfareportingReportsInsert* = Call_DfareportingReportsInsert_582935(
    name: "dfareportingReportsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/reports",
    validator: validate_DfareportingReportsInsert_582936,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsInsert_582937,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsList_582915 = ref object of OpenApiRestCall_579437
proc url_DfareportingReportsList_582917(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsList_582916(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves list of reports.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582918 = path.getOrDefault("profileId")
  valid_582918 = validateParameter(valid_582918, JString, required = true,
                                 default = nil)
  if valid_582918 != nil:
    section.add "profileId", valid_582918
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : The field by which to sort the list.
  ##   scope: JString
  ##        : The scope that defines which results are returned.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582919 = query.getOrDefault("fields")
  valid_582919 = validateParameter(valid_582919, JString, required = false,
                                 default = nil)
  if valid_582919 != nil:
    section.add "fields", valid_582919
  var valid_582920 = query.getOrDefault("pageToken")
  valid_582920 = validateParameter(valid_582920, JString, required = false,
                                 default = nil)
  if valid_582920 != nil:
    section.add "pageToken", valid_582920
  var valid_582921 = query.getOrDefault("quotaUser")
  valid_582921 = validateParameter(valid_582921, JString, required = false,
                                 default = nil)
  if valid_582921 != nil:
    section.add "quotaUser", valid_582921
  var valid_582922 = query.getOrDefault("sortField")
  valid_582922 = validateParameter(valid_582922, JString, required = false,
                                 default = newJString("LAST_MODIFIED_TIME"))
  if valid_582922 != nil:
    section.add "sortField", valid_582922
  var valid_582923 = query.getOrDefault("scope")
  valid_582923 = validateParameter(valid_582923, JString, required = false,
                                 default = newJString("MINE"))
  if valid_582923 != nil:
    section.add "scope", valid_582923
  var valid_582924 = query.getOrDefault("alt")
  valid_582924 = validateParameter(valid_582924, JString, required = false,
                                 default = newJString("json"))
  if valid_582924 != nil:
    section.add "alt", valid_582924
  var valid_582925 = query.getOrDefault("oauth_token")
  valid_582925 = validateParameter(valid_582925, JString, required = false,
                                 default = nil)
  if valid_582925 != nil:
    section.add "oauth_token", valid_582925
  var valid_582926 = query.getOrDefault("userIp")
  valid_582926 = validateParameter(valid_582926, JString, required = false,
                                 default = nil)
  if valid_582926 != nil:
    section.add "userIp", valid_582926
  var valid_582927 = query.getOrDefault("maxResults")
  valid_582927 = validateParameter(valid_582927, JInt, required = false,
                                 default = newJInt(10))
  if valid_582927 != nil:
    section.add "maxResults", valid_582927
  var valid_582928 = query.getOrDefault("key")
  valid_582928 = validateParameter(valid_582928, JString, required = false,
                                 default = nil)
  if valid_582928 != nil:
    section.add "key", valid_582928
  var valid_582929 = query.getOrDefault("sortOrder")
  valid_582929 = validateParameter(valid_582929, JString, required = false,
                                 default = newJString("DESCENDING"))
  if valid_582929 != nil:
    section.add "sortOrder", valid_582929
  var valid_582930 = query.getOrDefault("prettyPrint")
  valid_582930 = validateParameter(valid_582930, JBool, required = false,
                                 default = newJBool(true))
  if valid_582930 != nil:
    section.add "prettyPrint", valid_582930
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582931: Call_DfareportingReportsList_582915; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves list of reports.
  ## 
  let valid = call_582931.validator(path, query, header, formData, body)
  let scheme = call_582931.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582931.url(scheme.get, call_582931.host, call_582931.base,
                         call_582931.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582931, url, valid)

proc call*(call_582932: Call_DfareportingReportsList_582915; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "LAST_MODIFIED_TIME"; scope: string = "MINE";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 10; key: string = ""; sortOrder: string = "DESCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingReportsList
  ## Retrieves list of reports.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : The field by which to sort the list.
  ##   scope: string
  ##        : The scope that defines which results are returned.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582933 = newJObject()
  var query_582934 = newJObject()
  add(path_582933, "profileId", newJString(profileId))
  add(query_582934, "fields", newJString(fields))
  add(query_582934, "pageToken", newJString(pageToken))
  add(query_582934, "quotaUser", newJString(quotaUser))
  add(query_582934, "sortField", newJString(sortField))
  add(query_582934, "scope", newJString(scope))
  add(query_582934, "alt", newJString(alt))
  add(query_582934, "oauth_token", newJString(oauthToken))
  add(query_582934, "userIp", newJString(userIp))
  add(query_582934, "maxResults", newJInt(maxResults))
  add(query_582934, "key", newJString(key))
  add(query_582934, "sortOrder", newJString(sortOrder))
  add(query_582934, "prettyPrint", newJBool(prettyPrint))
  result = call_582932.call(path_582933, query_582934, nil, nil, nil)

var dfareportingReportsList* = Call_DfareportingReportsList_582915(
    name: "dfareportingReportsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/reports",
    validator: validate_DfareportingReportsList_582916,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsList_582917,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsCompatibleFieldsQuery_582952 = ref object of OpenApiRestCall_579437
proc url_DfareportingReportsCompatibleFieldsQuery_582954(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"), (kind: ConstantSegment,
        value: "/reports/compatiblefields/query")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsCompatibleFieldsQuery_582953(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the fields that are compatible to be selected in the respective sections of a report criteria, given the fields already selected in the input report and user permissions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582955 = path.getOrDefault("profileId")
  valid_582955 = validateParameter(valid_582955, JString, required = true,
                                 default = nil)
  if valid_582955 != nil:
    section.add "profileId", valid_582955
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582956 = query.getOrDefault("fields")
  valid_582956 = validateParameter(valid_582956, JString, required = false,
                                 default = nil)
  if valid_582956 != nil:
    section.add "fields", valid_582956
  var valid_582957 = query.getOrDefault("quotaUser")
  valid_582957 = validateParameter(valid_582957, JString, required = false,
                                 default = nil)
  if valid_582957 != nil:
    section.add "quotaUser", valid_582957
  var valid_582958 = query.getOrDefault("alt")
  valid_582958 = validateParameter(valid_582958, JString, required = false,
                                 default = newJString("json"))
  if valid_582958 != nil:
    section.add "alt", valid_582958
  var valid_582959 = query.getOrDefault("oauth_token")
  valid_582959 = validateParameter(valid_582959, JString, required = false,
                                 default = nil)
  if valid_582959 != nil:
    section.add "oauth_token", valid_582959
  var valid_582960 = query.getOrDefault("userIp")
  valid_582960 = validateParameter(valid_582960, JString, required = false,
                                 default = nil)
  if valid_582960 != nil:
    section.add "userIp", valid_582960
  var valid_582961 = query.getOrDefault("key")
  valid_582961 = validateParameter(valid_582961, JString, required = false,
                                 default = nil)
  if valid_582961 != nil:
    section.add "key", valid_582961
  var valid_582962 = query.getOrDefault("prettyPrint")
  valid_582962 = validateParameter(valid_582962, JBool, required = false,
                                 default = newJBool(true))
  if valid_582962 != nil:
    section.add "prettyPrint", valid_582962
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582964: Call_DfareportingReportsCompatibleFieldsQuery_582952;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the fields that are compatible to be selected in the respective sections of a report criteria, given the fields already selected in the input report and user permissions.
  ## 
  let valid = call_582964.validator(path, query, header, formData, body)
  let scheme = call_582964.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582964.url(scheme.get, call_582964.host, call_582964.base,
                         call_582964.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582964, url, valid)

proc call*(call_582965: Call_DfareportingReportsCompatibleFieldsQuery_582952;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsCompatibleFieldsQuery
  ## Returns the fields that are compatible to be selected in the respective sections of a report criteria, given the fields already selected in the input report and user permissions.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582966 = newJObject()
  var query_582967 = newJObject()
  var body_582968 = newJObject()
  add(path_582966, "profileId", newJString(profileId))
  add(query_582967, "fields", newJString(fields))
  add(query_582967, "quotaUser", newJString(quotaUser))
  add(query_582967, "alt", newJString(alt))
  add(query_582967, "oauth_token", newJString(oauthToken))
  add(query_582967, "userIp", newJString(userIp))
  add(query_582967, "key", newJString(key))
  if body != nil:
    body_582968 = body
  add(query_582967, "prettyPrint", newJBool(prettyPrint))
  result = call_582965.call(path_582966, query_582967, nil, nil, body_582968)

var dfareportingReportsCompatibleFieldsQuery* = Call_DfareportingReportsCompatibleFieldsQuery_582952(
    name: "dfareportingReportsCompatibleFieldsQuery", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/compatiblefields/query",
    validator: validate_DfareportingReportsCompatibleFieldsQuery_582953,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsCompatibleFieldsQuery_582954,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsUpdate_582985 = ref object of OpenApiRestCall_579437
proc url_DfareportingReportsUpdate_582987(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsUpdate_582986(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582988 = path.getOrDefault("profileId")
  valid_582988 = validateParameter(valid_582988, JString, required = true,
                                 default = nil)
  if valid_582988 != nil:
    section.add "profileId", valid_582988
  var valid_582989 = path.getOrDefault("reportId")
  valid_582989 = validateParameter(valid_582989, JString, required = true,
                                 default = nil)
  if valid_582989 != nil:
    section.add "reportId", valid_582989
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582990 = query.getOrDefault("fields")
  valid_582990 = validateParameter(valid_582990, JString, required = false,
                                 default = nil)
  if valid_582990 != nil:
    section.add "fields", valid_582990
  var valid_582991 = query.getOrDefault("quotaUser")
  valid_582991 = validateParameter(valid_582991, JString, required = false,
                                 default = nil)
  if valid_582991 != nil:
    section.add "quotaUser", valid_582991
  var valid_582992 = query.getOrDefault("alt")
  valid_582992 = validateParameter(valid_582992, JString, required = false,
                                 default = newJString("json"))
  if valid_582992 != nil:
    section.add "alt", valid_582992
  var valid_582993 = query.getOrDefault("oauth_token")
  valid_582993 = validateParameter(valid_582993, JString, required = false,
                                 default = nil)
  if valid_582993 != nil:
    section.add "oauth_token", valid_582993
  var valid_582994 = query.getOrDefault("userIp")
  valid_582994 = validateParameter(valid_582994, JString, required = false,
                                 default = nil)
  if valid_582994 != nil:
    section.add "userIp", valid_582994
  var valid_582995 = query.getOrDefault("key")
  valid_582995 = validateParameter(valid_582995, JString, required = false,
                                 default = nil)
  if valid_582995 != nil:
    section.add "key", valid_582995
  var valid_582996 = query.getOrDefault("prettyPrint")
  valid_582996 = validateParameter(valid_582996, JBool, required = false,
                                 default = newJBool(true))
  if valid_582996 != nil:
    section.add "prettyPrint", valid_582996
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_582998: Call_DfareportingReportsUpdate_582985; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a report.
  ## 
  let valid = call_582998.validator(path, query, header, formData, body)
  let scheme = call_582998.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582998.url(scheme.get, call_582998.host, call_582998.base,
                         call_582998.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582998, url, valid)

proc call*(call_582999: Call_DfareportingReportsUpdate_582985; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsUpdate
  ## Updates a report.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583000 = newJObject()
  var query_583001 = newJObject()
  var body_583002 = newJObject()
  add(path_583000, "profileId", newJString(profileId))
  add(query_583001, "fields", newJString(fields))
  add(query_583001, "quotaUser", newJString(quotaUser))
  add(query_583001, "alt", newJString(alt))
  add(query_583001, "oauth_token", newJString(oauthToken))
  add(query_583001, "userIp", newJString(userIp))
  add(query_583001, "key", newJString(key))
  add(path_583000, "reportId", newJString(reportId))
  if body != nil:
    body_583002 = body
  add(query_583001, "prettyPrint", newJBool(prettyPrint))
  result = call_582999.call(path_583000, query_583001, nil, nil, body_583002)

var dfareportingReportsUpdate* = Call_DfareportingReportsUpdate_582985(
    name: "dfareportingReportsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsUpdate_582986,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsUpdate_582987,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsGet_582969 = ref object of OpenApiRestCall_579437
proc url_DfareportingReportsGet_582971(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsGet_582970(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a report by its ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_582972 = path.getOrDefault("profileId")
  valid_582972 = validateParameter(valid_582972, JString, required = true,
                                 default = nil)
  if valid_582972 != nil:
    section.add "profileId", valid_582972
  var valid_582973 = path.getOrDefault("reportId")
  valid_582973 = validateParameter(valid_582973, JString, required = true,
                                 default = nil)
  if valid_582973 != nil:
    section.add "reportId", valid_582973
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_582974 = query.getOrDefault("fields")
  valid_582974 = validateParameter(valid_582974, JString, required = false,
                                 default = nil)
  if valid_582974 != nil:
    section.add "fields", valid_582974
  var valid_582975 = query.getOrDefault("quotaUser")
  valid_582975 = validateParameter(valid_582975, JString, required = false,
                                 default = nil)
  if valid_582975 != nil:
    section.add "quotaUser", valid_582975
  var valid_582976 = query.getOrDefault("alt")
  valid_582976 = validateParameter(valid_582976, JString, required = false,
                                 default = newJString("json"))
  if valid_582976 != nil:
    section.add "alt", valid_582976
  var valid_582977 = query.getOrDefault("oauth_token")
  valid_582977 = validateParameter(valid_582977, JString, required = false,
                                 default = nil)
  if valid_582977 != nil:
    section.add "oauth_token", valid_582977
  var valid_582978 = query.getOrDefault("userIp")
  valid_582978 = validateParameter(valid_582978, JString, required = false,
                                 default = nil)
  if valid_582978 != nil:
    section.add "userIp", valid_582978
  var valid_582979 = query.getOrDefault("key")
  valid_582979 = validateParameter(valid_582979, JString, required = false,
                                 default = nil)
  if valid_582979 != nil:
    section.add "key", valid_582979
  var valid_582980 = query.getOrDefault("prettyPrint")
  valid_582980 = validateParameter(valid_582980, JBool, required = false,
                                 default = newJBool(true))
  if valid_582980 != nil:
    section.add "prettyPrint", valid_582980
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_582981: Call_DfareportingReportsGet_582969; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a report by its ID.
  ## 
  let valid = call_582981.validator(path, query, header, formData, body)
  let scheme = call_582981.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_582981.url(scheme.get, call_582981.host, call_582981.base,
                         call_582981.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_582981, url, valid)

proc call*(call_582982: Call_DfareportingReportsGet_582969; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsGet
  ## Retrieves a report by its ID.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_582983 = newJObject()
  var query_582984 = newJObject()
  add(path_582983, "profileId", newJString(profileId))
  add(query_582984, "fields", newJString(fields))
  add(query_582984, "quotaUser", newJString(quotaUser))
  add(query_582984, "alt", newJString(alt))
  add(query_582984, "oauth_token", newJString(oauthToken))
  add(query_582984, "userIp", newJString(userIp))
  add(query_582984, "key", newJString(key))
  add(path_582983, "reportId", newJString(reportId))
  add(query_582984, "prettyPrint", newJBool(prettyPrint))
  result = call_582982.call(path_582983, query_582984, nil, nil, nil)

var dfareportingReportsGet* = Call_DfareportingReportsGet_582969(
    name: "dfareportingReportsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsGet_582970, base: "/dfareporting/v2.7",
    url: url_DfareportingReportsGet_582971, schemes: {Scheme.Https})
type
  Call_DfareportingReportsPatch_583019 = ref object of OpenApiRestCall_579437
proc url_DfareportingReportsPatch_583021(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsPatch_583020(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a report. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583022 = path.getOrDefault("profileId")
  valid_583022 = validateParameter(valid_583022, JString, required = true,
                                 default = nil)
  if valid_583022 != nil:
    section.add "profileId", valid_583022
  var valid_583023 = path.getOrDefault("reportId")
  valid_583023 = validateParameter(valid_583023, JString, required = true,
                                 default = nil)
  if valid_583023 != nil:
    section.add "reportId", valid_583023
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583024 = query.getOrDefault("fields")
  valid_583024 = validateParameter(valid_583024, JString, required = false,
                                 default = nil)
  if valid_583024 != nil:
    section.add "fields", valid_583024
  var valid_583025 = query.getOrDefault("quotaUser")
  valid_583025 = validateParameter(valid_583025, JString, required = false,
                                 default = nil)
  if valid_583025 != nil:
    section.add "quotaUser", valid_583025
  var valid_583026 = query.getOrDefault("alt")
  valid_583026 = validateParameter(valid_583026, JString, required = false,
                                 default = newJString("json"))
  if valid_583026 != nil:
    section.add "alt", valid_583026
  var valid_583027 = query.getOrDefault("oauth_token")
  valid_583027 = validateParameter(valid_583027, JString, required = false,
                                 default = nil)
  if valid_583027 != nil:
    section.add "oauth_token", valid_583027
  var valid_583028 = query.getOrDefault("userIp")
  valid_583028 = validateParameter(valid_583028, JString, required = false,
                                 default = nil)
  if valid_583028 != nil:
    section.add "userIp", valid_583028
  var valid_583029 = query.getOrDefault("key")
  valid_583029 = validateParameter(valid_583029, JString, required = false,
                                 default = nil)
  if valid_583029 != nil:
    section.add "key", valid_583029
  var valid_583030 = query.getOrDefault("prettyPrint")
  valid_583030 = validateParameter(valid_583030, JBool, required = false,
                                 default = newJBool(true))
  if valid_583030 != nil:
    section.add "prettyPrint", valid_583030
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_583032: Call_DfareportingReportsPatch_583019; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a report. This method supports patch semantics.
  ## 
  let valid = call_583032.validator(path, query, header, formData, body)
  let scheme = call_583032.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583032.url(scheme.get, call_583032.host, call_583032.base,
                         call_583032.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583032, url, valid)

proc call*(call_583033: Call_DfareportingReportsPatch_583019; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsPatch
  ## Updates a report. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583034 = newJObject()
  var query_583035 = newJObject()
  var body_583036 = newJObject()
  add(path_583034, "profileId", newJString(profileId))
  add(query_583035, "fields", newJString(fields))
  add(query_583035, "quotaUser", newJString(quotaUser))
  add(query_583035, "alt", newJString(alt))
  add(query_583035, "oauth_token", newJString(oauthToken))
  add(query_583035, "userIp", newJString(userIp))
  add(query_583035, "key", newJString(key))
  add(path_583034, "reportId", newJString(reportId))
  if body != nil:
    body_583036 = body
  add(query_583035, "prettyPrint", newJBool(prettyPrint))
  result = call_583033.call(path_583034, query_583035, nil, nil, body_583036)

var dfareportingReportsPatch* = Call_DfareportingReportsPatch_583019(
    name: "dfareportingReportsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsPatch_583020,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsPatch_583021,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsDelete_583003 = ref object of OpenApiRestCall_579437
proc url_DfareportingReportsDelete_583005(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsDelete_583004(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a report by its ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583006 = path.getOrDefault("profileId")
  valid_583006 = validateParameter(valid_583006, JString, required = true,
                                 default = nil)
  if valid_583006 != nil:
    section.add "profileId", valid_583006
  var valid_583007 = path.getOrDefault("reportId")
  valid_583007 = validateParameter(valid_583007, JString, required = true,
                                 default = nil)
  if valid_583007 != nil:
    section.add "reportId", valid_583007
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583008 = query.getOrDefault("fields")
  valid_583008 = validateParameter(valid_583008, JString, required = false,
                                 default = nil)
  if valid_583008 != nil:
    section.add "fields", valid_583008
  var valid_583009 = query.getOrDefault("quotaUser")
  valid_583009 = validateParameter(valid_583009, JString, required = false,
                                 default = nil)
  if valid_583009 != nil:
    section.add "quotaUser", valid_583009
  var valid_583010 = query.getOrDefault("alt")
  valid_583010 = validateParameter(valid_583010, JString, required = false,
                                 default = newJString("json"))
  if valid_583010 != nil:
    section.add "alt", valid_583010
  var valid_583011 = query.getOrDefault("oauth_token")
  valid_583011 = validateParameter(valid_583011, JString, required = false,
                                 default = nil)
  if valid_583011 != nil:
    section.add "oauth_token", valid_583011
  var valid_583012 = query.getOrDefault("userIp")
  valid_583012 = validateParameter(valid_583012, JString, required = false,
                                 default = nil)
  if valid_583012 != nil:
    section.add "userIp", valid_583012
  var valid_583013 = query.getOrDefault("key")
  valid_583013 = validateParameter(valid_583013, JString, required = false,
                                 default = nil)
  if valid_583013 != nil:
    section.add "key", valid_583013
  var valid_583014 = query.getOrDefault("prettyPrint")
  valid_583014 = validateParameter(valid_583014, JBool, required = false,
                                 default = newJBool(true))
  if valid_583014 != nil:
    section.add "prettyPrint", valid_583014
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583015: Call_DfareportingReportsDelete_583003; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a report by its ID.
  ## 
  let valid = call_583015.validator(path, query, header, formData, body)
  let scheme = call_583015.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583015.url(scheme.get, call_583015.host, call_583015.base,
                         call_583015.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583015, url, valid)

proc call*(call_583016: Call_DfareportingReportsDelete_583003; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsDelete
  ## Deletes a report by its ID.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583017 = newJObject()
  var query_583018 = newJObject()
  add(path_583017, "profileId", newJString(profileId))
  add(query_583018, "fields", newJString(fields))
  add(query_583018, "quotaUser", newJString(quotaUser))
  add(query_583018, "alt", newJString(alt))
  add(query_583018, "oauth_token", newJString(oauthToken))
  add(query_583018, "userIp", newJString(userIp))
  add(query_583018, "key", newJString(key))
  add(path_583017, "reportId", newJString(reportId))
  add(query_583018, "prettyPrint", newJBool(prettyPrint))
  result = call_583016.call(path_583017, query_583018, nil, nil, nil)

var dfareportingReportsDelete* = Call_DfareportingReportsDelete_583003(
    name: "dfareportingReportsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsDelete_583004,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsDelete_583005,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsFilesList_583037 = ref object of OpenApiRestCall_579437
proc url_DfareportingReportsFilesList_583039(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsFilesList_583038(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists files for a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the parent report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583040 = path.getOrDefault("profileId")
  valid_583040 = validateParameter(valid_583040, JString, required = true,
                                 default = nil)
  if valid_583040 != nil:
    section.add "profileId", valid_583040
  var valid_583041 = path.getOrDefault("reportId")
  valid_583041 = validateParameter(valid_583041, JString, required = true,
                                 default = nil)
  if valid_583041 != nil:
    section.add "reportId", valid_583041
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : The field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583042 = query.getOrDefault("fields")
  valid_583042 = validateParameter(valid_583042, JString, required = false,
                                 default = nil)
  if valid_583042 != nil:
    section.add "fields", valid_583042
  var valid_583043 = query.getOrDefault("pageToken")
  valid_583043 = validateParameter(valid_583043, JString, required = false,
                                 default = nil)
  if valid_583043 != nil:
    section.add "pageToken", valid_583043
  var valid_583044 = query.getOrDefault("quotaUser")
  valid_583044 = validateParameter(valid_583044, JString, required = false,
                                 default = nil)
  if valid_583044 != nil:
    section.add "quotaUser", valid_583044
  var valid_583045 = query.getOrDefault("sortField")
  valid_583045 = validateParameter(valid_583045, JString, required = false,
                                 default = newJString("LAST_MODIFIED_TIME"))
  if valid_583045 != nil:
    section.add "sortField", valid_583045
  var valid_583046 = query.getOrDefault("alt")
  valid_583046 = validateParameter(valid_583046, JString, required = false,
                                 default = newJString("json"))
  if valid_583046 != nil:
    section.add "alt", valid_583046
  var valid_583047 = query.getOrDefault("oauth_token")
  valid_583047 = validateParameter(valid_583047, JString, required = false,
                                 default = nil)
  if valid_583047 != nil:
    section.add "oauth_token", valid_583047
  var valid_583048 = query.getOrDefault("userIp")
  valid_583048 = validateParameter(valid_583048, JString, required = false,
                                 default = nil)
  if valid_583048 != nil:
    section.add "userIp", valid_583048
  var valid_583049 = query.getOrDefault("maxResults")
  valid_583049 = validateParameter(valid_583049, JInt, required = false,
                                 default = newJInt(10))
  if valid_583049 != nil:
    section.add "maxResults", valid_583049
  var valid_583050 = query.getOrDefault("key")
  valid_583050 = validateParameter(valid_583050, JString, required = false,
                                 default = nil)
  if valid_583050 != nil:
    section.add "key", valid_583050
  var valid_583051 = query.getOrDefault("sortOrder")
  valid_583051 = validateParameter(valid_583051, JString, required = false,
                                 default = newJString("DESCENDING"))
  if valid_583051 != nil:
    section.add "sortOrder", valid_583051
  var valid_583052 = query.getOrDefault("prettyPrint")
  valid_583052 = validateParameter(valid_583052, JBool, required = false,
                                 default = newJBool(true))
  if valid_583052 != nil:
    section.add "prettyPrint", valid_583052
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583053: Call_DfareportingReportsFilesList_583037; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists files for a report.
  ## 
  let valid = call_583053.validator(path, query, header, formData, body)
  let scheme = call_583053.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583053.url(scheme.get, call_583053.host, call_583053.base,
                         call_583053.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583053, url, valid)

proc call*(call_583054: Call_DfareportingReportsFilesList_583037;
          profileId: string; reportId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = "";
          sortField: string = "LAST_MODIFIED_TIME"; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 10;
          key: string = ""; sortOrder: string = "DESCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsFilesList
  ## Lists files for a report.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : The field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   reportId: string (required)
  ##           : The ID of the parent report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583055 = newJObject()
  var query_583056 = newJObject()
  add(path_583055, "profileId", newJString(profileId))
  add(query_583056, "fields", newJString(fields))
  add(query_583056, "pageToken", newJString(pageToken))
  add(query_583056, "quotaUser", newJString(quotaUser))
  add(query_583056, "sortField", newJString(sortField))
  add(query_583056, "alt", newJString(alt))
  add(query_583056, "oauth_token", newJString(oauthToken))
  add(query_583056, "userIp", newJString(userIp))
  add(query_583056, "maxResults", newJInt(maxResults))
  add(query_583056, "key", newJString(key))
  add(query_583056, "sortOrder", newJString(sortOrder))
  add(path_583055, "reportId", newJString(reportId))
  add(query_583056, "prettyPrint", newJBool(prettyPrint))
  result = call_583054.call(path_583055, query_583056, nil, nil, nil)

var dfareportingReportsFilesList* = Call_DfareportingReportsFilesList_583037(
    name: "dfareportingReportsFilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}/files",
    validator: validate_DfareportingReportsFilesList_583038,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsFilesList_583039,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsFilesGet_583057 = ref object of OpenApiRestCall_579437
proc url_DfareportingReportsFilesGet_583059(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  assert "fileId" in path, "`fileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/files/"),
               (kind: VariableSegment, value: "fileId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsFilesGet_583058(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a report file. This method supports media download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  ##   fileId: JString (required)
  ##         : The ID of the report file.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583060 = path.getOrDefault("profileId")
  valid_583060 = validateParameter(valid_583060, JString, required = true,
                                 default = nil)
  if valid_583060 != nil:
    section.add "profileId", valid_583060
  var valid_583061 = path.getOrDefault("fileId")
  valid_583061 = validateParameter(valid_583061, JString, required = true,
                                 default = nil)
  if valid_583061 != nil:
    section.add "fileId", valid_583061
  var valid_583062 = path.getOrDefault("reportId")
  valid_583062 = validateParameter(valid_583062, JString, required = true,
                                 default = nil)
  if valid_583062 != nil:
    section.add "reportId", valid_583062
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583063 = query.getOrDefault("fields")
  valid_583063 = validateParameter(valid_583063, JString, required = false,
                                 default = nil)
  if valid_583063 != nil:
    section.add "fields", valid_583063
  var valid_583064 = query.getOrDefault("quotaUser")
  valid_583064 = validateParameter(valid_583064, JString, required = false,
                                 default = nil)
  if valid_583064 != nil:
    section.add "quotaUser", valid_583064
  var valid_583065 = query.getOrDefault("alt")
  valid_583065 = validateParameter(valid_583065, JString, required = false,
                                 default = newJString("json"))
  if valid_583065 != nil:
    section.add "alt", valid_583065
  var valid_583066 = query.getOrDefault("oauth_token")
  valid_583066 = validateParameter(valid_583066, JString, required = false,
                                 default = nil)
  if valid_583066 != nil:
    section.add "oauth_token", valid_583066
  var valid_583067 = query.getOrDefault("userIp")
  valid_583067 = validateParameter(valid_583067, JString, required = false,
                                 default = nil)
  if valid_583067 != nil:
    section.add "userIp", valid_583067
  var valid_583068 = query.getOrDefault("key")
  valid_583068 = validateParameter(valid_583068, JString, required = false,
                                 default = nil)
  if valid_583068 != nil:
    section.add "key", valid_583068
  var valid_583069 = query.getOrDefault("prettyPrint")
  valid_583069 = validateParameter(valid_583069, JBool, required = false,
                                 default = newJBool(true))
  if valid_583069 != nil:
    section.add "prettyPrint", valid_583069
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583070: Call_DfareportingReportsFilesGet_583057; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a report file. This method supports media download.
  ## 
  let valid = call_583070.validator(path, query, header, formData, body)
  let scheme = call_583070.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583070.url(scheme.get, call_583070.host, call_583070.base,
                         call_583070.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583070, url, valid)

proc call*(call_583071: Call_DfareportingReportsFilesGet_583057; profileId: string;
          fileId: string; reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsFilesGet
  ## Retrieves a report file. This method supports media download.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fileId: string (required)
  ##         : The ID of the report file.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583072 = newJObject()
  var query_583073 = newJObject()
  add(path_583072, "profileId", newJString(profileId))
  add(query_583073, "fields", newJString(fields))
  add(query_583073, "quotaUser", newJString(quotaUser))
  add(path_583072, "fileId", newJString(fileId))
  add(query_583073, "alt", newJString(alt))
  add(query_583073, "oauth_token", newJString(oauthToken))
  add(query_583073, "userIp", newJString(userIp))
  add(query_583073, "key", newJString(key))
  add(path_583072, "reportId", newJString(reportId))
  add(query_583073, "prettyPrint", newJBool(prettyPrint))
  result = call_583071.call(path_583072, query_583073, nil, nil, nil)

var dfareportingReportsFilesGet* = Call_DfareportingReportsFilesGet_583057(
    name: "dfareportingReportsFilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}/files/{fileId}",
    validator: validate_DfareportingReportsFilesGet_583058,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsFilesGet_583059,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsRun_583074 = ref object of OpenApiRestCall_579437
proc url_DfareportingReportsRun_583076(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/run")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsRun_583075(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Runs a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583077 = path.getOrDefault("profileId")
  valid_583077 = validateParameter(valid_583077, JString, required = true,
                                 default = nil)
  if valid_583077 != nil:
    section.add "profileId", valid_583077
  var valid_583078 = path.getOrDefault("reportId")
  valid_583078 = validateParameter(valid_583078, JString, required = true,
                                 default = nil)
  if valid_583078 != nil:
    section.add "reportId", valid_583078
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   synchronous: JBool
  ##              : If set and true, tries to run the report synchronously.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583079 = query.getOrDefault("fields")
  valid_583079 = validateParameter(valid_583079, JString, required = false,
                                 default = nil)
  if valid_583079 != nil:
    section.add "fields", valid_583079
  var valid_583080 = query.getOrDefault("quotaUser")
  valid_583080 = validateParameter(valid_583080, JString, required = false,
                                 default = nil)
  if valid_583080 != nil:
    section.add "quotaUser", valid_583080
  var valid_583081 = query.getOrDefault("alt")
  valid_583081 = validateParameter(valid_583081, JString, required = false,
                                 default = newJString("json"))
  if valid_583081 != nil:
    section.add "alt", valid_583081
  var valid_583082 = query.getOrDefault("oauth_token")
  valid_583082 = validateParameter(valid_583082, JString, required = false,
                                 default = nil)
  if valid_583082 != nil:
    section.add "oauth_token", valid_583082
  var valid_583083 = query.getOrDefault("userIp")
  valid_583083 = validateParameter(valid_583083, JString, required = false,
                                 default = nil)
  if valid_583083 != nil:
    section.add "userIp", valid_583083
  var valid_583084 = query.getOrDefault("synchronous")
  valid_583084 = validateParameter(valid_583084, JBool, required = false,
                                 default = newJBool(false))
  if valid_583084 != nil:
    section.add "synchronous", valid_583084
  var valid_583085 = query.getOrDefault("key")
  valid_583085 = validateParameter(valid_583085, JString, required = false,
                                 default = nil)
  if valid_583085 != nil:
    section.add "key", valid_583085
  var valid_583086 = query.getOrDefault("prettyPrint")
  valid_583086 = validateParameter(valid_583086, JBool, required = false,
                                 default = newJBool(true))
  if valid_583086 != nil:
    section.add "prettyPrint", valid_583086
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583087: Call_DfareportingReportsRun_583074; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Runs a report.
  ## 
  let valid = call_583087.validator(path, query, header, formData, body)
  let scheme = call_583087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583087.url(scheme.get, call_583087.host, call_583087.base,
                         call_583087.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583087, url, valid)

proc call*(call_583088: Call_DfareportingReportsRun_583074; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          synchronous: bool = false; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsRun
  ## Runs a report.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   synchronous: bool
  ##              : If set and true, tries to run the report synchronously.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583089 = newJObject()
  var query_583090 = newJObject()
  add(path_583089, "profileId", newJString(profileId))
  add(query_583090, "fields", newJString(fields))
  add(query_583090, "quotaUser", newJString(quotaUser))
  add(query_583090, "alt", newJString(alt))
  add(query_583090, "oauth_token", newJString(oauthToken))
  add(query_583090, "userIp", newJString(userIp))
  add(query_583090, "synchronous", newJBool(synchronous))
  add(query_583090, "key", newJString(key))
  add(path_583089, "reportId", newJString(reportId))
  add(query_583090, "prettyPrint", newJBool(prettyPrint))
  result = call_583088.call(path_583089, query_583090, nil, nil, nil)

var dfareportingReportsRun* = Call_DfareportingReportsRun_583074(
    name: "dfareportingReportsRun", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}/run",
    validator: validate_DfareportingReportsRun_583075, base: "/dfareporting/v2.7",
    url: url_DfareportingReportsRun_583076, schemes: {Scheme.Https})
type
  Call_DfareportingSitesUpdate_583121 = ref object of OpenApiRestCall_579437
proc url_DfareportingSitesUpdate_583123(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesUpdate_583122(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing site.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583124 = path.getOrDefault("profileId")
  valid_583124 = validateParameter(valid_583124, JString, required = true,
                                 default = nil)
  if valid_583124 != nil:
    section.add "profileId", valid_583124
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583125 = query.getOrDefault("fields")
  valid_583125 = validateParameter(valid_583125, JString, required = false,
                                 default = nil)
  if valid_583125 != nil:
    section.add "fields", valid_583125
  var valid_583126 = query.getOrDefault("quotaUser")
  valid_583126 = validateParameter(valid_583126, JString, required = false,
                                 default = nil)
  if valid_583126 != nil:
    section.add "quotaUser", valid_583126
  var valid_583127 = query.getOrDefault("alt")
  valid_583127 = validateParameter(valid_583127, JString, required = false,
                                 default = newJString("json"))
  if valid_583127 != nil:
    section.add "alt", valid_583127
  var valid_583128 = query.getOrDefault("oauth_token")
  valid_583128 = validateParameter(valid_583128, JString, required = false,
                                 default = nil)
  if valid_583128 != nil:
    section.add "oauth_token", valid_583128
  var valid_583129 = query.getOrDefault("userIp")
  valid_583129 = validateParameter(valid_583129, JString, required = false,
                                 default = nil)
  if valid_583129 != nil:
    section.add "userIp", valid_583129
  var valid_583130 = query.getOrDefault("key")
  valid_583130 = validateParameter(valid_583130, JString, required = false,
                                 default = nil)
  if valid_583130 != nil:
    section.add "key", valid_583130
  var valid_583131 = query.getOrDefault("prettyPrint")
  valid_583131 = validateParameter(valid_583131, JBool, required = false,
                                 default = newJBool(true))
  if valid_583131 != nil:
    section.add "prettyPrint", valid_583131
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_583133: Call_DfareportingSitesUpdate_583121; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing site.
  ## 
  let valid = call_583133.validator(path, query, header, formData, body)
  let scheme = call_583133.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583133.url(scheme.get, call_583133.host, call_583133.base,
                         call_583133.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583133, url, valid)

proc call*(call_583134: Call_DfareportingSitesUpdate_583121; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSitesUpdate
  ## Updates an existing site.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583135 = newJObject()
  var query_583136 = newJObject()
  var body_583137 = newJObject()
  add(path_583135, "profileId", newJString(profileId))
  add(query_583136, "fields", newJString(fields))
  add(query_583136, "quotaUser", newJString(quotaUser))
  add(query_583136, "alt", newJString(alt))
  add(query_583136, "oauth_token", newJString(oauthToken))
  add(query_583136, "userIp", newJString(userIp))
  add(query_583136, "key", newJString(key))
  if body != nil:
    body_583137 = body
  add(query_583136, "prettyPrint", newJBool(prettyPrint))
  result = call_583134.call(path_583135, query_583136, nil, nil, body_583137)

var dfareportingSitesUpdate* = Call_DfareportingSitesUpdate_583121(
    name: "dfareportingSitesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesUpdate_583122,
    base: "/dfareporting/v2.7", url: url_DfareportingSitesUpdate_583123,
    schemes: {Scheme.Https})
type
  Call_DfareportingSitesInsert_583138 = ref object of OpenApiRestCall_579437
proc url_DfareportingSitesInsert_583140(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesInsert_583139(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new site.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583141 = path.getOrDefault("profileId")
  valid_583141 = validateParameter(valid_583141, JString, required = true,
                                 default = nil)
  if valid_583141 != nil:
    section.add "profileId", valid_583141
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583142 = query.getOrDefault("fields")
  valid_583142 = validateParameter(valid_583142, JString, required = false,
                                 default = nil)
  if valid_583142 != nil:
    section.add "fields", valid_583142
  var valid_583143 = query.getOrDefault("quotaUser")
  valid_583143 = validateParameter(valid_583143, JString, required = false,
                                 default = nil)
  if valid_583143 != nil:
    section.add "quotaUser", valid_583143
  var valid_583144 = query.getOrDefault("alt")
  valid_583144 = validateParameter(valid_583144, JString, required = false,
                                 default = newJString("json"))
  if valid_583144 != nil:
    section.add "alt", valid_583144
  var valid_583145 = query.getOrDefault("oauth_token")
  valid_583145 = validateParameter(valid_583145, JString, required = false,
                                 default = nil)
  if valid_583145 != nil:
    section.add "oauth_token", valid_583145
  var valid_583146 = query.getOrDefault("userIp")
  valid_583146 = validateParameter(valid_583146, JString, required = false,
                                 default = nil)
  if valid_583146 != nil:
    section.add "userIp", valid_583146
  var valid_583147 = query.getOrDefault("key")
  valid_583147 = validateParameter(valid_583147, JString, required = false,
                                 default = nil)
  if valid_583147 != nil:
    section.add "key", valid_583147
  var valid_583148 = query.getOrDefault("prettyPrint")
  valid_583148 = validateParameter(valid_583148, JBool, required = false,
                                 default = newJBool(true))
  if valid_583148 != nil:
    section.add "prettyPrint", valid_583148
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_583150: Call_DfareportingSitesInsert_583138; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new site.
  ## 
  let valid = call_583150.validator(path, query, header, formData, body)
  let scheme = call_583150.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583150.url(scheme.get, call_583150.host, call_583150.base,
                         call_583150.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583150, url, valid)

proc call*(call_583151: Call_DfareportingSitesInsert_583138; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSitesInsert
  ## Inserts a new site.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583152 = newJObject()
  var query_583153 = newJObject()
  var body_583154 = newJObject()
  add(path_583152, "profileId", newJString(profileId))
  add(query_583153, "fields", newJString(fields))
  add(query_583153, "quotaUser", newJString(quotaUser))
  add(query_583153, "alt", newJString(alt))
  add(query_583153, "oauth_token", newJString(oauthToken))
  add(query_583153, "userIp", newJString(userIp))
  add(query_583153, "key", newJString(key))
  if body != nil:
    body_583154 = body
  add(query_583153, "prettyPrint", newJBool(prettyPrint))
  result = call_583151.call(path_583152, query_583153, nil, nil, body_583154)

var dfareportingSitesInsert* = Call_DfareportingSitesInsert_583138(
    name: "dfareportingSitesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesInsert_583139,
    base: "/dfareporting/v2.7", url: url_DfareportingSitesInsert_583140,
    schemes: {Scheme.Https})
type
  Call_DfareportingSitesList_583091 = ref object of OpenApiRestCall_579437
proc url_DfareportingSitesList_583093(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesList_583092(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of sites, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583094 = path.getOrDefault("profileId")
  valid_583094 = validateParameter(valid_583094, JString, required = true,
                                 default = nil)
  if valid_583094 != nil:
    section.add "profileId", valid_583094
  result.add "path", section
  ## parameters in `query` object:
  ##   subaccountId: JString
  ##               : Select only sites with this subaccount ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or keyName. Wildcards (*) are allowed. For example, "site*2015" will return objects with names like "site June 2015", "site April 2015", or simply "site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "site" will match objects with name "my site", "site 2015", or simply "site".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   campaignIds: JArray
  ##              : Select only sites with these campaign IDs.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only sites with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsInterstitialPlacements: JBool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   acceptsInStreamVideoPlacements: JBool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   adWordsSite: JBool
  ##              : Select only AdWords sites.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   approved: JBool
  ##           : Select only approved sites.
  ##   unmappedSite: JBool
  ##               : Select only sites that have not been mapped to a directory site.
  ##   acceptsPublisherPaidPlacements: JBool
  ##                                 : Select only sites that accept publisher paid placements.
  ##   directorySiteIds: JArray
  ##                   : Select only sites with these directory site IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583095 = query.getOrDefault("subaccountId")
  valid_583095 = validateParameter(valid_583095, JString, required = false,
                                 default = nil)
  if valid_583095 != nil:
    section.add "subaccountId", valid_583095
  var valid_583096 = query.getOrDefault("fields")
  valid_583096 = validateParameter(valid_583096, JString, required = false,
                                 default = nil)
  if valid_583096 != nil:
    section.add "fields", valid_583096
  var valid_583097 = query.getOrDefault("pageToken")
  valid_583097 = validateParameter(valid_583097, JString, required = false,
                                 default = nil)
  if valid_583097 != nil:
    section.add "pageToken", valid_583097
  var valid_583098 = query.getOrDefault("quotaUser")
  valid_583098 = validateParameter(valid_583098, JString, required = false,
                                 default = nil)
  if valid_583098 != nil:
    section.add "quotaUser", valid_583098
  var valid_583099 = query.getOrDefault("sortField")
  valid_583099 = validateParameter(valid_583099, JString, required = false,
                                 default = newJString("ID"))
  if valid_583099 != nil:
    section.add "sortField", valid_583099
  var valid_583100 = query.getOrDefault("alt")
  valid_583100 = validateParameter(valid_583100, JString, required = false,
                                 default = newJString("json"))
  if valid_583100 != nil:
    section.add "alt", valid_583100
  var valid_583101 = query.getOrDefault("searchString")
  valid_583101 = validateParameter(valid_583101, JString, required = false,
                                 default = nil)
  if valid_583101 != nil:
    section.add "searchString", valid_583101
  var valid_583102 = query.getOrDefault("oauth_token")
  valid_583102 = validateParameter(valid_583102, JString, required = false,
                                 default = nil)
  if valid_583102 != nil:
    section.add "oauth_token", valid_583102
  var valid_583103 = query.getOrDefault("campaignIds")
  valid_583103 = validateParameter(valid_583103, JArray, required = false,
                                 default = nil)
  if valid_583103 != nil:
    section.add "campaignIds", valid_583103
  var valid_583104 = query.getOrDefault("userIp")
  valid_583104 = validateParameter(valid_583104, JString, required = false,
                                 default = nil)
  if valid_583104 != nil:
    section.add "userIp", valid_583104
  var valid_583105 = query.getOrDefault("maxResults")
  valid_583105 = validateParameter(valid_583105, JInt, required = false,
                                 default = newJInt(1000))
  if valid_583105 != nil:
    section.add "maxResults", valid_583105
  var valid_583106 = query.getOrDefault("ids")
  valid_583106 = validateParameter(valid_583106, JArray, required = false,
                                 default = nil)
  if valid_583106 != nil:
    section.add "ids", valid_583106
  var valid_583107 = query.getOrDefault("key")
  valid_583107 = validateParameter(valid_583107, JString, required = false,
                                 default = nil)
  if valid_583107 != nil:
    section.add "key", valid_583107
  var valid_583108 = query.getOrDefault("acceptsInterstitialPlacements")
  valid_583108 = validateParameter(valid_583108, JBool, required = false, default = nil)
  if valid_583108 != nil:
    section.add "acceptsInterstitialPlacements", valid_583108
  var valid_583109 = query.getOrDefault("acceptsInStreamVideoPlacements")
  valid_583109 = validateParameter(valid_583109, JBool, required = false, default = nil)
  if valid_583109 != nil:
    section.add "acceptsInStreamVideoPlacements", valid_583109
  var valid_583110 = query.getOrDefault("adWordsSite")
  valid_583110 = validateParameter(valid_583110, JBool, required = false, default = nil)
  if valid_583110 != nil:
    section.add "adWordsSite", valid_583110
  var valid_583111 = query.getOrDefault("sortOrder")
  valid_583111 = validateParameter(valid_583111, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_583111 != nil:
    section.add "sortOrder", valid_583111
  var valid_583112 = query.getOrDefault("approved")
  valid_583112 = validateParameter(valid_583112, JBool, required = false, default = nil)
  if valid_583112 != nil:
    section.add "approved", valid_583112
  var valid_583113 = query.getOrDefault("unmappedSite")
  valid_583113 = validateParameter(valid_583113, JBool, required = false, default = nil)
  if valid_583113 != nil:
    section.add "unmappedSite", valid_583113
  var valid_583114 = query.getOrDefault("acceptsPublisherPaidPlacements")
  valid_583114 = validateParameter(valid_583114, JBool, required = false, default = nil)
  if valid_583114 != nil:
    section.add "acceptsPublisherPaidPlacements", valid_583114
  var valid_583115 = query.getOrDefault("directorySiteIds")
  valid_583115 = validateParameter(valid_583115, JArray, required = false,
                                 default = nil)
  if valid_583115 != nil:
    section.add "directorySiteIds", valid_583115
  var valid_583116 = query.getOrDefault("prettyPrint")
  valid_583116 = validateParameter(valid_583116, JBool, required = false,
                                 default = newJBool(true))
  if valid_583116 != nil:
    section.add "prettyPrint", valid_583116
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583117: Call_DfareportingSitesList_583091; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of sites, possibly filtered. This method supports paging.
  ## 
  let valid = call_583117.validator(path, query, header, formData, body)
  let scheme = call_583117.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583117.url(scheme.get, call_583117.host, call_583117.base,
                         call_583117.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583117, url, valid)

proc call*(call_583118: Call_DfareportingSitesList_583091; profileId: string;
          subaccountId: string = ""; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = "";
          campaignIds: JsonNode = nil; userIp: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = "";
          acceptsInterstitialPlacements: bool = false;
          acceptsInStreamVideoPlacements: bool = false; adWordsSite: bool = false;
          sortOrder: string = "ASCENDING"; approved: bool = false;
          unmappedSite: bool = false; acceptsPublisherPaidPlacements: bool = false;
          directorySiteIds: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSitesList
  ## Retrieves a list of sites, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only sites with this subaccount ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or keyName. Wildcards (*) are allowed. For example, "site*2015" will return objects with names like "site June 2015", "site April 2015", or simply "site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "site" will match objects with name "my site", "site 2015", or simply "site".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   campaignIds: JArray
  ##              : Select only sites with these campaign IDs.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only sites with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsInterstitialPlacements: bool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   acceptsInStreamVideoPlacements: bool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   adWordsSite: bool
  ##              : Select only AdWords sites.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   approved: bool
  ##           : Select only approved sites.
  ##   unmappedSite: bool
  ##               : Select only sites that have not been mapped to a directory site.
  ##   acceptsPublisherPaidPlacements: bool
  ##                                 : Select only sites that accept publisher paid placements.
  ##   directorySiteIds: JArray
  ##                   : Select only sites with these directory site IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583119 = newJObject()
  var query_583120 = newJObject()
  add(path_583119, "profileId", newJString(profileId))
  add(query_583120, "subaccountId", newJString(subaccountId))
  add(query_583120, "fields", newJString(fields))
  add(query_583120, "pageToken", newJString(pageToken))
  add(query_583120, "quotaUser", newJString(quotaUser))
  add(query_583120, "sortField", newJString(sortField))
  add(query_583120, "alt", newJString(alt))
  add(query_583120, "searchString", newJString(searchString))
  add(query_583120, "oauth_token", newJString(oauthToken))
  if campaignIds != nil:
    query_583120.add "campaignIds", campaignIds
  add(query_583120, "userIp", newJString(userIp))
  add(query_583120, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_583120.add "ids", ids
  add(query_583120, "key", newJString(key))
  add(query_583120, "acceptsInterstitialPlacements",
      newJBool(acceptsInterstitialPlacements))
  add(query_583120, "acceptsInStreamVideoPlacements",
      newJBool(acceptsInStreamVideoPlacements))
  add(query_583120, "adWordsSite", newJBool(adWordsSite))
  add(query_583120, "sortOrder", newJString(sortOrder))
  add(query_583120, "approved", newJBool(approved))
  add(query_583120, "unmappedSite", newJBool(unmappedSite))
  add(query_583120, "acceptsPublisherPaidPlacements",
      newJBool(acceptsPublisherPaidPlacements))
  if directorySiteIds != nil:
    query_583120.add "directorySiteIds", directorySiteIds
  add(query_583120, "prettyPrint", newJBool(prettyPrint))
  result = call_583118.call(path_583119, query_583120, nil, nil, nil)

var dfareportingSitesList* = Call_DfareportingSitesList_583091(
    name: "dfareportingSitesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesList_583092, base: "/dfareporting/v2.7",
    url: url_DfareportingSitesList_583093, schemes: {Scheme.Https})
type
  Call_DfareportingSitesPatch_583155 = ref object of OpenApiRestCall_579437
proc url_DfareportingSitesPatch_583157(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesPatch_583156(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing site. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583158 = path.getOrDefault("profileId")
  valid_583158 = validateParameter(valid_583158, JString, required = true,
                                 default = nil)
  if valid_583158 != nil:
    section.add "profileId", valid_583158
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Site ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583159 = query.getOrDefault("fields")
  valid_583159 = validateParameter(valid_583159, JString, required = false,
                                 default = nil)
  if valid_583159 != nil:
    section.add "fields", valid_583159
  var valid_583160 = query.getOrDefault("quotaUser")
  valid_583160 = validateParameter(valid_583160, JString, required = false,
                                 default = nil)
  if valid_583160 != nil:
    section.add "quotaUser", valid_583160
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_583161 = query.getOrDefault("id")
  valid_583161 = validateParameter(valid_583161, JString, required = true,
                                 default = nil)
  if valid_583161 != nil:
    section.add "id", valid_583161
  var valid_583162 = query.getOrDefault("alt")
  valid_583162 = validateParameter(valid_583162, JString, required = false,
                                 default = newJString("json"))
  if valid_583162 != nil:
    section.add "alt", valid_583162
  var valid_583163 = query.getOrDefault("oauth_token")
  valid_583163 = validateParameter(valid_583163, JString, required = false,
                                 default = nil)
  if valid_583163 != nil:
    section.add "oauth_token", valid_583163
  var valid_583164 = query.getOrDefault("userIp")
  valid_583164 = validateParameter(valid_583164, JString, required = false,
                                 default = nil)
  if valid_583164 != nil:
    section.add "userIp", valid_583164
  var valid_583165 = query.getOrDefault("key")
  valid_583165 = validateParameter(valid_583165, JString, required = false,
                                 default = nil)
  if valid_583165 != nil:
    section.add "key", valid_583165
  var valid_583166 = query.getOrDefault("prettyPrint")
  valid_583166 = validateParameter(valid_583166, JBool, required = false,
                                 default = newJBool(true))
  if valid_583166 != nil:
    section.add "prettyPrint", valid_583166
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_583168: Call_DfareportingSitesPatch_583155; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing site. This method supports patch semantics.
  ## 
  let valid = call_583168.validator(path, query, header, formData, body)
  let scheme = call_583168.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583168.url(scheme.get, call_583168.host, call_583168.base,
                         call_583168.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583168, url, valid)

proc call*(call_583169: Call_DfareportingSitesPatch_583155; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSitesPatch
  ## Updates an existing site. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Site ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583170 = newJObject()
  var query_583171 = newJObject()
  var body_583172 = newJObject()
  add(path_583170, "profileId", newJString(profileId))
  add(query_583171, "fields", newJString(fields))
  add(query_583171, "quotaUser", newJString(quotaUser))
  add(query_583171, "id", newJString(id))
  add(query_583171, "alt", newJString(alt))
  add(query_583171, "oauth_token", newJString(oauthToken))
  add(query_583171, "userIp", newJString(userIp))
  add(query_583171, "key", newJString(key))
  if body != nil:
    body_583172 = body
  add(query_583171, "prettyPrint", newJBool(prettyPrint))
  result = call_583169.call(path_583170, query_583171, nil, nil, body_583172)

var dfareportingSitesPatch* = Call_DfareportingSitesPatch_583155(
    name: "dfareportingSitesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesPatch_583156, base: "/dfareporting/v2.7",
    url: url_DfareportingSitesPatch_583157, schemes: {Scheme.Https})
type
  Call_DfareportingSitesGet_583173 = ref object of OpenApiRestCall_579437
proc url_DfareportingSitesGet_583175(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesGet_583174(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one site by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Site ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583176 = path.getOrDefault("profileId")
  valid_583176 = validateParameter(valid_583176, JString, required = true,
                                 default = nil)
  if valid_583176 != nil:
    section.add "profileId", valid_583176
  var valid_583177 = path.getOrDefault("id")
  valid_583177 = validateParameter(valid_583177, JString, required = true,
                                 default = nil)
  if valid_583177 != nil:
    section.add "id", valid_583177
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583178 = query.getOrDefault("fields")
  valid_583178 = validateParameter(valid_583178, JString, required = false,
                                 default = nil)
  if valid_583178 != nil:
    section.add "fields", valid_583178
  var valid_583179 = query.getOrDefault("quotaUser")
  valid_583179 = validateParameter(valid_583179, JString, required = false,
                                 default = nil)
  if valid_583179 != nil:
    section.add "quotaUser", valid_583179
  var valid_583180 = query.getOrDefault("alt")
  valid_583180 = validateParameter(valid_583180, JString, required = false,
                                 default = newJString("json"))
  if valid_583180 != nil:
    section.add "alt", valid_583180
  var valid_583181 = query.getOrDefault("oauth_token")
  valid_583181 = validateParameter(valid_583181, JString, required = false,
                                 default = nil)
  if valid_583181 != nil:
    section.add "oauth_token", valid_583181
  var valid_583182 = query.getOrDefault("userIp")
  valid_583182 = validateParameter(valid_583182, JString, required = false,
                                 default = nil)
  if valid_583182 != nil:
    section.add "userIp", valid_583182
  var valid_583183 = query.getOrDefault("key")
  valid_583183 = validateParameter(valid_583183, JString, required = false,
                                 default = nil)
  if valid_583183 != nil:
    section.add "key", valid_583183
  var valid_583184 = query.getOrDefault("prettyPrint")
  valid_583184 = validateParameter(valid_583184, JBool, required = false,
                                 default = newJBool(true))
  if valid_583184 != nil:
    section.add "prettyPrint", valid_583184
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583185: Call_DfareportingSitesGet_583173; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one site by ID.
  ## 
  let valid = call_583185.validator(path, query, header, formData, body)
  let scheme = call_583185.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583185.url(scheme.get, call_583185.host, call_583185.base,
                         call_583185.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583185, url, valid)

proc call*(call_583186: Call_DfareportingSitesGet_583173; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingSitesGet
  ## Gets one site by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Site ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583187 = newJObject()
  var query_583188 = newJObject()
  add(path_583187, "profileId", newJString(profileId))
  add(query_583188, "fields", newJString(fields))
  add(query_583188, "quotaUser", newJString(quotaUser))
  add(query_583188, "alt", newJString(alt))
  add(query_583188, "oauth_token", newJString(oauthToken))
  add(query_583188, "userIp", newJString(userIp))
  add(path_583187, "id", newJString(id))
  add(query_583188, "key", newJString(key))
  add(query_583188, "prettyPrint", newJBool(prettyPrint))
  result = call_583186.call(path_583187, query_583188, nil, nil, nil)

var dfareportingSitesGet* = Call_DfareportingSitesGet_583173(
    name: "dfareportingSitesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites/{id}",
    validator: validate_DfareportingSitesGet_583174, base: "/dfareporting/v2.7",
    url: url_DfareportingSitesGet_583175, schemes: {Scheme.Https})
type
  Call_DfareportingSizesInsert_583208 = ref object of OpenApiRestCall_579437
proc url_DfareportingSizesInsert_583210(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sizes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSizesInsert_583209(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new size.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583211 = path.getOrDefault("profileId")
  valid_583211 = validateParameter(valid_583211, JString, required = true,
                                 default = nil)
  if valid_583211 != nil:
    section.add "profileId", valid_583211
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583212 = query.getOrDefault("fields")
  valid_583212 = validateParameter(valid_583212, JString, required = false,
                                 default = nil)
  if valid_583212 != nil:
    section.add "fields", valid_583212
  var valid_583213 = query.getOrDefault("quotaUser")
  valid_583213 = validateParameter(valid_583213, JString, required = false,
                                 default = nil)
  if valid_583213 != nil:
    section.add "quotaUser", valid_583213
  var valid_583214 = query.getOrDefault("alt")
  valid_583214 = validateParameter(valid_583214, JString, required = false,
                                 default = newJString("json"))
  if valid_583214 != nil:
    section.add "alt", valid_583214
  var valid_583215 = query.getOrDefault("oauth_token")
  valid_583215 = validateParameter(valid_583215, JString, required = false,
                                 default = nil)
  if valid_583215 != nil:
    section.add "oauth_token", valid_583215
  var valid_583216 = query.getOrDefault("userIp")
  valid_583216 = validateParameter(valid_583216, JString, required = false,
                                 default = nil)
  if valid_583216 != nil:
    section.add "userIp", valid_583216
  var valid_583217 = query.getOrDefault("key")
  valid_583217 = validateParameter(valid_583217, JString, required = false,
                                 default = nil)
  if valid_583217 != nil:
    section.add "key", valid_583217
  var valid_583218 = query.getOrDefault("prettyPrint")
  valid_583218 = validateParameter(valid_583218, JBool, required = false,
                                 default = newJBool(true))
  if valid_583218 != nil:
    section.add "prettyPrint", valid_583218
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_583220: Call_DfareportingSizesInsert_583208; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new size.
  ## 
  let valid = call_583220.validator(path, query, header, formData, body)
  let scheme = call_583220.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583220.url(scheme.get, call_583220.host, call_583220.base,
                         call_583220.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583220, url, valid)

proc call*(call_583221: Call_DfareportingSizesInsert_583208; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSizesInsert
  ## Inserts a new size.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583222 = newJObject()
  var query_583223 = newJObject()
  var body_583224 = newJObject()
  add(path_583222, "profileId", newJString(profileId))
  add(query_583223, "fields", newJString(fields))
  add(query_583223, "quotaUser", newJString(quotaUser))
  add(query_583223, "alt", newJString(alt))
  add(query_583223, "oauth_token", newJString(oauthToken))
  add(query_583223, "userIp", newJString(userIp))
  add(query_583223, "key", newJString(key))
  if body != nil:
    body_583224 = body
  add(query_583223, "prettyPrint", newJBool(prettyPrint))
  result = call_583221.call(path_583222, query_583223, nil, nil, body_583224)

var dfareportingSizesInsert* = Call_DfareportingSizesInsert_583208(
    name: "dfareportingSizesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sizes",
    validator: validate_DfareportingSizesInsert_583209,
    base: "/dfareporting/v2.7", url: url_DfareportingSizesInsert_583210,
    schemes: {Scheme.Https})
type
  Call_DfareportingSizesList_583189 = ref object of OpenApiRestCall_579437
proc url_DfareportingSizesList_583191(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sizes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSizesList_583190(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of sizes, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583192 = path.getOrDefault("profileId")
  valid_583192 = validateParameter(valid_583192, JString, required = true,
                                 default = nil)
  if valid_583192 != nil:
    section.add "profileId", valid_583192
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   height: JInt
  ##         : Select only sizes with this height.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Select only sizes with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   iabStandard: JBool
  ##              : Select only IAB standard sizes.
  ##   width: JInt
  ##        : Select only sizes with this width.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583193 = query.getOrDefault("fields")
  valid_583193 = validateParameter(valid_583193, JString, required = false,
                                 default = nil)
  if valid_583193 != nil:
    section.add "fields", valid_583193
  var valid_583194 = query.getOrDefault("quotaUser")
  valid_583194 = validateParameter(valid_583194, JString, required = false,
                                 default = nil)
  if valid_583194 != nil:
    section.add "quotaUser", valid_583194
  var valid_583195 = query.getOrDefault("alt")
  valid_583195 = validateParameter(valid_583195, JString, required = false,
                                 default = newJString("json"))
  if valid_583195 != nil:
    section.add "alt", valid_583195
  var valid_583196 = query.getOrDefault("oauth_token")
  valid_583196 = validateParameter(valid_583196, JString, required = false,
                                 default = nil)
  if valid_583196 != nil:
    section.add "oauth_token", valid_583196
  var valid_583197 = query.getOrDefault("height")
  valid_583197 = validateParameter(valid_583197, JInt, required = false, default = nil)
  if valid_583197 != nil:
    section.add "height", valid_583197
  var valid_583198 = query.getOrDefault("userIp")
  valid_583198 = validateParameter(valid_583198, JString, required = false,
                                 default = nil)
  if valid_583198 != nil:
    section.add "userIp", valid_583198
  var valid_583199 = query.getOrDefault("ids")
  valid_583199 = validateParameter(valid_583199, JArray, required = false,
                                 default = nil)
  if valid_583199 != nil:
    section.add "ids", valid_583199
  var valid_583200 = query.getOrDefault("key")
  valid_583200 = validateParameter(valid_583200, JString, required = false,
                                 default = nil)
  if valid_583200 != nil:
    section.add "key", valid_583200
  var valid_583201 = query.getOrDefault("iabStandard")
  valid_583201 = validateParameter(valid_583201, JBool, required = false, default = nil)
  if valid_583201 != nil:
    section.add "iabStandard", valid_583201
  var valid_583202 = query.getOrDefault("width")
  valid_583202 = validateParameter(valid_583202, JInt, required = false, default = nil)
  if valid_583202 != nil:
    section.add "width", valid_583202
  var valid_583203 = query.getOrDefault("prettyPrint")
  valid_583203 = validateParameter(valid_583203, JBool, required = false,
                                 default = newJBool(true))
  if valid_583203 != nil:
    section.add "prettyPrint", valid_583203
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583204: Call_DfareportingSizesList_583189; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of sizes, possibly filtered.
  ## 
  let valid = call_583204.validator(path, query, header, formData, body)
  let scheme = call_583204.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583204.url(scheme.get, call_583204.host, call_583204.base,
                         call_583204.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583204, url, valid)

proc call*(call_583205: Call_DfareportingSizesList_583189; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; height: int = 0; userIp: string = "";
          ids: JsonNode = nil; key: string = ""; iabStandard: bool = false; width: int = 0;
          prettyPrint: bool = true): Recallable =
  ## dfareportingSizesList
  ## Retrieves a list of sizes, possibly filtered.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   height: int
  ##         : Select only sizes with this height.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Select only sizes with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   iabStandard: bool
  ##              : Select only IAB standard sizes.
  ##   width: int
  ##        : Select only sizes with this width.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583206 = newJObject()
  var query_583207 = newJObject()
  add(path_583206, "profileId", newJString(profileId))
  add(query_583207, "fields", newJString(fields))
  add(query_583207, "quotaUser", newJString(quotaUser))
  add(query_583207, "alt", newJString(alt))
  add(query_583207, "oauth_token", newJString(oauthToken))
  add(query_583207, "height", newJInt(height))
  add(query_583207, "userIp", newJString(userIp))
  if ids != nil:
    query_583207.add "ids", ids
  add(query_583207, "key", newJString(key))
  add(query_583207, "iabStandard", newJBool(iabStandard))
  add(query_583207, "width", newJInt(width))
  add(query_583207, "prettyPrint", newJBool(prettyPrint))
  result = call_583205.call(path_583206, query_583207, nil, nil, nil)

var dfareportingSizesList* = Call_DfareportingSizesList_583189(
    name: "dfareportingSizesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sizes",
    validator: validate_DfareportingSizesList_583190, base: "/dfareporting/v2.7",
    url: url_DfareportingSizesList_583191, schemes: {Scheme.Https})
type
  Call_DfareportingSizesGet_583225 = ref object of OpenApiRestCall_579437
proc url_DfareportingSizesGet_583227(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sizes/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSizesGet_583226(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one size by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Size ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583228 = path.getOrDefault("profileId")
  valid_583228 = validateParameter(valid_583228, JString, required = true,
                                 default = nil)
  if valid_583228 != nil:
    section.add "profileId", valid_583228
  var valid_583229 = path.getOrDefault("id")
  valid_583229 = validateParameter(valid_583229, JString, required = true,
                                 default = nil)
  if valid_583229 != nil:
    section.add "id", valid_583229
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583230 = query.getOrDefault("fields")
  valid_583230 = validateParameter(valid_583230, JString, required = false,
                                 default = nil)
  if valid_583230 != nil:
    section.add "fields", valid_583230
  var valid_583231 = query.getOrDefault("quotaUser")
  valid_583231 = validateParameter(valid_583231, JString, required = false,
                                 default = nil)
  if valid_583231 != nil:
    section.add "quotaUser", valid_583231
  var valid_583232 = query.getOrDefault("alt")
  valid_583232 = validateParameter(valid_583232, JString, required = false,
                                 default = newJString("json"))
  if valid_583232 != nil:
    section.add "alt", valid_583232
  var valid_583233 = query.getOrDefault("oauth_token")
  valid_583233 = validateParameter(valid_583233, JString, required = false,
                                 default = nil)
  if valid_583233 != nil:
    section.add "oauth_token", valid_583233
  var valid_583234 = query.getOrDefault("userIp")
  valid_583234 = validateParameter(valid_583234, JString, required = false,
                                 default = nil)
  if valid_583234 != nil:
    section.add "userIp", valid_583234
  var valid_583235 = query.getOrDefault("key")
  valid_583235 = validateParameter(valid_583235, JString, required = false,
                                 default = nil)
  if valid_583235 != nil:
    section.add "key", valid_583235
  var valid_583236 = query.getOrDefault("prettyPrint")
  valid_583236 = validateParameter(valid_583236, JBool, required = false,
                                 default = newJBool(true))
  if valid_583236 != nil:
    section.add "prettyPrint", valid_583236
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583237: Call_DfareportingSizesGet_583225; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one size by ID.
  ## 
  let valid = call_583237.validator(path, query, header, formData, body)
  let scheme = call_583237.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583237.url(scheme.get, call_583237.host, call_583237.base,
                         call_583237.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583237, url, valid)

proc call*(call_583238: Call_DfareportingSizesGet_583225; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingSizesGet
  ## Gets one size by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Size ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583239 = newJObject()
  var query_583240 = newJObject()
  add(path_583239, "profileId", newJString(profileId))
  add(query_583240, "fields", newJString(fields))
  add(query_583240, "quotaUser", newJString(quotaUser))
  add(query_583240, "alt", newJString(alt))
  add(query_583240, "oauth_token", newJString(oauthToken))
  add(query_583240, "userIp", newJString(userIp))
  add(path_583239, "id", newJString(id))
  add(query_583240, "key", newJString(key))
  add(query_583240, "prettyPrint", newJBool(prettyPrint))
  result = call_583238.call(path_583239, query_583240, nil, nil, nil)

var dfareportingSizesGet* = Call_DfareportingSizesGet_583225(
    name: "dfareportingSizesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sizes/{id}",
    validator: validate_DfareportingSizesGet_583226, base: "/dfareporting/v2.7",
    url: url_DfareportingSizesGet_583227, schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsUpdate_583262 = ref object of OpenApiRestCall_579437
proc url_DfareportingSubaccountsUpdate_583264(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsUpdate_583263(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing subaccount.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583265 = path.getOrDefault("profileId")
  valid_583265 = validateParameter(valid_583265, JString, required = true,
                                 default = nil)
  if valid_583265 != nil:
    section.add "profileId", valid_583265
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583266 = query.getOrDefault("fields")
  valid_583266 = validateParameter(valid_583266, JString, required = false,
                                 default = nil)
  if valid_583266 != nil:
    section.add "fields", valid_583266
  var valid_583267 = query.getOrDefault("quotaUser")
  valid_583267 = validateParameter(valid_583267, JString, required = false,
                                 default = nil)
  if valid_583267 != nil:
    section.add "quotaUser", valid_583267
  var valid_583268 = query.getOrDefault("alt")
  valid_583268 = validateParameter(valid_583268, JString, required = false,
                                 default = newJString("json"))
  if valid_583268 != nil:
    section.add "alt", valid_583268
  var valid_583269 = query.getOrDefault("oauth_token")
  valid_583269 = validateParameter(valid_583269, JString, required = false,
                                 default = nil)
  if valid_583269 != nil:
    section.add "oauth_token", valid_583269
  var valid_583270 = query.getOrDefault("userIp")
  valid_583270 = validateParameter(valid_583270, JString, required = false,
                                 default = nil)
  if valid_583270 != nil:
    section.add "userIp", valid_583270
  var valid_583271 = query.getOrDefault("key")
  valid_583271 = validateParameter(valid_583271, JString, required = false,
                                 default = nil)
  if valid_583271 != nil:
    section.add "key", valid_583271
  var valid_583272 = query.getOrDefault("prettyPrint")
  valid_583272 = validateParameter(valid_583272, JBool, required = false,
                                 default = newJBool(true))
  if valid_583272 != nil:
    section.add "prettyPrint", valid_583272
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_583274: Call_DfareportingSubaccountsUpdate_583262; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing subaccount.
  ## 
  let valid = call_583274.validator(path, query, header, formData, body)
  let scheme = call_583274.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583274.url(scheme.get, call_583274.host, call_583274.base,
                         call_583274.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583274, url, valid)

proc call*(call_583275: Call_DfareportingSubaccountsUpdate_583262;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsUpdate
  ## Updates an existing subaccount.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583276 = newJObject()
  var query_583277 = newJObject()
  var body_583278 = newJObject()
  add(path_583276, "profileId", newJString(profileId))
  add(query_583277, "fields", newJString(fields))
  add(query_583277, "quotaUser", newJString(quotaUser))
  add(query_583277, "alt", newJString(alt))
  add(query_583277, "oauth_token", newJString(oauthToken))
  add(query_583277, "userIp", newJString(userIp))
  add(query_583277, "key", newJString(key))
  if body != nil:
    body_583278 = body
  add(query_583277, "prettyPrint", newJBool(prettyPrint))
  result = call_583275.call(path_583276, query_583277, nil, nil, body_583278)

var dfareportingSubaccountsUpdate* = Call_DfareportingSubaccountsUpdate_583262(
    name: "dfareportingSubaccountsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsUpdate_583263,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsUpdate_583264,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsInsert_583279 = ref object of OpenApiRestCall_579437
proc url_DfareportingSubaccountsInsert_583281(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsInsert_583280(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new subaccount.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583282 = path.getOrDefault("profileId")
  valid_583282 = validateParameter(valid_583282, JString, required = true,
                                 default = nil)
  if valid_583282 != nil:
    section.add "profileId", valid_583282
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583283 = query.getOrDefault("fields")
  valid_583283 = validateParameter(valid_583283, JString, required = false,
                                 default = nil)
  if valid_583283 != nil:
    section.add "fields", valid_583283
  var valid_583284 = query.getOrDefault("quotaUser")
  valid_583284 = validateParameter(valid_583284, JString, required = false,
                                 default = nil)
  if valid_583284 != nil:
    section.add "quotaUser", valid_583284
  var valid_583285 = query.getOrDefault("alt")
  valid_583285 = validateParameter(valid_583285, JString, required = false,
                                 default = newJString("json"))
  if valid_583285 != nil:
    section.add "alt", valid_583285
  var valid_583286 = query.getOrDefault("oauth_token")
  valid_583286 = validateParameter(valid_583286, JString, required = false,
                                 default = nil)
  if valid_583286 != nil:
    section.add "oauth_token", valid_583286
  var valid_583287 = query.getOrDefault("userIp")
  valid_583287 = validateParameter(valid_583287, JString, required = false,
                                 default = nil)
  if valid_583287 != nil:
    section.add "userIp", valid_583287
  var valid_583288 = query.getOrDefault("key")
  valid_583288 = validateParameter(valid_583288, JString, required = false,
                                 default = nil)
  if valid_583288 != nil:
    section.add "key", valid_583288
  var valid_583289 = query.getOrDefault("prettyPrint")
  valid_583289 = validateParameter(valid_583289, JBool, required = false,
                                 default = newJBool(true))
  if valid_583289 != nil:
    section.add "prettyPrint", valid_583289
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_583291: Call_DfareportingSubaccountsInsert_583279; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new subaccount.
  ## 
  let valid = call_583291.validator(path, query, header, formData, body)
  let scheme = call_583291.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583291.url(scheme.get, call_583291.host, call_583291.base,
                         call_583291.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583291, url, valid)

proc call*(call_583292: Call_DfareportingSubaccountsInsert_583279;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsInsert
  ## Inserts a new subaccount.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583293 = newJObject()
  var query_583294 = newJObject()
  var body_583295 = newJObject()
  add(path_583293, "profileId", newJString(profileId))
  add(query_583294, "fields", newJString(fields))
  add(query_583294, "quotaUser", newJString(quotaUser))
  add(query_583294, "alt", newJString(alt))
  add(query_583294, "oauth_token", newJString(oauthToken))
  add(query_583294, "userIp", newJString(userIp))
  add(query_583294, "key", newJString(key))
  if body != nil:
    body_583295 = body
  add(query_583294, "prettyPrint", newJBool(prettyPrint))
  result = call_583292.call(path_583293, query_583294, nil, nil, body_583295)

var dfareportingSubaccountsInsert* = Call_DfareportingSubaccountsInsert_583279(
    name: "dfareportingSubaccountsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsInsert_583280,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsInsert_583281,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsList_583241 = ref object of OpenApiRestCall_579437
proc url_DfareportingSubaccountsList_583243(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsList_583242(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of subaccounts, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583244 = path.getOrDefault("profileId")
  valid_583244 = validateParameter(valid_583244, JString, required = true,
                                 default = nil)
  if valid_583244 != nil:
    section.add "profileId", valid_583244
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "subaccount*2015" will return objects with names like "subaccount June 2015", "subaccount April 2015", or simply "subaccount 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "subaccount" will match objects with name "my subaccount", "subaccount 2015", or simply "subaccount".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only subaccounts with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583245 = query.getOrDefault("fields")
  valid_583245 = validateParameter(valid_583245, JString, required = false,
                                 default = nil)
  if valid_583245 != nil:
    section.add "fields", valid_583245
  var valid_583246 = query.getOrDefault("pageToken")
  valid_583246 = validateParameter(valid_583246, JString, required = false,
                                 default = nil)
  if valid_583246 != nil:
    section.add "pageToken", valid_583246
  var valid_583247 = query.getOrDefault("quotaUser")
  valid_583247 = validateParameter(valid_583247, JString, required = false,
                                 default = nil)
  if valid_583247 != nil:
    section.add "quotaUser", valid_583247
  var valid_583248 = query.getOrDefault("sortField")
  valid_583248 = validateParameter(valid_583248, JString, required = false,
                                 default = newJString("ID"))
  if valid_583248 != nil:
    section.add "sortField", valid_583248
  var valid_583249 = query.getOrDefault("alt")
  valid_583249 = validateParameter(valid_583249, JString, required = false,
                                 default = newJString("json"))
  if valid_583249 != nil:
    section.add "alt", valid_583249
  var valid_583250 = query.getOrDefault("searchString")
  valid_583250 = validateParameter(valid_583250, JString, required = false,
                                 default = nil)
  if valid_583250 != nil:
    section.add "searchString", valid_583250
  var valid_583251 = query.getOrDefault("oauth_token")
  valid_583251 = validateParameter(valid_583251, JString, required = false,
                                 default = nil)
  if valid_583251 != nil:
    section.add "oauth_token", valid_583251
  var valid_583252 = query.getOrDefault("userIp")
  valid_583252 = validateParameter(valid_583252, JString, required = false,
                                 default = nil)
  if valid_583252 != nil:
    section.add "userIp", valid_583252
  var valid_583253 = query.getOrDefault("maxResults")
  valid_583253 = validateParameter(valid_583253, JInt, required = false,
                                 default = newJInt(1000))
  if valid_583253 != nil:
    section.add "maxResults", valid_583253
  var valid_583254 = query.getOrDefault("ids")
  valid_583254 = validateParameter(valid_583254, JArray, required = false,
                                 default = nil)
  if valid_583254 != nil:
    section.add "ids", valid_583254
  var valid_583255 = query.getOrDefault("key")
  valid_583255 = validateParameter(valid_583255, JString, required = false,
                                 default = nil)
  if valid_583255 != nil:
    section.add "key", valid_583255
  var valid_583256 = query.getOrDefault("sortOrder")
  valid_583256 = validateParameter(valid_583256, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_583256 != nil:
    section.add "sortOrder", valid_583256
  var valid_583257 = query.getOrDefault("prettyPrint")
  valid_583257 = validateParameter(valid_583257, JBool, required = false,
                                 default = newJBool(true))
  if valid_583257 != nil:
    section.add "prettyPrint", valid_583257
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583258: Call_DfareportingSubaccountsList_583241; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of subaccounts, possibly filtered. This method supports paging.
  ## 
  let valid = call_583258.validator(path, query, header, formData, body)
  let scheme = call_583258.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583258.url(scheme.get, call_583258.host, call_583258.base,
                         call_583258.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583258, url, valid)

proc call*(call_583259: Call_DfareportingSubaccountsList_583241; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; searchString: string = "";
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsList
  ## Gets a list of subaccounts, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "subaccount*2015" will return objects with names like "subaccount June 2015", "subaccount April 2015", or simply "subaccount 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "subaccount" will match objects with name "my subaccount", "subaccount 2015", or simply "subaccount".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only subaccounts with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583260 = newJObject()
  var query_583261 = newJObject()
  add(path_583260, "profileId", newJString(profileId))
  add(query_583261, "fields", newJString(fields))
  add(query_583261, "pageToken", newJString(pageToken))
  add(query_583261, "quotaUser", newJString(quotaUser))
  add(query_583261, "sortField", newJString(sortField))
  add(query_583261, "alt", newJString(alt))
  add(query_583261, "searchString", newJString(searchString))
  add(query_583261, "oauth_token", newJString(oauthToken))
  add(query_583261, "userIp", newJString(userIp))
  add(query_583261, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_583261.add "ids", ids
  add(query_583261, "key", newJString(key))
  add(query_583261, "sortOrder", newJString(sortOrder))
  add(query_583261, "prettyPrint", newJBool(prettyPrint))
  result = call_583259.call(path_583260, query_583261, nil, nil, nil)

var dfareportingSubaccountsList* = Call_DfareportingSubaccountsList_583241(
    name: "dfareportingSubaccountsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsList_583242,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsList_583243,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsPatch_583296 = ref object of OpenApiRestCall_579437
proc url_DfareportingSubaccountsPatch_583298(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsPatch_583297(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing subaccount. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583299 = path.getOrDefault("profileId")
  valid_583299 = validateParameter(valid_583299, JString, required = true,
                                 default = nil)
  if valid_583299 != nil:
    section.add "profileId", valid_583299
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Subaccount ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583300 = query.getOrDefault("fields")
  valid_583300 = validateParameter(valid_583300, JString, required = false,
                                 default = nil)
  if valid_583300 != nil:
    section.add "fields", valid_583300
  var valid_583301 = query.getOrDefault("quotaUser")
  valid_583301 = validateParameter(valid_583301, JString, required = false,
                                 default = nil)
  if valid_583301 != nil:
    section.add "quotaUser", valid_583301
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_583302 = query.getOrDefault("id")
  valid_583302 = validateParameter(valid_583302, JString, required = true,
                                 default = nil)
  if valid_583302 != nil:
    section.add "id", valid_583302
  var valid_583303 = query.getOrDefault("alt")
  valid_583303 = validateParameter(valid_583303, JString, required = false,
                                 default = newJString("json"))
  if valid_583303 != nil:
    section.add "alt", valid_583303
  var valid_583304 = query.getOrDefault("oauth_token")
  valid_583304 = validateParameter(valid_583304, JString, required = false,
                                 default = nil)
  if valid_583304 != nil:
    section.add "oauth_token", valid_583304
  var valid_583305 = query.getOrDefault("userIp")
  valid_583305 = validateParameter(valid_583305, JString, required = false,
                                 default = nil)
  if valid_583305 != nil:
    section.add "userIp", valid_583305
  var valid_583306 = query.getOrDefault("key")
  valid_583306 = validateParameter(valid_583306, JString, required = false,
                                 default = nil)
  if valid_583306 != nil:
    section.add "key", valid_583306
  var valid_583307 = query.getOrDefault("prettyPrint")
  valid_583307 = validateParameter(valid_583307, JBool, required = false,
                                 default = newJBool(true))
  if valid_583307 != nil:
    section.add "prettyPrint", valid_583307
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_583309: Call_DfareportingSubaccountsPatch_583296; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing subaccount. This method supports patch semantics.
  ## 
  let valid = call_583309.validator(path, query, header, formData, body)
  let scheme = call_583309.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583309.url(scheme.get, call_583309.host, call_583309.base,
                         call_583309.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583309, url, valid)

proc call*(call_583310: Call_DfareportingSubaccountsPatch_583296;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsPatch
  ## Updates an existing subaccount. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Subaccount ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583311 = newJObject()
  var query_583312 = newJObject()
  var body_583313 = newJObject()
  add(path_583311, "profileId", newJString(profileId))
  add(query_583312, "fields", newJString(fields))
  add(query_583312, "quotaUser", newJString(quotaUser))
  add(query_583312, "id", newJString(id))
  add(query_583312, "alt", newJString(alt))
  add(query_583312, "oauth_token", newJString(oauthToken))
  add(query_583312, "userIp", newJString(userIp))
  add(query_583312, "key", newJString(key))
  if body != nil:
    body_583313 = body
  add(query_583312, "prettyPrint", newJBool(prettyPrint))
  result = call_583310.call(path_583311, query_583312, nil, nil, body_583313)

var dfareportingSubaccountsPatch* = Call_DfareportingSubaccountsPatch_583296(
    name: "dfareportingSubaccountsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsPatch_583297,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsPatch_583298,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsGet_583314 = ref object of OpenApiRestCall_579437
proc url_DfareportingSubaccountsGet_583316(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsGet_583315(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one subaccount by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Subaccount ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583317 = path.getOrDefault("profileId")
  valid_583317 = validateParameter(valid_583317, JString, required = true,
                                 default = nil)
  if valid_583317 != nil:
    section.add "profileId", valid_583317
  var valid_583318 = path.getOrDefault("id")
  valid_583318 = validateParameter(valid_583318, JString, required = true,
                                 default = nil)
  if valid_583318 != nil:
    section.add "id", valid_583318
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583319 = query.getOrDefault("fields")
  valid_583319 = validateParameter(valid_583319, JString, required = false,
                                 default = nil)
  if valid_583319 != nil:
    section.add "fields", valid_583319
  var valid_583320 = query.getOrDefault("quotaUser")
  valid_583320 = validateParameter(valid_583320, JString, required = false,
                                 default = nil)
  if valid_583320 != nil:
    section.add "quotaUser", valid_583320
  var valid_583321 = query.getOrDefault("alt")
  valid_583321 = validateParameter(valid_583321, JString, required = false,
                                 default = newJString("json"))
  if valid_583321 != nil:
    section.add "alt", valid_583321
  var valid_583322 = query.getOrDefault("oauth_token")
  valid_583322 = validateParameter(valid_583322, JString, required = false,
                                 default = nil)
  if valid_583322 != nil:
    section.add "oauth_token", valid_583322
  var valid_583323 = query.getOrDefault("userIp")
  valid_583323 = validateParameter(valid_583323, JString, required = false,
                                 default = nil)
  if valid_583323 != nil:
    section.add "userIp", valid_583323
  var valid_583324 = query.getOrDefault("key")
  valid_583324 = validateParameter(valid_583324, JString, required = false,
                                 default = nil)
  if valid_583324 != nil:
    section.add "key", valid_583324
  var valid_583325 = query.getOrDefault("prettyPrint")
  valid_583325 = validateParameter(valid_583325, JBool, required = false,
                                 default = newJBool(true))
  if valid_583325 != nil:
    section.add "prettyPrint", valid_583325
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583326: Call_DfareportingSubaccountsGet_583314; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one subaccount by ID.
  ## 
  let valid = call_583326.validator(path, query, header, formData, body)
  let scheme = call_583326.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583326.url(scheme.get, call_583326.host, call_583326.base,
                         call_583326.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583326, url, valid)

proc call*(call_583327: Call_DfareportingSubaccountsGet_583314; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsGet
  ## Gets one subaccount by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Subaccount ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583328 = newJObject()
  var query_583329 = newJObject()
  add(path_583328, "profileId", newJString(profileId))
  add(query_583329, "fields", newJString(fields))
  add(query_583329, "quotaUser", newJString(quotaUser))
  add(query_583329, "alt", newJString(alt))
  add(query_583329, "oauth_token", newJString(oauthToken))
  add(query_583329, "userIp", newJString(userIp))
  add(path_583328, "id", newJString(id))
  add(query_583329, "key", newJString(key))
  add(query_583329, "prettyPrint", newJBool(prettyPrint))
  result = call_583327.call(path_583328, query_583329, nil, nil, nil)

var dfareportingSubaccountsGet* = Call_DfareportingSubaccountsGet_583314(
    name: "dfareportingSubaccountsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/subaccounts/{id}",
    validator: validate_DfareportingSubaccountsGet_583315,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsGet_583316,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetableRemarketingListsList_583330 = ref object of OpenApiRestCall_579437
proc url_DfareportingTargetableRemarketingListsList_583332(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetableRemarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetableRemarketingListsList_583331(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of targetable remarketing lists, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583333 = path.getOrDefault("profileId")
  valid_583333 = validateParameter(valid_583333, JString, required = true,
                                 default = nil)
  if valid_583333 != nil:
    section.add "profileId", valid_583333
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   advertiserId: JString (required)
  ##               : Select only targetable remarketing lists targetable by these advertisers.
  ##   active: JBool
  ##         : Select only active or only inactive targetable remarketing lists.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: JString
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583334 = query.getOrDefault("fields")
  valid_583334 = validateParameter(valid_583334, JString, required = false,
                                 default = nil)
  if valid_583334 != nil:
    section.add "fields", valid_583334
  var valid_583335 = query.getOrDefault("pageToken")
  valid_583335 = validateParameter(valid_583335, JString, required = false,
                                 default = nil)
  if valid_583335 != nil:
    section.add "pageToken", valid_583335
  var valid_583336 = query.getOrDefault("quotaUser")
  valid_583336 = validateParameter(valid_583336, JString, required = false,
                                 default = nil)
  if valid_583336 != nil:
    section.add "quotaUser", valid_583336
  var valid_583337 = query.getOrDefault("sortField")
  valid_583337 = validateParameter(valid_583337, JString, required = false,
                                 default = newJString("ID"))
  if valid_583337 != nil:
    section.add "sortField", valid_583337
  var valid_583338 = query.getOrDefault("alt")
  valid_583338 = validateParameter(valid_583338, JString, required = false,
                                 default = newJString("json"))
  if valid_583338 != nil:
    section.add "alt", valid_583338
  assert query != nil,
        "query argument is necessary due to required `advertiserId` field"
  var valid_583339 = query.getOrDefault("advertiserId")
  valid_583339 = validateParameter(valid_583339, JString, required = true,
                                 default = nil)
  if valid_583339 != nil:
    section.add "advertiserId", valid_583339
  var valid_583340 = query.getOrDefault("active")
  valid_583340 = validateParameter(valid_583340, JBool, required = false, default = nil)
  if valid_583340 != nil:
    section.add "active", valid_583340
  var valid_583341 = query.getOrDefault("oauth_token")
  valid_583341 = validateParameter(valid_583341, JString, required = false,
                                 default = nil)
  if valid_583341 != nil:
    section.add "oauth_token", valid_583341
  var valid_583342 = query.getOrDefault("userIp")
  valid_583342 = validateParameter(valid_583342, JString, required = false,
                                 default = nil)
  if valid_583342 != nil:
    section.add "userIp", valid_583342
  var valid_583343 = query.getOrDefault("maxResults")
  valid_583343 = validateParameter(valid_583343, JInt, required = false,
                                 default = newJInt(1000))
  if valid_583343 != nil:
    section.add "maxResults", valid_583343
  var valid_583344 = query.getOrDefault("key")
  valid_583344 = validateParameter(valid_583344, JString, required = false,
                                 default = nil)
  if valid_583344 != nil:
    section.add "key", valid_583344
  var valid_583345 = query.getOrDefault("name")
  valid_583345 = validateParameter(valid_583345, JString, required = false,
                                 default = nil)
  if valid_583345 != nil:
    section.add "name", valid_583345
  var valid_583346 = query.getOrDefault("sortOrder")
  valid_583346 = validateParameter(valid_583346, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_583346 != nil:
    section.add "sortOrder", valid_583346
  var valid_583347 = query.getOrDefault("prettyPrint")
  valid_583347 = validateParameter(valid_583347, JBool, required = false,
                                 default = newJBool(true))
  if valid_583347 != nil:
    section.add "prettyPrint", valid_583347
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583348: Call_DfareportingTargetableRemarketingListsList_583330;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of targetable remarketing lists, possibly filtered. This method supports paging.
  ## 
  let valid = call_583348.validator(path, query, header, formData, body)
  let scheme = call_583348.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583348.url(scheme.get, call_583348.host, call_583348.base,
                         call_583348.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583348, url, valid)

proc call*(call_583349: Call_DfareportingTargetableRemarketingListsList_583330;
          profileId: string; advertiserId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; active: bool = false; oauthToken: string = "";
          userIp: string = ""; maxResults: int = 1000; key: string = ""; name: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetableRemarketingListsList
  ## Retrieves a list of targetable remarketing lists, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   advertiserId: string (required)
  ##               : Select only targetable remarketing lists targetable by these advertisers.
  ##   active: bool
  ##         : Select only active or only inactive targetable remarketing lists.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: string
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583350 = newJObject()
  var query_583351 = newJObject()
  add(path_583350, "profileId", newJString(profileId))
  add(query_583351, "fields", newJString(fields))
  add(query_583351, "pageToken", newJString(pageToken))
  add(query_583351, "quotaUser", newJString(quotaUser))
  add(query_583351, "sortField", newJString(sortField))
  add(query_583351, "alt", newJString(alt))
  add(query_583351, "advertiserId", newJString(advertiserId))
  add(query_583351, "active", newJBool(active))
  add(query_583351, "oauth_token", newJString(oauthToken))
  add(query_583351, "userIp", newJString(userIp))
  add(query_583351, "maxResults", newJInt(maxResults))
  add(query_583351, "key", newJString(key))
  add(query_583351, "name", newJString(name))
  add(query_583351, "sortOrder", newJString(sortOrder))
  add(query_583351, "prettyPrint", newJBool(prettyPrint))
  result = call_583349.call(path_583350, query_583351, nil, nil, nil)

var dfareportingTargetableRemarketingListsList* = Call_DfareportingTargetableRemarketingListsList_583330(
    name: "dfareportingTargetableRemarketingListsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetableRemarketingLists",
    validator: validate_DfareportingTargetableRemarketingListsList_583331,
    base: "/dfareporting/v2.7",
    url: url_DfareportingTargetableRemarketingListsList_583332,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetableRemarketingListsGet_583352 = ref object of OpenApiRestCall_579437
proc url_DfareportingTargetableRemarketingListsGet_583354(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetableRemarketingLists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetableRemarketingListsGet_583353(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one remarketing list by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Remarketing list ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583355 = path.getOrDefault("profileId")
  valid_583355 = validateParameter(valid_583355, JString, required = true,
                                 default = nil)
  if valid_583355 != nil:
    section.add "profileId", valid_583355
  var valid_583356 = path.getOrDefault("id")
  valid_583356 = validateParameter(valid_583356, JString, required = true,
                                 default = nil)
  if valid_583356 != nil:
    section.add "id", valid_583356
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583357 = query.getOrDefault("fields")
  valid_583357 = validateParameter(valid_583357, JString, required = false,
                                 default = nil)
  if valid_583357 != nil:
    section.add "fields", valid_583357
  var valid_583358 = query.getOrDefault("quotaUser")
  valid_583358 = validateParameter(valid_583358, JString, required = false,
                                 default = nil)
  if valid_583358 != nil:
    section.add "quotaUser", valid_583358
  var valid_583359 = query.getOrDefault("alt")
  valid_583359 = validateParameter(valid_583359, JString, required = false,
                                 default = newJString("json"))
  if valid_583359 != nil:
    section.add "alt", valid_583359
  var valid_583360 = query.getOrDefault("oauth_token")
  valid_583360 = validateParameter(valid_583360, JString, required = false,
                                 default = nil)
  if valid_583360 != nil:
    section.add "oauth_token", valid_583360
  var valid_583361 = query.getOrDefault("userIp")
  valid_583361 = validateParameter(valid_583361, JString, required = false,
                                 default = nil)
  if valid_583361 != nil:
    section.add "userIp", valid_583361
  var valid_583362 = query.getOrDefault("key")
  valid_583362 = validateParameter(valid_583362, JString, required = false,
                                 default = nil)
  if valid_583362 != nil:
    section.add "key", valid_583362
  var valid_583363 = query.getOrDefault("prettyPrint")
  valid_583363 = validateParameter(valid_583363, JBool, required = false,
                                 default = newJBool(true))
  if valid_583363 != nil:
    section.add "prettyPrint", valid_583363
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583364: Call_DfareportingTargetableRemarketingListsGet_583352;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one remarketing list by ID.
  ## 
  let valid = call_583364.validator(path, query, header, formData, body)
  let scheme = call_583364.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583364.url(scheme.get, call_583364.host, call_583364.base,
                         call_583364.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583364, url, valid)

proc call*(call_583365: Call_DfareportingTargetableRemarketingListsGet_583352;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetableRemarketingListsGet
  ## Gets one remarketing list by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Remarketing list ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583366 = newJObject()
  var query_583367 = newJObject()
  add(path_583366, "profileId", newJString(profileId))
  add(query_583367, "fields", newJString(fields))
  add(query_583367, "quotaUser", newJString(quotaUser))
  add(query_583367, "alt", newJString(alt))
  add(query_583367, "oauth_token", newJString(oauthToken))
  add(query_583367, "userIp", newJString(userIp))
  add(path_583366, "id", newJString(id))
  add(query_583367, "key", newJString(key))
  add(query_583367, "prettyPrint", newJBool(prettyPrint))
  result = call_583365.call(path_583366, query_583367, nil, nil, nil)

var dfareportingTargetableRemarketingListsGet* = Call_DfareportingTargetableRemarketingListsGet_583352(
    name: "dfareportingTargetableRemarketingListsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetableRemarketingLists/{id}",
    validator: validate_DfareportingTargetableRemarketingListsGet_583353,
    base: "/dfareporting/v2.7",
    url: url_DfareportingTargetableRemarketingListsGet_583354,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesUpdate_583390 = ref object of OpenApiRestCall_579437
proc url_DfareportingTargetingTemplatesUpdate_583392(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesUpdate_583391(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing targeting template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583393 = path.getOrDefault("profileId")
  valid_583393 = validateParameter(valid_583393, JString, required = true,
                                 default = nil)
  if valid_583393 != nil:
    section.add "profileId", valid_583393
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583394 = query.getOrDefault("fields")
  valid_583394 = validateParameter(valid_583394, JString, required = false,
                                 default = nil)
  if valid_583394 != nil:
    section.add "fields", valid_583394
  var valid_583395 = query.getOrDefault("quotaUser")
  valid_583395 = validateParameter(valid_583395, JString, required = false,
                                 default = nil)
  if valid_583395 != nil:
    section.add "quotaUser", valid_583395
  var valid_583396 = query.getOrDefault("alt")
  valid_583396 = validateParameter(valid_583396, JString, required = false,
                                 default = newJString("json"))
  if valid_583396 != nil:
    section.add "alt", valid_583396
  var valid_583397 = query.getOrDefault("oauth_token")
  valid_583397 = validateParameter(valid_583397, JString, required = false,
                                 default = nil)
  if valid_583397 != nil:
    section.add "oauth_token", valid_583397
  var valid_583398 = query.getOrDefault("userIp")
  valid_583398 = validateParameter(valid_583398, JString, required = false,
                                 default = nil)
  if valid_583398 != nil:
    section.add "userIp", valid_583398
  var valid_583399 = query.getOrDefault("key")
  valid_583399 = validateParameter(valid_583399, JString, required = false,
                                 default = nil)
  if valid_583399 != nil:
    section.add "key", valid_583399
  var valid_583400 = query.getOrDefault("prettyPrint")
  valid_583400 = validateParameter(valid_583400, JBool, required = false,
                                 default = newJBool(true))
  if valid_583400 != nil:
    section.add "prettyPrint", valid_583400
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_583402: Call_DfareportingTargetingTemplatesUpdate_583390;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing targeting template.
  ## 
  let valid = call_583402.validator(path, query, header, formData, body)
  let scheme = call_583402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583402.url(scheme.get, call_583402.host, call_583402.base,
                         call_583402.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583402, url, valid)

proc call*(call_583403: Call_DfareportingTargetingTemplatesUpdate_583390;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesUpdate
  ## Updates an existing targeting template.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583404 = newJObject()
  var query_583405 = newJObject()
  var body_583406 = newJObject()
  add(path_583404, "profileId", newJString(profileId))
  add(query_583405, "fields", newJString(fields))
  add(query_583405, "quotaUser", newJString(quotaUser))
  add(query_583405, "alt", newJString(alt))
  add(query_583405, "oauth_token", newJString(oauthToken))
  add(query_583405, "userIp", newJString(userIp))
  add(query_583405, "key", newJString(key))
  if body != nil:
    body_583406 = body
  add(query_583405, "prettyPrint", newJBool(prettyPrint))
  result = call_583403.call(path_583404, query_583405, nil, nil, body_583406)

var dfareportingTargetingTemplatesUpdate* = Call_DfareportingTargetingTemplatesUpdate_583390(
    name: "dfareportingTargetingTemplatesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesUpdate_583391,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesUpdate_583392,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesInsert_583407 = ref object of OpenApiRestCall_579437
proc url_DfareportingTargetingTemplatesInsert_583409(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesInsert_583408(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new targeting template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583410 = path.getOrDefault("profileId")
  valid_583410 = validateParameter(valid_583410, JString, required = true,
                                 default = nil)
  if valid_583410 != nil:
    section.add "profileId", valid_583410
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583411 = query.getOrDefault("fields")
  valid_583411 = validateParameter(valid_583411, JString, required = false,
                                 default = nil)
  if valid_583411 != nil:
    section.add "fields", valid_583411
  var valid_583412 = query.getOrDefault("quotaUser")
  valid_583412 = validateParameter(valid_583412, JString, required = false,
                                 default = nil)
  if valid_583412 != nil:
    section.add "quotaUser", valid_583412
  var valid_583413 = query.getOrDefault("alt")
  valid_583413 = validateParameter(valid_583413, JString, required = false,
                                 default = newJString("json"))
  if valid_583413 != nil:
    section.add "alt", valid_583413
  var valid_583414 = query.getOrDefault("oauth_token")
  valid_583414 = validateParameter(valid_583414, JString, required = false,
                                 default = nil)
  if valid_583414 != nil:
    section.add "oauth_token", valid_583414
  var valid_583415 = query.getOrDefault("userIp")
  valid_583415 = validateParameter(valid_583415, JString, required = false,
                                 default = nil)
  if valid_583415 != nil:
    section.add "userIp", valid_583415
  var valid_583416 = query.getOrDefault("key")
  valid_583416 = validateParameter(valid_583416, JString, required = false,
                                 default = nil)
  if valid_583416 != nil:
    section.add "key", valid_583416
  var valid_583417 = query.getOrDefault("prettyPrint")
  valid_583417 = validateParameter(valid_583417, JBool, required = false,
                                 default = newJBool(true))
  if valid_583417 != nil:
    section.add "prettyPrint", valid_583417
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_583419: Call_DfareportingTargetingTemplatesInsert_583407;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new targeting template.
  ## 
  let valid = call_583419.validator(path, query, header, formData, body)
  let scheme = call_583419.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583419.url(scheme.get, call_583419.host, call_583419.base,
                         call_583419.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583419, url, valid)

proc call*(call_583420: Call_DfareportingTargetingTemplatesInsert_583407;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesInsert
  ## Inserts a new targeting template.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583421 = newJObject()
  var query_583422 = newJObject()
  var body_583423 = newJObject()
  add(path_583421, "profileId", newJString(profileId))
  add(query_583422, "fields", newJString(fields))
  add(query_583422, "quotaUser", newJString(quotaUser))
  add(query_583422, "alt", newJString(alt))
  add(query_583422, "oauth_token", newJString(oauthToken))
  add(query_583422, "userIp", newJString(userIp))
  add(query_583422, "key", newJString(key))
  if body != nil:
    body_583423 = body
  add(query_583422, "prettyPrint", newJBool(prettyPrint))
  result = call_583420.call(path_583421, query_583422, nil, nil, body_583423)

var dfareportingTargetingTemplatesInsert* = Call_DfareportingTargetingTemplatesInsert_583407(
    name: "dfareportingTargetingTemplatesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesInsert_583408,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesInsert_583409,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesList_583368 = ref object of OpenApiRestCall_579437
proc url_DfareportingTargetingTemplatesList_583370(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesList_583369(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of targeting templates, optionally filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583371 = path.getOrDefault("profileId")
  valid_583371 = validateParameter(valid_583371, JString, required = true,
                                 default = nil)
  if valid_583371 != nil:
    section.add "profileId", valid_583371
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "template*2015" will return objects with names like "template June 2015", "template April 2015", or simply "template 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "template" will match objects with name "my template", "template 2015", or simply "template".
  ##   advertiserId: JString
  ##               : Select only targeting templates with this advertiser ID.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only targeting templates with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583372 = query.getOrDefault("fields")
  valid_583372 = validateParameter(valid_583372, JString, required = false,
                                 default = nil)
  if valid_583372 != nil:
    section.add "fields", valid_583372
  var valid_583373 = query.getOrDefault("pageToken")
  valid_583373 = validateParameter(valid_583373, JString, required = false,
                                 default = nil)
  if valid_583373 != nil:
    section.add "pageToken", valid_583373
  var valid_583374 = query.getOrDefault("quotaUser")
  valid_583374 = validateParameter(valid_583374, JString, required = false,
                                 default = nil)
  if valid_583374 != nil:
    section.add "quotaUser", valid_583374
  var valid_583375 = query.getOrDefault("sortField")
  valid_583375 = validateParameter(valid_583375, JString, required = false,
                                 default = newJString("ID"))
  if valid_583375 != nil:
    section.add "sortField", valid_583375
  var valid_583376 = query.getOrDefault("alt")
  valid_583376 = validateParameter(valid_583376, JString, required = false,
                                 default = newJString("json"))
  if valid_583376 != nil:
    section.add "alt", valid_583376
  var valid_583377 = query.getOrDefault("searchString")
  valid_583377 = validateParameter(valid_583377, JString, required = false,
                                 default = nil)
  if valid_583377 != nil:
    section.add "searchString", valid_583377
  var valid_583378 = query.getOrDefault("advertiserId")
  valid_583378 = validateParameter(valid_583378, JString, required = false,
                                 default = nil)
  if valid_583378 != nil:
    section.add "advertiserId", valid_583378
  var valid_583379 = query.getOrDefault("oauth_token")
  valid_583379 = validateParameter(valid_583379, JString, required = false,
                                 default = nil)
  if valid_583379 != nil:
    section.add "oauth_token", valid_583379
  var valid_583380 = query.getOrDefault("userIp")
  valid_583380 = validateParameter(valid_583380, JString, required = false,
                                 default = nil)
  if valid_583380 != nil:
    section.add "userIp", valid_583380
  var valid_583381 = query.getOrDefault("maxResults")
  valid_583381 = validateParameter(valid_583381, JInt, required = false,
                                 default = newJInt(1000))
  if valid_583381 != nil:
    section.add "maxResults", valid_583381
  var valid_583382 = query.getOrDefault("ids")
  valid_583382 = validateParameter(valid_583382, JArray, required = false,
                                 default = nil)
  if valid_583382 != nil:
    section.add "ids", valid_583382
  var valid_583383 = query.getOrDefault("key")
  valid_583383 = validateParameter(valid_583383, JString, required = false,
                                 default = nil)
  if valid_583383 != nil:
    section.add "key", valid_583383
  var valid_583384 = query.getOrDefault("sortOrder")
  valid_583384 = validateParameter(valid_583384, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_583384 != nil:
    section.add "sortOrder", valid_583384
  var valid_583385 = query.getOrDefault("prettyPrint")
  valid_583385 = validateParameter(valid_583385, JBool, required = false,
                                 default = newJBool(true))
  if valid_583385 != nil:
    section.add "prettyPrint", valid_583385
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583386: Call_DfareportingTargetingTemplatesList_583368;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of targeting templates, optionally filtered. This method supports paging.
  ## 
  let valid = call_583386.validator(path, query, header, formData, body)
  let scheme = call_583386.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583386.url(scheme.get, call_583386.host, call_583386.base,
                         call_583386.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583386, url, valid)

proc call*(call_583387: Call_DfareportingTargetingTemplatesList_583368;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; advertiserId: string = ""; oauthToken: string = "";
          userIp: string = ""; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesList
  ## Retrieves a list of targeting templates, optionally filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "template*2015" will return objects with names like "template June 2015", "template April 2015", or simply "template 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "template" will match objects with name "my template", "template 2015", or simply "template".
  ##   advertiserId: string
  ##               : Select only targeting templates with this advertiser ID.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only targeting templates with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583388 = newJObject()
  var query_583389 = newJObject()
  add(path_583388, "profileId", newJString(profileId))
  add(query_583389, "fields", newJString(fields))
  add(query_583389, "pageToken", newJString(pageToken))
  add(query_583389, "quotaUser", newJString(quotaUser))
  add(query_583389, "sortField", newJString(sortField))
  add(query_583389, "alt", newJString(alt))
  add(query_583389, "searchString", newJString(searchString))
  add(query_583389, "advertiserId", newJString(advertiserId))
  add(query_583389, "oauth_token", newJString(oauthToken))
  add(query_583389, "userIp", newJString(userIp))
  add(query_583389, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_583389.add "ids", ids
  add(query_583389, "key", newJString(key))
  add(query_583389, "sortOrder", newJString(sortOrder))
  add(query_583389, "prettyPrint", newJBool(prettyPrint))
  result = call_583387.call(path_583388, query_583389, nil, nil, nil)

var dfareportingTargetingTemplatesList* = Call_DfareportingTargetingTemplatesList_583368(
    name: "dfareportingTargetingTemplatesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesList_583369,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesList_583370,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesPatch_583424 = ref object of OpenApiRestCall_579437
proc url_DfareportingTargetingTemplatesPatch_583426(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesPatch_583425(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing targeting template. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583427 = path.getOrDefault("profileId")
  valid_583427 = validateParameter(valid_583427, JString, required = true,
                                 default = nil)
  if valid_583427 != nil:
    section.add "profileId", valid_583427
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Targeting template ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583428 = query.getOrDefault("fields")
  valid_583428 = validateParameter(valid_583428, JString, required = false,
                                 default = nil)
  if valid_583428 != nil:
    section.add "fields", valid_583428
  var valid_583429 = query.getOrDefault("quotaUser")
  valid_583429 = validateParameter(valid_583429, JString, required = false,
                                 default = nil)
  if valid_583429 != nil:
    section.add "quotaUser", valid_583429
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_583430 = query.getOrDefault("id")
  valid_583430 = validateParameter(valid_583430, JString, required = true,
                                 default = nil)
  if valid_583430 != nil:
    section.add "id", valid_583430
  var valid_583431 = query.getOrDefault("alt")
  valid_583431 = validateParameter(valid_583431, JString, required = false,
                                 default = newJString("json"))
  if valid_583431 != nil:
    section.add "alt", valid_583431
  var valid_583432 = query.getOrDefault("oauth_token")
  valid_583432 = validateParameter(valid_583432, JString, required = false,
                                 default = nil)
  if valid_583432 != nil:
    section.add "oauth_token", valid_583432
  var valid_583433 = query.getOrDefault("userIp")
  valid_583433 = validateParameter(valid_583433, JString, required = false,
                                 default = nil)
  if valid_583433 != nil:
    section.add "userIp", valid_583433
  var valid_583434 = query.getOrDefault("key")
  valid_583434 = validateParameter(valid_583434, JString, required = false,
                                 default = nil)
  if valid_583434 != nil:
    section.add "key", valid_583434
  var valid_583435 = query.getOrDefault("prettyPrint")
  valid_583435 = validateParameter(valid_583435, JBool, required = false,
                                 default = newJBool(true))
  if valid_583435 != nil:
    section.add "prettyPrint", valid_583435
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_583437: Call_DfareportingTargetingTemplatesPatch_583424;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing targeting template. This method supports patch semantics.
  ## 
  let valid = call_583437.validator(path, query, header, formData, body)
  let scheme = call_583437.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583437.url(scheme.get, call_583437.host, call_583437.base,
                         call_583437.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583437, url, valid)

proc call*(call_583438: Call_DfareportingTargetingTemplatesPatch_583424;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesPatch
  ## Updates an existing targeting template. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Targeting template ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583439 = newJObject()
  var query_583440 = newJObject()
  var body_583441 = newJObject()
  add(path_583439, "profileId", newJString(profileId))
  add(query_583440, "fields", newJString(fields))
  add(query_583440, "quotaUser", newJString(quotaUser))
  add(query_583440, "id", newJString(id))
  add(query_583440, "alt", newJString(alt))
  add(query_583440, "oauth_token", newJString(oauthToken))
  add(query_583440, "userIp", newJString(userIp))
  add(query_583440, "key", newJString(key))
  if body != nil:
    body_583441 = body
  add(query_583440, "prettyPrint", newJBool(prettyPrint))
  result = call_583438.call(path_583439, query_583440, nil, nil, body_583441)

var dfareportingTargetingTemplatesPatch* = Call_DfareportingTargetingTemplatesPatch_583424(
    name: "dfareportingTargetingTemplatesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesPatch_583425,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesPatch_583426,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesGet_583442 = ref object of OpenApiRestCall_579437
proc url_DfareportingTargetingTemplatesGet_583444(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesGet_583443(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one targeting template by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Targeting template ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583445 = path.getOrDefault("profileId")
  valid_583445 = validateParameter(valid_583445, JString, required = true,
                                 default = nil)
  if valid_583445 != nil:
    section.add "profileId", valid_583445
  var valid_583446 = path.getOrDefault("id")
  valid_583446 = validateParameter(valid_583446, JString, required = true,
                                 default = nil)
  if valid_583446 != nil:
    section.add "id", valid_583446
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583447 = query.getOrDefault("fields")
  valid_583447 = validateParameter(valid_583447, JString, required = false,
                                 default = nil)
  if valid_583447 != nil:
    section.add "fields", valid_583447
  var valid_583448 = query.getOrDefault("quotaUser")
  valid_583448 = validateParameter(valid_583448, JString, required = false,
                                 default = nil)
  if valid_583448 != nil:
    section.add "quotaUser", valid_583448
  var valid_583449 = query.getOrDefault("alt")
  valid_583449 = validateParameter(valid_583449, JString, required = false,
                                 default = newJString("json"))
  if valid_583449 != nil:
    section.add "alt", valid_583449
  var valid_583450 = query.getOrDefault("oauth_token")
  valid_583450 = validateParameter(valid_583450, JString, required = false,
                                 default = nil)
  if valid_583450 != nil:
    section.add "oauth_token", valid_583450
  var valid_583451 = query.getOrDefault("userIp")
  valid_583451 = validateParameter(valid_583451, JString, required = false,
                                 default = nil)
  if valid_583451 != nil:
    section.add "userIp", valid_583451
  var valid_583452 = query.getOrDefault("key")
  valid_583452 = validateParameter(valid_583452, JString, required = false,
                                 default = nil)
  if valid_583452 != nil:
    section.add "key", valid_583452
  var valid_583453 = query.getOrDefault("prettyPrint")
  valid_583453 = validateParameter(valid_583453, JBool, required = false,
                                 default = newJBool(true))
  if valid_583453 != nil:
    section.add "prettyPrint", valid_583453
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583454: Call_DfareportingTargetingTemplatesGet_583442;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one targeting template by ID.
  ## 
  let valid = call_583454.validator(path, query, header, formData, body)
  let scheme = call_583454.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583454.url(scheme.get, call_583454.host, call_583454.base,
                         call_583454.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583454, url, valid)

proc call*(call_583455: Call_DfareportingTargetingTemplatesGet_583442;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesGet
  ## Gets one targeting template by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Targeting template ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583456 = newJObject()
  var query_583457 = newJObject()
  add(path_583456, "profileId", newJString(profileId))
  add(query_583457, "fields", newJString(fields))
  add(query_583457, "quotaUser", newJString(quotaUser))
  add(query_583457, "alt", newJString(alt))
  add(query_583457, "oauth_token", newJString(oauthToken))
  add(query_583457, "userIp", newJString(userIp))
  add(path_583456, "id", newJString(id))
  add(query_583457, "key", newJString(key))
  add(query_583457, "prettyPrint", newJBool(prettyPrint))
  result = call_583455.call(path_583456, query_583457, nil, nil, nil)

var dfareportingTargetingTemplatesGet* = Call_DfareportingTargetingTemplatesGet_583442(
    name: "dfareportingTargetingTemplatesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates/{id}",
    validator: validate_DfareportingTargetingTemplatesGet_583443,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesGet_583444,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionGroupsList_583458 = ref object of OpenApiRestCall_579437
proc url_DfareportingUserRolePermissionGroupsList_583460(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissionGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionGroupsList_583459(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of all supported user role permission groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583461 = path.getOrDefault("profileId")
  valid_583461 = validateParameter(valid_583461, JString, required = true,
                                 default = nil)
  if valid_583461 != nil:
    section.add "profileId", valid_583461
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583462 = query.getOrDefault("fields")
  valid_583462 = validateParameter(valid_583462, JString, required = false,
                                 default = nil)
  if valid_583462 != nil:
    section.add "fields", valid_583462
  var valid_583463 = query.getOrDefault("quotaUser")
  valid_583463 = validateParameter(valid_583463, JString, required = false,
                                 default = nil)
  if valid_583463 != nil:
    section.add "quotaUser", valid_583463
  var valid_583464 = query.getOrDefault("alt")
  valid_583464 = validateParameter(valid_583464, JString, required = false,
                                 default = newJString("json"))
  if valid_583464 != nil:
    section.add "alt", valid_583464
  var valid_583465 = query.getOrDefault("oauth_token")
  valid_583465 = validateParameter(valid_583465, JString, required = false,
                                 default = nil)
  if valid_583465 != nil:
    section.add "oauth_token", valid_583465
  var valid_583466 = query.getOrDefault("userIp")
  valid_583466 = validateParameter(valid_583466, JString, required = false,
                                 default = nil)
  if valid_583466 != nil:
    section.add "userIp", valid_583466
  var valid_583467 = query.getOrDefault("key")
  valid_583467 = validateParameter(valid_583467, JString, required = false,
                                 default = nil)
  if valid_583467 != nil:
    section.add "key", valid_583467
  var valid_583468 = query.getOrDefault("prettyPrint")
  valid_583468 = validateParameter(valid_583468, JBool, required = false,
                                 default = newJBool(true))
  if valid_583468 != nil:
    section.add "prettyPrint", valid_583468
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583469: Call_DfareportingUserRolePermissionGroupsList_583458;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of all supported user role permission groups.
  ## 
  let valid = call_583469.validator(path, query, header, formData, body)
  let scheme = call_583469.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583469.url(scheme.get, call_583469.host, call_583469.base,
                         call_583469.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583469, url, valid)

proc call*(call_583470: Call_DfareportingUserRolePermissionGroupsList_583458;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolePermissionGroupsList
  ## Gets a list of all supported user role permission groups.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583471 = newJObject()
  var query_583472 = newJObject()
  add(path_583471, "profileId", newJString(profileId))
  add(query_583472, "fields", newJString(fields))
  add(query_583472, "quotaUser", newJString(quotaUser))
  add(query_583472, "alt", newJString(alt))
  add(query_583472, "oauth_token", newJString(oauthToken))
  add(query_583472, "userIp", newJString(userIp))
  add(query_583472, "key", newJString(key))
  add(query_583472, "prettyPrint", newJBool(prettyPrint))
  result = call_583470.call(path_583471, query_583472, nil, nil, nil)

var dfareportingUserRolePermissionGroupsList* = Call_DfareportingUserRolePermissionGroupsList_583458(
    name: "dfareportingUserRolePermissionGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissionGroups",
    validator: validate_DfareportingUserRolePermissionGroupsList_583459,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionGroupsList_583460,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionGroupsGet_583473 = ref object of OpenApiRestCall_579437
proc url_DfareportingUserRolePermissionGroupsGet_583475(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissionGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionGroupsGet_583474(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user role permission group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role permission group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583476 = path.getOrDefault("profileId")
  valid_583476 = validateParameter(valid_583476, JString, required = true,
                                 default = nil)
  if valid_583476 != nil:
    section.add "profileId", valid_583476
  var valid_583477 = path.getOrDefault("id")
  valid_583477 = validateParameter(valid_583477, JString, required = true,
                                 default = nil)
  if valid_583477 != nil:
    section.add "id", valid_583477
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583478 = query.getOrDefault("fields")
  valid_583478 = validateParameter(valid_583478, JString, required = false,
                                 default = nil)
  if valid_583478 != nil:
    section.add "fields", valid_583478
  var valid_583479 = query.getOrDefault("quotaUser")
  valid_583479 = validateParameter(valid_583479, JString, required = false,
                                 default = nil)
  if valid_583479 != nil:
    section.add "quotaUser", valid_583479
  var valid_583480 = query.getOrDefault("alt")
  valid_583480 = validateParameter(valid_583480, JString, required = false,
                                 default = newJString("json"))
  if valid_583480 != nil:
    section.add "alt", valid_583480
  var valid_583481 = query.getOrDefault("oauth_token")
  valid_583481 = validateParameter(valid_583481, JString, required = false,
                                 default = nil)
  if valid_583481 != nil:
    section.add "oauth_token", valid_583481
  var valid_583482 = query.getOrDefault("userIp")
  valid_583482 = validateParameter(valid_583482, JString, required = false,
                                 default = nil)
  if valid_583482 != nil:
    section.add "userIp", valid_583482
  var valid_583483 = query.getOrDefault("key")
  valid_583483 = validateParameter(valid_583483, JString, required = false,
                                 default = nil)
  if valid_583483 != nil:
    section.add "key", valid_583483
  var valid_583484 = query.getOrDefault("prettyPrint")
  valid_583484 = validateParameter(valid_583484, JBool, required = false,
                                 default = newJBool(true))
  if valid_583484 != nil:
    section.add "prettyPrint", valid_583484
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583485: Call_DfareportingUserRolePermissionGroupsGet_583473;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one user role permission group by ID.
  ## 
  let valid = call_583485.validator(path, query, header, formData, body)
  let scheme = call_583485.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583485.url(scheme.get, call_583485.host, call_583485.base,
                         call_583485.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583485, url, valid)

proc call*(call_583486: Call_DfareportingUserRolePermissionGroupsGet_583473;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolePermissionGroupsGet
  ## Gets one user role permission group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User role permission group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583487 = newJObject()
  var query_583488 = newJObject()
  add(path_583487, "profileId", newJString(profileId))
  add(query_583488, "fields", newJString(fields))
  add(query_583488, "quotaUser", newJString(quotaUser))
  add(query_583488, "alt", newJString(alt))
  add(query_583488, "oauth_token", newJString(oauthToken))
  add(query_583488, "userIp", newJString(userIp))
  add(path_583487, "id", newJString(id))
  add(query_583488, "key", newJString(key))
  add(query_583488, "prettyPrint", newJBool(prettyPrint))
  result = call_583486.call(path_583487, query_583488, nil, nil, nil)

var dfareportingUserRolePermissionGroupsGet* = Call_DfareportingUserRolePermissionGroupsGet_583473(
    name: "dfareportingUserRolePermissionGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissionGroups/{id}",
    validator: validate_DfareportingUserRolePermissionGroupsGet_583474,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionGroupsGet_583475,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionsList_583489 = ref object of OpenApiRestCall_579437
proc url_DfareportingUserRolePermissionsList_583491(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionsList_583490(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of user role permissions, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583492 = path.getOrDefault("profileId")
  valid_583492 = validateParameter(valid_583492, JString, required = true,
                                 default = nil)
  if valid_583492 != nil:
    section.add "profileId", valid_583492
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Select only user role permissions with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583493 = query.getOrDefault("fields")
  valid_583493 = validateParameter(valid_583493, JString, required = false,
                                 default = nil)
  if valid_583493 != nil:
    section.add "fields", valid_583493
  var valid_583494 = query.getOrDefault("quotaUser")
  valid_583494 = validateParameter(valid_583494, JString, required = false,
                                 default = nil)
  if valid_583494 != nil:
    section.add "quotaUser", valid_583494
  var valid_583495 = query.getOrDefault("alt")
  valid_583495 = validateParameter(valid_583495, JString, required = false,
                                 default = newJString("json"))
  if valid_583495 != nil:
    section.add "alt", valid_583495
  var valid_583496 = query.getOrDefault("oauth_token")
  valid_583496 = validateParameter(valid_583496, JString, required = false,
                                 default = nil)
  if valid_583496 != nil:
    section.add "oauth_token", valid_583496
  var valid_583497 = query.getOrDefault("userIp")
  valid_583497 = validateParameter(valid_583497, JString, required = false,
                                 default = nil)
  if valid_583497 != nil:
    section.add "userIp", valid_583497
  var valid_583498 = query.getOrDefault("ids")
  valid_583498 = validateParameter(valid_583498, JArray, required = false,
                                 default = nil)
  if valid_583498 != nil:
    section.add "ids", valid_583498
  var valid_583499 = query.getOrDefault("key")
  valid_583499 = validateParameter(valid_583499, JString, required = false,
                                 default = nil)
  if valid_583499 != nil:
    section.add "key", valid_583499
  var valid_583500 = query.getOrDefault("prettyPrint")
  valid_583500 = validateParameter(valid_583500, JBool, required = false,
                                 default = newJBool(true))
  if valid_583500 != nil:
    section.add "prettyPrint", valid_583500
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583501: Call_DfareportingUserRolePermissionsList_583489;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of user role permissions, possibly filtered.
  ## 
  let valid = call_583501.validator(path, query, header, formData, body)
  let scheme = call_583501.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583501.url(scheme.get, call_583501.host, call_583501.base,
                         call_583501.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583501, url, valid)

proc call*(call_583502: Call_DfareportingUserRolePermissionsList_583489;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          ids: JsonNode = nil; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolePermissionsList
  ## Gets a list of user role permissions, possibly filtered.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Select only user role permissions with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583503 = newJObject()
  var query_583504 = newJObject()
  add(path_583503, "profileId", newJString(profileId))
  add(query_583504, "fields", newJString(fields))
  add(query_583504, "quotaUser", newJString(quotaUser))
  add(query_583504, "alt", newJString(alt))
  add(query_583504, "oauth_token", newJString(oauthToken))
  add(query_583504, "userIp", newJString(userIp))
  if ids != nil:
    query_583504.add "ids", ids
  add(query_583504, "key", newJString(key))
  add(query_583504, "prettyPrint", newJBool(prettyPrint))
  result = call_583502.call(path_583503, query_583504, nil, nil, nil)

var dfareportingUserRolePermissionsList* = Call_DfareportingUserRolePermissionsList_583489(
    name: "dfareportingUserRolePermissionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissions",
    validator: validate_DfareportingUserRolePermissionsList_583490,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionsList_583491,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionsGet_583505 = ref object of OpenApiRestCall_579437
proc url_DfareportingUserRolePermissionsGet_583507(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissions/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionsGet_583506(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user role permission by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role permission ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583508 = path.getOrDefault("profileId")
  valid_583508 = validateParameter(valid_583508, JString, required = true,
                                 default = nil)
  if valid_583508 != nil:
    section.add "profileId", valid_583508
  var valid_583509 = path.getOrDefault("id")
  valid_583509 = validateParameter(valid_583509, JString, required = true,
                                 default = nil)
  if valid_583509 != nil:
    section.add "id", valid_583509
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583510 = query.getOrDefault("fields")
  valid_583510 = validateParameter(valid_583510, JString, required = false,
                                 default = nil)
  if valid_583510 != nil:
    section.add "fields", valid_583510
  var valid_583511 = query.getOrDefault("quotaUser")
  valid_583511 = validateParameter(valid_583511, JString, required = false,
                                 default = nil)
  if valid_583511 != nil:
    section.add "quotaUser", valid_583511
  var valid_583512 = query.getOrDefault("alt")
  valid_583512 = validateParameter(valid_583512, JString, required = false,
                                 default = newJString("json"))
  if valid_583512 != nil:
    section.add "alt", valid_583512
  var valid_583513 = query.getOrDefault("oauth_token")
  valid_583513 = validateParameter(valid_583513, JString, required = false,
                                 default = nil)
  if valid_583513 != nil:
    section.add "oauth_token", valid_583513
  var valid_583514 = query.getOrDefault("userIp")
  valid_583514 = validateParameter(valid_583514, JString, required = false,
                                 default = nil)
  if valid_583514 != nil:
    section.add "userIp", valid_583514
  var valid_583515 = query.getOrDefault("key")
  valid_583515 = validateParameter(valid_583515, JString, required = false,
                                 default = nil)
  if valid_583515 != nil:
    section.add "key", valid_583515
  var valid_583516 = query.getOrDefault("prettyPrint")
  valid_583516 = validateParameter(valid_583516, JBool, required = false,
                                 default = newJBool(true))
  if valid_583516 != nil:
    section.add "prettyPrint", valid_583516
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583517: Call_DfareportingUserRolePermissionsGet_583505;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one user role permission by ID.
  ## 
  let valid = call_583517.validator(path, query, header, formData, body)
  let scheme = call_583517.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583517.url(scheme.get, call_583517.host, call_583517.base,
                         call_583517.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583517, url, valid)

proc call*(call_583518: Call_DfareportingUserRolePermissionsGet_583505;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolePermissionsGet
  ## Gets one user role permission by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User role permission ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583519 = newJObject()
  var query_583520 = newJObject()
  add(path_583519, "profileId", newJString(profileId))
  add(query_583520, "fields", newJString(fields))
  add(query_583520, "quotaUser", newJString(quotaUser))
  add(query_583520, "alt", newJString(alt))
  add(query_583520, "oauth_token", newJString(oauthToken))
  add(query_583520, "userIp", newJString(userIp))
  add(path_583519, "id", newJString(id))
  add(query_583520, "key", newJString(key))
  add(query_583520, "prettyPrint", newJBool(prettyPrint))
  result = call_583518.call(path_583519, query_583520, nil, nil, nil)

var dfareportingUserRolePermissionsGet* = Call_DfareportingUserRolePermissionsGet_583505(
    name: "dfareportingUserRolePermissionsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissions/{id}",
    validator: validate_DfareportingUserRolePermissionsGet_583506,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionsGet_583507,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesUpdate_583544 = ref object of OpenApiRestCall_579437
proc url_DfareportingUserRolesUpdate_583546(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesUpdate_583545(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing user role.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583547 = path.getOrDefault("profileId")
  valid_583547 = validateParameter(valid_583547, JString, required = true,
                                 default = nil)
  if valid_583547 != nil:
    section.add "profileId", valid_583547
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583548 = query.getOrDefault("fields")
  valid_583548 = validateParameter(valid_583548, JString, required = false,
                                 default = nil)
  if valid_583548 != nil:
    section.add "fields", valid_583548
  var valid_583549 = query.getOrDefault("quotaUser")
  valid_583549 = validateParameter(valid_583549, JString, required = false,
                                 default = nil)
  if valid_583549 != nil:
    section.add "quotaUser", valid_583549
  var valid_583550 = query.getOrDefault("alt")
  valid_583550 = validateParameter(valid_583550, JString, required = false,
                                 default = newJString("json"))
  if valid_583550 != nil:
    section.add "alt", valid_583550
  var valid_583551 = query.getOrDefault("oauth_token")
  valid_583551 = validateParameter(valid_583551, JString, required = false,
                                 default = nil)
  if valid_583551 != nil:
    section.add "oauth_token", valid_583551
  var valid_583552 = query.getOrDefault("userIp")
  valid_583552 = validateParameter(valid_583552, JString, required = false,
                                 default = nil)
  if valid_583552 != nil:
    section.add "userIp", valid_583552
  var valid_583553 = query.getOrDefault("key")
  valid_583553 = validateParameter(valid_583553, JString, required = false,
                                 default = nil)
  if valid_583553 != nil:
    section.add "key", valid_583553
  var valid_583554 = query.getOrDefault("prettyPrint")
  valid_583554 = validateParameter(valid_583554, JBool, required = false,
                                 default = newJBool(true))
  if valid_583554 != nil:
    section.add "prettyPrint", valid_583554
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_583556: Call_DfareportingUserRolesUpdate_583544; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing user role.
  ## 
  let valid = call_583556.validator(path, query, header, formData, body)
  let scheme = call_583556.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583556.url(scheme.get, call_583556.host, call_583556.base,
                         call_583556.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583556, url, valid)

proc call*(call_583557: Call_DfareportingUserRolesUpdate_583544; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesUpdate
  ## Updates an existing user role.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583558 = newJObject()
  var query_583559 = newJObject()
  var body_583560 = newJObject()
  add(path_583558, "profileId", newJString(profileId))
  add(query_583559, "fields", newJString(fields))
  add(query_583559, "quotaUser", newJString(quotaUser))
  add(query_583559, "alt", newJString(alt))
  add(query_583559, "oauth_token", newJString(oauthToken))
  add(query_583559, "userIp", newJString(userIp))
  add(query_583559, "key", newJString(key))
  if body != nil:
    body_583560 = body
  add(query_583559, "prettyPrint", newJBool(prettyPrint))
  result = call_583557.call(path_583558, query_583559, nil, nil, body_583560)

var dfareportingUserRolesUpdate* = Call_DfareportingUserRolesUpdate_583544(
    name: "dfareportingUserRolesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesUpdate_583545,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesUpdate_583546,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesInsert_583561 = ref object of OpenApiRestCall_579437
proc url_DfareportingUserRolesInsert_583563(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesInsert_583562(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new user role.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583564 = path.getOrDefault("profileId")
  valid_583564 = validateParameter(valid_583564, JString, required = true,
                                 default = nil)
  if valid_583564 != nil:
    section.add "profileId", valid_583564
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583565 = query.getOrDefault("fields")
  valid_583565 = validateParameter(valid_583565, JString, required = false,
                                 default = nil)
  if valid_583565 != nil:
    section.add "fields", valid_583565
  var valid_583566 = query.getOrDefault("quotaUser")
  valid_583566 = validateParameter(valid_583566, JString, required = false,
                                 default = nil)
  if valid_583566 != nil:
    section.add "quotaUser", valid_583566
  var valid_583567 = query.getOrDefault("alt")
  valid_583567 = validateParameter(valid_583567, JString, required = false,
                                 default = newJString("json"))
  if valid_583567 != nil:
    section.add "alt", valid_583567
  var valid_583568 = query.getOrDefault("oauth_token")
  valid_583568 = validateParameter(valid_583568, JString, required = false,
                                 default = nil)
  if valid_583568 != nil:
    section.add "oauth_token", valid_583568
  var valid_583569 = query.getOrDefault("userIp")
  valid_583569 = validateParameter(valid_583569, JString, required = false,
                                 default = nil)
  if valid_583569 != nil:
    section.add "userIp", valid_583569
  var valid_583570 = query.getOrDefault("key")
  valid_583570 = validateParameter(valid_583570, JString, required = false,
                                 default = nil)
  if valid_583570 != nil:
    section.add "key", valid_583570
  var valid_583571 = query.getOrDefault("prettyPrint")
  valid_583571 = validateParameter(valid_583571, JBool, required = false,
                                 default = newJBool(true))
  if valid_583571 != nil:
    section.add "prettyPrint", valid_583571
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_583573: Call_DfareportingUserRolesInsert_583561; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new user role.
  ## 
  let valid = call_583573.validator(path, query, header, formData, body)
  let scheme = call_583573.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583573.url(scheme.get, call_583573.host, call_583573.base,
                         call_583573.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583573, url, valid)

proc call*(call_583574: Call_DfareportingUserRolesInsert_583561; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesInsert
  ## Inserts a new user role.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583575 = newJObject()
  var query_583576 = newJObject()
  var body_583577 = newJObject()
  add(path_583575, "profileId", newJString(profileId))
  add(query_583576, "fields", newJString(fields))
  add(query_583576, "quotaUser", newJString(quotaUser))
  add(query_583576, "alt", newJString(alt))
  add(query_583576, "oauth_token", newJString(oauthToken))
  add(query_583576, "userIp", newJString(userIp))
  add(query_583576, "key", newJString(key))
  if body != nil:
    body_583577 = body
  add(query_583576, "prettyPrint", newJBool(prettyPrint))
  result = call_583574.call(path_583575, query_583576, nil, nil, body_583577)

var dfareportingUserRolesInsert* = Call_DfareportingUserRolesInsert_583561(
    name: "dfareportingUserRolesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesInsert_583562,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesInsert_583563,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesList_583521 = ref object of OpenApiRestCall_579437
proc url_DfareportingUserRolesList_583523(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesList_583522(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of user roles, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583524 = path.getOrDefault("profileId")
  valid_583524 = validateParameter(valid_583524, JString, required = true,
                                 default = nil)
  if valid_583524 != nil:
    section.add "profileId", valid_583524
  result.add "path", section
  ## parameters in `query` object:
  ##   subaccountId: JString
  ##               : Select only user roles that belong to this subaccount.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "userrole*2015" will return objects with names like "userrole June 2015", "userrole April 2015", or simply "userrole 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "userrole" will match objects with name "my userrole", "userrole 2015", or simply "userrole".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   accountUserRoleOnly: JBool
  ##                      : Select only account level user roles not associated with any specific subaccount.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only user roles with the specified IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583525 = query.getOrDefault("subaccountId")
  valid_583525 = validateParameter(valid_583525, JString, required = false,
                                 default = nil)
  if valid_583525 != nil:
    section.add "subaccountId", valid_583525
  var valid_583526 = query.getOrDefault("fields")
  valid_583526 = validateParameter(valid_583526, JString, required = false,
                                 default = nil)
  if valid_583526 != nil:
    section.add "fields", valid_583526
  var valid_583527 = query.getOrDefault("pageToken")
  valid_583527 = validateParameter(valid_583527, JString, required = false,
                                 default = nil)
  if valid_583527 != nil:
    section.add "pageToken", valid_583527
  var valid_583528 = query.getOrDefault("quotaUser")
  valid_583528 = validateParameter(valid_583528, JString, required = false,
                                 default = nil)
  if valid_583528 != nil:
    section.add "quotaUser", valid_583528
  var valid_583529 = query.getOrDefault("sortField")
  valid_583529 = validateParameter(valid_583529, JString, required = false,
                                 default = newJString("ID"))
  if valid_583529 != nil:
    section.add "sortField", valid_583529
  var valid_583530 = query.getOrDefault("alt")
  valid_583530 = validateParameter(valid_583530, JString, required = false,
                                 default = newJString("json"))
  if valid_583530 != nil:
    section.add "alt", valid_583530
  var valid_583531 = query.getOrDefault("searchString")
  valid_583531 = validateParameter(valid_583531, JString, required = false,
                                 default = nil)
  if valid_583531 != nil:
    section.add "searchString", valid_583531
  var valid_583532 = query.getOrDefault("oauth_token")
  valid_583532 = validateParameter(valid_583532, JString, required = false,
                                 default = nil)
  if valid_583532 != nil:
    section.add "oauth_token", valid_583532
  var valid_583533 = query.getOrDefault("accountUserRoleOnly")
  valid_583533 = validateParameter(valid_583533, JBool, required = false, default = nil)
  if valid_583533 != nil:
    section.add "accountUserRoleOnly", valid_583533
  var valid_583534 = query.getOrDefault("userIp")
  valid_583534 = validateParameter(valid_583534, JString, required = false,
                                 default = nil)
  if valid_583534 != nil:
    section.add "userIp", valid_583534
  var valid_583535 = query.getOrDefault("maxResults")
  valid_583535 = validateParameter(valid_583535, JInt, required = false,
                                 default = newJInt(1000))
  if valid_583535 != nil:
    section.add "maxResults", valid_583535
  var valid_583536 = query.getOrDefault("ids")
  valid_583536 = validateParameter(valid_583536, JArray, required = false,
                                 default = nil)
  if valid_583536 != nil:
    section.add "ids", valid_583536
  var valid_583537 = query.getOrDefault("key")
  valid_583537 = validateParameter(valid_583537, JString, required = false,
                                 default = nil)
  if valid_583537 != nil:
    section.add "key", valid_583537
  var valid_583538 = query.getOrDefault("sortOrder")
  valid_583538 = validateParameter(valid_583538, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_583538 != nil:
    section.add "sortOrder", valid_583538
  var valid_583539 = query.getOrDefault("prettyPrint")
  valid_583539 = validateParameter(valid_583539, JBool, required = false,
                                 default = newJBool(true))
  if valid_583539 != nil:
    section.add "prettyPrint", valid_583539
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583540: Call_DfareportingUserRolesList_583521; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of user roles, possibly filtered. This method supports paging.
  ## 
  let valid = call_583540.validator(path, query, header, formData, body)
  let scheme = call_583540.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583540.url(scheme.get, call_583540.host, call_583540.base,
                         call_583540.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583540, url, valid)

proc call*(call_583541: Call_DfareportingUserRolesList_583521; profileId: string;
          subaccountId: string = ""; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = "";
          accountUserRoleOnly: bool = false; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesList
  ## Retrieves a list of user roles, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only user roles that belong to this subaccount.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "userrole*2015" will return objects with names like "userrole June 2015", "userrole April 2015", or simply "userrole 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "userrole" will match objects with name "my userrole", "userrole 2015", or simply "userrole".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   accountUserRoleOnly: bool
  ##                      : Select only account level user roles not associated with any specific subaccount.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only user roles with the specified IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583542 = newJObject()
  var query_583543 = newJObject()
  add(path_583542, "profileId", newJString(profileId))
  add(query_583543, "subaccountId", newJString(subaccountId))
  add(query_583543, "fields", newJString(fields))
  add(query_583543, "pageToken", newJString(pageToken))
  add(query_583543, "quotaUser", newJString(quotaUser))
  add(query_583543, "sortField", newJString(sortField))
  add(query_583543, "alt", newJString(alt))
  add(query_583543, "searchString", newJString(searchString))
  add(query_583543, "oauth_token", newJString(oauthToken))
  add(query_583543, "accountUserRoleOnly", newJBool(accountUserRoleOnly))
  add(query_583543, "userIp", newJString(userIp))
  add(query_583543, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_583543.add "ids", ids
  add(query_583543, "key", newJString(key))
  add(query_583543, "sortOrder", newJString(sortOrder))
  add(query_583543, "prettyPrint", newJBool(prettyPrint))
  result = call_583541.call(path_583542, query_583543, nil, nil, nil)

var dfareportingUserRolesList* = Call_DfareportingUserRolesList_583521(
    name: "dfareportingUserRolesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesList_583522,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesList_583523,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesPatch_583578 = ref object of OpenApiRestCall_579437
proc url_DfareportingUserRolesPatch_583580(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesPatch_583579(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing user role. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583581 = path.getOrDefault("profileId")
  valid_583581 = validateParameter(valid_583581, JString, required = true,
                                 default = nil)
  if valid_583581 != nil:
    section.add "profileId", valid_583581
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : User role ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583582 = query.getOrDefault("fields")
  valid_583582 = validateParameter(valid_583582, JString, required = false,
                                 default = nil)
  if valid_583582 != nil:
    section.add "fields", valid_583582
  var valid_583583 = query.getOrDefault("quotaUser")
  valid_583583 = validateParameter(valid_583583, JString, required = false,
                                 default = nil)
  if valid_583583 != nil:
    section.add "quotaUser", valid_583583
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_583584 = query.getOrDefault("id")
  valid_583584 = validateParameter(valid_583584, JString, required = true,
                                 default = nil)
  if valid_583584 != nil:
    section.add "id", valid_583584
  var valid_583585 = query.getOrDefault("alt")
  valid_583585 = validateParameter(valid_583585, JString, required = false,
                                 default = newJString("json"))
  if valid_583585 != nil:
    section.add "alt", valid_583585
  var valid_583586 = query.getOrDefault("oauth_token")
  valid_583586 = validateParameter(valid_583586, JString, required = false,
                                 default = nil)
  if valid_583586 != nil:
    section.add "oauth_token", valid_583586
  var valid_583587 = query.getOrDefault("userIp")
  valid_583587 = validateParameter(valid_583587, JString, required = false,
                                 default = nil)
  if valid_583587 != nil:
    section.add "userIp", valid_583587
  var valid_583588 = query.getOrDefault("key")
  valid_583588 = validateParameter(valid_583588, JString, required = false,
                                 default = nil)
  if valid_583588 != nil:
    section.add "key", valid_583588
  var valid_583589 = query.getOrDefault("prettyPrint")
  valid_583589 = validateParameter(valid_583589, JBool, required = false,
                                 default = newJBool(true))
  if valid_583589 != nil:
    section.add "prettyPrint", valid_583589
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_583591: Call_DfareportingUserRolesPatch_583578; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing user role. This method supports patch semantics.
  ## 
  let valid = call_583591.validator(path, query, header, formData, body)
  let scheme = call_583591.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583591.url(scheme.get, call_583591.host, call_583591.base,
                         call_583591.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583591, url, valid)

proc call*(call_583592: Call_DfareportingUserRolesPatch_583578; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesPatch
  ## Updates an existing user role. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : User role ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583593 = newJObject()
  var query_583594 = newJObject()
  var body_583595 = newJObject()
  add(path_583593, "profileId", newJString(profileId))
  add(query_583594, "fields", newJString(fields))
  add(query_583594, "quotaUser", newJString(quotaUser))
  add(query_583594, "id", newJString(id))
  add(query_583594, "alt", newJString(alt))
  add(query_583594, "oauth_token", newJString(oauthToken))
  add(query_583594, "userIp", newJString(userIp))
  add(query_583594, "key", newJString(key))
  if body != nil:
    body_583595 = body
  add(query_583594, "prettyPrint", newJBool(prettyPrint))
  result = call_583592.call(path_583593, query_583594, nil, nil, body_583595)

var dfareportingUserRolesPatch* = Call_DfareportingUserRolesPatch_583578(
    name: "dfareportingUserRolesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesPatch_583579,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesPatch_583580,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesGet_583596 = ref object of OpenApiRestCall_579437
proc url_DfareportingUserRolesGet_583598(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesGet_583597(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user role by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583599 = path.getOrDefault("profileId")
  valid_583599 = validateParameter(valid_583599, JString, required = true,
                                 default = nil)
  if valid_583599 != nil:
    section.add "profileId", valid_583599
  var valid_583600 = path.getOrDefault("id")
  valid_583600 = validateParameter(valid_583600, JString, required = true,
                                 default = nil)
  if valid_583600 != nil:
    section.add "id", valid_583600
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583601 = query.getOrDefault("fields")
  valid_583601 = validateParameter(valid_583601, JString, required = false,
                                 default = nil)
  if valid_583601 != nil:
    section.add "fields", valid_583601
  var valid_583602 = query.getOrDefault("quotaUser")
  valid_583602 = validateParameter(valid_583602, JString, required = false,
                                 default = nil)
  if valid_583602 != nil:
    section.add "quotaUser", valid_583602
  var valid_583603 = query.getOrDefault("alt")
  valid_583603 = validateParameter(valid_583603, JString, required = false,
                                 default = newJString("json"))
  if valid_583603 != nil:
    section.add "alt", valid_583603
  var valid_583604 = query.getOrDefault("oauth_token")
  valid_583604 = validateParameter(valid_583604, JString, required = false,
                                 default = nil)
  if valid_583604 != nil:
    section.add "oauth_token", valid_583604
  var valid_583605 = query.getOrDefault("userIp")
  valid_583605 = validateParameter(valid_583605, JString, required = false,
                                 default = nil)
  if valid_583605 != nil:
    section.add "userIp", valid_583605
  var valid_583606 = query.getOrDefault("key")
  valid_583606 = validateParameter(valid_583606, JString, required = false,
                                 default = nil)
  if valid_583606 != nil:
    section.add "key", valid_583606
  var valid_583607 = query.getOrDefault("prettyPrint")
  valid_583607 = validateParameter(valid_583607, JBool, required = false,
                                 default = newJBool(true))
  if valid_583607 != nil:
    section.add "prettyPrint", valid_583607
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583608: Call_DfareportingUserRolesGet_583596; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one user role by ID.
  ## 
  let valid = call_583608.validator(path, query, header, formData, body)
  let scheme = call_583608.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583608.url(scheme.get, call_583608.host, call_583608.base,
                         call_583608.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583608, url, valid)

proc call*(call_583609: Call_DfareportingUserRolesGet_583596; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesGet
  ## Gets one user role by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User role ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583610 = newJObject()
  var query_583611 = newJObject()
  add(path_583610, "profileId", newJString(profileId))
  add(query_583611, "fields", newJString(fields))
  add(query_583611, "quotaUser", newJString(quotaUser))
  add(query_583611, "alt", newJString(alt))
  add(query_583611, "oauth_token", newJString(oauthToken))
  add(query_583611, "userIp", newJString(userIp))
  add(path_583610, "id", newJString(id))
  add(query_583611, "key", newJString(key))
  add(query_583611, "prettyPrint", newJBool(prettyPrint))
  result = call_583609.call(path_583610, query_583611, nil, nil, nil)

var dfareportingUserRolesGet* = Call_DfareportingUserRolesGet_583596(
    name: "dfareportingUserRolesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles/{id}",
    validator: validate_DfareportingUserRolesGet_583597,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesGet_583598,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesDelete_583612 = ref object of OpenApiRestCall_579437
proc url_DfareportingUserRolesDelete_583614(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesDelete_583613(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing user role.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583615 = path.getOrDefault("profileId")
  valid_583615 = validateParameter(valid_583615, JString, required = true,
                                 default = nil)
  if valid_583615 != nil:
    section.add "profileId", valid_583615
  var valid_583616 = path.getOrDefault("id")
  valid_583616 = validateParameter(valid_583616, JString, required = true,
                                 default = nil)
  if valid_583616 != nil:
    section.add "id", valid_583616
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583617 = query.getOrDefault("fields")
  valid_583617 = validateParameter(valid_583617, JString, required = false,
                                 default = nil)
  if valid_583617 != nil:
    section.add "fields", valid_583617
  var valid_583618 = query.getOrDefault("quotaUser")
  valid_583618 = validateParameter(valid_583618, JString, required = false,
                                 default = nil)
  if valid_583618 != nil:
    section.add "quotaUser", valid_583618
  var valid_583619 = query.getOrDefault("alt")
  valid_583619 = validateParameter(valid_583619, JString, required = false,
                                 default = newJString("json"))
  if valid_583619 != nil:
    section.add "alt", valid_583619
  var valid_583620 = query.getOrDefault("oauth_token")
  valid_583620 = validateParameter(valid_583620, JString, required = false,
                                 default = nil)
  if valid_583620 != nil:
    section.add "oauth_token", valid_583620
  var valid_583621 = query.getOrDefault("userIp")
  valid_583621 = validateParameter(valid_583621, JString, required = false,
                                 default = nil)
  if valid_583621 != nil:
    section.add "userIp", valid_583621
  var valid_583622 = query.getOrDefault("key")
  valid_583622 = validateParameter(valid_583622, JString, required = false,
                                 default = nil)
  if valid_583622 != nil:
    section.add "key", valid_583622
  var valid_583623 = query.getOrDefault("prettyPrint")
  valid_583623 = validateParameter(valid_583623, JBool, required = false,
                                 default = newJBool(true))
  if valid_583623 != nil:
    section.add "prettyPrint", valid_583623
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583624: Call_DfareportingUserRolesDelete_583612; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing user role.
  ## 
  let valid = call_583624.validator(path, query, header, formData, body)
  let scheme = call_583624.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583624.url(scheme.get, call_583624.host, call_583624.base,
                         call_583624.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583624, url, valid)

proc call*(call_583625: Call_DfareportingUserRolesDelete_583612; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesDelete
  ## Deletes an existing user role.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User role ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583626 = newJObject()
  var query_583627 = newJObject()
  add(path_583626, "profileId", newJString(profileId))
  add(query_583627, "fields", newJString(fields))
  add(query_583627, "quotaUser", newJString(quotaUser))
  add(query_583627, "alt", newJString(alt))
  add(query_583627, "oauth_token", newJString(oauthToken))
  add(query_583627, "userIp", newJString(userIp))
  add(path_583626, "id", newJString(id))
  add(query_583627, "key", newJString(key))
  add(query_583627, "prettyPrint", newJBool(prettyPrint))
  result = call_583625.call(path_583626, query_583627, nil, nil, nil)

var dfareportingUserRolesDelete* = Call_DfareportingUserRolesDelete_583612(
    name: "dfareportingUserRolesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles/{id}",
    validator: validate_DfareportingUserRolesDelete_583613,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesDelete_583614,
    schemes: {Scheme.Https})
type
  Call_DfareportingVideoFormatsList_583628 = ref object of OpenApiRestCall_579437
proc url_DfareportingVideoFormatsList_583630(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/videoFormats")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingVideoFormatsList_583629(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists available video formats.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583631 = path.getOrDefault("profileId")
  valid_583631 = validateParameter(valid_583631, JString, required = true,
                                 default = nil)
  if valid_583631 != nil:
    section.add "profileId", valid_583631
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583632 = query.getOrDefault("fields")
  valid_583632 = validateParameter(valid_583632, JString, required = false,
                                 default = nil)
  if valid_583632 != nil:
    section.add "fields", valid_583632
  var valid_583633 = query.getOrDefault("quotaUser")
  valid_583633 = validateParameter(valid_583633, JString, required = false,
                                 default = nil)
  if valid_583633 != nil:
    section.add "quotaUser", valid_583633
  var valid_583634 = query.getOrDefault("alt")
  valid_583634 = validateParameter(valid_583634, JString, required = false,
                                 default = newJString("json"))
  if valid_583634 != nil:
    section.add "alt", valid_583634
  var valid_583635 = query.getOrDefault("oauth_token")
  valid_583635 = validateParameter(valid_583635, JString, required = false,
                                 default = nil)
  if valid_583635 != nil:
    section.add "oauth_token", valid_583635
  var valid_583636 = query.getOrDefault("userIp")
  valid_583636 = validateParameter(valid_583636, JString, required = false,
                                 default = nil)
  if valid_583636 != nil:
    section.add "userIp", valid_583636
  var valid_583637 = query.getOrDefault("key")
  valid_583637 = validateParameter(valid_583637, JString, required = false,
                                 default = nil)
  if valid_583637 != nil:
    section.add "key", valid_583637
  var valid_583638 = query.getOrDefault("prettyPrint")
  valid_583638 = validateParameter(valid_583638, JBool, required = false,
                                 default = newJBool(true))
  if valid_583638 != nil:
    section.add "prettyPrint", valid_583638
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583639: Call_DfareportingVideoFormatsList_583628; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists available video formats.
  ## 
  let valid = call_583639.validator(path, query, header, formData, body)
  let scheme = call_583639.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583639.url(scheme.get, call_583639.host, call_583639.base,
                         call_583639.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583639, url, valid)

proc call*(call_583640: Call_DfareportingVideoFormatsList_583628;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingVideoFormatsList
  ## Lists available video formats.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583641 = newJObject()
  var query_583642 = newJObject()
  add(path_583641, "profileId", newJString(profileId))
  add(query_583642, "fields", newJString(fields))
  add(query_583642, "quotaUser", newJString(quotaUser))
  add(query_583642, "alt", newJString(alt))
  add(query_583642, "oauth_token", newJString(oauthToken))
  add(query_583642, "userIp", newJString(userIp))
  add(query_583642, "key", newJString(key))
  add(query_583642, "prettyPrint", newJBool(prettyPrint))
  result = call_583640.call(path_583641, query_583642, nil, nil, nil)

var dfareportingVideoFormatsList* = Call_DfareportingVideoFormatsList_583628(
    name: "dfareportingVideoFormatsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/videoFormats",
    validator: validate_DfareportingVideoFormatsList_583629,
    base: "/dfareporting/v2.7", url: url_DfareportingVideoFormatsList_583630,
    schemes: {Scheme.Https})
type
  Call_DfareportingVideoFormatsGet_583643 = ref object of OpenApiRestCall_579437
proc url_DfareportingVideoFormatsGet_583645(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/videoFormats/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingVideoFormatsGet_583644(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one video format by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JInt (required)
  ##     : Video format ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_583646 = path.getOrDefault("profileId")
  valid_583646 = validateParameter(valid_583646, JString, required = true,
                                 default = nil)
  if valid_583646 != nil:
    section.add "profileId", valid_583646
  var valid_583647 = path.getOrDefault("id")
  valid_583647 = validateParameter(valid_583647, JInt, required = true, default = nil)
  if valid_583647 != nil:
    section.add "id", valid_583647
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_583648 = query.getOrDefault("fields")
  valid_583648 = validateParameter(valid_583648, JString, required = false,
                                 default = nil)
  if valid_583648 != nil:
    section.add "fields", valid_583648
  var valid_583649 = query.getOrDefault("quotaUser")
  valid_583649 = validateParameter(valid_583649, JString, required = false,
                                 default = nil)
  if valid_583649 != nil:
    section.add "quotaUser", valid_583649
  var valid_583650 = query.getOrDefault("alt")
  valid_583650 = validateParameter(valid_583650, JString, required = false,
                                 default = newJString("json"))
  if valid_583650 != nil:
    section.add "alt", valid_583650
  var valid_583651 = query.getOrDefault("oauth_token")
  valid_583651 = validateParameter(valid_583651, JString, required = false,
                                 default = nil)
  if valid_583651 != nil:
    section.add "oauth_token", valid_583651
  var valid_583652 = query.getOrDefault("userIp")
  valid_583652 = validateParameter(valid_583652, JString, required = false,
                                 default = nil)
  if valid_583652 != nil:
    section.add "userIp", valid_583652
  var valid_583653 = query.getOrDefault("key")
  valid_583653 = validateParameter(valid_583653, JString, required = false,
                                 default = nil)
  if valid_583653 != nil:
    section.add "key", valid_583653
  var valid_583654 = query.getOrDefault("prettyPrint")
  valid_583654 = validateParameter(valid_583654, JBool, required = false,
                                 default = newJBool(true))
  if valid_583654 != nil:
    section.add "prettyPrint", valid_583654
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_583655: Call_DfareportingVideoFormatsGet_583643; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one video format by ID.
  ## 
  let valid = call_583655.validator(path, query, header, formData, body)
  let scheme = call_583655.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_583655.url(scheme.get, call_583655.host, call_583655.base,
                         call_583655.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_583655, url, valid)

proc call*(call_583656: Call_DfareportingVideoFormatsGet_583643; profileId: string;
          id: int; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingVideoFormatsGet
  ## Gets one video format by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: int (required)
  ##     : Video format ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_583657 = newJObject()
  var query_583658 = newJObject()
  add(path_583657, "profileId", newJString(profileId))
  add(query_583658, "fields", newJString(fields))
  add(query_583658, "quotaUser", newJString(quotaUser))
  add(query_583658, "alt", newJString(alt))
  add(query_583658, "oauth_token", newJString(oauthToken))
  add(query_583658, "userIp", newJString(userIp))
  add(path_583657, "id", newJInt(id))
  add(query_583658, "key", newJString(key))
  add(query_583658, "prettyPrint", newJBool(prettyPrint))
  result = call_583656.call(path_583657, query_583658, nil, nil, nil)

var dfareportingVideoFormatsGet* = Call_DfareportingVideoFormatsGet_583643(
    name: "dfareportingVideoFormatsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/videoFormats/{id}",
    validator: validate_DfareportingVideoFormatsGet_583644,
    base: "/dfareporting/v2.7", url: url_DfareportingVideoFormatsGet_583645,
    schemes: {Scheme.Https})
export
  rest

type
  GoogleAuth = ref object
    endpoint*: Uri
    token: string
    expiry*: float64
    issued*: float64
    email: string
    key: string
    scope*: seq[string]
    form: string
    digest: Hash

const
  endpoint = "https://www.googleapis.com/oauth2/v4/token".parseUri
var auth = GoogleAuth(endpoint: endpoint)
proc hash(auth: GoogleAuth): Hash =
  ## yield differing values for effectively different auth payloads
  result = hash($auth.endpoint)
  result = result !& hash(auth.email)
  result = result !& hash(auth.key)
  result = result !& hash(auth.scope.join(" "))
  result = !$result

proc newAuthenticator*(path: string): GoogleAuth =
  let
    input = readFile(path)
    js = parseJson(input)
  auth.email = js["client_email"].getStr
  auth.key = js["private_key"].getStr
  result = auth

proc store(auth: var GoogleAuth; token: string; expiry: int; form: string) =
  auth.token = token
  auth.issued = epochTime()
  auth.expiry = auth.issued + expiry.float64
  auth.form = form
  auth.digest = auth.hash

proc authenticate*(fresh: float64 = -3600.0; lifetime: int = 3600): Future[bool] {.async.} =
  ## get or refresh an authentication token; provide `fresh`
  ## to ensure that the token won't expire in the next N seconds.
  ## provide `lifetime` to indicate how long the token should last.
  let clock = epochTime()
  if auth.expiry > clock + fresh:
    if auth.hash == auth.digest:
      return true
  let
    expiry = clock.int + lifetime
    header = JOSEHeader(alg: RS256, typ: "JWT")
    claims = %*{"iss": auth.email, "scope": auth.scope.join(" "),
              "aud": "https://www.googleapis.com/oauth2/v4/token", "exp": expiry,
              "iat": clock.int}
  var tok = JWT(header: header, claims: toClaims(claims))
  tok.sign(auth.key)
  let post = encodeQuery({"grant_type": "urn:ietf:params:oauth:grant-type:jwt-bearer",
                       "assertion": $tok}, usePlus = false, omitEq = false)
  var client = newAsyncHttpClient()
  client.headers = newHttpHeaders({"Content-Type": "application/x-www-form-urlencoded",
                                 "Content-Length": $post.len})
  let response = await client.request($auth.endpoint, HttpPost, body = post)
  if not response.code.is2xx:
    return false
  let body = await response.body
  client.close
  try:
    let js = parseJson(body)
    auth.store(js["access_token"].getStr, js["expires_in"].getInt,
               js["token_type"].getStr)
  except KeyError:
    return false
  except JsonParsingError:
    return false
  return true

proc composeQueryString(query: JsonNode): string =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs, usePlus = false, omitEq = false)

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  var headers = massageHeaders(input.getOrDefault("header"))
  let body = input.getOrDefault("body").getStr
  if auth.scope.len == 0:
    raise newException(ValueError, "specify authentication scopes")
  if not waitfor authenticate(fresh = 10.0):
    raise newException(IOError, "unable to refresh authentication token")
  headers.add ("Authorization", auth.form & " " & auth.token)
  headers.add ("Content-Type", "application/json")
  headers.add ("Content-Length", $body.len)
  result = newRecallable(call, url, headers, body = body)
