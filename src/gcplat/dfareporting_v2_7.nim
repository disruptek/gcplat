
import
  json, options, hashes, uri, rest, os, uri, strutils, times, httpcore, httpclient,
  asyncdispatch, jwt

## auto-generated via openapi macro
## title: DCM/DFA Reporting And Trafficking
## version: v2.7
## termsOfService: (not provided)
## license: (not provided)
## 
## Manages your DoubleClick Campaign Manager ad campaigns and reports.
## 
## https://developers.google.com/doubleclick-advertisers/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_588466 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_588466](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_588466): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    if js.kind notin {JString, JInt, JFloat, JNull, JBool}:
      return
    head = $js
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  gcpServiceName = "dfareporting"
proc composeQueryString(query: JsonNode): string
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_DfareportingFilesGet_588735 = ref object of OpenApiRestCall_588466
proc url_DfareportingFilesGet_588737(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "reportId" in path, "`reportId` is a required path parameter"
  assert "fileId" in path, "`fileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/files/"),
               (kind: VariableSegment, value: "fileId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFilesGet_588736(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a report file by its report ID and file ID. This method supports media download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   fileId: JString (required)
  ##         : The ID of the report file.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `fileId` field"
  var valid_588863 = path.getOrDefault("fileId")
  valid_588863 = validateParameter(valid_588863, JString, required = true,
                                 default = nil)
  if valid_588863 != nil:
    section.add "fileId", valid_588863
  var valid_588864 = path.getOrDefault("reportId")
  valid_588864 = validateParameter(valid_588864, JString, required = true,
                                 default = nil)
  if valid_588864 != nil:
    section.add "reportId", valid_588864
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_588865 = query.getOrDefault("fields")
  valid_588865 = validateParameter(valid_588865, JString, required = false,
                                 default = nil)
  if valid_588865 != nil:
    section.add "fields", valid_588865
  var valid_588866 = query.getOrDefault("quotaUser")
  valid_588866 = validateParameter(valid_588866, JString, required = false,
                                 default = nil)
  if valid_588866 != nil:
    section.add "quotaUser", valid_588866
  var valid_588880 = query.getOrDefault("alt")
  valid_588880 = validateParameter(valid_588880, JString, required = false,
                                 default = newJString("json"))
  if valid_588880 != nil:
    section.add "alt", valid_588880
  var valid_588881 = query.getOrDefault("oauth_token")
  valid_588881 = validateParameter(valid_588881, JString, required = false,
                                 default = nil)
  if valid_588881 != nil:
    section.add "oauth_token", valid_588881
  var valid_588882 = query.getOrDefault("userIp")
  valid_588882 = validateParameter(valid_588882, JString, required = false,
                                 default = nil)
  if valid_588882 != nil:
    section.add "userIp", valid_588882
  var valid_588883 = query.getOrDefault("key")
  valid_588883 = validateParameter(valid_588883, JString, required = false,
                                 default = nil)
  if valid_588883 != nil:
    section.add "key", valid_588883
  var valid_588884 = query.getOrDefault("prettyPrint")
  valid_588884 = validateParameter(valid_588884, JBool, required = false,
                                 default = newJBool(true))
  if valid_588884 != nil:
    section.add "prettyPrint", valid_588884
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_588907: Call_DfareportingFilesGet_588735; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a report file by its report ID and file ID. This method supports media download.
  ## 
  let valid = call_588907.validator(path, query, header, formData, body)
  let scheme = call_588907.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_588907.url(scheme.get, call_588907.host, call_588907.base,
                         call_588907.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_588907, url, valid)

proc call*(call_588978: Call_DfareportingFilesGet_588735; fileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFilesGet
  ## Retrieves a report file by its report ID and file ID. This method supports media download.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fileId: string (required)
  ##         : The ID of the report file.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_588979 = newJObject()
  var query_588981 = newJObject()
  add(query_588981, "fields", newJString(fields))
  add(query_588981, "quotaUser", newJString(quotaUser))
  add(path_588979, "fileId", newJString(fileId))
  add(query_588981, "alt", newJString(alt))
  add(query_588981, "oauth_token", newJString(oauthToken))
  add(query_588981, "userIp", newJString(userIp))
  add(query_588981, "key", newJString(key))
  add(path_588979, "reportId", newJString(reportId))
  add(query_588981, "prettyPrint", newJBool(prettyPrint))
  result = call_588978.call(path_588979, query_588981, nil, nil, nil)

var dfareportingFilesGet* = Call_DfareportingFilesGet_588735(
    name: "dfareportingFilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/reports/{reportId}/files/{fileId}",
    validator: validate_DfareportingFilesGet_588736, base: "/dfareporting/v2.7",
    url: url_DfareportingFilesGet_588737, schemes: {Scheme.Https})
type
  Call_DfareportingUserProfilesList_589020 = ref object of OpenApiRestCall_588466
proc url_DfareportingUserProfilesList_589022(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  result.path = base & route

proc validate_DfareportingUserProfilesList_589021(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves list of user profiles for a user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589023 = query.getOrDefault("fields")
  valid_589023 = validateParameter(valid_589023, JString, required = false,
                                 default = nil)
  if valid_589023 != nil:
    section.add "fields", valid_589023
  var valid_589024 = query.getOrDefault("quotaUser")
  valid_589024 = validateParameter(valid_589024, JString, required = false,
                                 default = nil)
  if valid_589024 != nil:
    section.add "quotaUser", valid_589024
  var valid_589025 = query.getOrDefault("alt")
  valid_589025 = validateParameter(valid_589025, JString, required = false,
                                 default = newJString("json"))
  if valid_589025 != nil:
    section.add "alt", valid_589025
  var valid_589026 = query.getOrDefault("oauth_token")
  valid_589026 = validateParameter(valid_589026, JString, required = false,
                                 default = nil)
  if valid_589026 != nil:
    section.add "oauth_token", valid_589026
  var valid_589027 = query.getOrDefault("userIp")
  valid_589027 = validateParameter(valid_589027, JString, required = false,
                                 default = nil)
  if valid_589027 != nil:
    section.add "userIp", valid_589027
  var valid_589028 = query.getOrDefault("key")
  valid_589028 = validateParameter(valid_589028, JString, required = false,
                                 default = nil)
  if valid_589028 != nil:
    section.add "key", valid_589028
  var valid_589029 = query.getOrDefault("prettyPrint")
  valid_589029 = validateParameter(valid_589029, JBool, required = false,
                                 default = newJBool(true))
  if valid_589029 != nil:
    section.add "prettyPrint", valid_589029
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589030: Call_DfareportingUserProfilesList_589020; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves list of user profiles for a user.
  ## 
  let valid = call_589030.validator(path, query, header, formData, body)
  let scheme = call_589030.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589030.url(scheme.get, call_589030.host, call_589030.base,
                         call_589030.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589030, url, valid)

proc call*(call_589031: Call_DfareportingUserProfilesList_589020;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingUserProfilesList
  ## Retrieves list of user profiles for a user.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var query_589032 = newJObject()
  add(query_589032, "fields", newJString(fields))
  add(query_589032, "quotaUser", newJString(quotaUser))
  add(query_589032, "alt", newJString(alt))
  add(query_589032, "oauth_token", newJString(oauthToken))
  add(query_589032, "userIp", newJString(userIp))
  add(query_589032, "key", newJString(key))
  add(query_589032, "prettyPrint", newJBool(prettyPrint))
  result = call_589031.call(nil, query_589032, nil, nil, nil)

var dfareportingUserProfilesList* = Call_DfareportingUserProfilesList_589020(
    name: "dfareportingUserProfilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles",
    validator: validate_DfareportingUserProfilesList_589021,
    base: "/dfareporting/v2.7", url: url_DfareportingUserProfilesList_589022,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserProfilesGet_589033 = ref object of OpenApiRestCall_588466
proc url_DfareportingUserProfilesGet_589035(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserProfilesGet_589034(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user profile by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589036 = path.getOrDefault("profileId")
  valid_589036 = validateParameter(valid_589036, JString, required = true,
                                 default = nil)
  if valid_589036 != nil:
    section.add "profileId", valid_589036
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589037 = query.getOrDefault("fields")
  valid_589037 = validateParameter(valid_589037, JString, required = false,
                                 default = nil)
  if valid_589037 != nil:
    section.add "fields", valid_589037
  var valid_589038 = query.getOrDefault("quotaUser")
  valid_589038 = validateParameter(valid_589038, JString, required = false,
                                 default = nil)
  if valid_589038 != nil:
    section.add "quotaUser", valid_589038
  var valid_589039 = query.getOrDefault("alt")
  valid_589039 = validateParameter(valid_589039, JString, required = false,
                                 default = newJString("json"))
  if valid_589039 != nil:
    section.add "alt", valid_589039
  var valid_589040 = query.getOrDefault("oauth_token")
  valid_589040 = validateParameter(valid_589040, JString, required = false,
                                 default = nil)
  if valid_589040 != nil:
    section.add "oauth_token", valid_589040
  var valid_589041 = query.getOrDefault("userIp")
  valid_589041 = validateParameter(valid_589041, JString, required = false,
                                 default = nil)
  if valid_589041 != nil:
    section.add "userIp", valid_589041
  var valid_589042 = query.getOrDefault("key")
  valid_589042 = validateParameter(valid_589042, JString, required = false,
                                 default = nil)
  if valid_589042 != nil:
    section.add "key", valid_589042
  var valid_589043 = query.getOrDefault("prettyPrint")
  valid_589043 = validateParameter(valid_589043, JBool, required = false,
                                 default = newJBool(true))
  if valid_589043 != nil:
    section.add "prettyPrint", valid_589043
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589044: Call_DfareportingUserProfilesGet_589033; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one user profile by ID.
  ## 
  let valid = call_589044.validator(path, query, header, formData, body)
  let scheme = call_589044.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589044.url(scheme.get, call_589044.host, call_589044.base,
                         call_589044.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589044, url, valid)

proc call*(call_589045: Call_DfareportingUserProfilesGet_589033; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingUserProfilesGet
  ## Gets one user profile by ID.
  ##   profileId: string (required)
  ##            : The user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589046 = newJObject()
  var query_589047 = newJObject()
  add(path_589046, "profileId", newJString(profileId))
  add(query_589047, "fields", newJString(fields))
  add(query_589047, "quotaUser", newJString(quotaUser))
  add(query_589047, "alt", newJString(alt))
  add(query_589047, "oauth_token", newJString(oauthToken))
  add(query_589047, "userIp", newJString(userIp))
  add(query_589047, "key", newJString(key))
  add(query_589047, "prettyPrint", newJBool(prettyPrint))
  result = call_589045.call(path_589046, query_589047, nil, nil, nil)

var dfareportingUserProfilesGet* = Call_DfareportingUserProfilesGet_589033(
    name: "dfareportingUserProfilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}",
    validator: validate_DfareportingUserProfilesGet_589034,
    base: "/dfareporting/v2.7", url: url_DfareportingUserProfilesGet_589035,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountActiveAdSummariesGet_589048 = ref object of OpenApiRestCall_588466
proc url_DfareportingAccountActiveAdSummariesGet_589050(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "summaryAccountId" in path,
        "`summaryAccountId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountActiveAdSummaries/"),
               (kind: VariableSegment, value: "summaryAccountId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountActiveAdSummariesGet_589049(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the account's active ad summary by account ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   summaryAccountId: JString (required)
  ##                   : Account ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589051 = path.getOrDefault("profileId")
  valid_589051 = validateParameter(valid_589051, JString, required = true,
                                 default = nil)
  if valid_589051 != nil:
    section.add "profileId", valid_589051
  var valid_589052 = path.getOrDefault("summaryAccountId")
  valid_589052 = validateParameter(valid_589052, JString, required = true,
                                 default = nil)
  if valid_589052 != nil:
    section.add "summaryAccountId", valid_589052
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589053 = query.getOrDefault("fields")
  valid_589053 = validateParameter(valid_589053, JString, required = false,
                                 default = nil)
  if valid_589053 != nil:
    section.add "fields", valid_589053
  var valid_589054 = query.getOrDefault("quotaUser")
  valid_589054 = validateParameter(valid_589054, JString, required = false,
                                 default = nil)
  if valid_589054 != nil:
    section.add "quotaUser", valid_589054
  var valid_589055 = query.getOrDefault("alt")
  valid_589055 = validateParameter(valid_589055, JString, required = false,
                                 default = newJString("json"))
  if valid_589055 != nil:
    section.add "alt", valid_589055
  var valid_589056 = query.getOrDefault("oauth_token")
  valid_589056 = validateParameter(valid_589056, JString, required = false,
                                 default = nil)
  if valid_589056 != nil:
    section.add "oauth_token", valid_589056
  var valid_589057 = query.getOrDefault("userIp")
  valid_589057 = validateParameter(valid_589057, JString, required = false,
                                 default = nil)
  if valid_589057 != nil:
    section.add "userIp", valid_589057
  var valid_589058 = query.getOrDefault("key")
  valid_589058 = validateParameter(valid_589058, JString, required = false,
                                 default = nil)
  if valid_589058 != nil:
    section.add "key", valid_589058
  var valid_589059 = query.getOrDefault("prettyPrint")
  valid_589059 = validateParameter(valid_589059, JBool, required = false,
                                 default = newJBool(true))
  if valid_589059 != nil:
    section.add "prettyPrint", valid_589059
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589060: Call_DfareportingAccountActiveAdSummariesGet_589048;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the account's active ad summary by account ID.
  ## 
  let valid = call_589060.validator(path, query, header, formData, body)
  let scheme = call_589060.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589060.url(scheme.get, call_589060.host, call_589060.base,
                         call_589060.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589060, url, valid)

proc call*(call_589061: Call_DfareportingAccountActiveAdSummariesGet_589048;
          profileId: string; summaryAccountId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountActiveAdSummariesGet
  ## Gets the account's active ad summary by account ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   summaryAccountId: string (required)
  ##                   : Account ID.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589062 = newJObject()
  var query_589063 = newJObject()
  add(path_589062, "profileId", newJString(profileId))
  add(query_589063, "fields", newJString(fields))
  add(query_589063, "quotaUser", newJString(quotaUser))
  add(query_589063, "alt", newJString(alt))
  add(query_589063, "oauth_token", newJString(oauthToken))
  add(query_589063, "userIp", newJString(userIp))
  add(query_589063, "key", newJString(key))
  add(path_589062, "summaryAccountId", newJString(summaryAccountId))
  add(query_589063, "prettyPrint", newJBool(prettyPrint))
  result = call_589061.call(path_589062, query_589063, nil, nil, nil)

var dfareportingAccountActiveAdSummariesGet* = Call_DfareportingAccountActiveAdSummariesGet_589048(
    name: "dfareportingAccountActiveAdSummariesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accountActiveAdSummaries/{summaryAccountId}",
    validator: validate_DfareportingAccountActiveAdSummariesGet_589049,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountActiveAdSummariesGet_589050,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionGroupsList_589064 = ref object of OpenApiRestCall_588466
proc url_DfareportingAccountPermissionGroupsList_589066(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissionGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionGroupsList_589065(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of account permission groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589067 = path.getOrDefault("profileId")
  valid_589067 = validateParameter(valid_589067, JString, required = true,
                                 default = nil)
  if valid_589067 != nil:
    section.add "profileId", valid_589067
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589068 = query.getOrDefault("fields")
  valid_589068 = validateParameter(valid_589068, JString, required = false,
                                 default = nil)
  if valid_589068 != nil:
    section.add "fields", valid_589068
  var valid_589069 = query.getOrDefault("quotaUser")
  valid_589069 = validateParameter(valid_589069, JString, required = false,
                                 default = nil)
  if valid_589069 != nil:
    section.add "quotaUser", valid_589069
  var valid_589070 = query.getOrDefault("alt")
  valid_589070 = validateParameter(valid_589070, JString, required = false,
                                 default = newJString("json"))
  if valid_589070 != nil:
    section.add "alt", valid_589070
  var valid_589071 = query.getOrDefault("oauth_token")
  valid_589071 = validateParameter(valid_589071, JString, required = false,
                                 default = nil)
  if valid_589071 != nil:
    section.add "oauth_token", valid_589071
  var valid_589072 = query.getOrDefault("userIp")
  valid_589072 = validateParameter(valid_589072, JString, required = false,
                                 default = nil)
  if valid_589072 != nil:
    section.add "userIp", valid_589072
  var valid_589073 = query.getOrDefault("key")
  valid_589073 = validateParameter(valid_589073, JString, required = false,
                                 default = nil)
  if valid_589073 != nil:
    section.add "key", valid_589073
  var valid_589074 = query.getOrDefault("prettyPrint")
  valid_589074 = validateParameter(valid_589074, JBool, required = false,
                                 default = newJBool(true))
  if valid_589074 != nil:
    section.add "prettyPrint", valid_589074
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589075: Call_DfareportingAccountPermissionGroupsList_589064;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves the list of account permission groups.
  ## 
  let valid = call_589075.validator(path, query, header, formData, body)
  let scheme = call_589075.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589075.url(scheme.get, call_589075.host, call_589075.base,
                         call_589075.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589075, url, valid)

proc call*(call_589076: Call_DfareportingAccountPermissionGroupsList_589064;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountPermissionGroupsList
  ## Retrieves the list of account permission groups.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589077 = newJObject()
  var query_589078 = newJObject()
  add(path_589077, "profileId", newJString(profileId))
  add(query_589078, "fields", newJString(fields))
  add(query_589078, "quotaUser", newJString(quotaUser))
  add(query_589078, "alt", newJString(alt))
  add(query_589078, "oauth_token", newJString(oauthToken))
  add(query_589078, "userIp", newJString(userIp))
  add(query_589078, "key", newJString(key))
  add(query_589078, "prettyPrint", newJBool(prettyPrint))
  result = call_589076.call(path_589077, query_589078, nil, nil, nil)

var dfareportingAccountPermissionGroupsList* = Call_DfareportingAccountPermissionGroupsList_589064(
    name: "dfareportingAccountPermissionGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissionGroups",
    validator: validate_DfareportingAccountPermissionGroupsList_589065,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionGroupsList_589066,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionGroupsGet_589079 = ref object of OpenApiRestCall_588466
proc url_DfareportingAccountPermissionGroupsGet_589081(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissionGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionGroupsGet_589080(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account permission group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Account permission group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589082 = path.getOrDefault("profileId")
  valid_589082 = validateParameter(valid_589082, JString, required = true,
                                 default = nil)
  if valid_589082 != nil:
    section.add "profileId", valid_589082
  var valid_589083 = path.getOrDefault("id")
  valid_589083 = validateParameter(valid_589083, JString, required = true,
                                 default = nil)
  if valid_589083 != nil:
    section.add "id", valid_589083
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589084 = query.getOrDefault("fields")
  valid_589084 = validateParameter(valid_589084, JString, required = false,
                                 default = nil)
  if valid_589084 != nil:
    section.add "fields", valid_589084
  var valid_589085 = query.getOrDefault("quotaUser")
  valid_589085 = validateParameter(valid_589085, JString, required = false,
                                 default = nil)
  if valid_589085 != nil:
    section.add "quotaUser", valid_589085
  var valid_589086 = query.getOrDefault("alt")
  valid_589086 = validateParameter(valid_589086, JString, required = false,
                                 default = newJString("json"))
  if valid_589086 != nil:
    section.add "alt", valid_589086
  var valid_589087 = query.getOrDefault("oauth_token")
  valid_589087 = validateParameter(valid_589087, JString, required = false,
                                 default = nil)
  if valid_589087 != nil:
    section.add "oauth_token", valid_589087
  var valid_589088 = query.getOrDefault("userIp")
  valid_589088 = validateParameter(valid_589088, JString, required = false,
                                 default = nil)
  if valid_589088 != nil:
    section.add "userIp", valid_589088
  var valid_589089 = query.getOrDefault("key")
  valid_589089 = validateParameter(valid_589089, JString, required = false,
                                 default = nil)
  if valid_589089 != nil:
    section.add "key", valid_589089
  var valid_589090 = query.getOrDefault("prettyPrint")
  valid_589090 = validateParameter(valid_589090, JBool, required = false,
                                 default = newJBool(true))
  if valid_589090 != nil:
    section.add "prettyPrint", valid_589090
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589091: Call_DfareportingAccountPermissionGroupsGet_589079;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one account permission group by ID.
  ## 
  let valid = call_589091.validator(path, query, header, formData, body)
  let scheme = call_589091.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589091.url(scheme.get, call_589091.host, call_589091.base,
                         call_589091.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589091, url, valid)

proc call*(call_589092: Call_DfareportingAccountPermissionGroupsGet_589079;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountPermissionGroupsGet
  ## Gets one account permission group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Account permission group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589093 = newJObject()
  var query_589094 = newJObject()
  add(path_589093, "profileId", newJString(profileId))
  add(query_589094, "fields", newJString(fields))
  add(query_589094, "quotaUser", newJString(quotaUser))
  add(query_589094, "alt", newJString(alt))
  add(query_589094, "oauth_token", newJString(oauthToken))
  add(query_589094, "userIp", newJString(userIp))
  add(path_589093, "id", newJString(id))
  add(query_589094, "key", newJString(key))
  add(query_589094, "prettyPrint", newJBool(prettyPrint))
  result = call_589092.call(path_589093, query_589094, nil, nil, nil)

var dfareportingAccountPermissionGroupsGet* = Call_DfareportingAccountPermissionGroupsGet_589079(
    name: "dfareportingAccountPermissionGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissionGroups/{id}",
    validator: validate_DfareportingAccountPermissionGroupsGet_589080,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionGroupsGet_589081,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionsList_589095 = ref object of OpenApiRestCall_588466
proc url_DfareportingAccountPermissionsList_589097(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionsList_589096(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of account permissions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589098 = path.getOrDefault("profileId")
  valid_589098 = validateParameter(valid_589098, JString, required = true,
                                 default = nil)
  if valid_589098 != nil:
    section.add "profileId", valid_589098
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589099 = query.getOrDefault("fields")
  valid_589099 = validateParameter(valid_589099, JString, required = false,
                                 default = nil)
  if valid_589099 != nil:
    section.add "fields", valid_589099
  var valid_589100 = query.getOrDefault("quotaUser")
  valid_589100 = validateParameter(valid_589100, JString, required = false,
                                 default = nil)
  if valid_589100 != nil:
    section.add "quotaUser", valid_589100
  var valid_589101 = query.getOrDefault("alt")
  valid_589101 = validateParameter(valid_589101, JString, required = false,
                                 default = newJString("json"))
  if valid_589101 != nil:
    section.add "alt", valid_589101
  var valid_589102 = query.getOrDefault("oauth_token")
  valid_589102 = validateParameter(valid_589102, JString, required = false,
                                 default = nil)
  if valid_589102 != nil:
    section.add "oauth_token", valid_589102
  var valid_589103 = query.getOrDefault("userIp")
  valid_589103 = validateParameter(valid_589103, JString, required = false,
                                 default = nil)
  if valid_589103 != nil:
    section.add "userIp", valid_589103
  var valid_589104 = query.getOrDefault("key")
  valid_589104 = validateParameter(valid_589104, JString, required = false,
                                 default = nil)
  if valid_589104 != nil:
    section.add "key", valid_589104
  var valid_589105 = query.getOrDefault("prettyPrint")
  valid_589105 = validateParameter(valid_589105, JBool, required = false,
                                 default = newJBool(true))
  if valid_589105 != nil:
    section.add "prettyPrint", valid_589105
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589106: Call_DfareportingAccountPermissionsList_589095;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves the list of account permissions.
  ## 
  let valid = call_589106.validator(path, query, header, formData, body)
  let scheme = call_589106.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589106.url(scheme.get, call_589106.host, call_589106.base,
                         call_589106.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589106, url, valid)

proc call*(call_589107: Call_DfareportingAccountPermissionsList_589095;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountPermissionsList
  ## Retrieves the list of account permissions.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589108 = newJObject()
  var query_589109 = newJObject()
  add(path_589108, "profileId", newJString(profileId))
  add(query_589109, "fields", newJString(fields))
  add(query_589109, "quotaUser", newJString(quotaUser))
  add(query_589109, "alt", newJString(alt))
  add(query_589109, "oauth_token", newJString(oauthToken))
  add(query_589109, "userIp", newJString(userIp))
  add(query_589109, "key", newJString(key))
  add(query_589109, "prettyPrint", newJBool(prettyPrint))
  result = call_589107.call(path_589108, query_589109, nil, nil, nil)

var dfareportingAccountPermissionsList* = Call_DfareportingAccountPermissionsList_589095(
    name: "dfareportingAccountPermissionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissions",
    validator: validate_DfareportingAccountPermissionsList_589096,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionsList_589097,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionsGet_589110 = ref object of OpenApiRestCall_588466
proc url_DfareportingAccountPermissionsGet_589112(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissions/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionsGet_589111(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account permission by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Account permission ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589113 = path.getOrDefault("profileId")
  valid_589113 = validateParameter(valid_589113, JString, required = true,
                                 default = nil)
  if valid_589113 != nil:
    section.add "profileId", valid_589113
  var valid_589114 = path.getOrDefault("id")
  valid_589114 = validateParameter(valid_589114, JString, required = true,
                                 default = nil)
  if valid_589114 != nil:
    section.add "id", valid_589114
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589115 = query.getOrDefault("fields")
  valid_589115 = validateParameter(valid_589115, JString, required = false,
                                 default = nil)
  if valid_589115 != nil:
    section.add "fields", valid_589115
  var valid_589116 = query.getOrDefault("quotaUser")
  valid_589116 = validateParameter(valid_589116, JString, required = false,
                                 default = nil)
  if valid_589116 != nil:
    section.add "quotaUser", valid_589116
  var valid_589117 = query.getOrDefault("alt")
  valid_589117 = validateParameter(valid_589117, JString, required = false,
                                 default = newJString("json"))
  if valid_589117 != nil:
    section.add "alt", valid_589117
  var valid_589118 = query.getOrDefault("oauth_token")
  valid_589118 = validateParameter(valid_589118, JString, required = false,
                                 default = nil)
  if valid_589118 != nil:
    section.add "oauth_token", valid_589118
  var valid_589119 = query.getOrDefault("userIp")
  valid_589119 = validateParameter(valid_589119, JString, required = false,
                                 default = nil)
  if valid_589119 != nil:
    section.add "userIp", valid_589119
  var valid_589120 = query.getOrDefault("key")
  valid_589120 = validateParameter(valid_589120, JString, required = false,
                                 default = nil)
  if valid_589120 != nil:
    section.add "key", valid_589120
  var valid_589121 = query.getOrDefault("prettyPrint")
  valid_589121 = validateParameter(valid_589121, JBool, required = false,
                                 default = newJBool(true))
  if valid_589121 != nil:
    section.add "prettyPrint", valid_589121
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589122: Call_DfareportingAccountPermissionsGet_589110;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one account permission by ID.
  ## 
  let valid = call_589122.validator(path, query, header, formData, body)
  let scheme = call_589122.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589122.url(scheme.get, call_589122.host, call_589122.base,
                         call_589122.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589122, url, valid)

proc call*(call_589123: Call_DfareportingAccountPermissionsGet_589110;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountPermissionsGet
  ## Gets one account permission by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Account permission ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589124 = newJObject()
  var query_589125 = newJObject()
  add(path_589124, "profileId", newJString(profileId))
  add(query_589125, "fields", newJString(fields))
  add(query_589125, "quotaUser", newJString(quotaUser))
  add(query_589125, "alt", newJString(alt))
  add(query_589125, "oauth_token", newJString(oauthToken))
  add(query_589125, "userIp", newJString(userIp))
  add(path_589124, "id", newJString(id))
  add(query_589125, "key", newJString(key))
  add(query_589125, "prettyPrint", newJBool(prettyPrint))
  result = call_589123.call(path_589124, query_589125, nil, nil, nil)

var dfareportingAccountPermissionsGet* = Call_DfareportingAccountPermissionsGet_589110(
    name: "dfareportingAccountPermissionsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissions/{id}",
    validator: validate_DfareportingAccountPermissionsGet_589111,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionsGet_589112,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesUpdate_589151 = ref object of OpenApiRestCall_588466
proc url_DfareportingAccountUserProfilesUpdate_589153(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesUpdate_589152(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account user profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589154 = path.getOrDefault("profileId")
  valid_589154 = validateParameter(valid_589154, JString, required = true,
                                 default = nil)
  if valid_589154 != nil:
    section.add "profileId", valid_589154
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589155 = query.getOrDefault("fields")
  valid_589155 = validateParameter(valid_589155, JString, required = false,
                                 default = nil)
  if valid_589155 != nil:
    section.add "fields", valid_589155
  var valid_589156 = query.getOrDefault("quotaUser")
  valid_589156 = validateParameter(valid_589156, JString, required = false,
                                 default = nil)
  if valid_589156 != nil:
    section.add "quotaUser", valid_589156
  var valid_589157 = query.getOrDefault("alt")
  valid_589157 = validateParameter(valid_589157, JString, required = false,
                                 default = newJString("json"))
  if valid_589157 != nil:
    section.add "alt", valid_589157
  var valid_589158 = query.getOrDefault("oauth_token")
  valid_589158 = validateParameter(valid_589158, JString, required = false,
                                 default = nil)
  if valid_589158 != nil:
    section.add "oauth_token", valid_589158
  var valid_589159 = query.getOrDefault("userIp")
  valid_589159 = validateParameter(valid_589159, JString, required = false,
                                 default = nil)
  if valid_589159 != nil:
    section.add "userIp", valid_589159
  var valid_589160 = query.getOrDefault("key")
  valid_589160 = validateParameter(valid_589160, JString, required = false,
                                 default = nil)
  if valid_589160 != nil:
    section.add "key", valid_589160
  var valid_589161 = query.getOrDefault("prettyPrint")
  valid_589161 = validateParameter(valid_589161, JBool, required = false,
                                 default = newJBool(true))
  if valid_589161 != nil:
    section.add "prettyPrint", valid_589161
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589163: Call_DfareportingAccountUserProfilesUpdate_589151;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing account user profile.
  ## 
  let valid = call_589163.validator(path, query, header, formData, body)
  let scheme = call_589163.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589163.url(scheme.get, call_589163.host, call_589163.base,
                         call_589163.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589163, url, valid)

proc call*(call_589164: Call_DfareportingAccountUserProfilesUpdate_589151;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountUserProfilesUpdate
  ## Updates an existing account user profile.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589165 = newJObject()
  var query_589166 = newJObject()
  var body_589167 = newJObject()
  add(path_589165, "profileId", newJString(profileId))
  add(query_589166, "fields", newJString(fields))
  add(query_589166, "quotaUser", newJString(quotaUser))
  add(query_589166, "alt", newJString(alt))
  add(query_589166, "oauth_token", newJString(oauthToken))
  add(query_589166, "userIp", newJString(userIp))
  add(query_589166, "key", newJString(key))
  if body != nil:
    body_589167 = body
  add(query_589166, "prettyPrint", newJBool(prettyPrint))
  result = call_589164.call(path_589165, query_589166, nil, nil, body_589167)

var dfareportingAccountUserProfilesUpdate* = Call_DfareportingAccountUserProfilesUpdate_589151(
    name: "dfareportingAccountUserProfilesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesUpdate_589152,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesUpdate_589153,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesInsert_589168 = ref object of OpenApiRestCall_588466
proc url_DfareportingAccountUserProfilesInsert_589170(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesInsert_589169(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new account user profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589171 = path.getOrDefault("profileId")
  valid_589171 = validateParameter(valid_589171, JString, required = true,
                                 default = nil)
  if valid_589171 != nil:
    section.add "profileId", valid_589171
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589172 = query.getOrDefault("fields")
  valid_589172 = validateParameter(valid_589172, JString, required = false,
                                 default = nil)
  if valid_589172 != nil:
    section.add "fields", valid_589172
  var valid_589173 = query.getOrDefault("quotaUser")
  valid_589173 = validateParameter(valid_589173, JString, required = false,
                                 default = nil)
  if valid_589173 != nil:
    section.add "quotaUser", valid_589173
  var valid_589174 = query.getOrDefault("alt")
  valid_589174 = validateParameter(valid_589174, JString, required = false,
                                 default = newJString("json"))
  if valid_589174 != nil:
    section.add "alt", valid_589174
  var valid_589175 = query.getOrDefault("oauth_token")
  valid_589175 = validateParameter(valid_589175, JString, required = false,
                                 default = nil)
  if valid_589175 != nil:
    section.add "oauth_token", valid_589175
  var valid_589176 = query.getOrDefault("userIp")
  valid_589176 = validateParameter(valid_589176, JString, required = false,
                                 default = nil)
  if valid_589176 != nil:
    section.add "userIp", valid_589176
  var valid_589177 = query.getOrDefault("key")
  valid_589177 = validateParameter(valid_589177, JString, required = false,
                                 default = nil)
  if valid_589177 != nil:
    section.add "key", valid_589177
  var valid_589178 = query.getOrDefault("prettyPrint")
  valid_589178 = validateParameter(valid_589178, JBool, required = false,
                                 default = newJBool(true))
  if valid_589178 != nil:
    section.add "prettyPrint", valid_589178
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589180: Call_DfareportingAccountUserProfilesInsert_589168;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new account user profile.
  ## 
  let valid = call_589180.validator(path, query, header, formData, body)
  let scheme = call_589180.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589180.url(scheme.get, call_589180.host, call_589180.base,
                         call_589180.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589180, url, valid)

proc call*(call_589181: Call_DfareportingAccountUserProfilesInsert_589168;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountUserProfilesInsert
  ## Inserts a new account user profile.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589182 = newJObject()
  var query_589183 = newJObject()
  var body_589184 = newJObject()
  add(path_589182, "profileId", newJString(profileId))
  add(query_589183, "fields", newJString(fields))
  add(query_589183, "quotaUser", newJString(quotaUser))
  add(query_589183, "alt", newJString(alt))
  add(query_589183, "oauth_token", newJString(oauthToken))
  add(query_589183, "userIp", newJString(userIp))
  add(query_589183, "key", newJString(key))
  if body != nil:
    body_589184 = body
  add(query_589183, "prettyPrint", newJBool(prettyPrint))
  result = call_589181.call(path_589182, query_589183, nil, nil, body_589184)

var dfareportingAccountUserProfilesInsert* = Call_DfareportingAccountUserProfilesInsert_589168(
    name: "dfareportingAccountUserProfilesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesInsert_589169,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesInsert_589170,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesList_589126 = ref object of OpenApiRestCall_588466
proc url_DfareportingAccountUserProfilesList_589128(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesList_589127(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of account user profiles, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589129 = path.getOrDefault("profileId")
  valid_589129 = validateParameter(valid_589129, JString, required = true,
                                 default = nil)
  if valid_589129 != nil:
    section.add "profileId", valid_589129
  result.add "path", section
  ## parameters in `query` object:
  ##   subaccountId: JString
  ##               : Select only user profiles with the specified subaccount ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "user profile*2015" will return objects with names like "user profile June 2015", "user profile April 2015", or simply "user profile 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "user profile" will match objects with name "my user profile", "user profile 2015", or simply "user profile".
  ##   active: JBool
  ##         : Select only active user profiles.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only user profiles with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   userRoleId: JString
  ##             : Select only user profiles with the specified user role ID.
  section = newJObject()
  var valid_589130 = query.getOrDefault("subaccountId")
  valid_589130 = validateParameter(valid_589130, JString, required = false,
                                 default = nil)
  if valid_589130 != nil:
    section.add "subaccountId", valid_589130
  var valid_589131 = query.getOrDefault("fields")
  valid_589131 = validateParameter(valid_589131, JString, required = false,
                                 default = nil)
  if valid_589131 != nil:
    section.add "fields", valid_589131
  var valid_589132 = query.getOrDefault("pageToken")
  valid_589132 = validateParameter(valid_589132, JString, required = false,
                                 default = nil)
  if valid_589132 != nil:
    section.add "pageToken", valid_589132
  var valid_589133 = query.getOrDefault("quotaUser")
  valid_589133 = validateParameter(valid_589133, JString, required = false,
                                 default = nil)
  if valid_589133 != nil:
    section.add "quotaUser", valid_589133
  var valid_589134 = query.getOrDefault("sortField")
  valid_589134 = validateParameter(valid_589134, JString, required = false,
                                 default = newJString("ID"))
  if valid_589134 != nil:
    section.add "sortField", valid_589134
  var valid_589135 = query.getOrDefault("alt")
  valid_589135 = validateParameter(valid_589135, JString, required = false,
                                 default = newJString("json"))
  if valid_589135 != nil:
    section.add "alt", valid_589135
  var valid_589136 = query.getOrDefault("searchString")
  valid_589136 = validateParameter(valid_589136, JString, required = false,
                                 default = nil)
  if valid_589136 != nil:
    section.add "searchString", valid_589136
  var valid_589137 = query.getOrDefault("active")
  valid_589137 = validateParameter(valid_589137, JBool, required = false, default = nil)
  if valid_589137 != nil:
    section.add "active", valid_589137
  var valid_589138 = query.getOrDefault("oauth_token")
  valid_589138 = validateParameter(valid_589138, JString, required = false,
                                 default = nil)
  if valid_589138 != nil:
    section.add "oauth_token", valid_589138
  var valid_589139 = query.getOrDefault("userIp")
  valid_589139 = validateParameter(valid_589139, JString, required = false,
                                 default = nil)
  if valid_589139 != nil:
    section.add "userIp", valid_589139
  var valid_589141 = query.getOrDefault("maxResults")
  valid_589141 = validateParameter(valid_589141, JInt, required = false,
                                 default = newJInt(1000))
  if valid_589141 != nil:
    section.add "maxResults", valid_589141
  var valid_589142 = query.getOrDefault("ids")
  valid_589142 = validateParameter(valid_589142, JArray, required = false,
                                 default = nil)
  if valid_589142 != nil:
    section.add "ids", valid_589142
  var valid_589143 = query.getOrDefault("key")
  valid_589143 = validateParameter(valid_589143, JString, required = false,
                                 default = nil)
  if valid_589143 != nil:
    section.add "key", valid_589143
  var valid_589144 = query.getOrDefault("sortOrder")
  valid_589144 = validateParameter(valid_589144, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_589144 != nil:
    section.add "sortOrder", valid_589144
  var valid_589145 = query.getOrDefault("prettyPrint")
  valid_589145 = validateParameter(valid_589145, JBool, required = false,
                                 default = newJBool(true))
  if valid_589145 != nil:
    section.add "prettyPrint", valid_589145
  var valid_589146 = query.getOrDefault("userRoleId")
  valid_589146 = validateParameter(valid_589146, JString, required = false,
                                 default = nil)
  if valid_589146 != nil:
    section.add "userRoleId", valid_589146
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589147: Call_DfareportingAccountUserProfilesList_589126;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of account user profiles, possibly filtered. This method supports paging.
  ## 
  let valid = call_589147.validator(path, query, header, formData, body)
  let scheme = call_589147.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589147.url(scheme.get, call_589147.host, call_589147.base,
                         call_589147.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589147, url, valid)

proc call*(call_589148: Call_DfareportingAccountUserProfilesList_589126;
          profileId: string; subaccountId: string = ""; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; searchString: string = ""; active: bool = false;
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true; userRoleId: string = ""): Recallable =
  ## dfareportingAccountUserProfilesList
  ## Retrieves a list of account user profiles, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only user profiles with the specified subaccount ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "user profile*2015" will return objects with names like "user profile June 2015", "user profile April 2015", or simply "user profile 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "user profile" will match objects with name "my user profile", "user profile 2015", or simply "user profile".
  ##   active: bool
  ##         : Select only active user profiles.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only user profiles with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userRoleId: string
  ##             : Select only user profiles with the specified user role ID.
  var path_589149 = newJObject()
  var query_589150 = newJObject()
  add(path_589149, "profileId", newJString(profileId))
  add(query_589150, "subaccountId", newJString(subaccountId))
  add(query_589150, "fields", newJString(fields))
  add(query_589150, "pageToken", newJString(pageToken))
  add(query_589150, "quotaUser", newJString(quotaUser))
  add(query_589150, "sortField", newJString(sortField))
  add(query_589150, "alt", newJString(alt))
  add(query_589150, "searchString", newJString(searchString))
  add(query_589150, "active", newJBool(active))
  add(query_589150, "oauth_token", newJString(oauthToken))
  add(query_589150, "userIp", newJString(userIp))
  add(query_589150, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_589150.add "ids", ids
  add(query_589150, "key", newJString(key))
  add(query_589150, "sortOrder", newJString(sortOrder))
  add(query_589150, "prettyPrint", newJBool(prettyPrint))
  add(query_589150, "userRoleId", newJString(userRoleId))
  result = call_589148.call(path_589149, query_589150, nil, nil, nil)

var dfareportingAccountUserProfilesList* = Call_DfareportingAccountUserProfilesList_589126(
    name: "dfareportingAccountUserProfilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesList_589127,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesList_589128,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesPatch_589185 = ref object of OpenApiRestCall_588466
proc url_DfareportingAccountUserProfilesPatch_589187(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesPatch_589186(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account user profile. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589188 = path.getOrDefault("profileId")
  valid_589188 = validateParameter(valid_589188, JString, required = true,
                                 default = nil)
  if valid_589188 != nil:
    section.add "profileId", valid_589188
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : User profile ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589189 = query.getOrDefault("fields")
  valid_589189 = validateParameter(valid_589189, JString, required = false,
                                 default = nil)
  if valid_589189 != nil:
    section.add "fields", valid_589189
  var valid_589190 = query.getOrDefault("quotaUser")
  valid_589190 = validateParameter(valid_589190, JString, required = false,
                                 default = nil)
  if valid_589190 != nil:
    section.add "quotaUser", valid_589190
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_589191 = query.getOrDefault("id")
  valid_589191 = validateParameter(valid_589191, JString, required = true,
                                 default = nil)
  if valid_589191 != nil:
    section.add "id", valid_589191
  var valid_589192 = query.getOrDefault("alt")
  valid_589192 = validateParameter(valid_589192, JString, required = false,
                                 default = newJString("json"))
  if valid_589192 != nil:
    section.add "alt", valid_589192
  var valid_589193 = query.getOrDefault("oauth_token")
  valid_589193 = validateParameter(valid_589193, JString, required = false,
                                 default = nil)
  if valid_589193 != nil:
    section.add "oauth_token", valid_589193
  var valid_589194 = query.getOrDefault("userIp")
  valid_589194 = validateParameter(valid_589194, JString, required = false,
                                 default = nil)
  if valid_589194 != nil:
    section.add "userIp", valid_589194
  var valid_589195 = query.getOrDefault("key")
  valid_589195 = validateParameter(valid_589195, JString, required = false,
                                 default = nil)
  if valid_589195 != nil:
    section.add "key", valid_589195
  var valid_589196 = query.getOrDefault("prettyPrint")
  valid_589196 = validateParameter(valid_589196, JBool, required = false,
                                 default = newJBool(true))
  if valid_589196 != nil:
    section.add "prettyPrint", valid_589196
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589198: Call_DfareportingAccountUserProfilesPatch_589185;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing account user profile. This method supports patch semantics.
  ## 
  let valid = call_589198.validator(path, query, header, formData, body)
  let scheme = call_589198.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589198.url(scheme.get, call_589198.host, call_589198.base,
                         call_589198.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589198, url, valid)

proc call*(call_589199: Call_DfareportingAccountUserProfilesPatch_589185;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountUserProfilesPatch
  ## Updates an existing account user profile. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : User profile ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589200 = newJObject()
  var query_589201 = newJObject()
  var body_589202 = newJObject()
  add(path_589200, "profileId", newJString(profileId))
  add(query_589201, "fields", newJString(fields))
  add(query_589201, "quotaUser", newJString(quotaUser))
  add(query_589201, "id", newJString(id))
  add(query_589201, "alt", newJString(alt))
  add(query_589201, "oauth_token", newJString(oauthToken))
  add(query_589201, "userIp", newJString(userIp))
  add(query_589201, "key", newJString(key))
  if body != nil:
    body_589202 = body
  add(query_589201, "prettyPrint", newJBool(prettyPrint))
  result = call_589199.call(path_589200, query_589201, nil, nil, body_589202)

var dfareportingAccountUserProfilesPatch* = Call_DfareportingAccountUserProfilesPatch_589185(
    name: "dfareportingAccountUserProfilesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesPatch_589186,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesPatch_589187,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesGet_589203 = ref object of OpenApiRestCall_588466
proc url_DfareportingAccountUserProfilesGet_589205(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesGet_589204(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account user profile by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589206 = path.getOrDefault("profileId")
  valid_589206 = validateParameter(valid_589206, JString, required = true,
                                 default = nil)
  if valid_589206 != nil:
    section.add "profileId", valid_589206
  var valid_589207 = path.getOrDefault("id")
  valid_589207 = validateParameter(valid_589207, JString, required = true,
                                 default = nil)
  if valid_589207 != nil:
    section.add "id", valid_589207
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589208 = query.getOrDefault("fields")
  valid_589208 = validateParameter(valid_589208, JString, required = false,
                                 default = nil)
  if valid_589208 != nil:
    section.add "fields", valid_589208
  var valid_589209 = query.getOrDefault("quotaUser")
  valid_589209 = validateParameter(valid_589209, JString, required = false,
                                 default = nil)
  if valid_589209 != nil:
    section.add "quotaUser", valid_589209
  var valid_589210 = query.getOrDefault("alt")
  valid_589210 = validateParameter(valid_589210, JString, required = false,
                                 default = newJString("json"))
  if valid_589210 != nil:
    section.add "alt", valid_589210
  var valid_589211 = query.getOrDefault("oauth_token")
  valid_589211 = validateParameter(valid_589211, JString, required = false,
                                 default = nil)
  if valid_589211 != nil:
    section.add "oauth_token", valid_589211
  var valid_589212 = query.getOrDefault("userIp")
  valid_589212 = validateParameter(valid_589212, JString, required = false,
                                 default = nil)
  if valid_589212 != nil:
    section.add "userIp", valid_589212
  var valid_589213 = query.getOrDefault("key")
  valid_589213 = validateParameter(valid_589213, JString, required = false,
                                 default = nil)
  if valid_589213 != nil:
    section.add "key", valid_589213
  var valid_589214 = query.getOrDefault("prettyPrint")
  valid_589214 = validateParameter(valid_589214, JBool, required = false,
                                 default = newJBool(true))
  if valid_589214 != nil:
    section.add "prettyPrint", valid_589214
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589215: Call_DfareportingAccountUserProfilesGet_589203;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one account user profile by ID.
  ## 
  let valid = call_589215.validator(path, query, header, formData, body)
  let scheme = call_589215.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589215.url(scheme.get, call_589215.host, call_589215.base,
                         call_589215.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589215, url, valid)

proc call*(call_589216: Call_DfareportingAccountUserProfilesGet_589203;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountUserProfilesGet
  ## Gets one account user profile by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User profile ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589217 = newJObject()
  var query_589218 = newJObject()
  add(path_589217, "profileId", newJString(profileId))
  add(query_589218, "fields", newJString(fields))
  add(query_589218, "quotaUser", newJString(quotaUser))
  add(query_589218, "alt", newJString(alt))
  add(query_589218, "oauth_token", newJString(oauthToken))
  add(query_589218, "userIp", newJString(userIp))
  add(path_589217, "id", newJString(id))
  add(query_589218, "key", newJString(key))
  add(query_589218, "prettyPrint", newJBool(prettyPrint))
  result = call_589216.call(path_589217, query_589218, nil, nil, nil)

var dfareportingAccountUserProfilesGet* = Call_DfareportingAccountUserProfilesGet_589203(
    name: "dfareportingAccountUserProfilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles/{id}",
    validator: validate_DfareportingAccountUserProfilesGet_589204,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesGet_589205,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsUpdate_589241 = ref object of OpenApiRestCall_588466
proc url_DfareportingAccountsUpdate_589243(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsUpdate_589242(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589244 = path.getOrDefault("profileId")
  valid_589244 = validateParameter(valid_589244, JString, required = true,
                                 default = nil)
  if valid_589244 != nil:
    section.add "profileId", valid_589244
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589245 = query.getOrDefault("fields")
  valid_589245 = validateParameter(valid_589245, JString, required = false,
                                 default = nil)
  if valid_589245 != nil:
    section.add "fields", valid_589245
  var valid_589246 = query.getOrDefault("quotaUser")
  valid_589246 = validateParameter(valid_589246, JString, required = false,
                                 default = nil)
  if valid_589246 != nil:
    section.add "quotaUser", valid_589246
  var valid_589247 = query.getOrDefault("alt")
  valid_589247 = validateParameter(valid_589247, JString, required = false,
                                 default = newJString("json"))
  if valid_589247 != nil:
    section.add "alt", valid_589247
  var valid_589248 = query.getOrDefault("oauth_token")
  valid_589248 = validateParameter(valid_589248, JString, required = false,
                                 default = nil)
  if valid_589248 != nil:
    section.add "oauth_token", valid_589248
  var valid_589249 = query.getOrDefault("userIp")
  valid_589249 = validateParameter(valid_589249, JString, required = false,
                                 default = nil)
  if valid_589249 != nil:
    section.add "userIp", valid_589249
  var valid_589250 = query.getOrDefault("key")
  valid_589250 = validateParameter(valid_589250, JString, required = false,
                                 default = nil)
  if valid_589250 != nil:
    section.add "key", valid_589250
  var valid_589251 = query.getOrDefault("prettyPrint")
  valid_589251 = validateParameter(valid_589251, JBool, required = false,
                                 default = newJBool(true))
  if valid_589251 != nil:
    section.add "prettyPrint", valid_589251
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589253: Call_DfareportingAccountsUpdate_589241; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing account.
  ## 
  let valid = call_589253.validator(path, query, header, formData, body)
  let scheme = call_589253.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589253.url(scheme.get, call_589253.host, call_589253.base,
                         call_589253.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589253, url, valid)

proc call*(call_589254: Call_DfareportingAccountsUpdate_589241; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountsUpdate
  ## Updates an existing account.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589255 = newJObject()
  var query_589256 = newJObject()
  var body_589257 = newJObject()
  add(path_589255, "profileId", newJString(profileId))
  add(query_589256, "fields", newJString(fields))
  add(query_589256, "quotaUser", newJString(quotaUser))
  add(query_589256, "alt", newJString(alt))
  add(query_589256, "oauth_token", newJString(oauthToken))
  add(query_589256, "userIp", newJString(userIp))
  add(query_589256, "key", newJString(key))
  if body != nil:
    body_589257 = body
  add(query_589256, "prettyPrint", newJBool(prettyPrint))
  result = call_589254.call(path_589255, query_589256, nil, nil, body_589257)

var dfareportingAccountsUpdate* = Call_DfareportingAccountsUpdate_589241(
    name: "dfareportingAccountsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts",
    validator: validate_DfareportingAccountsUpdate_589242,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsUpdate_589243,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsList_589219 = ref object of OpenApiRestCall_588466
proc url_DfareportingAccountsList_589221(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsList_589220(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of accounts, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589222 = path.getOrDefault("profileId")
  valid_589222 = validateParameter(valid_589222, JString, required = true,
                                 default = nil)
  if valid_589222 != nil:
    section.add "profileId", valid_589222
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "account*2015" will return objects with names like "account June 2015", "account April 2015", or simply "account 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "account" will match objects with name "my account", "account 2015", or simply "account".
  ##   active: JBool
  ##         : Select only active accounts. Don't set this field to select both active and non-active accounts.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only accounts with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589223 = query.getOrDefault("fields")
  valid_589223 = validateParameter(valid_589223, JString, required = false,
                                 default = nil)
  if valid_589223 != nil:
    section.add "fields", valid_589223
  var valid_589224 = query.getOrDefault("pageToken")
  valid_589224 = validateParameter(valid_589224, JString, required = false,
                                 default = nil)
  if valid_589224 != nil:
    section.add "pageToken", valid_589224
  var valid_589225 = query.getOrDefault("quotaUser")
  valid_589225 = validateParameter(valid_589225, JString, required = false,
                                 default = nil)
  if valid_589225 != nil:
    section.add "quotaUser", valid_589225
  var valid_589226 = query.getOrDefault("sortField")
  valid_589226 = validateParameter(valid_589226, JString, required = false,
                                 default = newJString("ID"))
  if valid_589226 != nil:
    section.add "sortField", valid_589226
  var valid_589227 = query.getOrDefault("alt")
  valid_589227 = validateParameter(valid_589227, JString, required = false,
                                 default = newJString("json"))
  if valid_589227 != nil:
    section.add "alt", valid_589227
  var valid_589228 = query.getOrDefault("searchString")
  valid_589228 = validateParameter(valid_589228, JString, required = false,
                                 default = nil)
  if valid_589228 != nil:
    section.add "searchString", valid_589228
  var valid_589229 = query.getOrDefault("active")
  valid_589229 = validateParameter(valid_589229, JBool, required = false, default = nil)
  if valid_589229 != nil:
    section.add "active", valid_589229
  var valid_589230 = query.getOrDefault("oauth_token")
  valid_589230 = validateParameter(valid_589230, JString, required = false,
                                 default = nil)
  if valid_589230 != nil:
    section.add "oauth_token", valid_589230
  var valid_589231 = query.getOrDefault("userIp")
  valid_589231 = validateParameter(valid_589231, JString, required = false,
                                 default = nil)
  if valid_589231 != nil:
    section.add "userIp", valid_589231
  var valid_589232 = query.getOrDefault("maxResults")
  valid_589232 = validateParameter(valid_589232, JInt, required = false,
                                 default = newJInt(1000))
  if valid_589232 != nil:
    section.add "maxResults", valid_589232
  var valid_589233 = query.getOrDefault("ids")
  valid_589233 = validateParameter(valid_589233, JArray, required = false,
                                 default = nil)
  if valid_589233 != nil:
    section.add "ids", valid_589233
  var valid_589234 = query.getOrDefault("key")
  valid_589234 = validateParameter(valid_589234, JString, required = false,
                                 default = nil)
  if valid_589234 != nil:
    section.add "key", valid_589234
  var valid_589235 = query.getOrDefault("sortOrder")
  valid_589235 = validateParameter(valid_589235, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_589235 != nil:
    section.add "sortOrder", valid_589235
  var valid_589236 = query.getOrDefault("prettyPrint")
  valid_589236 = validateParameter(valid_589236, JBool, required = false,
                                 default = newJBool(true))
  if valid_589236 != nil:
    section.add "prettyPrint", valid_589236
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589237: Call_DfareportingAccountsList_589219; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves the list of accounts, possibly filtered. This method supports paging.
  ## 
  let valid = call_589237.validator(path, query, header, formData, body)
  let scheme = call_589237.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589237.url(scheme.get, call_589237.host, call_589237.base,
                         call_589237.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589237, url, valid)

proc call*(call_589238: Call_DfareportingAccountsList_589219; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; searchString: string = "";
          active: bool = false; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountsList
  ## Retrieves the list of accounts, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "account*2015" will return objects with names like "account June 2015", "account April 2015", or simply "account 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "account" will match objects with name "my account", "account 2015", or simply "account".
  ##   active: bool
  ##         : Select only active accounts. Don't set this field to select both active and non-active accounts.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only accounts with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589239 = newJObject()
  var query_589240 = newJObject()
  add(path_589239, "profileId", newJString(profileId))
  add(query_589240, "fields", newJString(fields))
  add(query_589240, "pageToken", newJString(pageToken))
  add(query_589240, "quotaUser", newJString(quotaUser))
  add(query_589240, "sortField", newJString(sortField))
  add(query_589240, "alt", newJString(alt))
  add(query_589240, "searchString", newJString(searchString))
  add(query_589240, "active", newJBool(active))
  add(query_589240, "oauth_token", newJString(oauthToken))
  add(query_589240, "userIp", newJString(userIp))
  add(query_589240, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_589240.add "ids", ids
  add(query_589240, "key", newJString(key))
  add(query_589240, "sortOrder", newJString(sortOrder))
  add(query_589240, "prettyPrint", newJBool(prettyPrint))
  result = call_589238.call(path_589239, query_589240, nil, nil, nil)

var dfareportingAccountsList* = Call_DfareportingAccountsList_589219(
    name: "dfareportingAccountsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts",
    validator: validate_DfareportingAccountsList_589220,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsList_589221,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsPatch_589258 = ref object of OpenApiRestCall_588466
proc url_DfareportingAccountsPatch_589260(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsPatch_589259(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589261 = path.getOrDefault("profileId")
  valid_589261 = validateParameter(valid_589261, JString, required = true,
                                 default = nil)
  if valid_589261 != nil:
    section.add "profileId", valid_589261
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Account ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589262 = query.getOrDefault("fields")
  valid_589262 = validateParameter(valid_589262, JString, required = false,
                                 default = nil)
  if valid_589262 != nil:
    section.add "fields", valid_589262
  var valid_589263 = query.getOrDefault("quotaUser")
  valid_589263 = validateParameter(valid_589263, JString, required = false,
                                 default = nil)
  if valid_589263 != nil:
    section.add "quotaUser", valid_589263
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_589264 = query.getOrDefault("id")
  valid_589264 = validateParameter(valid_589264, JString, required = true,
                                 default = nil)
  if valid_589264 != nil:
    section.add "id", valid_589264
  var valid_589265 = query.getOrDefault("alt")
  valid_589265 = validateParameter(valid_589265, JString, required = false,
                                 default = newJString("json"))
  if valid_589265 != nil:
    section.add "alt", valid_589265
  var valid_589266 = query.getOrDefault("oauth_token")
  valid_589266 = validateParameter(valid_589266, JString, required = false,
                                 default = nil)
  if valid_589266 != nil:
    section.add "oauth_token", valid_589266
  var valid_589267 = query.getOrDefault("userIp")
  valid_589267 = validateParameter(valid_589267, JString, required = false,
                                 default = nil)
  if valid_589267 != nil:
    section.add "userIp", valid_589267
  var valid_589268 = query.getOrDefault("key")
  valid_589268 = validateParameter(valid_589268, JString, required = false,
                                 default = nil)
  if valid_589268 != nil:
    section.add "key", valid_589268
  var valid_589269 = query.getOrDefault("prettyPrint")
  valid_589269 = validateParameter(valid_589269, JBool, required = false,
                                 default = newJBool(true))
  if valid_589269 != nil:
    section.add "prettyPrint", valid_589269
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589271: Call_DfareportingAccountsPatch_589258; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing account. This method supports patch semantics.
  ## 
  let valid = call_589271.validator(path, query, header, formData, body)
  let scheme = call_589271.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589271.url(scheme.get, call_589271.host, call_589271.base,
                         call_589271.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589271, url, valid)

proc call*(call_589272: Call_DfareportingAccountsPatch_589258; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountsPatch
  ## Updates an existing account. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Account ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589273 = newJObject()
  var query_589274 = newJObject()
  var body_589275 = newJObject()
  add(path_589273, "profileId", newJString(profileId))
  add(query_589274, "fields", newJString(fields))
  add(query_589274, "quotaUser", newJString(quotaUser))
  add(query_589274, "id", newJString(id))
  add(query_589274, "alt", newJString(alt))
  add(query_589274, "oauth_token", newJString(oauthToken))
  add(query_589274, "userIp", newJString(userIp))
  add(query_589274, "key", newJString(key))
  if body != nil:
    body_589275 = body
  add(query_589274, "prettyPrint", newJBool(prettyPrint))
  result = call_589272.call(path_589273, query_589274, nil, nil, body_589275)

var dfareportingAccountsPatch* = Call_DfareportingAccountsPatch_589258(
    name: "dfareportingAccountsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts",
    validator: validate_DfareportingAccountsPatch_589259,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsPatch_589260,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsGet_589276 = ref object of OpenApiRestCall_588466
proc url_DfareportingAccountsGet_589278(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsGet_589277(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Account ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589279 = path.getOrDefault("profileId")
  valid_589279 = validateParameter(valid_589279, JString, required = true,
                                 default = nil)
  if valid_589279 != nil:
    section.add "profileId", valid_589279
  var valid_589280 = path.getOrDefault("id")
  valid_589280 = validateParameter(valid_589280, JString, required = true,
                                 default = nil)
  if valid_589280 != nil:
    section.add "id", valid_589280
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589281 = query.getOrDefault("fields")
  valid_589281 = validateParameter(valid_589281, JString, required = false,
                                 default = nil)
  if valid_589281 != nil:
    section.add "fields", valid_589281
  var valid_589282 = query.getOrDefault("quotaUser")
  valid_589282 = validateParameter(valid_589282, JString, required = false,
                                 default = nil)
  if valid_589282 != nil:
    section.add "quotaUser", valid_589282
  var valid_589283 = query.getOrDefault("alt")
  valid_589283 = validateParameter(valid_589283, JString, required = false,
                                 default = newJString("json"))
  if valid_589283 != nil:
    section.add "alt", valid_589283
  var valid_589284 = query.getOrDefault("oauth_token")
  valid_589284 = validateParameter(valid_589284, JString, required = false,
                                 default = nil)
  if valid_589284 != nil:
    section.add "oauth_token", valid_589284
  var valid_589285 = query.getOrDefault("userIp")
  valid_589285 = validateParameter(valid_589285, JString, required = false,
                                 default = nil)
  if valid_589285 != nil:
    section.add "userIp", valid_589285
  var valid_589286 = query.getOrDefault("key")
  valid_589286 = validateParameter(valid_589286, JString, required = false,
                                 default = nil)
  if valid_589286 != nil:
    section.add "key", valid_589286
  var valid_589287 = query.getOrDefault("prettyPrint")
  valid_589287 = validateParameter(valid_589287, JBool, required = false,
                                 default = newJBool(true))
  if valid_589287 != nil:
    section.add "prettyPrint", valid_589287
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589288: Call_DfareportingAccountsGet_589276; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one account by ID.
  ## 
  let valid = call_589288.validator(path, query, header, formData, body)
  let scheme = call_589288.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589288.url(scheme.get, call_589288.host, call_589288.base,
                         call_589288.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589288, url, valid)

proc call*(call_589289: Call_DfareportingAccountsGet_589276; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingAccountsGet
  ## Gets one account by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Account ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589290 = newJObject()
  var query_589291 = newJObject()
  add(path_589290, "profileId", newJString(profileId))
  add(query_589291, "fields", newJString(fields))
  add(query_589291, "quotaUser", newJString(quotaUser))
  add(query_589291, "alt", newJString(alt))
  add(query_589291, "oauth_token", newJString(oauthToken))
  add(query_589291, "userIp", newJString(userIp))
  add(path_589290, "id", newJString(id))
  add(query_589291, "key", newJString(key))
  add(query_589291, "prettyPrint", newJBool(prettyPrint))
  result = call_589289.call(path_589290, query_589291, nil, nil, nil)

var dfareportingAccountsGet* = Call_DfareportingAccountsGet_589276(
    name: "dfareportingAccountsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts/{id}",
    validator: validate_DfareportingAccountsGet_589277,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsGet_589278,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdsUpdate_589330 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdsUpdate_589332(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsUpdate_589331(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing ad.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589333 = path.getOrDefault("profileId")
  valid_589333 = validateParameter(valid_589333, JString, required = true,
                                 default = nil)
  if valid_589333 != nil:
    section.add "profileId", valid_589333
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589334 = query.getOrDefault("fields")
  valid_589334 = validateParameter(valid_589334, JString, required = false,
                                 default = nil)
  if valid_589334 != nil:
    section.add "fields", valid_589334
  var valid_589335 = query.getOrDefault("quotaUser")
  valid_589335 = validateParameter(valid_589335, JString, required = false,
                                 default = nil)
  if valid_589335 != nil:
    section.add "quotaUser", valid_589335
  var valid_589336 = query.getOrDefault("alt")
  valid_589336 = validateParameter(valid_589336, JString, required = false,
                                 default = newJString("json"))
  if valid_589336 != nil:
    section.add "alt", valid_589336
  var valid_589337 = query.getOrDefault("oauth_token")
  valid_589337 = validateParameter(valid_589337, JString, required = false,
                                 default = nil)
  if valid_589337 != nil:
    section.add "oauth_token", valid_589337
  var valid_589338 = query.getOrDefault("userIp")
  valid_589338 = validateParameter(valid_589338, JString, required = false,
                                 default = nil)
  if valid_589338 != nil:
    section.add "userIp", valid_589338
  var valid_589339 = query.getOrDefault("key")
  valid_589339 = validateParameter(valid_589339, JString, required = false,
                                 default = nil)
  if valid_589339 != nil:
    section.add "key", valid_589339
  var valid_589340 = query.getOrDefault("prettyPrint")
  valid_589340 = validateParameter(valid_589340, JBool, required = false,
                                 default = newJBool(true))
  if valid_589340 != nil:
    section.add "prettyPrint", valid_589340
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589342: Call_DfareportingAdsUpdate_589330; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing ad.
  ## 
  let valid = call_589342.validator(path, query, header, formData, body)
  let scheme = call_589342.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589342.url(scheme.get, call_589342.host, call_589342.base,
                         call_589342.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589342, url, valid)

proc call*(call_589343: Call_DfareportingAdsUpdate_589330; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdsUpdate
  ## Updates an existing ad.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589344 = newJObject()
  var query_589345 = newJObject()
  var body_589346 = newJObject()
  add(path_589344, "profileId", newJString(profileId))
  add(query_589345, "fields", newJString(fields))
  add(query_589345, "quotaUser", newJString(quotaUser))
  add(query_589345, "alt", newJString(alt))
  add(query_589345, "oauth_token", newJString(oauthToken))
  add(query_589345, "userIp", newJString(userIp))
  add(query_589345, "key", newJString(key))
  if body != nil:
    body_589346 = body
  add(query_589345, "prettyPrint", newJBool(prettyPrint))
  result = call_589343.call(path_589344, query_589345, nil, nil, body_589346)

var dfareportingAdsUpdate* = Call_DfareportingAdsUpdate_589330(
    name: "dfareportingAdsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsUpdate_589331, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsUpdate_589332, schemes: {Scheme.Https})
type
  Call_DfareportingAdsInsert_589347 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdsInsert_589349(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsInsert_589348(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new ad.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589350 = path.getOrDefault("profileId")
  valid_589350 = validateParameter(valid_589350, JString, required = true,
                                 default = nil)
  if valid_589350 != nil:
    section.add "profileId", valid_589350
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589351 = query.getOrDefault("fields")
  valid_589351 = validateParameter(valid_589351, JString, required = false,
                                 default = nil)
  if valid_589351 != nil:
    section.add "fields", valid_589351
  var valid_589352 = query.getOrDefault("quotaUser")
  valid_589352 = validateParameter(valid_589352, JString, required = false,
                                 default = nil)
  if valid_589352 != nil:
    section.add "quotaUser", valid_589352
  var valid_589353 = query.getOrDefault("alt")
  valid_589353 = validateParameter(valid_589353, JString, required = false,
                                 default = newJString("json"))
  if valid_589353 != nil:
    section.add "alt", valid_589353
  var valid_589354 = query.getOrDefault("oauth_token")
  valid_589354 = validateParameter(valid_589354, JString, required = false,
                                 default = nil)
  if valid_589354 != nil:
    section.add "oauth_token", valid_589354
  var valid_589355 = query.getOrDefault("userIp")
  valid_589355 = validateParameter(valid_589355, JString, required = false,
                                 default = nil)
  if valid_589355 != nil:
    section.add "userIp", valid_589355
  var valid_589356 = query.getOrDefault("key")
  valid_589356 = validateParameter(valid_589356, JString, required = false,
                                 default = nil)
  if valid_589356 != nil:
    section.add "key", valid_589356
  var valid_589357 = query.getOrDefault("prettyPrint")
  valid_589357 = validateParameter(valid_589357, JBool, required = false,
                                 default = newJBool(true))
  if valid_589357 != nil:
    section.add "prettyPrint", valid_589357
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589359: Call_DfareportingAdsInsert_589347; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new ad.
  ## 
  let valid = call_589359.validator(path, query, header, formData, body)
  let scheme = call_589359.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589359.url(scheme.get, call_589359.host, call_589359.base,
                         call_589359.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589359, url, valid)

proc call*(call_589360: Call_DfareportingAdsInsert_589347; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdsInsert
  ## Inserts a new ad.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589361 = newJObject()
  var query_589362 = newJObject()
  var body_589363 = newJObject()
  add(path_589361, "profileId", newJString(profileId))
  add(query_589362, "fields", newJString(fields))
  add(query_589362, "quotaUser", newJString(quotaUser))
  add(query_589362, "alt", newJString(alt))
  add(query_589362, "oauth_token", newJString(oauthToken))
  add(query_589362, "userIp", newJString(userIp))
  add(query_589362, "key", newJString(key))
  if body != nil:
    body_589363 = body
  add(query_589362, "prettyPrint", newJBool(prettyPrint))
  result = call_589360.call(path_589361, query_589362, nil, nil, body_589363)

var dfareportingAdsInsert* = Call_DfareportingAdsInsert_589347(
    name: "dfareportingAdsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsInsert_589348, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsInsert_589349, schemes: {Scheme.Https})
type
  Call_DfareportingAdsList_589292 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdsList_589294(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsList_589293(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Retrieves a list of ads, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589295 = path.getOrDefault("profileId")
  valid_589295 = validateParameter(valid_589295, JString, required = true,
                                 default = nil)
  if valid_589295 != nil:
    section.add "profileId", valid_589295
  result.add "path", section
  ## parameters in `query` object:
  ##   overriddenEventTagId: JString
  ##                       : Select only ads with this event tag override ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   creativeIds: JArray
  ##              : Select only ads with these creative IDs assigned.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   sslCompliant: JBool
  ##               : Select only ads that are SSL-compliant.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "ad*2015" will return objects with names like "ad June 2015", "ad April 2015", or simply "ad 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "ad" will match objects with name "my ad", "ad 2015", or simply "ad".
  ##   advertiserId: JString
  ##               : Select only ads with this advertiser ID.
  ##   dynamicClickTracker: JBool
  ##                      : Select only dynamic click trackers. Applicable when type is AD_SERVING_CLICK_TRACKER. If true, select dynamic click trackers. If false, select static click trackers. Leave unset to select both.
  ##   sizeIds: JArray
  ##          : Select only ads with these size IDs.
  ##   type: JArray
  ##       : Select only ads with these types.
  ##   active: JBool
  ##         : Select only active ads.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   campaignIds: JArray
  ##              : Select only ads with these campaign IDs.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   creativeOptimizationConfigurationIds: JArray
  ##                                       : Select only ads with these creative optimization configuration IDs.
  ##   archived: JBool
  ##           : Select only archived ads.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only ads with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   compatibility: JString
  ##                : Select default ads with the specified compatibility. Applicable when type is AD_SERVING_DEFAULT_AD. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads, respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering an in-stream video ads developed with the VAST standard.
  ##   landingPageIds: JArray
  ##                 : Select only ads with these landing page IDs.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   remarketingListIds: JArray
  ##                     : Select only ads whose list targeting expression use these remarketing list IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   sslRequired: JBool
  ##              : Select only ads that require SSL.
  ##   audienceSegmentIds: JArray
  ##                     : Select only ads with these audience segment IDs.
  ##   placementIds: JArray
  ##               : Select only ads with these placement IDs assigned.
  section = newJObject()
  var valid_589296 = query.getOrDefault("overriddenEventTagId")
  valid_589296 = validateParameter(valid_589296, JString, required = false,
                                 default = nil)
  if valid_589296 != nil:
    section.add "overriddenEventTagId", valid_589296
  var valid_589297 = query.getOrDefault("fields")
  valid_589297 = validateParameter(valid_589297, JString, required = false,
                                 default = nil)
  if valid_589297 != nil:
    section.add "fields", valid_589297
  var valid_589298 = query.getOrDefault("creativeIds")
  valid_589298 = validateParameter(valid_589298, JArray, required = false,
                                 default = nil)
  if valid_589298 != nil:
    section.add "creativeIds", valid_589298
  var valid_589299 = query.getOrDefault("quotaUser")
  valid_589299 = validateParameter(valid_589299, JString, required = false,
                                 default = nil)
  if valid_589299 != nil:
    section.add "quotaUser", valid_589299
  var valid_589300 = query.getOrDefault("pageToken")
  valid_589300 = validateParameter(valid_589300, JString, required = false,
                                 default = nil)
  if valid_589300 != nil:
    section.add "pageToken", valid_589300
  var valid_589301 = query.getOrDefault("sortField")
  valid_589301 = validateParameter(valid_589301, JString, required = false,
                                 default = newJString("ID"))
  if valid_589301 != nil:
    section.add "sortField", valid_589301
  var valid_589302 = query.getOrDefault("alt")
  valid_589302 = validateParameter(valid_589302, JString, required = false,
                                 default = newJString("json"))
  if valid_589302 != nil:
    section.add "alt", valid_589302
  var valid_589303 = query.getOrDefault("sslCompliant")
  valid_589303 = validateParameter(valid_589303, JBool, required = false, default = nil)
  if valid_589303 != nil:
    section.add "sslCompliant", valid_589303
  var valid_589304 = query.getOrDefault("searchString")
  valid_589304 = validateParameter(valid_589304, JString, required = false,
                                 default = nil)
  if valid_589304 != nil:
    section.add "searchString", valid_589304
  var valid_589305 = query.getOrDefault("advertiserId")
  valid_589305 = validateParameter(valid_589305, JString, required = false,
                                 default = nil)
  if valid_589305 != nil:
    section.add "advertiserId", valid_589305
  var valid_589306 = query.getOrDefault("dynamicClickTracker")
  valid_589306 = validateParameter(valid_589306, JBool, required = false, default = nil)
  if valid_589306 != nil:
    section.add "dynamicClickTracker", valid_589306
  var valid_589307 = query.getOrDefault("sizeIds")
  valid_589307 = validateParameter(valid_589307, JArray, required = false,
                                 default = nil)
  if valid_589307 != nil:
    section.add "sizeIds", valid_589307
  var valid_589308 = query.getOrDefault("type")
  valid_589308 = validateParameter(valid_589308, JArray, required = false,
                                 default = nil)
  if valid_589308 != nil:
    section.add "type", valid_589308
  var valid_589309 = query.getOrDefault("active")
  valid_589309 = validateParameter(valid_589309, JBool, required = false, default = nil)
  if valid_589309 != nil:
    section.add "active", valid_589309
  var valid_589310 = query.getOrDefault("oauth_token")
  valid_589310 = validateParameter(valid_589310, JString, required = false,
                                 default = nil)
  if valid_589310 != nil:
    section.add "oauth_token", valid_589310
  var valid_589311 = query.getOrDefault("campaignIds")
  valid_589311 = validateParameter(valid_589311, JArray, required = false,
                                 default = nil)
  if valid_589311 != nil:
    section.add "campaignIds", valid_589311
  var valid_589312 = query.getOrDefault("userIp")
  valid_589312 = validateParameter(valid_589312, JString, required = false,
                                 default = nil)
  if valid_589312 != nil:
    section.add "userIp", valid_589312
  var valid_589313 = query.getOrDefault("creativeOptimizationConfigurationIds")
  valid_589313 = validateParameter(valid_589313, JArray, required = false,
                                 default = nil)
  if valid_589313 != nil:
    section.add "creativeOptimizationConfigurationIds", valid_589313
  var valid_589314 = query.getOrDefault("archived")
  valid_589314 = validateParameter(valid_589314, JBool, required = false, default = nil)
  if valid_589314 != nil:
    section.add "archived", valid_589314
  var valid_589315 = query.getOrDefault("maxResults")
  valid_589315 = validateParameter(valid_589315, JInt, required = false,
                                 default = newJInt(1000))
  if valid_589315 != nil:
    section.add "maxResults", valid_589315
  var valid_589316 = query.getOrDefault("ids")
  valid_589316 = validateParameter(valid_589316, JArray, required = false,
                                 default = nil)
  if valid_589316 != nil:
    section.add "ids", valid_589316
  var valid_589317 = query.getOrDefault("key")
  valid_589317 = validateParameter(valid_589317, JString, required = false,
                                 default = nil)
  if valid_589317 != nil:
    section.add "key", valid_589317
  var valid_589318 = query.getOrDefault("compatibility")
  valid_589318 = validateParameter(valid_589318, JString, required = false,
                                 default = newJString("APP"))
  if valid_589318 != nil:
    section.add "compatibility", valid_589318
  var valid_589319 = query.getOrDefault("landingPageIds")
  valid_589319 = validateParameter(valid_589319, JArray, required = false,
                                 default = nil)
  if valid_589319 != nil:
    section.add "landingPageIds", valid_589319
  var valid_589320 = query.getOrDefault("sortOrder")
  valid_589320 = validateParameter(valid_589320, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_589320 != nil:
    section.add "sortOrder", valid_589320
  var valid_589321 = query.getOrDefault("remarketingListIds")
  valid_589321 = validateParameter(valid_589321, JArray, required = false,
                                 default = nil)
  if valid_589321 != nil:
    section.add "remarketingListIds", valid_589321
  var valid_589322 = query.getOrDefault("prettyPrint")
  valid_589322 = validateParameter(valid_589322, JBool, required = false,
                                 default = newJBool(true))
  if valid_589322 != nil:
    section.add "prettyPrint", valid_589322
  var valid_589323 = query.getOrDefault("sslRequired")
  valid_589323 = validateParameter(valid_589323, JBool, required = false, default = nil)
  if valid_589323 != nil:
    section.add "sslRequired", valid_589323
  var valid_589324 = query.getOrDefault("audienceSegmentIds")
  valid_589324 = validateParameter(valid_589324, JArray, required = false,
                                 default = nil)
  if valid_589324 != nil:
    section.add "audienceSegmentIds", valid_589324
  var valid_589325 = query.getOrDefault("placementIds")
  valid_589325 = validateParameter(valid_589325, JArray, required = false,
                                 default = nil)
  if valid_589325 != nil:
    section.add "placementIds", valid_589325
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589326: Call_DfareportingAdsList_589292; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of ads, possibly filtered. This method supports paging.
  ## 
  let valid = call_589326.validator(path, query, header, formData, body)
  let scheme = call_589326.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589326.url(scheme.get, call_589326.host, call_589326.base,
                         call_589326.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589326, url, valid)

proc call*(call_589327: Call_DfareportingAdsList_589292; profileId: string;
          overriddenEventTagId: string = ""; fields: string = "";
          creativeIds: JsonNode = nil; quotaUser: string = ""; pageToken: string = "";
          sortField: string = "ID"; alt: string = "json"; sslCompliant: bool = false;
          searchString: string = ""; advertiserId: string = "";
          dynamicClickTracker: bool = false; sizeIds: JsonNode = nil;
          `type`: JsonNode = nil; active: bool = false; oauthToken: string = "";
          campaignIds: JsonNode = nil; userIp: string = "";
          creativeOptimizationConfigurationIds: JsonNode = nil;
          archived: bool = false; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; compatibility: string = "APP";
          landingPageIds: JsonNode = nil; sortOrder: string = "ASCENDING";
          remarketingListIds: JsonNode = nil; prettyPrint: bool = true;
          sslRequired: bool = false; audienceSegmentIds: JsonNode = nil;
          placementIds: JsonNode = nil): Recallable =
  ## dfareportingAdsList
  ## Retrieves a list of ads, possibly filtered. This method supports paging.
  ##   overriddenEventTagId: string
  ##                       : Select only ads with this event tag override ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   creativeIds: JArray
  ##              : Select only ads with these creative IDs assigned.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   sslCompliant: bool
  ##               : Select only ads that are SSL-compliant.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "ad*2015" will return objects with names like "ad June 2015", "ad April 2015", or simply "ad 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "ad" will match objects with name "my ad", "ad 2015", or simply "ad".
  ##   advertiserId: string
  ##               : Select only ads with this advertiser ID.
  ##   dynamicClickTracker: bool
  ##                      : Select only dynamic click trackers. Applicable when type is AD_SERVING_CLICK_TRACKER. If true, select dynamic click trackers. If false, select static click trackers. Leave unset to select both.
  ##   sizeIds: JArray
  ##          : Select only ads with these size IDs.
  ##   type: JArray
  ##       : Select only ads with these types.
  ##   active: bool
  ##         : Select only active ads.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   campaignIds: JArray
  ##              : Select only ads with these campaign IDs.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   creativeOptimizationConfigurationIds: JArray
  ##                                       : Select only ads with these creative optimization configuration IDs.
  ##   archived: bool
  ##           : Select only archived ads.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only ads with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   compatibility: string
  ##                : Select default ads with the specified compatibility. Applicable when type is AD_SERVING_DEFAULT_AD. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads, respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering an in-stream video ads developed with the VAST standard.
  ##   landingPageIds: JArray
  ##                 : Select only ads with these landing page IDs.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   remarketingListIds: JArray
  ##                     : Select only ads whose list targeting expression use these remarketing list IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   sslRequired: bool
  ##              : Select only ads that require SSL.
  ##   audienceSegmentIds: JArray
  ##                     : Select only ads with these audience segment IDs.
  ##   placementIds: JArray
  ##               : Select only ads with these placement IDs assigned.
  var path_589328 = newJObject()
  var query_589329 = newJObject()
  add(query_589329, "overriddenEventTagId", newJString(overriddenEventTagId))
  add(path_589328, "profileId", newJString(profileId))
  add(query_589329, "fields", newJString(fields))
  if creativeIds != nil:
    query_589329.add "creativeIds", creativeIds
  add(query_589329, "quotaUser", newJString(quotaUser))
  add(query_589329, "pageToken", newJString(pageToken))
  add(query_589329, "sortField", newJString(sortField))
  add(query_589329, "alt", newJString(alt))
  add(query_589329, "sslCompliant", newJBool(sslCompliant))
  add(query_589329, "searchString", newJString(searchString))
  add(query_589329, "advertiserId", newJString(advertiserId))
  add(query_589329, "dynamicClickTracker", newJBool(dynamicClickTracker))
  if sizeIds != nil:
    query_589329.add "sizeIds", sizeIds
  if `type` != nil:
    query_589329.add "type", `type`
  add(query_589329, "active", newJBool(active))
  add(query_589329, "oauth_token", newJString(oauthToken))
  if campaignIds != nil:
    query_589329.add "campaignIds", campaignIds
  add(query_589329, "userIp", newJString(userIp))
  if creativeOptimizationConfigurationIds != nil:
    query_589329.add "creativeOptimizationConfigurationIds",
                    creativeOptimizationConfigurationIds
  add(query_589329, "archived", newJBool(archived))
  add(query_589329, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_589329.add "ids", ids
  add(query_589329, "key", newJString(key))
  add(query_589329, "compatibility", newJString(compatibility))
  if landingPageIds != nil:
    query_589329.add "landingPageIds", landingPageIds
  add(query_589329, "sortOrder", newJString(sortOrder))
  if remarketingListIds != nil:
    query_589329.add "remarketingListIds", remarketingListIds
  add(query_589329, "prettyPrint", newJBool(prettyPrint))
  add(query_589329, "sslRequired", newJBool(sslRequired))
  if audienceSegmentIds != nil:
    query_589329.add "audienceSegmentIds", audienceSegmentIds
  if placementIds != nil:
    query_589329.add "placementIds", placementIds
  result = call_589327.call(path_589328, query_589329, nil, nil, nil)

var dfareportingAdsList* = Call_DfareportingAdsList_589292(
    name: "dfareportingAdsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsList_589293, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsList_589294, schemes: {Scheme.Https})
type
  Call_DfareportingAdsPatch_589364 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdsPatch_589366(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsPatch_589365(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing ad. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589367 = path.getOrDefault("profileId")
  valid_589367 = validateParameter(valid_589367, JString, required = true,
                                 default = nil)
  if valid_589367 != nil:
    section.add "profileId", valid_589367
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Ad ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589368 = query.getOrDefault("fields")
  valid_589368 = validateParameter(valid_589368, JString, required = false,
                                 default = nil)
  if valid_589368 != nil:
    section.add "fields", valid_589368
  var valid_589369 = query.getOrDefault("quotaUser")
  valid_589369 = validateParameter(valid_589369, JString, required = false,
                                 default = nil)
  if valid_589369 != nil:
    section.add "quotaUser", valid_589369
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_589370 = query.getOrDefault("id")
  valid_589370 = validateParameter(valid_589370, JString, required = true,
                                 default = nil)
  if valid_589370 != nil:
    section.add "id", valid_589370
  var valid_589371 = query.getOrDefault("alt")
  valid_589371 = validateParameter(valid_589371, JString, required = false,
                                 default = newJString("json"))
  if valid_589371 != nil:
    section.add "alt", valid_589371
  var valid_589372 = query.getOrDefault("oauth_token")
  valid_589372 = validateParameter(valid_589372, JString, required = false,
                                 default = nil)
  if valid_589372 != nil:
    section.add "oauth_token", valid_589372
  var valid_589373 = query.getOrDefault("userIp")
  valid_589373 = validateParameter(valid_589373, JString, required = false,
                                 default = nil)
  if valid_589373 != nil:
    section.add "userIp", valid_589373
  var valid_589374 = query.getOrDefault("key")
  valid_589374 = validateParameter(valid_589374, JString, required = false,
                                 default = nil)
  if valid_589374 != nil:
    section.add "key", valid_589374
  var valid_589375 = query.getOrDefault("prettyPrint")
  valid_589375 = validateParameter(valid_589375, JBool, required = false,
                                 default = newJBool(true))
  if valid_589375 != nil:
    section.add "prettyPrint", valid_589375
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589377: Call_DfareportingAdsPatch_589364; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing ad. This method supports patch semantics.
  ## 
  let valid = call_589377.validator(path, query, header, formData, body)
  let scheme = call_589377.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589377.url(scheme.get, call_589377.host, call_589377.base,
                         call_589377.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589377, url, valid)

proc call*(call_589378: Call_DfareportingAdsPatch_589364; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdsPatch
  ## Updates an existing ad. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Ad ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589379 = newJObject()
  var query_589380 = newJObject()
  var body_589381 = newJObject()
  add(path_589379, "profileId", newJString(profileId))
  add(query_589380, "fields", newJString(fields))
  add(query_589380, "quotaUser", newJString(quotaUser))
  add(query_589380, "id", newJString(id))
  add(query_589380, "alt", newJString(alt))
  add(query_589380, "oauth_token", newJString(oauthToken))
  add(query_589380, "userIp", newJString(userIp))
  add(query_589380, "key", newJString(key))
  if body != nil:
    body_589381 = body
  add(query_589380, "prettyPrint", newJBool(prettyPrint))
  result = call_589378.call(path_589379, query_589380, nil, nil, body_589381)

var dfareportingAdsPatch* = Call_DfareportingAdsPatch_589364(
    name: "dfareportingAdsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsPatch_589365, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsPatch_589366, schemes: {Scheme.Https})
type
  Call_DfareportingAdsGet_589382 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdsGet_589384(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsGet_589383(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Gets one ad by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Ad ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589385 = path.getOrDefault("profileId")
  valid_589385 = validateParameter(valid_589385, JString, required = true,
                                 default = nil)
  if valid_589385 != nil:
    section.add "profileId", valid_589385
  var valid_589386 = path.getOrDefault("id")
  valid_589386 = validateParameter(valid_589386, JString, required = true,
                                 default = nil)
  if valid_589386 != nil:
    section.add "id", valid_589386
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589387 = query.getOrDefault("fields")
  valid_589387 = validateParameter(valid_589387, JString, required = false,
                                 default = nil)
  if valid_589387 != nil:
    section.add "fields", valid_589387
  var valid_589388 = query.getOrDefault("quotaUser")
  valid_589388 = validateParameter(valid_589388, JString, required = false,
                                 default = nil)
  if valid_589388 != nil:
    section.add "quotaUser", valid_589388
  var valid_589389 = query.getOrDefault("alt")
  valid_589389 = validateParameter(valid_589389, JString, required = false,
                                 default = newJString("json"))
  if valid_589389 != nil:
    section.add "alt", valid_589389
  var valid_589390 = query.getOrDefault("oauth_token")
  valid_589390 = validateParameter(valid_589390, JString, required = false,
                                 default = nil)
  if valid_589390 != nil:
    section.add "oauth_token", valid_589390
  var valid_589391 = query.getOrDefault("userIp")
  valid_589391 = validateParameter(valid_589391, JString, required = false,
                                 default = nil)
  if valid_589391 != nil:
    section.add "userIp", valid_589391
  var valid_589392 = query.getOrDefault("key")
  valid_589392 = validateParameter(valid_589392, JString, required = false,
                                 default = nil)
  if valid_589392 != nil:
    section.add "key", valid_589392
  var valid_589393 = query.getOrDefault("prettyPrint")
  valid_589393 = validateParameter(valid_589393, JBool, required = false,
                                 default = newJBool(true))
  if valid_589393 != nil:
    section.add "prettyPrint", valid_589393
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589394: Call_DfareportingAdsGet_589382; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one ad by ID.
  ## 
  let valid = call_589394.validator(path, query, header, formData, body)
  let scheme = call_589394.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589394.url(scheme.get, call_589394.host, call_589394.base,
                         call_589394.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589394, url, valid)

proc call*(call_589395: Call_DfareportingAdsGet_589382; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingAdsGet
  ## Gets one ad by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Ad ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589396 = newJObject()
  var query_589397 = newJObject()
  add(path_589396, "profileId", newJString(profileId))
  add(query_589397, "fields", newJString(fields))
  add(query_589397, "quotaUser", newJString(quotaUser))
  add(query_589397, "alt", newJString(alt))
  add(query_589397, "oauth_token", newJString(oauthToken))
  add(query_589397, "userIp", newJString(userIp))
  add(path_589396, "id", newJString(id))
  add(query_589397, "key", newJString(key))
  add(query_589397, "prettyPrint", newJBool(prettyPrint))
  result = call_589395.call(path_589396, query_589397, nil, nil, nil)

var dfareportingAdsGet* = Call_DfareportingAdsGet_589382(
    name: "dfareportingAdsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads/{id}",
    validator: validate_DfareportingAdsGet_589383, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsGet_589384, schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsUpdate_589419 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdvertiserGroupsUpdate_589421(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsUpdate_589420(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589422 = path.getOrDefault("profileId")
  valid_589422 = validateParameter(valid_589422, JString, required = true,
                                 default = nil)
  if valid_589422 != nil:
    section.add "profileId", valid_589422
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589423 = query.getOrDefault("fields")
  valid_589423 = validateParameter(valid_589423, JString, required = false,
                                 default = nil)
  if valid_589423 != nil:
    section.add "fields", valid_589423
  var valid_589424 = query.getOrDefault("quotaUser")
  valid_589424 = validateParameter(valid_589424, JString, required = false,
                                 default = nil)
  if valid_589424 != nil:
    section.add "quotaUser", valid_589424
  var valid_589425 = query.getOrDefault("alt")
  valid_589425 = validateParameter(valid_589425, JString, required = false,
                                 default = newJString("json"))
  if valid_589425 != nil:
    section.add "alt", valid_589425
  var valid_589426 = query.getOrDefault("oauth_token")
  valid_589426 = validateParameter(valid_589426, JString, required = false,
                                 default = nil)
  if valid_589426 != nil:
    section.add "oauth_token", valid_589426
  var valid_589427 = query.getOrDefault("userIp")
  valid_589427 = validateParameter(valid_589427, JString, required = false,
                                 default = nil)
  if valid_589427 != nil:
    section.add "userIp", valid_589427
  var valid_589428 = query.getOrDefault("key")
  valid_589428 = validateParameter(valid_589428, JString, required = false,
                                 default = nil)
  if valid_589428 != nil:
    section.add "key", valid_589428
  var valid_589429 = query.getOrDefault("prettyPrint")
  valid_589429 = validateParameter(valid_589429, JBool, required = false,
                                 default = newJBool(true))
  if valid_589429 != nil:
    section.add "prettyPrint", valid_589429
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589431: Call_DfareportingAdvertiserGroupsUpdate_589419;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing advertiser group.
  ## 
  let valid = call_589431.validator(path, query, header, formData, body)
  let scheme = call_589431.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589431.url(scheme.get, call_589431.host, call_589431.base,
                         call_589431.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589431, url, valid)

proc call*(call_589432: Call_DfareportingAdvertiserGroupsUpdate_589419;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsUpdate
  ## Updates an existing advertiser group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589433 = newJObject()
  var query_589434 = newJObject()
  var body_589435 = newJObject()
  add(path_589433, "profileId", newJString(profileId))
  add(query_589434, "fields", newJString(fields))
  add(query_589434, "quotaUser", newJString(quotaUser))
  add(query_589434, "alt", newJString(alt))
  add(query_589434, "oauth_token", newJString(oauthToken))
  add(query_589434, "userIp", newJString(userIp))
  add(query_589434, "key", newJString(key))
  if body != nil:
    body_589435 = body
  add(query_589434, "prettyPrint", newJBool(prettyPrint))
  result = call_589432.call(path_589433, query_589434, nil, nil, body_589435)

var dfareportingAdvertiserGroupsUpdate* = Call_DfareportingAdvertiserGroupsUpdate_589419(
    name: "dfareportingAdvertiserGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsUpdate_589420,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsUpdate_589421,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsInsert_589436 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdvertiserGroupsInsert_589438(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsInsert_589437(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new advertiser group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589439 = path.getOrDefault("profileId")
  valid_589439 = validateParameter(valid_589439, JString, required = true,
                                 default = nil)
  if valid_589439 != nil:
    section.add "profileId", valid_589439
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589440 = query.getOrDefault("fields")
  valid_589440 = validateParameter(valid_589440, JString, required = false,
                                 default = nil)
  if valid_589440 != nil:
    section.add "fields", valid_589440
  var valid_589441 = query.getOrDefault("quotaUser")
  valid_589441 = validateParameter(valid_589441, JString, required = false,
                                 default = nil)
  if valid_589441 != nil:
    section.add "quotaUser", valid_589441
  var valid_589442 = query.getOrDefault("alt")
  valid_589442 = validateParameter(valid_589442, JString, required = false,
                                 default = newJString("json"))
  if valid_589442 != nil:
    section.add "alt", valid_589442
  var valid_589443 = query.getOrDefault("oauth_token")
  valid_589443 = validateParameter(valid_589443, JString, required = false,
                                 default = nil)
  if valid_589443 != nil:
    section.add "oauth_token", valid_589443
  var valid_589444 = query.getOrDefault("userIp")
  valid_589444 = validateParameter(valid_589444, JString, required = false,
                                 default = nil)
  if valid_589444 != nil:
    section.add "userIp", valid_589444
  var valid_589445 = query.getOrDefault("key")
  valid_589445 = validateParameter(valid_589445, JString, required = false,
                                 default = nil)
  if valid_589445 != nil:
    section.add "key", valid_589445
  var valid_589446 = query.getOrDefault("prettyPrint")
  valid_589446 = validateParameter(valid_589446, JBool, required = false,
                                 default = newJBool(true))
  if valid_589446 != nil:
    section.add "prettyPrint", valid_589446
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589448: Call_DfareportingAdvertiserGroupsInsert_589436;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new advertiser group.
  ## 
  let valid = call_589448.validator(path, query, header, formData, body)
  let scheme = call_589448.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589448.url(scheme.get, call_589448.host, call_589448.base,
                         call_589448.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589448, url, valid)

proc call*(call_589449: Call_DfareportingAdvertiserGroupsInsert_589436;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsInsert
  ## Inserts a new advertiser group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589450 = newJObject()
  var query_589451 = newJObject()
  var body_589452 = newJObject()
  add(path_589450, "profileId", newJString(profileId))
  add(query_589451, "fields", newJString(fields))
  add(query_589451, "quotaUser", newJString(quotaUser))
  add(query_589451, "alt", newJString(alt))
  add(query_589451, "oauth_token", newJString(oauthToken))
  add(query_589451, "userIp", newJString(userIp))
  add(query_589451, "key", newJString(key))
  if body != nil:
    body_589452 = body
  add(query_589451, "prettyPrint", newJBool(prettyPrint))
  result = call_589449.call(path_589450, query_589451, nil, nil, body_589452)

var dfareportingAdvertiserGroupsInsert* = Call_DfareportingAdvertiserGroupsInsert_589436(
    name: "dfareportingAdvertiserGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsInsert_589437,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsInsert_589438,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsList_589398 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdvertiserGroupsList_589400(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsList_589399(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of advertiser groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589401 = path.getOrDefault("profileId")
  valid_589401 = validateParameter(valid_589401, JString, required = true,
                                 default = nil)
  if valid_589401 != nil:
    section.add "profileId", valid_589401
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser group June 2015", "advertiser group April 2015", or simply "advertiser group 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertisergroup" will match objects with name "my advertisergroup", "advertisergroup 2015", or simply "advertisergroup".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only advertiser groups with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589402 = query.getOrDefault("fields")
  valid_589402 = validateParameter(valid_589402, JString, required = false,
                                 default = nil)
  if valid_589402 != nil:
    section.add "fields", valid_589402
  var valid_589403 = query.getOrDefault("pageToken")
  valid_589403 = validateParameter(valid_589403, JString, required = false,
                                 default = nil)
  if valid_589403 != nil:
    section.add "pageToken", valid_589403
  var valid_589404 = query.getOrDefault("quotaUser")
  valid_589404 = validateParameter(valid_589404, JString, required = false,
                                 default = nil)
  if valid_589404 != nil:
    section.add "quotaUser", valid_589404
  var valid_589405 = query.getOrDefault("sortField")
  valid_589405 = validateParameter(valid_589405, JString, required = false,
                                 default = newJString("ID"))
  if valid_589405 != nil:
    section.add "sortField", valid_589405
  var valid_589406 = query.getOrDefault("alt")
  valid_589406 = validateParameter(valid_589406, JString, required = false,
                                 default = newJString("json"))
  if valid_589406 != nil:
    section.add "alt", valid_589406
  var valid_589407 = query.getOrDefault("searchString")
  valid_589407 = validateParameter(valid_589407, JString, required = false,
                                 default = nil)
  if valid_589407 != nil:
    section.add "searchString", valid_589407
  var valid_589408 = query.getOrDefault("oauth_token")
  valid_589408 = validateParameter(valid_589408, JString, required = false,
                                 default = nil)
  if valid_589408 != nil:
    section.add "oauth_token", valid_589408
  var valid_589409 = query.getOrDefault("userIp")
  valid_589409 = validateParameter(valid_589409, JString, required = false,
                                 default = nil)
  if valid_589409 != nil:
    section.add "userIp", valid_589409
  var valid_589410 = query.getOrDefault("maxResults")
  valid_589410 = validateParameter(valid_589410, JInt, required = false,
                                 default = newJInt(1000))
  if valid_589410 != nil:
    section.add "maxResults", valid_589410
  var valid_589411 = query.getOrDefault("ids")
  valid_589411 = validateParameter(valid_589411, JArray, required = false,
                                 default = nil)
  if valid_589411 != nil:
    section.add "ids", valid_589411
  var valid_589412 = query.getOrDefault("key")
  valid_589412 = validateParameter(valid_589412, JString, required = false,
                                 default = nil)
  if valid_589412 != nil:
    section.add "key", valid_589412
  var valid_589413 = query.getOrDefault("sortOrder")
  valid_589413 = validateParameter(valid_589413, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_589413 != nil:
    section.add "sortOrder", valid_589413
  var valid_589414 = query.getOrDefault("prettyPrint")
  valid_589414 = validateParameter(valid_589414, JBool, required = false,
                                 default = newJBool(true))
  if valid_589414 != nil:
    section.add "prettyPrint", valid_589414
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589415: Call_DfareportingAdvertiserGroupsList_589398;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of advertiser groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_589415.validator(path, query, header, formData, body)
  let scheme = call_589415.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589415.url(scheme.get, call_589415.host, call_589415.base,
                         call_589415.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589415, url, valid)

proc call*(call_589416: Call_DfareportingAdvertiserGroupsList_589398;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsList
  ## Retrieves a list of advertiser groups, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser group June 2015", "advertiser group April 2015", or simply "advertiser group 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertisergroup" will match objects with name "my advertisergroup", "advertisergroup 2015", or simply "advertisergroup".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only advertiser groups with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589417 = newJObject()
  var query_589418 = newJObject()
  add(path_589417, "profileId", newJString(profileId))
  add(query_589418, "fields", newJString(fields))
  add(query_589418, "pageToken", newJString(pageToken))
  add(query_589418, "quotaUser", newJString(quotaUser))
  add(query_589418, "sortField", newJString(sortField))
  add(query_589418, "alt", newJString(alt))
  add(query_589418, "searchString", newJString(searchString))
  add(query_589418, "oauth_token", newJString(oauthToken))
  add(query_589418, "userIp", newJString(userIp))
  add(query_589418, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_589418.add "ids", ids
  add(query_589418, "key", newJString(key))
  add(query_589418, "sortOrder", newJString(sortOrder))
  add(query_589418, "prettyPrint", newJBool(prettyPrint))
  result = call_589416.call(path_589417, query_589418, nil, nil, nil)

var dfareportingAdvertiserGroupsList* = Call_DfareportingAdvertiserGroupsList_589398(
    name: "dfareportingAdvertiserGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsList_589399,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsList_589400,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsPatch_589453 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdvertiserGroupsPatch_589455(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsPatch_589454(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589456 = path.getOrDefault("profileId")
  valid_589456 = validateParameter(valid_589456, JString, required = true,
                                 default = nil)
  if valid_589456 != nil:
    section.add "profileId", valid_589456
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Advertiser group ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589457 = query.getOrDefault("fields")
  valid_589457 = validateParameter(valid_589457, JString, required = false,
                                 default = nil)
  if valid_589457 != nil:
    section.add "fields", valid_589457
  var valid_589458 = query.getOrDefault("quotaUser")
  valid_589458 = validateParameter(valid_589458, JString, required = false,
                                 default = nil)
  if valid_589458 != nil:
    section.add "quotaUser", valid_589458
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_589459 = query.getOrDefault("id")
  valid_589459 = validateParameter(valid_589459, JString, required = true,
                                 default = nil)
  if valid_589459 != nil:
    section.add "id", valid_589459
  var valid_589460 = query.getOrDefault("alt")
  valid_589460 = validateParameter(valid_589460, JString, required = false,
                                 default = newJString("json"))
  if valid_589460 != nil:
    section.add "alt", valid_589460
  var valid_589461 = query.getOrDefault("oauth_token")
  valid_589461 = validateParameter(valid_589461, JString, required = false,
                                 default = nil)
  if valid_589461 != nil:
    section.add "oauth_token", valid_589461
  var valid_589462 = query.getOrDefault("userIp")
  valid_589462 = validateParameter(valid_589462, JString, required = false,
                                 default = nil)
  if valid_589462 != nil:
    section.add "userIp", valid_589462
  var valid_589463 = query.getOrDefault("key")
  valid_589463 = validateParameter(valid_589463, JString, required = false,
                                 default = nil)
  if valid_589463 != nil:
    section.add "key", valid_589463
  var valid_589464 = query.getOrDefault("prettyPrint")
  valid_589464 = validateParameter(valid_589464, JBool, required = false,
                                 default = newJBool(true))
  if valid_589464 != nil:
    section.add "prettyPrint", valid_589464
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589466: Call_DfareportingAdvertiserGroupsPatch_589453;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing advertiser group. This method supports patch semantics.
  ## 
  let valid = call_589466.validator(path, query, header, formData, body)
  let scheme = call_589466.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589466.url(scheme.get, call_589466.host, call_589466.base,
                         call_589466.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589466, url, valid)

proc call*(call_589467: Call_DfareportingAdvertiserGroupsPatch_589453;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsPatch
  ## Updates an existing advertiser group. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Advertiser group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589468 = newJObject()
  var query_589469 = newJObject()
  var body_589470 = newJObject()
  add(path_589468, "profileId", newJString(profileId))
  add(query_589469, "fields", newJString(fields))
  add(query_589469, "quotaUser", newJString(quotaUser))
  add(query_589469, "id", newJString(id))
  add(query_589469, "alt", newJString(alt))
  add(query_589469, "oauth_token", newJString(oauthToken))
  add(query_589469, "userIp", newJString(userIp))
  add(query_589469, "key", newJString(key))
  if body != nil:
    body_589470 = body
  add(query_589469, "prettyPrint", newJBool(prettyPrint))
  result = call_589467.call(path_589468, query_589469, nil, nil, body_589470)

var dfareportingAdvertiserGroupsPatch* = Call_DfareportingAdvertiserGroupsPatch_589453(
    name: "dfareportingAdvertiserGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsPatch_589454,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsPatch_589455,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsGet_589471 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdvertiserGroupsGet_589473(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsGet_589472(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one advertiser group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Advertiser group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589474 = path.getOrDefault("profileId")
  valid_589474 = validateParameter(valid_589474, JString, required = true,
                                 default = nil)
  if valid_589474 != nil:
    section.add "profileId", valid_589474
  var valid_589475 = path.getOrDefault("id")
  valid_589475 = validateParameter(valid_589475, JString, required = true,
                                 default = nil)
  if valid_589475 != nil:
    section.add "id", valid_589475
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589476 = query.getOrDefault("fields")
  valid_589476 = validateParameter(valid_589476, JString, required = false,
                                 default = nil)
  if valid_589476 != nil:
    section.add "fields", valid_589476
  var valid_589477 = query.getOrDefault("quotaUser")
  valid_589477 = validateParameter(valid_589477, JString, required = false,
                                 default = nil)
  if valid_589477 != nil:
    section.add "quotaUser", valid_589477
  var valid_589478 = query.getOrDefault("alt")
  valid_589478 = validateParameter(valid_589478, JString, required = false,
                                 default = newJString("json"))
  if valid_589478 != nil:
    section.add "alt", valid_589478
  var valid_589479 = query.getOrDefault("oauth_token")
  valid_589479 = validateParameter(valid_589479, JString, required = false,
                                 default = nil)
  if valid_589479 != nil:
    section.add "oauth_token", valid_589479
  var valid_589480 = query.getOrDefault("userIp")
  valid_589480 = validateParameter(valid_589480, JString, required = false,
                                 default = nil)
  if valid_589480 != nil:
    section.add "userIp", valid_589480
  var valid_589481 = query.getOrDefault("key")
  valid_589481 = validateParameter(valid_589481, JString, required = false,
                                 default = nil)
  if valid_589481 != nil:
    section.add "key", valid_589481
  var valid_589482 = query.getOrDefault("prettyPrint")
  valid_589482 = validateParameter(valid_589482, JBool, required = false,
                                 default = newJBool(true))
  if valid_589482 != nil:
    section.add "prettyPrint", valid_589482
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589483: Call_DfareportingAdvertiserGroupsGet_589471;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one advertiser group by ID.
  ## 
  let valid = call_589483.validator(path, query, header, formData, body)
  let scheme = call_589483.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589483.url(scheme.get, call_589483.host, call_589483.base,
                         call_589483.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589483, url, valid)

proc call*(call_589484: Call_DfareportingAdvertiserGroupsGet_589471;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsGet
  ## Gets one advertiser group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Advertiser group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589485 = newJObject()
  var query_589486 = newJObject()
  add(path_589485, "profileId", newJString(profileId))
  add(query_589486, "fields", newJString(fields))
  add(query_589486, "quotaUser", newJString(quotaUser))
  add(query_589486, "alt", newJString(alt))
  add(query_589486, "oauth_token", newJString(oauthToken))
  add(query_589486, "userIp", newJString(userIp))
  add(path_589485, "id", newJString(id))
  add(query_589486, "key", newJString(key))
  add(query_589486, "prettyPrint", newJBool(prettyPrint))
  result = call_589484.call(path_589485, query_589486, nil, nil, nil)

var dfareportingAdvertiserGroupsGet* = Call_DfareportingAdvertiserGroupsGet_589471(
    name: "dfareportingAdvertiserGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups/{id}",
    validator: validate_DfareportingAdvertiserGroupsGet_589472,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsGet_589473,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsDelete_589487 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdvertiserGroupsDelete_589489(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsDelete_589488(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing advertiser group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Advertiser group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589490 = path.getOrDefault("profileId")
  valid_589490 = validateParameter(valid_589490, JString, required = true,
                                 default = nil)
  if valid_589490 != nil:
    section.add "profileId", valid_589490
  var valid_589491 = path.getOrDefault("id")
  valid_589491 = validateParameter(valid_589491, JString, required = true,
                                 default = nil)
  if valid_589491 != nil:
    section.add "id", valid_589491
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589492 = query.getOrDefault("fields")
  valid_589492 = validateParameter(valid_589492, JString, required = false,
                                 default = nil)
  if valid_589492 != nil:
    section.add "fields", valid_589492
  var valid_589493 = query.getOrDefault("quotaUser")
  valid_589493 = validateParameter(valid_589493, JString, required = false,
                                 default = nil)
  if valid_589493 != nil:
    section.add "quotaUser", valid_589493
  var valid_589494 = query.getOrDefault("alt")
  valid_589494 = validateParameter(valid_589494, JString, required = false,
                                 default = newJString("json"))
  if valid_589494 != nil:
    section.add "alt", valid_589494
  var valid_589495 = query.getOrDefault("oauth_token")
  valid_589495 = validateParameter(valid_589495, JString, required = false,
                                 default = nil)
  if valid_589495 != nil:
    section.add "oauth_token", valid_589495
  var valid_589496 = query.getOrDefault("userIp")
  valid_589496 = validateParameter(valid_589496, JString, required = false,
                                 default = nil)
  if valid_589496 != nil:
    section.add "userIp", valid_589496
  var valid_589497 = query.getOrDefault("key")
  valid_589497 = validateParameter(valid_589497, JString, required = false,
                                 default = nil)
  if valid_589497 != nil:
    section.add "key", valid_589497
  var valid_589498 = query.getOrDefault("prettyPrint")
  valid_589498 = validateParameter(valid_589498, JBool, required = false,
                                 default = newJBool(true))
  if valid_589498 != nil:
    section.add "prettyPrint", valid_589498
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589499: Call_DfareportingAdvertiserGroupsDelete_589487;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing advertiser group.
  ## 
  let valid = call_589499.validator(path, query, header, formData, body)
  let scheme = call_589499.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589499.url(scheme.get, call_589499.host, call_589499.base,
                         call_589499.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589499, url, valid)

proc call*(call_589500: Call_DfareportingAdvertiserGroupsDelete_589487;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsDelete
  ## Deletes an existing advertiser group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Advertiser group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589501 = newJObject()
  var query_589502 = newJObject()
  add(path_589501, "profileId", newJString(profileId))
  add(query_589502, "fields", newJString(fields))
  add(query_589502, "quotaUser", newJString(quotaUser))
  add(query_589502, "alt", newJString(alt))
  add(query_589502, "oauth_token", newJString(oauthToken))
  add(query_589502, "userIp", newJString(userIp))
  add(path_589501, "id", newJString(id))
  add(query_589502, "key", newJString(key))
  add(query_589502, "prettyPrint", newJBool(prettyPrint))
  result = call_589500.call(path_589501, query_589502, nil, nil, nil)

var dfareportingAdvertiserGroupsDelete* = Call_DfareportingAdvertiserGroupsDelete_589487(
    name: "dfareportingAdvertiserGroupsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups/{id}",
    validator: validate_DfareportingAdvertiserGroupsDelete_589488,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsDelete_589489,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersUpdate_589530 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdvertisersUpdate_589532(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersUpdate_589531(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589533 = path.getOrDefault("profileId")
  valid_589533 = validateParameter(valid_589533, JString, required = true,
                                 default = nil)
  if valid_589533 != nil:
    section.add "profileId", valid_589533
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589534 = query.getOrDefault("fields")
  valid_589534 = validateParameter(valid_589534, JString, required = false,
                                 default = nil)
  if valid_589534 != nil:
    section.add "fields", valid_589534
  var valid_589535 = query.getOrDefault("quotaUser")
  valid_589535 = validateParameter(valid_589535, JString, required = false,
                                 default = nil)
  if valid_589535 != nil:
    section.add "quotaUser", valid_589535
  var valid_589536 = query.getOrDefault("alt")
  valid_589536 = validateParameter(valid_589536, JString, required = false,
                                 default = newJString("json"))
  if valid_589536 != nil:
    section.add "alt", valid_589536
  var valid_589537 = query.getOrDefault("oauth_token")
  valid_589537 = validateParameter(valid_589537, JString, required = false,
                                 default = nil)
  if valid_589537 != nil:
    section.add "oauth_token", valid_589537
  var valid_589538 = query.getOrDefault("userIp")
  valid_589538 = validateParameter(valid_589538, JString, required = false,
                                 default = nil)
  if valid_589538 != nil:
    section.add "userIp", valid_589538
  var valid_589539 = query.getOrDefault("key")
  valid_589539 = validateParameter(valid_589539, JString, required = false,
                                 default = nil)
  if valid_589539 != nil:
    section.add "key", valid_589539
  var valid_589540 = query.getOrDefault("prettyPrint")
  valid_589540 = validateParameter(valid_589540, JBool, required = false,
                                 default = newJBool(true))
  if valid_589540 != nil:
    section.add "prettyPrint", valid_589540
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589542: Call_DfareportingAdvertisersUpdate_589530; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing advertiser.
  ## 
  let valid = call_589542.validator(path, query, header, formData, body)
  let scheme = call_589542.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589542.url(scheme.get, call_589542.host, call_589542.base,
                         call_589542.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589542, url, valid)

proc call*(call_589543: Call_DfareportingAdvertisersUpdate_589530;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertisersUpdate
  ## Updates an existing advertiser.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589544 = newJObject()
  var query_589545 = newJObject()
  var body_589546 = newJObject()
  add(path_589544, "profileId", newJString(profileId))
  add(query_589545, "fields", newJString(fields))
  add(query_589545, "quotaUser", newJString(quotaUser))
  add(query_589545, "alt", newJString(alt))
  add(query_589545, "oauth_token", newJString(oauthToken))
  add(query_589545, "userIp", newJString(userIp))
  add(query_589545, "key", newJString(key))
  if body != nil:
    body_589546 = body
  add(query_589545, "prettyPrint", newJBool(prettyPrint))
  result = call_589543.call(path_589544, query_589545, nil, nil, body_589546)

var dfareportingAdvertisersUpdate* = Call_DfareportingAdvertisersUpdate_589530(
    name: "dfareportingAdvertisersUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersUpdate_589531,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersUpdate_589532,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersInsert_589547 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdvertisersInsert_589549(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersInsert_589548(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new advertiser.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589550 = path.getOrDefault("profileId")
  valid_589550 = validateParameter(valid_589550, JString, required = true,
                                 default = nil)
  if valid_589550 != nil:
    section.add "profileId", valid_589550
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589551 = query.getOrDefault("fields")
  valid_589551 = validateParameter(valid_589551, JString, required = false,
                                 default = nil)
  if valid_589551 != nil:
    section.add "fields", valid_589551
  var valid_589552 = query.getOrDefault("quotaUser")
  valid_589552 = validateParameter(valid_589552, JString, required = false,
                                 default = nil)
  if valid_589552 != nil:
    section.add "quotaUser", valid_589552
  var valid_589553 = query.getOrDefault("alt")
  valid_589553 = validateParameter(valid_589553, JString, required = false,
                                 default = newJString("json"))
  if valid_589553 != nil:
    section.add "alt", valid_589553
  var valid_589554 = query.getOrDefault("oauth_token")
  valid_589554 = validateParameter(valid_589554, JString, required = false,
                                 default = nil)
  if valid_589554 != nil:
    section.add "oauth_token", valid_589554
  var valid_589555 = query.getOrDefault("userIp")
  valid_589555 = validateParameter(valid_589555, JString, required = false,
                                 default = nil)
  if valid_589555 != nil:
    section.add "userIp", valid_589555
  var valid_589556 = query.getOrDefault("key")
  valid_589556 = validateParameter(valid_589556, JString, required = false,
                                 default = nil)
  if valid_589556 != nil:
    section.add "key", valid_589556
  var valid_589557 = query.getOrDefault("prettyPrint")
  valid_589557 = validateParameter(valid_589557, JBool, required = false,
                                 default = newJBool(true))
  if valid_589557 != nil:
    section.add "prettyPrint", valid_589557
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589559: Call_DfareportingAdvertisersInsert_589547; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new advertiser.
  ## 
  let valid = call_589559.validator(path, query, header, formData, body)
  let scheme = call_589559.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589559.url(scheme.get, call_589559.host, call_589559.base,
                         call_589559.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589559, url, valid)

proc call*(call_589560: Call_DfareportingAdvertisersInsert_589547;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertisersInsert
  ## Inserts a new advertiser.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589561 = newJObject()
  var query_589562 = newJObject()
  var body_589563 = newJObject()
  add(path_589561, "profileId", newJString(profileId))
  add(query_589562, "fields", newJString(fields))
  add(query_589562, "quotaUser", newJString(quotaUser))
  add(query_589562, "alt", newJString(alt))
  add(query_589562, "oauth_token", newJString(oauthToken))
  add(query_589562, "userIp", newJString(userIp))
  add(query_589562, "key", newJString(key))
  if body != nil:
    body_589563 = body
  add(query_589562, "prettyPrint", newJBool(prettyPrint))
  result = call_589560.call(path_589561, query_589562, nil, nil, body_589563)

var dfareportingAdvertisersInsert* = Call_DfareportingAdvertisersInsert_589547(
    name: "dfareportingAdvertisersInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersInsert_589548,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersInsert_589549,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersList_589503 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdvertisersList_589505(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersList_589504(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of advertisers, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589506 = path.getOrDefault("profileId")
  valid_589506 = validateParameter(valid_589506, JString, required = true,
                                 default = nil)
  if valid_589506 != nil:
    section.add "profileId", valid_589506
  result.add "path", section
  ## parameters in `query` object:
  ##   subaccountId: JString
  ##               : Select only advertisers with these subaccount IDs.
  ##   advertiserGroupIds: JArray
  ##                     : Select only advertisers with these advertiser group IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   onlyParent: JBool
  ##             : Select only advertisers which use another advertiser's floodlight configuration.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser June 2015", "advertiser April 2015", or simply "advertiser 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertiser" will match objects with name "my advertiser", "advertiser 2015", or simply "advertiser".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   floodlightConfigurationIds: JArray
  ##                             : Select only advertisers with these floodlight configuration IDs.
  ##   ids: JArray
  ##      : Select only advertisers with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   status: JString
  ##         : Select only advertisers with the specified status.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   includeAdvertisersWithoutGroupsOnly: JBool
  ##                                      : Select only advertisers which do not belong to any advertiser group.
  section = newJObject()
  var valid_589507 = query.getOrDefault("subaccountId")
  valid_589507 = validateParameter(valid_589507, JString, required = false,
                                 default = nil)
  if valid_589507 != nil:
    section.add "subaccountId", valid_589507
  var valid_589508 = query.getOrDefault("advertiserGroupIds")
  valid_589508 = validateParameter(valid_589508, JArray, required = false,
                                 default = nil)
  if valid_589508 != nil:
    section.add "advertiserGroupIds", valid_589508
  var valid_589509 = query.getOrDefault("fields")
  valid_589509 = validateParameter(valid_589509, JString, required = false,
                                 default = nil)
  if valid_589509 != nil:
    section.add "fields", valid_589509
  var valid_589510 = query.getOrDefault("pageToken")
  valid_589510 = validateParameter(valid_589510, JString, required = false,
                                 default = nil)
  if valid_589510 != nil:
    section.add "pageToken", valid_589510
  var valid_589511 = query.getOrDefault("quotaUser")
  valid_589511 = validateParameter(valid_589511, JString, required = false,
                                 default = nil)
  if valid_589511 != nil:
    section.add "quotaUser", valid_589511
  var valid_589512 = query.getOrDefault("sortField")
  valid_589512 = validateParameter(valid_589512, JString, required = false,
                                 default = newJString("ID"))
  if valid_589512 != nil:
    section.add "sortField", valid_589512
  var valid_589513 = query.getOrDefault("alt")
  valid_589513 = validateParameter(valid_589513, JString, required = false,
                                 default = newJString("json"))
  if valid_589513 != nil:
    section.add "alt", valid_589513
  var valid_589514 = query.getOrDefault("onlyParent")
  valid_589514 = validateParameter(valid_589514, JBool, required = false, default = nil)
  if valid_589514 != nil:
    section.add "onlyParent", valid_589514
  var valid_589515 = query.getOrDefault("searchString")
  valid_589515 = validateParameter(valid_589515, JString, required = false,
                                 default = nil)
  if valid_589515 != nil:
    section.add "searchString", valid_589515
  var valid_589516 = query.getOrDefault("oauth_token")
  valid_589516 = validateParameter(valid_589516, JString, required = false,
                                 default = nil)
  if valid_589516 != nil:
    section.add "oauth_token", valid_589516
  var valid_589517 = query.getOrDefault("userIp")
  valid_589517 = validateParameter(valid_589517, JString, required = false,
                                 default = nil)
  if valid_589517 != nil:
    section.add "userIp", valid_589517
  var valid_589518 = query.getOrDefault("maxResults")
  valid_589518 = validateParameter(valid_589518, JInt, required = false,
                                 default = newJInt(1000))
  if valid_589518 != nil:
    section.add "maxResults", valid_589518
  var valid_589519 = query.getOrDefault("floodlightConfigurationIds")
  valid_589519 = validateParameter(valid_589519, JArray, required = false,
                                 default = nil)
  if valid_589519 != nil:
    section.add "floodlightConfigurationIds", valid_589519
  var valid_589520 = query.getOrDefault("ids")
  valid_589520 = validateParameter(valid_589520, JArray, required = false,
                                 default = nil)
  if valid_589520 != nil:
    section.add "ids", valid_589520
  var valid_589521 = query.getOrDefault("key")
  valid_589521 = validateParameter(valid_589521, JString, required = false,
                                 default = nil)
  if valid_589521 != nil:
    section.add "key", valid_589521
  var valid_589522 = query.getOrDefault("status")
  valid_589522 = validateParameter(valid_589522, JString, required = false,
                                 default = newJString("APPROVED"))
  if valid_589522 != nil:
    section.add "status", valid_589522
  var valid_589523 = query.getOrDefault("sortOrder")
  valid_589523 = validateParameter(valid_589523, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_589523 != nil:
    section.add "sortOrder", valid_589523
  var valid_589524 = query.getOrDefault("prettyPrint")
  valid_589524 = validateParameter(valid_589524, JBool, required = false,
                                 default = newJBool(true))
  if valid_589524 != nil:
    section.add "prettyPrint", valid_589524
  var valid_589525 = query.getOrDefault("includeAdvertisersWithoutGroupsOnly")
  valid_589525 = validateParameter(valid_589525, JBool, required = false, default = nil)
  if valid_589525 != nil:
    section.add "includeAdvertisersWithoutGroupsOnly", valid_589525
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589526: Call_DfareportingAdvertisersList_589503; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of advertisers, possibly filtered. This method supports paging.
  ## 
  let valid = call_589526.validator(path, query, header, formData, body)
  let scheme = call_589526.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589526.url(scheme.get, call_589526.host, call_589526.base,
                         call_589526.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589526, url, valid)

proc call*(call_589527: Call_DfareportingAdvertisersList_589503; profileId: string;
          subaccountId: string = ""; advertiserGroupIds: JsonNode = nil;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; onlyParent: bool = false;
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; floodlightConfigurationIds: JsonNode = nil;
          ids: JsonNode = nil; key: string = ""; status: string = "APPROVED";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true;
          includeAdvertisersWithoutGroupsOnly: bool = false): Recallable =
  ## dfareportingAdvertisersList
  ## Retrieves a list of advertisers, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only advertisers with these subaccount IDs.
  ##   advertiserGroupIds: JArray
  ##                     : Select only advertisers with these advertiser group IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   onlyParent: bool
  ##             : Select only advertisers which use another advertiser's floodlight configuration.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser June 2015", "advertiser April 2015", or simply "advertiser 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertiser" will match objects with name "my advertiser", "advertiser 2015", or simply "advertiser".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   floodlightConfigurationIds: JArray
  ##                             : Select only advertisers with these floodlight configuration IDs.
  ##   ids: JArray
  ##      : Select only advertisers with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   status: string
  ##         : Select only advertisers with the specified status.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   includeAdvertisersWithoutGroupsOnly: bool
  ##                                      : Select only advertisers which do not belong to any advertiser group.
  var path_589528 = newJObject()
  var query_589529 = newJObject()
  add(path_589528, "profileId", newJString(profileId))
  add(query_589529, "subaccountId", newJString(subaccountId))
  if advertiserGroupIds != nil:
    query_589529.add "advertiserGroupIds", advertiserGroupIds
  add(query_589529, "fields", newJString(fields))
  add(query_589529, "pageToken", newJString(pageToken))
  add(query_589529, "quotaUser", newJString(quotaUser))
  add(query_589529, "sortField", newJString(sortField))
  add(query_589529, "alt", newJString(alt))
  add(query_589529, "onlyParent", newJBool(onlyParent))
  add(query_589529, "searchString", newJString(searchString))
  add(query_589529, "oauth_token", newJString(oauthToken))
  add(query_589529, "userIp", newJString(userIp))
  add(query_589529, "maxResults", newJInt(maxResults))
  if floodlightConfigurationIds != nil:
    query_589529.add "floodlightConfigurationIds", floodlightConfigurationIds
  if ids != nil:
    query_589529.add "ids", ids
  add(query_589529, "key", newJString(key))
  add(query_589529, "status", newJString(status))
  add(query_589529, "sortOrder", newJString(sortOrder))
  add(query_589529, "prettyPrint", newJBool(prettyPrint))
  add(query_589529, "includeAdvertisersWithoutGroupsOnly",
      newJBool(includeAdvertisersWithoutGroupsOnly))
  result = call_589527.call(path_589528, query_589529, nil, nil, nil)

var dfareportingAdvertisersList* = Call_DfareportingAdvertisersList_589503(
    name: "dfareportingAdvertisersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersList_589504,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersList_589505,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersPatch_589564 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdvertisersPatch_589566(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersPatch_589565(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589567 = path.getOrDefault("profileId")
  valid_589567 = validateParameter(valid_589567, JString, required = true,
                                 default = nil)
  if valid_589567 != nil:
    section.add "profileId", valid_589567
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Advertiser ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589568 = query.getOrDefault("fields")
  valid_589568 = validateParameter(valid_589568, JString, required = false,
                                 default = nil)
  if valid_589568 != nil:
    section.add "fields", valid_589568
  var valid_589569 = query.getOrDefault("quotaUser")
  valid_589569 = validateParameter(valid_589569, JString, required = false,
                                 default = nil)
  if valid_589569 != nil:
    section.add "quotaUser", valid_589569
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_589570 = query.getOrDefault("id")
  valid_589570 = validateParameter(valid_589570, JString, required = true,
                                 default = nil)
  if valid_589570 != nil:
    section.add "id", valid_589570
  var valid_589571 = query.getOrDefault("alt")
  valid_589571 = validateParameter(valid_589571, JString, required = false,
                                 default = newJString("json"))
  if valid_589571 != nil:
    section.add "alt", valid_589571
  var valid_589572 = query.getOrDefault("oauth_token")
  valid_589572 = validateParameter(valid_589572, JString, required = false,
                                 default = nil)
  if valid_589572 != nil:
    section.add "oauth_token", valid_589572
  var valid_589573 = query.getOrDefault("userIp")
  valid_589573 = validateParameter(valid_589573, JString, required = false,
                                 default = nil)
  if valid_589573 != nil:
    section.add "userIp", valid_589573
  var valid_589574 = query.getOrDefault("key")
  valid_589574 = validateParameter(valid_589574, JString, required = false,
                                 default = nil)
  if valid_589574 != nil:
    section.add "key", valid_589574
  var valid_589575 = query.getOrDefault("prettyPrint")
  valid_589575 = validateParameter(valid_589575, JBool, required = false,
                                 default = newJBool(true))
  if valid_589575 != nil:
    section.add "prettyPrint", valid_589575
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589577: Call_DfareportingAdvertisersPatch_589564; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing advertiser. This method supports patch semantics.
  ## 
  let valid = call_589577.validator(path, query, header, formData, body)
  let scheme = call_589577.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589577.url(scheme.get, call_589577.host, call_589577.base,
                         call_589577.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589577, url, valid)

proc call*(call_589578: Call_DfareportingAdvertisersPatch_589564;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertisersPatch
  ## Updates an existing advertiser. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Advertiser ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589579 = newJObject()
  var query_589580 = newJObject()
  var body_589581 = newJObject()
  add(path_589579, "profileId", newJString(profileId))
  add(query_589580, "fields", newJString(fields))
  add(query_589580, "quotaUser", newJString(quotaUser))
  add(query_589580, "id", newJString(id))
  add(query_589580, "alt", newJString(alt))
  add(query_589580, "oauth_token", newJString(oauthToken))
  add(query_589580, "userIp", newJString(userIp))
  add(query_589580, "key", newJString(key))
  if body != nil:
    body_589581 = body
  add(query_589580, "prettyPrint", newJBool(prettyPrint))
  result = call_589578.call(path_589579, query_589580, nil, nil, body_589581)

var dfareportingAdvertisersPatch* = Call_DfareportingAdvertisersPatch_589564(
    name: "dfareportingAdvertisersPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersPatch_589565,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersPatch_589566,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersGet_589582 = ref object of OpenApiRestCall_588466
proc url_DfareportingAdvertisersGet_589584(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersGet_589583(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one advertiser by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Advertiser ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589585 = path.getOrDefault("profileId")
  valid_589585 = validateParameter(valid_589585, JString, required = true,
                                 default = nil)
  if valid_589585 != nil:
    section.add "profileId", valid_589585
  var valid_589586 = path.getOrDefault("id")
  valid_589586 = validateParameter(valid_589586, JString, required = true,
                                 default = nil)
  if valid_589586 != nil:
    section.add "id", valid_589586
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589587 = query.getOrDefault("fields")
  valid_589587 = validateParameter(valid_589587, JString, required = false,
                                 default = nil)
  if valid_589587 != nil:
    section.add "fields", valid_589587
  var valid_589588 = query.getOrDefault("quotaUser")
  valid_589588 = validateParameter(valid_589588, JString, required = false,
                                 default = nil)
  if valid_589588 != nil:
    section.add "quotaUser", valid_589588
  var valid_589589 = query.getOrDefault("alt")
  valid_589589 = validateParameter(valid_589589, JString, required = false,
                                 default = newJString("json"))
  if valid_589589 != nil:
    section.add "alt", valid_589589
  var valid_589590 = query.getOrDefault("oauth_token")
  valid_589590 = validateParameter(valid_589590, JString, required = false,
                                 default = nil)
  if valid_589590 != nil:
    section.add "oauth_token", valid_589590
  var valid_589591 = query.getOrDefault("userIp")
  valid_589591 = validateParameter(valid_589591, JString, required = false,
                                 default = nil)
  if valid_589591 != nil:
    section.add "userIp", valid_589591
  var valid_589592 = query.getOrDefault("key")
  valid_589592 = validateParameter(valid_589592, JString, required = false,
                                 default = nil)
  if valid_589592 != nil:
    section.add "key", valid_589592
  var valid_589593 = query.getOrDefault("prettyPrint")
  valid_589593 = validateParameter(valid_589593, JBool, required = false,
                                 default = newJBool(true))
  if valid_589593 != nil:
    section.add "prettyPrint", valid_589593
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589594: Call_DfareportingAdvertisersGet_589582; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one advertiser by ID.
  ## 
  let valid = call_589594.validator(path, query, header, formData, body)
  let scheme = call_589594.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589594.url(scheme.get, call_589594.host, call_589594.base,
                         call_589594.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589594, url, valid)

proc call*(call_589595: Call_DfareportingAdvertisersGet_589582; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertisersGet
  ## Gets one advertiser by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Advertiser ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589596 = newJObject()
  var query_589597 = newJObject()
  add(path_589596, "profileId", newJString(profileId))
  add(query_589597, "fields", newJString(fields))
  add(query_589597, "quotaUser", newJString(quotaUser))
  add(query_589597, "alt", newJString(alt))
  add(query_589597, "oauth_token", newJString(oauthToken))
  add(query_589597, "userIp", newJString(userIp))
  add(path_589596, "id", newJString(id))
  add(query_589597, "key", newJString(key))
  add(query_589597, "prettyPrint", newJBool(prettyPrint))
  result = call_589595.call(path_589596, query_589597, nil, nil, nil)

var dfareportingAdvertisersGet* = Call_DfareportingAdvertisersGet_589582(
    name: "dfareportingAdvertisersGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertisers/{id}",
    validator: validate_DfareportingAdvertisersGet_589583,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersGet_589584,
    schemes: {Scheme.Https})
type
  Call_DfareportingBrowsersList_589598 = ref object of OpenApiRestCall_588466
proc url_DfareportingBrowsersList_589600(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/browsers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingBrowsersList_589599(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of browsers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589601 = path.getOrDefault("profileId")
  valid_589601 = validateParameter(valid_589601, JString, required = true,
                                 default = nil)
  if valid_589601 != nil:
    section.add "profileId", valid_589601
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589602 = query.getOrDefault("fields")
  valid_589602 = validateParameter(valid_589602, JString, required = false,
                                 default = nil)
  if valid_589602 != nil:
    section.add "fields", valid_589602
  var valid_589603 = query.getOrDefault("quotaUser")
  valid_589603 = validateParameter(valid_589603, JString, required = false,
                                 default = nil)
  if valid_589603 != nil:
    section.add "quotaUser", valid_589603
  var valid_589604 = query.getOrDefault("alt")
  valid_589604 = validateParameter(valid_589604, JString, required = false,
                                 default = newJString("json"))
  if valid_589604 != nil:
    section.add "alt", valid_589604
  var valid_589605 = query.getOrDefault("oauth_token")
  valid_589605 = validateParameter(valid_589605, JString, required = false,
                                 default = nil)
  if valid_589605 != nil:
    section.add "oauth_token", valid_589605
  var valid_589606 = query.getOrDefault("userIp")
  valid_589606 = validateParameter(valid_589606, JString, required = false,
                                 default = nil)
  if valid_589606 != nil:
    section.add "userIp", valid_589606
  var valid_589607 = query.getOrDefault("key")
  valid_589607 = validateParameter(valid_589607, JString, required = false,
                                 default = nil)
  if valid_589607 != nil:
    section.add "key", valid_589607
  var valid_589608 = query.getOrDefault("prettyPrint")
  valid_589608 = validateParameter(valid_589608, JBool, required = false,
                                 default = newJBool(true))
  if valid_589608 != nil:
    section.add "prettyPrint", valid_589608
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589609: Call_DfareportingBrowsersList_589598; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of browsers.
  ## 
  let valid = call_589609.validator(path, query, header, formData, body)
  let scheme = call_589609.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589609.url(scheme.get, call_589609.host, call_589609.base,
                         call_589609.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589609, url, valid)

proc call*(call_589610: Call_DfareportingBrowsersList_589598; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingBrowsersList
  ## Retrieves a list of browsers.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589611 = newJObject()
  var query_589612 = newJObject()
  add(path_589611, "profileId", newJString(profileId))
  add(query_589612, "fields", newJString(fields))
  add(query_589612, "quotaUser", newJString(quotaUser))
  add(query_589612, "alt", newJString(alt))
  add(query_589612, "oauth_token", newJString(oauthToken))
  add(query_589612, "userIp", newJString(userIp))
  add(query_589612, "key", newJString(key))
  add(query_589612, "prettyPrint", newJBool(prettyPrint))
  result = call_589610.call(path_589611, query_589612, nil, nil, nil)

var dfareportingBrowsersList* = Call_DfareportingBrowsersList_589598(
    name: "dfareportingBrowsersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/browsers",
    validator: validate_DfareportingBrowsersList_589599,
    base: "/dfareporting/v2.7", url: url_DfareportingBrowsersList_589600,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsUpdate_589641 = ref object of OpenApiRestCall_588466
proc url_DfareportingCampaignsUpdate_589643(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsUpdate_589642(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589644 = path.getOrDefault("profileId")
  valid_589644 = validateParameter(valid_589644, JString, required = true,
                                 default = nil)
  if valid_589644 != nil:
    section.add "profileId", valid_589644
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589645 = query.getOrDefault("fields")
  valid_589645 = validateParameter(valid_589645, JString, required = false,
                                 default = nil)
  if valid_589645 != nil:
    section.add "fields", valid_589645
  var valid_589646 = query.getOrDefault("quotaUser")
  valid_589646 = validateParameter(valid_589646, JString, required = false,
                                 default = nil)
  if valid_589646 != nil:
    section.add "quotaUser", valid_589646
  var valid_589647 = query.getOrDefault("alt")
  valid_589647 = validateParameter(valid_589647, JString, required = false,
                                 default = newJString("json"))
  if valid_589647 != nil:
    section.add "alt", valid_589647
  var valid_589648 = query.getOrDefault("oauth_token")
  valid_589648 = validateParameter(valid_589648, JString, required = false,
                                 default = nil)
  if valid_589648 != nil:
    section.add "oauth_token", valid_589648
  var valid_589649 = query.getOrDefault("userIp")
  valid_589649 = validateParameter(valid_589649, JString, required = false,
                                 default = nil)
  if valid_589649 != nil:
    section.add "userIp", valid_589649
  var valid_589650 = query.getOrDefault("key")
  valid_589650 = validateParameter(valid_589650, JString, required = false,
                                 default = nil)
  if valid_589650 != nil:
    section.add "key", valid_589650
  var valid_589651 = query.getOrDefault("prettyPrint")
  valid_589651 = validateParameter(valid_589651, JBool, required = false,
                                 default = newJBool(true))
  if valid_589651 != nil:
    section.add "prettyPrint", valid_589651
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589653: Call_DfareportingCampaignsUpdate_589641; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign.
  ## 
  let valid = call_589653.validator(path, query, header, formData, body)
  let scheme = call_589653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589653.url(scheme.get, call_589653.host, call_589653.base,
                         call_589653.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589653, url, valid)

proc call*(call_589654: Call_DfareportingCampaignsUpdate_589641; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsUpdate
  ## Updates an existing campaign.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589655 = newJObject()
  var query_589656 = newJObject()
  var body_589657 = newJObject()
  add(path_589655, "profileId", newJString(profileId))
  add(query_589656, "fields", newJString(fields))
  add(query_589656, "quotaUser", newJString(quotaUser))
  add(query_589656, "alt", newJString(alt))
  add(query_589656, "oauth_token", newJString(oauthToken))
  add(query_589656, "userIp", newJString(userIp))
  add(query_589656, "key", newJString(key))
  if body != nil:
    body_589657 = body
  add(query_589656, "prettyPrint", newJBool(prettyPrint))
  result = call_589654.call(path_589655, query_589656, nil, nil, body_589657)

var dfareportingCampaignsUpdate* = Call_DfareportingCampaignsUpdate_589641(
    name: "dfareportingCampaignsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsUpdate_589642,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsUpdate_589643,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsInsert_589658 = ref object of OpenApiRestCall_588466
proc url_DfareportingCampaignsInsert_589660(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsInsert_589659(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589661 = path.getOrDefault("profileId")
  valid_589661 = validateParameter(valid_589661, JString, required = true,
                                 default = nil)
  if valid_589661 != nil:
    section.add "profileId", valid_589661
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   defaultLandingPageName: JString (required)
  ##                         : Default landing page name for this new campaign. Must be less than 256 characters long.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   defaultLandingPageUrl: JString (required)
  ##                        : Default landing page URL for this new campaign.
  section = newJObject()
  var valid_589662 = query.getOrDefault("fields")
  valid_589662 = validateParameter(valid_589662, JString, required = false,
                                 default = nil)
  if valid_589662 != nil:
    section.add "fields", valid_589662
  var valid_589663 = query.getOrDefault("quotaUser")
  valid_589663 = validateParameter(valid_589663, JString, required = false,
                                 default = nil)
  if valid_589663 != nil:
    section.add "quotaUser", valid_589663
  var valid_589664 = query.getOrDefault("alt")
  valid_589664 = validateParameter(valid_589664, JString, required = false,
                                 default = newJString("json"))
  if valid_589664 != nil:
    section.add "alt", valid_589664
  var valid_589665 = query.getOrDefault("oauth_token")
  valid_589665 = validateParameter(valid_589665, JString, required = false,
                                 default = nil)
  if valid_589665 != nil:
    section.add "oauth_token", valid_589665
  var valid_589666 = query.getOrDefault("userIp")
  valid_589666 = validateParameter(valid_589666, JString, required = false,
                                 default = nil)
  if valid_589666 != nil:
    section.add "userIp", valid_589666
  assert query != nil, "query argument is necessary due to required `defaultLandingPageName` field"
  var valid_589667 = query.getOrDefault("defaultLandingPageName")
  valid_589667 = validateParameter(valid_589667, JString, required = true,
                                 default = nil)
  if valid_589667 != nil:
    section.add "defaultLandingPageName", valid_589667
  var valid_589668 = query.getOrDefault("key")
  valid_589668 = validateParameter(valid_589668, JString, required = false,
                                 default = nil)
  if valid_589668 != nil:
    section.add "key", valid_589668
  var valid_589669 = query.getOrDefault("prettyPrint")
  valid_589669 = validateParameter(valid_589669, JBool, required = false,
                                 default = newJBool(true))
  if valid_589669 != nil:
    section.add "prettyPrint", valid_589669
  var valid_589670 = query.getOrDefault("defaultLandingPageUrl")
  valid_589670 = validateParameter(valid_589670, JString, required = true,
                                 default = nil)
  if valid_589670 != nil:
    section.add "defaultLandingPageUrl", valid_589670
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589672: Call_DfareportingCampaignsInsert_589658; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new campaign.
  ## 
  let valid = call_589672.validator(path, query, header, formData, body)
  let scheme = call_589672.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589672.url(scheme.get, call_589672.host, call_589672.base,
                         call_589672.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589672, url, valid)

proc call*(call_589673: Call_DfareportingCampaignsInsert_589658; profileId: string;
          defaultLandingPageName: string; defaultLandingPageUrl: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsInsert
  ## Inserts a new campaign.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   defaultLandingPageName: string (required)
  ##                         : Default landing page name for this new campaign. Must be less than 256 characters long.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   defaultLandingPageUrl: string (required)
  ##                        : Default landing page URL for this new campaign.
  var path_589674 = newJObject()
  var query_589675 = newJObject()
  var body_589676 = newJObject()
  add(path_589674, "profileId", newJString(profileId))
  add(query_589675, "fields", newJString(fields))
  add(query_589675, "quotaUser", newJString(quotaUser))
  add(query_589675, "alt", newJString(alt))
  add(query_589675, "oauth_token", newJString(oauthToken))
  add(query_589675, "userIp", newJString(userIp))
  add(query_589675, "defaultLandingPageName", newJString(defaultLandingPageName))
  add(query_589675, "key", newJString(key))
  if body != nil:
    body_589676 = body
  add(query_589675, "prettyPrint", newJBool(prettyPrint))
  add(query_589675, "defaultLandingPageUrl", newJString(defaultLandingPageUrl))
  result = call_589673.call(path_589674, query_589675, nil, nil, body_589676)

var dfareportingCampaignsInsert* = Call_DfareportingCampaignsInsert_589658(
    name: "dfareportingCampaignsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsInsert_589659,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsInsert_589660,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsList_589613 = ref object of OpenApiRestCall_588466
proc url_DfareportingCampaignsList_589615(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsList_589614(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of campaigns, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589616 = path.getOrDefault("profileId")
  valid_589616 = validateParameter(valid_589616, JString, required = true,
                                 default = nil)
  if valid_589616 != nil:
    section.add "profileId", valid_589616
  result.add "path", section
  ## parameters in `query` object:
  ##   overriddenEventTagId: JString
  ##                       : Select only campaigns that have overridden this event tag ID.
  ##   subaccountId: JString
  ##               : Select only campaigns that belong to this subaccount.
  ##   advertiserGroupIds: JArray
  ##                     : Select only campaigns whose advertisers belong to these advertiser groups.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   atLeastOneOptimizationActivity: JBool
  ##                                 : Select only campaigns that have at least one optimization activity.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for campaigns by name or ID. Wildcards (*) are allowed. For example, "campaign*2015" will return campaigns with names like "campaign June 2015", "campaign April 2015", or simply "campaign 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "campaign" will match campaigns with name "my campaign", "campaign 2015", or simply "campaign".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: JBool
  ##           : Select only archived campaigns. Don't set this field to select both archived and non-archived campaigns.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only campaigns with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only campaigns that belong to these advertisers.
  ##   excludedIds: JArray
  ##              : Exclude campaigns with these IDs.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589617 = query.getOrDefault("overriddenEventTagId")
  valid_589617 = validateParameter(valid_589617, JString, required = false,
                                 default = nil)
  if valid_589617 != nil:
    section.add "overriddenEventTagId", valid_589617
  var valid_589618 = query.getOrDefault("subaccountId")
  valid_589618 = validateParameter(valid_589618, JString, required = false,
                                 default = nil)
  if valid_589618 != nil:
    section.add "subaccountId", valid_589618
  var valid_589619 = query.getOrDefault("advertiserGroupIds")
  valid_589619 = validateParameter(valid_589619, JArray, required = false,
                                 default = nil)
  if valid_589619 != nil:
    section.add "advertiserGroupIds", valid_589619
  var valid_589620 = query.getOrDefault("fields")
  valid_589620 = validateParameter(valid_589620, JString, required = false,
                                 default = nil)
  if valid_589620 != nil:
    section.add "fields", valid_589620
  var valid_589621 = query.getOrDefault("atLeastOneOptimizationActivity")
  valid_589621 = validateParameter(valid_589621, JBool, required = false, default = nil)
  if valid_589621 != nil:
    section.add "atLeastOneOptimizationActivity", valid_589621
  var valid_589622 = query.getOrDefault("quotaUser")
  valid_589622 = validateParameter(valid_589622, JString, required = false,
                                 default = nil)
  if valid_589622 != nil:
    section.add "quotaUser", valid_589622
  var valid_589623 = query.getOrDefault("pageToken")
  valid_589623 = validateParameter(valid_589623, JString, required = false,
                                 default = nil)
  if valid_589623 != nil:
    section.add "pageToken", valid_589623
  var valid_589624 = query.getOrDefault("sortField")
  valid_589624 = validateParameter(valid_589624, JString, required = false,
                                 default = newJString("ID"))
  if valid_589624 != nil:
    section.add "sortField", valid_589624
  var valid_589625 = query.getOrDefault("alt")
  valid_589625 = validateParameter(valid_589625, JString, required = false,
                                 default = newJString("json"))
  if valid_589625 != nil:
    section.add "alt", valid_589625
  var valid_589626 = query.getOrDefault("searchString")
  valid_589626 = validateParameter(valid_589626, JString, required = false,
                                 default = nil)
  if valid_589626 != nil:
    section.add "searchString", valid_589626
  var valid_589627 = query.getOrDefault("oauth_token")
  valid_589627 = validateParameter(valid_589627, JString, required = false,
                                 default = nil)
  if valid_589627 != nil:
    section.add "oauth_token", valid_589627
  var valid_589628 = query.getOrDefault("userIp")
  valid_589628 = validateParameter(valid_589628, JString, required = false,
                                 default = nil)
  if valid_589628 != nil:
    section.add "userIp", valid_589628
  var valid_589629 = query.getOrDefault("archived")
  valid_589629 = validateParameter(valid_589629, JBool, required = false, default = nil)
  if valid_589629 != nil:
    section.add "archived", valid_589629
  var valid_589630 = query.getOrDefault("maxResults")
  valid_589630 = validateParameter(valid_589630, JInt, required = false,
                                 default = newJInt(1000))
  if valid_589630 != nil:
    section.add "maxResults", valid_589630
  var valid_589631 = query.getOrDefault("ids")
  valid_589631 = validateParameter(valid_589631, JArray, required = false,
                                 default = nil)
  if valid_589631 != nil:
    section.add "ids", valid_589631
  var valid_589632 = query.getOrDefault("key")
  valid_589632 = validateParameter(valid_589632, JString, required = false,
                                 default = nil)
  if valid_589632 != nil:
    section.add "key", valid_589632
  var valid_589633 = query.getOrDefault("advertiserIds")
  valid_589633 = validateParameter(valid_589633, JArray, required = false,
                                 default = nil)
  if valid_589633 != nil:
    section.add "advertiserIds", valid_589633
  var valid_589634 = query.getOrDefault("excludedIds")
  valid_589634 = validateParameter(valid_589634, JArray, required = false,
                                 default = nil)
  if valid_589634 != nil:
    section.add "excludedIds", valid_589634
  var valid_589635 = query.getOrDefault("sortOrder")
  valid_589635 = validateParameter(valid_589635, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_589635 != nil:
    section.add "sortOrder", valid_589635
  var valid_589636 = query.getOrDefault("prettyPrint")
  valid_589636 = validateParameter(valid_589636, JBool, required = false,
                                 default = newJBool(true))
  if valid_589636 != nil:
    section.add "prettyPrint", valid_589636
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589637: Call_DfareportingCampaignsList_589613; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of campaigns, possibly filtered. This method supports paging.
  ## 
  let valid = call_589637.validator(path, query, header, formData, body)
  let scheme = call_589637.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589637.url(scheme.get, call_589637.host, call_589637.base,
                         call_589637.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589637, url, valid)

proc call*(call_589638: Call_DfareportingCampaignsList_589613; profileId: string;
          overriddenEventTagId: string = ""; subaccountId: string = "";
          advertiserGroupIds: JsonNode = nil; fields: string = "";
          atLeastOneOptimizationActivity: bool = false; quotaUser: string = "";
          pageToken: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          archived: bool = false; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; advertiserIds: JsonNode = nil; excludedIds: JsonNode = nil;
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsList
  ## Retrieves a list of campaigns, possibly filtered. This method supports paging.
  ##   overriddenEventTagId: string
  ##                       : Select only campaigns that have overridden this event tag ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only campaigns that belong to this subaccount.
  ##   advertiserGroupIds: JArray
  ##                     : Select only campaigns whose advertisers belong to these advertiser groups.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   atLeastOneOptimizationActivity: bool
  ##                                 : Select only campaigns that have at least one optimization activity.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for campaigns by name or ID. Wildcards (*) are allowed. For example, "campaign*2015" will return campaigns with names like "campaign June 2015", "campaign April 2015", or simply "campaign 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "campaign" will match campaigns with name "my campaign", "campaign 2015", or simply "campaign".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: bool
  ##           : Select only archived campaigns. Don't set this field to select both archived and non-archived campaigns.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only campaigns with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only campaigns that belong to these advertisers.
  ##   excludedIds: JArray
  ##              : Exclude campaigns with these IDs.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589639 = newJObject()
  var query_589640 = newJObject()
  add(query_589640, "overriddenEventTagId", newJString(overriddenEventTagId))
  add(path_589639, "profileId", newJString(profileId))
  add(query_589640, "subaccountId", newJString(subaccountId))
  if advertiserGroupIds != nil:
    query_589640.add "advertiserGroupIds", advertiserGroupIds
  add(query_589640, "fields", newJString(fields))
  add(query_589640, "atLeastOneOptimizationActivity",
      newJBool(atLeastOneOptimizationActivity))
  add(query_589640, "quotaUser", newJString(quotaUser))
  add(query_589640, "pageToken", newJString(pageToken))
  add(query_589640, "sortField", newJString(sortField))
  add(query_589640, "alt", newJString(alt))
  add(query_589640, "searchString", newJString(searchString))
  add(query_589640, "oauth_token", newJString(oauthToken))
  add(query_589640, "userIp", newJString(userIp))
  add(query_589640, "archived", newJBool(archived))
  add(query_589640, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_589640.add "ids", ids
  add(query_589640, "key", newJString(key))
  if advertiserIds != nil:
    query_589640.add "advertiserIds", advertiserIds
  if excludedIds != nil:
    query_589640.add "excludedIds", excludedIds
  add(query_589640, "sortOrder", newJString(sortOrder))
  add(query_589640, "prettyPrint", newJBool(prettyPrint))
  result = call_589638.call(path_589639, query_589640, nil, nil, nil)

var dfareportingCampaignsList* = Call_DfareportingCampaignsList_589613(
    name: "dfareportingCampaignsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsList_589614,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsList_589615,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsPatch_589677 = ref object of OpenApiRestCall_588466
proc url_DfareportingCampaignsPatch_589679(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsPatch_589678(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589680 = path.getOrDefault("profileId")
  valid_589680 = validateParameter(valid_589680, JString, required = true,
                                 default = nil)
  if valid_589680 != nil:
    section.add "profileId", valid_589680
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Campaign ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589681 = query.getOrDefault("fields")
  valid_589681 = validateParameter(valid_589681, JString, required = false,
                                 default = nil)
  if valid_589681 != nil:
    section.add "fields", valid_589681
  var valid_589682 = query.getOrDefault("quotaUser")
  valid_589682 = validateParameter(valid_589682, JString, required = false,
                                 default = nil)
  if valid_589682 != nil:
    section.add "quotaUser", valid_589682
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_589683 = query.getOrDefault("id")
  valid_589683 = validateParameter(valid_589683, JString, required = true,
                                 default = nil)
  if valid_589683 != nil:
    section.add "id", valid_589683
  var valid_589684 = query.getOrDefault("alt")
  valid_589684 = validateParameter(valid_589684, JString, required = false,
                                 default = newJString("json"))
  if valid_589684 != nil:
    section.add "alt", valid_589684
  var valid_589685 = query.getOrDefault("oauth_token")
  valid_589685 = validateParameter(valid_589685, JString, required = false,
                                 default = nil)
  if valid_589685 != nil:
    section.add "oauth_token", valid_589685
  var valid_589686 = query.getOrDefault("userIp")
  valid_589686 = validateParameter(valid_589686, JString, required = false,
                                 default = nil)
  if valid_589686 != nil:
    section.add "userIp", valid_589686
  var valid_589687 = query.getOrDefault("key")
  valid_589687 = validateParameter(valid_589687, JString, required = false,
                                 default = nil)
  if valid_589687 != nil:
    section.add "key", valid_589687
  var valid_589688 = query.getOrDefault("prettyPrint")
  valid_589688 = validateParameter(valid_589688, JBool, required = false,
                                 default = newJBool(true))
  if valid_589688 != nil:
    section.add "prettyPrint", valid_589688
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589690: Call_DfareportingCampaignsPatch_589677; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign. This method supports patch semantics.
  ## 
  let valid = call_589690.validator(path, query, header, formData, body)
  let scheme = call_589690.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589690.url(scheme.get, call_589690.host, call_589690.base,
                         call_589690.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589690, url, valid)

proc call*(call_589691: Call_DfareportingCampaignsPatch_589677; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsPatch
  ## Updates an existing campaign. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Campaign ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589692 = newJObject()
  var query_589693 = newJObject()
  var body_589694 = newJObject()
  add(path_589692, "profileId", newJString(profileId))
  add(query_589693, "fields", newJString(fields))
  add(query_589693, "quotaUser", newJString(quotaUser))
  add(query_589693, "id", newJString(id))
  add(query_589693, "alt", newJString(alt))
  add(query_589693, "oauth_token", newJString(oauthToken))
  add(query_589693, "userIp", newJString(userIp))
  add(query_589693, "key", newJString(key))
  if body != nil:
    body_589694 = body
  add(query_589693, "prettyPrint", newJBool(prettyPrint))
  result = call_589691.call(path_589692, query_589693, nil, nil, body_589694)

var dfareportingCampaignsPatch* = Call_DfareportingCampaignsPatch_589677(
    name: "dfareportingCampaignsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsPatch_589678,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsPatch_589679,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignCreativeAssociationsInsert_589714 = ref object of OpenApiRestCall_588466
proc url_DfareportingCampaignCreativeAssociationsInsert_589716(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/campaignCreativeAssociations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignCreativeAssociationsInsert_589715(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Associates a creative with the specified campaign. This method creates a default ad with dimensions matching the creative in the campaign if such a default ad does not exist already.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Campaign ID in this association.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589717 = path.getOrDefault("profileId")
  valid_589717 = validateParameter(valid_589717, JString, required = true,
                                 default = nil)
  if valid_589717 != nil:
    section.add "profileId", valid_589717
  var valid_589718 = path.getOrDefault("campaignId")
  valid_589718 = validateParameter(valid_589718, JString, required = true,
                                 default = nil)
  if valid_589718 != nil:
    section.add "campaignId", valid_589718
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589719 = query.getOrDefault("fields")
  valid_589719 = validateParameter(valid_589719, JString, required = false,
                                 default = nil)
  if valid_589719 != nil:
    section.add "fields", valid_589719
  var valid_589720 = query.getOrDefault("quotaUser")
  valid_589720 = validateParameter(valid_589720, JString, required = false,
                                 default = nil)
  if valid_589720 != nil:
    section.add "quotaUser", valid_589720
  var valid_589721 = query.getOrDefault("alt")
  valid_589721 = validateParameter(valid_589721, JString, required = false,
                                 default = newJString("json"))
  if valid_589721 != nil:
    section.add "alt", valid_589721
  var valid_589722 = query.getOrDefault("oauth_token")
  valid_589722 = validateParameter(valid_589722, JString, required = false,
                                 default = nil)
  if valid_589722 != nil:
    section.add "oauth_token", valid_589722
  var valid_589723 = query.getOrDefault("userIp")
  valid_589723 = validateParameter(valid_589723, JString, required = false,
                                 default = nil)
  if valid_589723 != nil:
    section.add "userIp", valid_589723
  var valid_589724 = query.getOrDefault("key")
  valid_589724 = validateParameter(valid_589724, JString, required = false,
                                 default = nil)
  if valid_589724 != nil:
    section.add "key", valid_589724
  var valid_589725 = query.getOrDefault("prettyPrint")
  valid_589725 = validateParameter(valid_589725, JBool, required = false,
                                 default = newJBool(true))
  if valid_589725 != nil:
    section.add "prettyPrint", valid_589725
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589727: Call_DfareportingCampaignCreativeAssociationsInsert_589714;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Associates a creative with the specified campaign. This method creates a default ad with dimensions matching the creative in the campaign if such a default ad does not exist already.
  ## 
  let valid = call_589727.validator(path, query, header, formData, body)
  let scheme = call_589727.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589727.url(scheme.get, call_589727.host, call_589727.base,
                         call_589727.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589727, url, valid)

proc call*(call_589728: Call_DfareportingCampaignCreativeAssociationsInsert_589714;
          profileId: string; campaignId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignCreativeAssociationsInsert
  ## Associates a creative with the specified campaign. This method creates a default ad with dimensions matching the creative in the campaign if such a default ad does not exist already.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Campaign ID in this association.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589729 = newJObject()
  var query_589730 = newJObject()
  var body_589731 = newJObject()
  add(path_589729, "profileId", newJString(profileId))
  add(path_589729, "campaignId", newJString(campaignId))
  add(query_589730, "fields", newJString(fields))
  add(query_589730, "quotaUser", newJString(quotaUser))
  add(query_589730, "alt", newJString(alt))
  add(query_589730, "oauth_token", newJString(oauthToken))
  add(query_589730, "userIp", newJString(userIp))
  add(query_589730, "key", newJString(key))
  if body != nil:
    body_589731 = body
  add(query_589730, "prettyPrint", newJBool(prettyPrint))
  result = call_589728.call(path_589729, query_589730, nil, nil, body_589731)

var dfareportingCampaignCreativeAssociationsInsert* = Call_DfareportingCampaignCreativeAssociationsInsert_589714(
    name: "dfareportingCampaignCreativeAssociationsInsert",
    meth: HttpMethod.HttpPost, host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/campaignCreativeAssociations",
    validator: validate_DfareportingCampaignCreativeAssociationsInsert_589715,
    base: "/dfareporting/v2.7",
    url: url_DfareportingCampaignCreativeAssociationsInsert_589716,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignCreativeAssociationsList_589695 = ref object of OpenApiRestCall_588466
proc url_DfareportingCampaignCreativeAssociationsList_589697(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/campaignCreativeAssociations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignCreativeAssociationsList_589696(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of creative IDs associated with the specified campaign. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Campaign ID in this association.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589698 = path.getOrDefault("profileId")
  valid_589698 = validateParameter(valid_589698, JString, required = true,
                                 default = nil)
  if valid_589698 != nil:
    section.add "profileId", valid_589698
  var valid_589699 = path.getOrDefault("campaignId")
  valid_589699 = validateParameter(valid_589699, JString, required = true,
                                 default = nil)
  if valid_589699 != nil:
    section.add "campaignId", valid_589699
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589700 = query.getOrDefault("fields")
  valid_589700 = validateParameter(valid_589700, JString, required = false,
                                 default = nil)
  if valid_589700 != nil:
    section.add "fields", valid_589700
  var valid_589701 = query.getOrDefault("pageToken")
  valid_589701 = validateParameter(valid_589701, JString, required = false,
                                 default = nil)
  if valid_589701 != nil:
    section.add "pageToken", valid_589701
  var valid_589702 = query.getOrDefault("quotaUser")
  valid_589702 = validateParameter(valid_589702, JString, required = false,
                                 default = nil)
  if valid_589702 != nil:
    section.add "quotaUser", valid_589702
  var valid_589703 = query.getOrDefault("alt")
  valid_589703 = validateParameter(valid_589703, JString, required = false,
                                 default = newJString("json"))
  if valid_589703 != nil:
    section.add "alt", valid_589703
  var valid_589704 = query.getOrDefault("oauth_token")
  valid_589704 = validateParameter(valid_589704, JString, required = false,
                                 default = nil)
  if valid_589704 != nil:
    section.add "oauth_token", valid_589704
  var valid_589705 = query.getOrDefault("userIp")
  valid_589705 = validateParameter(valid_589705, JString, required = false,
                                 default = nil)
  if valid_589705 != nil:
    section.add "userIp", valid_589705
  var valid_589706 = query.getOrDefault("maxResults")
  valid_589706 = validateParameter(valid_589706, JInt, required = false,
                                 default = newJInt(1000))
  if valid_589706 != nil:
    section.add "maxResults", valid_589706
  var valid_589707 = query.getOrDefault("key")
  valid_589707 = validateParameter(valid_589707, JString, required = false,
                                 default = nil)
  if valid_589707 != nil:
    section.add "key", valid_589707
  var valid_589708 = query.getOrDefault("sortOrder")
  valid_589708 = validateParameter(valid_589708, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_589708 != nil:
    section.add "sortOrder", valid_589708
  var valid_589709 = query.getOrDefault("prettyPrint")
  valid_589709 = validateParameter(valid_589709, JBool, required = false,
                                 default = newJBool(true))
  if valid_589709 != nil:
    section.add "prettyPrint", valid_589709
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589710: Call_DfareportingCampaignCreativeAssociationsList_589695;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves the list of creative IDs associated with the specified campaign. This method supports paging.
  ## 
  let valid = call_589710.validator(path, query, header, formData, body)
  let scheme = call_589710.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589710.url(scheme.get, call_589710.host, call_589710.base,
                         call_589710.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589710, url, valid)

proc call*(call_589711: Call_DfareportingCampaignCreativeAssociationsList_589695;
          profileId: string; campaignId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 1000;
          key: string = ""; sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignCreativeAssociationsList
  ## Retrieves the list of creative IDs associated with the specified campaign. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Campaign ID in this association.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589712 = newJObject()
  var query_589713 = newJObject()
  add(path_589712, "profileId", newJString(profileId))
  add(path_589712, "campaignId", newJString(campaignId))
  add(query_589713, "fields", newJString(fields))
  add(query_589713, "pageToken", newJString(pageToken))
  add(query_589713, "quotaUser", newJString(quotaUser))
  add(query_589713, "alt", newJString(alt))
  add(query_589713, "oauth_token", newJString(oauthToken))
  add(query_589713, "userIp", newJString(userIp))
  add(query_589713, "maxResults", newJInt(maxResults))
  add(query_589713, "key", newJString(key))
  add(query_589713, "sortOrder", newJString(sortOrder))
  add(query_589713, "prettyPrint", newJBool(prettyPrint))
  result = call_589711.call(path_589712, query_589713, nil, nil, nil)

var dfareportingCampaignCreativeAssociationsList* = Call_DfareportingCampaignCreativeAssociationsList_589695(
    name: "dfareportingCampaignCreativeAssociationsList",
    meth: HttpMethod.HttpGet, host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/campaignCreativeAssociations",
    validator: validate_DfareportingCampaignCreativeAssociationsList_589696,
    base: "/dfareporting/v2.7",
    url: url_DfareportingCampaignCreativeAssociationsList_589697,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesUpdate_589748 = ref object of OpenApiRestCall_588466
proc url_DfareportingLandingPagesUpdate_589750(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesUpdate_589749(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign landing page.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589751 = path.getOrDefault("profileId")
  valid_589751 = validateParameter(valid_589751, JString, required = true,
                                 default = nil)
  if valid_589751 != nil:
    section.add "profileId", valid_589751
  var valid_589752 = path.getOrDefault("campaignId")
  valid_589752 = validateParameter(valid_589752, JString, required = true,
                                 default = nil)
  if valid_589752 != nil:
    section.add "campaignId", valid_589752
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589753 = query.getOrDefault("fields")
  valid_589753 = validateParameter(valid_589753, JString, required = false,
                                 default = nil)
  if valid_589753 != nil:
    section.add "fields", valid_589753
  var valid_589754 = query.getOrDefault("quotaUser")
  valid_589754 = validateParameter(valid_589754, JString, required = false,
                                 default = nil)
  if valid_589754 != nil:
    section.add "quotaUser", valid_589754
  var valid_589755 = query.getOrDefault("alt")
  valid_589755 = validateParameter(valid_589755, JString, required = false,
                                 default = newJString("json"))
  if valid_589755 != nil:
    section.add "alt", valid_589755
  var valid_589756 = query.getOrDefault("oauth_token")
  valid_589756 = validateParameter(valid_589756, JString, required = false,
                                 default = nil)
  if valid_589756 != nil:
    section.add "oauth_token", valid_589756
  var valid_589757 = query.getOrDefault("userIp")
  valid_589757 = validateParameter(valid_589757, JString, required = false,
                                 default = nil)
  if valid_589757 != nil:
    section.add "userIp", valid_589757
  var valid_589758 = query.getOrDefault("key")
  valid_589758 = validateParameter(valid_589758, JString, required = false,
                                 default = nil)
  if valid_589758 != nil:
    section.add "key", valid_589758
  var valid_589759 = query.getOrDefault("prettyPrint")
  valid_589759 = validateParameter(valid_589759, JBool, required = false,
                                 default = newJBool(true))
  if valid_589759 != nil:
    section.add "prettyPrint", valid_589759
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589761: Call_DfareportingLandingPagesUpdate_589748; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign landing page.
  ## 
  let valid = call_589761.validator(path, query, header, formData, body)
  let scheme = call_589761.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589761.url(scheme.get, call_589761.host, call_589761.base,
                         call_589761.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589761, url, valid)

proc call*(call_589762: Call_DfareportingLandingPagesUpdate_589748;
          profileId: string; campaignId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesUpdate
  ## Updates an existing campaign landing page.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589763 = newJObject()
  var query_589764 = newJObject()
  var body_589765 = newJObject()
  add(path_589763, "profileId", newJString(profileId))
  add(path_589763, "campaignId", newJString(campaignId))
  add(query_589764, "fields", newJString(fields))
  add(query_589764, "quotaUser", newJString(quotaUser))
  add(query_589764, "alt", newJString(alt))
  add(query_589764, "oauth_token", newJString(oauthToken))
  add(query_589764, "userIp", newJString(userIp))
  add(query_589764, "key", newJString(key))
  if body != nil:
    body_589765 = body
  add(query_589764, "prettyPrint", newJBool(prettyPrint))
  result = call_589762.call(path_589763, query_589764, nil, nil, body_589765)

var dfareportingLandingPagesUpdate* = Call_DfareportingLandingPagesUpdate_589748(
    name: "dfareportingLandingPagesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesUpdate_589749,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesUpdate_589750,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesInsert_589766 = ref object of OpenApiRestCall_588466
proc url_DfareportingLandingPagesInsert_589768(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesInsert_589767(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new landing page for the specified campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589769 = path.getOrDefault("profileId")
  valid_589769 = validateParameter(valid_589769, JString, required = true,
                                 default = nil)
  if valid_589769 != nil:
    section.add "profileId", valid_589769
  var valid_589770 = path.getOrDefault("campaignId")
  valid_589770 = validateParameter(valid_589770, JString, required = true,
                                 default = nil)
  if valid_589770 != nil:
    section.add "campaignId", valid_589770
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589771 = query.getOrDefault("fields")
  valid_589771 = validateParameter(valid_589771, JString, required = false,
                                 default = nil)
  if valid_589771 != nil:
    section.add "fields", valid_589771
  var valid_589772 = query.getOrDefault("quotaUser")
  valid_589772 = validateParameter(valid_589772, JString, required = false,
                                 default = nil)
  if valid_589772 != nil:
    section.add "quotaUser", valid_589772
  var valid_589773 = query.getOrDefault("alt")
  valid_589773 = validateParameter(valid_589773, JString, required = false,
                                 default = newJString("json"))
  if valid_589773 != nil:
    section.add "alt", valid_589773
  var valid_589774 = query.getOrDefault("oauth_token")
  valid_589774 = validateParameter(valid_589774, JString, required = false,
                                 default = nil)
  if valid_589774 != nil:
    section.add "oauth_token", valid_589774
  var valid_589775 = query.getOrDefault("userIp")
  valid_589775 = validateParameter(valid_589775, JString, required = false,
                                 default = nil)
  if valid_589775 != nil:
    section.add "userIp", valid_589775
  var valid_589776 = query.getOrDefault("key")
  valid_589776 = validateParameter(valid_589776, JString, required = false,
                                 default = nil)
  if valid_589776 != nil:
    section.add "key", valid_589776
  var valid_589777 = query.getOrDefault("prettyPrint")
  valid_589777 = validateParameter(valid_589777, JBool, required = false,
                                 default = newJBool(true))
  if valid_589777 != nil:
    section.add "prettyPrint", valid_589777
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589779: Call_DfareportingLandingPagesInsert_589766; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new landing page for the specified campaign.
  ## 
  let valid = call_589779.validator(path, query, header, formData, body)
  let scheme = call_589779.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589779.url(scheme.get, call_589779.host, call_589779.base,
                         call_589779.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589779, url, valid)

proc call*(call_589780: Call_DfareportingLandingPagesInsert_589766;
          profileId: string; campaignId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesInsert
  ## Inserts a new landing page for the specified campaign.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589781 = newJObject()
  var query_589782 = newJObject()
  var body_589783 = newJObject()
  add(path_589781, "profileId", newJString(profileId))
  add(path_589781, "campaignId", newJString(campaignId))
  add(query_589782, "fields", newJString(fields))
  add(query_589782, "quotaUser", newJString(quotaUser))
  add(query_589782, "alt", newJString(alt))
  add(query_589782, "oauth_token", newJString(oauthToken))
  add(query_589782, "userIp", newJString(userIp))
  add(query_589782, "key", newJString(key))
  if body != nil:
    body_589783 = body
  add(query_589782, "prettyPrint", newJBool(prettyPrint))
  result = call_589780.call(path_589781, query_589782, nil, nil, body_589783)

var dfareportingLandingPagesInsert* = Call_DfareportingLandingPagesInsert_589766(
    name: "dfareportingLandingPagesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesInsert_589767,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesInsert_589768,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesList_589732 = ref object of OpenApiRestCall_588466
proc url_DfareportingLandingPagesList_589734(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesList_589733(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of landing pages for the specified campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589735 = path.getOrDefault("profileId")
  valid_589735 = validateParameter(valid_589735, JString, required = true,
                                 default = nil)
  if valid_589735 != nil:
    section.add "profileId", valid_589735
  var valid_589736 = path.getOrDefault("campaignId")
  valid_589736 = validateParameter(valid_589736, JString, required = true,
                                 default = nil)
  if valid_589736 != nil:
    section.add "campaignId", valid_589736
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589737 = query.getOrDefault("fields")
  valid_589737 = validateParameter(valid_589737, JString, required = false,
                                 default = nil)
  if valid_589737 != nil:
    section.add "fields", valid_589737
  var valid_589738 = query.getOrDefault("quotaUser")
  valid_589738 = validateParameter(valid_589738, JString, required = false,
                                 default = nil)
  if valid_589738 != nil:
    section.add "quotaUser", valid_589738
  var valid_589739 = query.getOrDefault("alt")
  valid_589739 = validateParameter(valid_589739, JString, required = false,
                                 default = newJString("json"))
  if valid_589739 != nil:
    section.add "alt", valid_589739
  var valid_589740 = query.getOrDefault("oauth_token")
  valid_589740 = validateParameter(valid_589740, JString, required = false,
                                 default = nil)
  if valid_589740 != nil:
    section.add "oauth_token", valid_589740
  var valid_589741 = query.getOrDefault("userIp")
  valid_589741 = validateParameter(valid_589741, JString, required = false,
                                 default = nil)
  if valid_589741 != nil:
    section.add "userIp", valid_589741
  var valid_589742 = query.getOrDefault("key")
  valid_589742 = validateParameter(valid_589742, JString, required = false,
                                 default = nil)
  if valid_589742 != nil:
    section.add "key", valid_589742
  var valid_589743 = query.getOrDefault("prettyPrint")
  valid_589743 = validateParameter(valid_589743, JBool, required = false,
                                 default = newJBool(true))
  if valid_589743 != nil:
    section.add "prettyPrint", valid_589743
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589744: Call_DfareportingLandingPagesList_589732; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves the list of landing pages for the specified campaign.
  ## 
  let valid = call_589744.validator(path, query, header, formData, body)
  let scheme = call_589744.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589744.url(scheme.get, call_589744.host, call_589744.base,
                         call_589744.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589744, url, valid)

proc call*(call_589745: Call_DfareportingLandingPagesList_589732;
          profileId: string; campaignId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesList
  ## Retrieves the list of landing pages for the specified campaign.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589746 = newJObject()
  var query_589747 = newJObject()
  add(path_589746, "profileId", newJString(profileId))
  add(path_589746, "campaignId", newJString(campaignId))
  add(query_589747, "fields", newJString(fields))
  add(query_589747, "quotaUser", newJString(quotaUser))
  add(query_589747, "alt", newJString(alt))
  add(query_589747, "oauth_token", newJString(oauthToken))
  add(query_589747, "userIp", newJString(userIp))
  add(query_589747, "key", newJString(key))
  add(query_589747, "prettyPrint", newJBool(prettyPrint))
  result = call_589745.call(path_589746, query_589747, nil, nil, nil)

var dfareportingLandingPagesList* = Call_DfareportingLandingPagesList_589732(
    name: "dfareportingLandingPagesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesList_589733,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesList_589734,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesPatch_589784 = ref object of OpenApiRestCall_588466
proc url_DfareportingLandingPagesPatch_589786(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesPatch_589785(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign landing page. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589787 = path.getOrDefault("profileId")
  valid_589787 = validateParameter(valid_589787, JString, required = true,
                                 default = nil)
  if valid_589787 != nil:
    section.add "profileId", valid_589787
  var valid_589788 = path.getOrDefault("campaignId")
  valid_589788 = validateParameter(valid_589788, JString, required = true,
                                 default = nil)
  if valid_589788 != nil:
    section.add "campaignId", valid_589788
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Landing page ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589789 = query.getOrDefault("fields")
  valid_589789 = validateParameter(valid_589789, JString, required = false,
                                 default = nil)
  if valid_589789 != nil:
    section.add "fields", valid_589789
  var valid_589790 = query.getOrDefault("quotaUser")
  valid_589790 = validateParameter(valid_589790, JString, required = false,
                                 default = nil)
  if valid_589790 != nil:
    section.add "quotaUser", valid_589790
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_589791 = query.getOrDefault("id")
  valid_589791 = validateParameter(valid_589791, JString, required = true,
                                 default = nil)
  if valid_589791 != nil:
    section.add "id", valid_589791
  var valid_589792 = query.getOrDefault("alt")
  valid_589792 = validateParameter(valid_589792, JString, required = false,
                                 default = newJString("json"))
  if valid_589792 != nil:
    section.add "alt", valid_589792
  var valid_589793 = query.getOrDefault("oauth_token")
  valid_589793 = validateParameter(valid_589793, JString, required = false,
                                 default = nil)
  if valid_589793 != nil:
    section.add "oauth_token", valid_589793
  var valid_589794 = query.getOrDefault("userIp")
  valid_589794 = validateParameter(valid_589794, JString, required = false,
                                 default = nil)
  if valid_589794 != nil:
    section.add "userIp", valid_589794
  var valid_589795 = query.getOrDefault("key")
  valid_589795 = validateParameter(valid_589795, JString, required = false,
                                 default = nil)
  if valid_589795 != nil:
    section.add "key", valid_589795
  var valid_589796 = query.getOrDefault("prettyPrint")
  valid_589796 = validateParameter(valid_589796, JBool, required = false,
                                 default = newJBool(true))
  if valid_589796 != nil:
    section.add "prettyPrint", valid_589796
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589798: Call_DfareportingLandingPagesPatch_589784; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign landing page. This method supports patch semantics.
  ## 
  let valid = call_589798.validator(path, query, header, formData, body)
  let scheme = call_589798.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589798.url(scheme.get, call_589798.host, call_589798.base,
                         call_589798.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589798, url, valid)

proc call*(call_589799: Call_DfareportingLandingPagesPatch_589784;
          profileId: string; campaignId: string; id: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesPatch
  ## Updates an existing campaign landing page. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Landing page ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589800 = newJObject()
  var query_589801 = newJObject()
  var body_589802 = newJObject()
  add(path_589800, "profileId", newJString(profileId))
  add(path_589800, "campaignId", newJString(campaignId))
  add(query_589801, "fields", newJString(fields))
  add(query_589801, "quotaUser", newJString(quotaUser))
  add(query_589801, "id", newJString(id))
  add(query_589801, "alt", newJString(alt))
  add(query_589801, "oauth_token", newJString(oauthToken))
  add(query_589801, "userIp", newJString(userIp))
  add(query_589801, "key", newJString(key))
  if body != nil:
    body_589802 = body
  add(query_589801, "prettyPrint", newJBool(prettyPrint))
  result = call_589799.call(path_589800, query_589801, nil, nil, body_589802)

var dfareportingLandingPagesPatch* = Call_DfareportingLandingPagesPatch_589784(
    name: "dfareportingLandingPagesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesPatch_589785,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesPatch_589786,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesGet_589803 = ref object of OpenApiRestCall_588466
proc url_DfareportingLandingPagesGet_589805(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesGet_589804(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one campaign landing page by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  ##   id: JString (required)
  ##     : Landing page ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589806 = path.getOrDefault("profileId")
  valid_589806 = validateParameter(valid_589806, JString, required = true,
                                 default = nil)
  if valid_589806 != nil:
    section.add "profileId", valid_589806
  var valid_589807 = path.getOrDefault("campaignId")
  valid_589807 = validateParameter(valid_589807, JString, required = true,
                                 default = nil)
  if valid_589807 != nil:
    section.add "campaignId", valid_589807
  var valid_589808 = path.getOrDefault("id")
  valid_589808 = validateParameter(valid_589808, JString, required = true,
                                 default = nil)
  if valid_589808 != nil:
    section.add "id", valid_589808
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589809 = query.getOrDefault("fields")
  valid_589809 = validateParameter(valid_589809, JString, required = false,
                                 default = nil)
  if valid_589809 != nil:
    section.add "fields", valid_589809
  var valid_589810 = query.getOrDefault("quotaUser")
  valid_589810 = validateParameter(valid_589810, JString, required = false,
                                 default = nil)
  if valid_589810 != nil:
    section.add "quotaUser", valid_589810
  var valid_589811 = query.getOrDefault("alt")
  valid_589811 = validateParameter(valid_589811, JString, required = false,
                                 default = newJString("json"))
  if valid_589811 != nil:
    section.add "alt", valid_589811
  var valid_589812 = query.getOrDefault("oauth_token")
  valid_589812 = validateParameter(valid_589812, JString, required = false,
                                 default = nil)
  if valid_589812 != nil:
    section.add "oauth_token", valid_589812
  var valid_589813 = query.getOrDefault("userIp")
  valid_589813 = validateParameter(valid_589813, JString, required = false,
                                 default = nil)
  if valid_589813 != nil:
    section.add "userIp", valid_589813
  var valid_589814 = query.getOrDefault("key")
  valid_589814 = validateParameter(valid_589814, JString, required = false,
                                 default = nil)
  if valid_589814 != nil:
    section.add "key", valid_589814
  var valid_589815 = query.getOrDefault("prettyPrint")
  valid_589815 = validateParameter(valid_589815, JBool, required = false,
                                 default = newJBool(true))
  if valid_589815 != nil:
    section.add "prettyPrint", valid_589815
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589816: Call_DfareportingLandingPagesGet_589803; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one campaign landing page by ID.
  ## 
  let valid = call_589816.validator(path, query, header, formData, body)
  let scheme = call_589816.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589816.url(scheme.get, call_589816.host, call_589816.base,
                         call_589816.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589816, url, valid)

proc call*(call_589817: Call_DfareportingLandingPagesGet_589803; profileId: string;
          campaignId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesGet
  ## Gets one campaign landing page by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Landing page ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589818 = newJObject()
  var query_589819 = newJObject()
  add(path_589818, "profileId", newJString(profileId))
  add(path_589818, "campaignId", newJString(campaignId))
  add(query_589819, "fields", newJString(fields))
  add(query_589819, "quotaUser", newJString(quotaUser))
  add(query_589819, "alt", newJString(alt))
  add(query_589819, "oauth_token", newJString(oauthToken))
  add(query_589819, "userIp", newJString(userIp))
  add(path_589818, "id", newJString(id))
  add(query_589819, "key", newJString(key))
  add(query_589819, "prettyPrint", newJBool(prettyPrint))
  result = call_589817.call(path_589818, query_589819, nil, nil, nil)

var dfareportingLandingPagesGet* = Call_DfareportingLandingPagesGet_589803(
    name: "dfareportingLandingPagesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages/{id}",
    validator: validate_DfareportingLandingPagesGet_589804,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesGet_589805,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesDelete_589820 = ref object of OpenApiRestCall_588466
proc url_DfareportingLandingPagesDelete_589822(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesDelete_589821(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing campaign landing page.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  ##   id: JString (required)
  ##     : Landing page ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589823 = path.getOrDefault("profileId")
  valid_589823 = validateParameter(valid_589823, JString, required = true,
                                 default = nil)
  if valid_589823 != nil:
    section.add "profileId", valid_589823
  var valid_589824 = path.getOrDefault("campaignId")
  valid_589824 = validateParameter(valid_589824, JString, required = true,
                                 default = nil)
  if valid_589824 != nil:
    section.add "campaignId", valid_589824
  var valid_589825 = path.getOrDefault("id")
  valid_589825 = validateParameter(valid_589825, JString, required = true,
                                 default = nil)
  if valid_589825 != nil:
    section.add "id", valid_589825
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589826 = query.getOrDefault("fields")
  valid_589826 = validateParameter(valid_589826, JString, required = false,
                                 default = nil)
  if valid_589826 != nil:
    section.add "fields", valid_589826
  var valid_589827 = query.getOrDefault("quotaUser")
  valid_589827 = validateParameter(valid_589827, JString, required = false,
                                 default = nil)
  if valid_589827 != nil:
    section.add "quotaUser", valid_589827
  var valid_589828 = query.getOrDefault("alt")
  valid_589828 = validateParameter(valid_589828, JString, required = false,
                                 default = newJString("json"))
  if valid_589828 != nil:
    section.add "alt", valid_589828
  var valid_589829 = query.getOrDefault("oauth_token")
  valid_589829 = validateParameter(valid_589829, JString, required = false,
                                 default = nil)
  if valid_589829 != nil:
    section.add "oauth_token", valid_589829
  var valid_589830 = query.getOrDefault("userIp")
  valid_589830 = validateParameter(valid_589830, JString, required = false,
                                 default = nil)
  if valid_589830 != nil:
    section.add "userIp", valid_589830
  var valid_589831 = query.getOrDefault("key")
  valid_589831 = validateParameter(valid_589831, JString, required = false,
                                 default = nil)
  if valid_589831 != nil:
    section.add "key", valid_589831
  var valid_589832 = query.getOrDefault("prettyPrint")
  valid_589832 = validateParameter(valid_589832, JBool, required = false,
                                 default = newJBool(true))
  if valid_589832 != nil:
    section.add "prettyPrint", valid_589832
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589833: Call_DfareportingLandingPagesDelete_589820; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing campaign landing page.
  ## 
  let valid = call_589833.validator(path, query, header, formData, body)
  let scheme = call_589833.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589833.url(scheme.get, call_589833.host, call_589833.base,
                         call_589833.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589833, url, valid)

proc call*(call_589834: Call_DfareportingLandingPagesDelete_589820;
          profileId: string; campaignId: string; id: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesDelete
  ## Deletes an existing campaign landing page.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Landing page ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589835 = newJObject()
  var query_589836 = newJObject()
  add(path_589835, "profileId", newJString(profileId))
  add(path_589835, "campaignId", newJString(campaignId))
  add(query_589836, "fields", newJString(fields))
  add(query_589836, "quotaUser", newJString(quotaUser))
  add(query_589836, "alt", newJString(alt))
  add(query_589836, "oauth_token", newJString(oauthToken))
  add(query_589836, "userIp", newJString(userIp))
  add(path_589835, "id", newJString(id))
  add(query_589836, "key", newJString(key))
  add(query_589836, "prettyPrint", newJBool(prettyPrint))
  result = call_589834.call(path_589835, query_589836, nil, nil, nil)

var dfareportingLandingPagesDelete* = Call_DfareportingLandingPagesDelete_589820(
    name: "dfareportingLandingPagesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages/{id}",
    validator: validate_DfareportingLandingPagesDelete_589821,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesDelete_589822,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsGet_589837 = ref object of OpenApiRestCall_588466
proc url_DfareportingCampaignsGet_589839(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsGet_589838(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one campaign by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589840 = path.getOrDefault("profileId")
  valid_589840 = validateParameter(valid_589840, JString, required = true,
                                 default = nil)
  if valid_589840 != nil:
    section.add "profileId", valid_589840
  var valid_589841 = path.getOrDefault("id")
  valid_589841 = validateParameter(valid_589841, JString, required = true,
                                 default = nil)
  if valid_589841 != nil:
    section.add "id", valid_589841
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589842 = query.getOrDefault("fields")
  valid_589842 = validateParameter(valid_589842, JString, required = false,
                                 default = nil)
  if valid_589842 != nil:
    section.add "fields", valid_589842
  var valid_589843 = query.getOrDefault("quotaUser")
  valid_589843 = validateParameter(valid_589843, JString, required = false,
                                 default = nil)
  if valid_589843 != nil:
    section.add "quotaUser", valid_589843
  var valid_589844 = query.getOrDefault("alt")
  valid_589844 = validateParameter(valid_589844, JString, required = false,
                                 default = newJString("json"))
  if valid_589844 != nil:
    section.add "alt", valid_589844
  var valid_589845 = query.getOrDefault("oauth_token")
  valid_589845 = validateParameter(valid_589845, JString, required = false,
                                 default = nil)
  if valid_589845 != nil:
    section.add "oauth_token", valid_589845
  var valid_589846 = query.getOrDefault("userIp")
  valid_589846 = validateParameter(valid_589846, JString, required = false,
                                 default = nil)
  if valid_589846 != nil:
    section.add "userIp", valid_589846
  var valid_589847 = query.getOrDefault("key")
  valid_589847 = validateParameter(valid_589847, JString, required = false,
                                 default = nil)
  if valid_589847 != nil:
    section.add "key", valid_589847
  var valid_589848 = query.getOrDefault("prettyPrint")
  valid_589848 = validateParameter(valid_589848, JBool, required = false,
                                 default = newJBool(true))
  if valid_589848 != nil:
    section.add "prettyPrint", valid_589848
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589849: Call_DfareportingCampaignsGet_589837; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one campaign by ID.
  ## 
  let valid = call_589849.validator(path, query, header, formData, body)
  let scheme = call_589849.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589849.url(scheme.get, call_589849.host, call_589849.base,
                         call_589849.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589849, url, valid)

proc call*(call_589850: Call_DfareportingCampaignsGet_589837; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsGet
  ## Gets one campaign by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Campaign ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589851 = newJObject()
  var query_589852 = newJObject()
  add(path_589851, "profileId", newJString(profileId))
  add(query_589852, "fields", newJString(fields))
  add(query_589852, "quotaUser", newJString(quotaUser))
  add(query_589852, "alt", newJString(alt))
  add(query_589852, "oauth_token", newJString(oauthToken))
  add(query_589852, "userIp", newJString(userIp))
  add(path_589851, "id", newJString(id))
  add(query_589852, "key", newJString(key))
  add(query_589852, "prettyPrint", newJBool(prettyPrint))
  result = call_589850.call(path_589851, query_589852, nil, nil, nil)

var dfareportingCampaignsGet* = Call_DfareportingCampaignsGet_589837(
    name: "dfareportingCampaignsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{id}",
    validator: validate_DfareportingCampaignsGet_589838,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsGet_589839,
    schemes: {Scheme.Https})
type
  Call_DfareportingChangeLogsList_589853 = ref object of OpenApiRestCall_588466
proc url_DfareportingChangeLogsList_589855(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/changeLogs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingChangeLogsList_589854(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of change logs. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589856 = path.getOrDefault("profileId")
  valid_589856 = validateParameter(valid_589856, JString, required = true,
                                 default = nil)
  if valid_589856 != nil:
    section.add "profileId", valid_589856
  result.add "path", section
  ## parameters in `query` object:
  ##   action: JString
  ##         : Select only change logs with the specified action.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   minChangeTime: JString
  ##                : Select only change logs whose change time is before the specified minChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Select only change logs whose object ID, user name, old or new values match the search string.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   maxChangeTime: JString
  ##                : Select only change logs whose change time is before the specified maxChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   ids: JArray
  ##      : Select only change logs with these IDs.
  ##   objectType: JString
  ##             : Select only change logs with the specified object type.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   objectIds: JArray
  ##            : Select only change logs with these object IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   userProfileIds: JArray
  ##                 : Select only change logs with these user profile IDs.
  section = newJObject()
  var valid_589857 = query.getOrDefault("action")
  valid_589857 = validateParameter(valid_589857, JString, required = false,
                                 default = newJString("ACTION_ADD"))
  if valid_589857 != nil:
    section.add "action", valid_589857
  var valid_589858 = query.getOrDefault("fields")
  valid_589858 = validateParameter(valid_589858, JString, required = false,
                                 default = nil)
  if valid_589858 != nil:
    section.add "fields", valid_589858
  var valid_589859 = query.getOrDefault("pageToken")
  valid_589859 = validateParameter(valid_589859, JString, required = false,
                                 default = nil)
  if valid_589859 != nil:
    section.add "pageToken", valid_589859
  var valid_589860 = query.getOrDefault("quotaUser")
  valid_589860 = validateParameter(valid_589860, JString, required = false,
                                 default = nil)
  if valid_589860 != nil:
    section.add "quotaUser", valid_589860
  var valid_589861 = query.getOrDefault("minChangeTime")
  valid_589861 = validateParameter(valid_589861, JString, required = false,
                                 default = nil)
  if valid_589861 != nil:
    section.add "minChangeTime", valid_589861
  var valid_589862 = query.getOrDefault("alt")
  valid_589862 = validateParameter(valid_589862, JString, required = false,
                                 default = newJString("json"))
  if valid_589862 != nil:
    section.add "alt", valid_589862
  var valid_589863 = query.getOrDefault("searchString")
  valid_589863 = validateParameter(valid_589863, JString, required = false,
                                 default = nil)
  if valid_589863 != nil:
    section.add "searchString", valid_589863
  var valid_589864 = query.getOrDefault("oauth_token")
  valid_589864 = validateParameter(valid_589864, JString, required = false,
                                 default = nil)
  if valid_589864 != nil:
    section.add "oauth_token", valid_589864
  var valid_589865 = query.getOrDefault("userIp")
  valid_589865 = validateParameter(valid_589865, JString, required = false,
                                 default = nil)
  if valid_589865 != nil:
    section.add "userIp", valid_589865
  var valid_589866 = query.getOrDefault("maxResults")
  valid_589866 = validateParameter(valid_589866, JInt, required = false,
                                 default = newJInt(1000))
  if valid_589866 != nil:
    section.add "maxResults", valid_589866
  var valid_589867 = query.getOrDefault("maxChangeTime")
  valid_589867 = validateParameter(valid_589867, JString, required = false,
                                 default = nil)
  if valid_589867 != nil:
    section.add "maxChangeTime", valid_589867
  var valid_589868 = query.getOrDefault("ids")
  valid_589868 = validateParameter(valid_589868, JArray, required = false,
                                 default = nil)
  if valid_589868 != nil:
    section.add "ids", valid_589868
  var valid_589869 = query.getOrDefault("objectType")
  valid_589869 = validateParameter(valid_589869, JString, required = false,
                                 default = newJString("OBJECT_ACCOUNT"))
  if valid_589869 != nil:
    section.add "objectType", valid_589869
  var valid_589870 = query.getOrDefault("key")
  valid_589870 = validateParameter(valid_589870, JString, required = false,
                                 default = nil)
  if valid_589870 != nil:
    section.add "key", valid_589870
  var valid_589871 = query.getOrDefault("objectIds")
  valid_589871 = validateParameter(valid_589871, JArray, required = false,
                                 default = nil)
  if valid_589871 != nil:
    section.add "objectIds", valid_589871
  var valid_589872 = query.getOrDefault("prettyPrint")
  valid_589872 = validateParameter(valid_589872, JBool, required = false,
                                 default = newJBool(true))
  if valid_589872 != nil:
    section.add "prettyPrint", valid_589872
  var valid_589873 = query.getOrDefault("userProfileIds")
  valid_589873 = validateParameter(valid_589873, JArray, required = false,
                                 default = nil)
  if valid_589873 != nil:
    section.add "userProfileIds", valid_589873
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589874: Call_DfareportingChangeLogsList_589853; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of change logs. This method supports paging.
  ## 
  let valid = call_589874.validator(path, query, header, formData, body)
  let scheme = call_589874.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589874.url(scheme.get, call_589874.host, call_589874.base,
                         call_589874.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589874, url, valid)

proc call*(call_589875: Call_DfareportingChangeLogsList_589853; profileId: string;
          action: string = "ACTION_ADD"; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; minChangeTime: string = ""; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; maxChangeTime: string = ""; ids: JsonNode = nil;
          objectType: string = "OBJECT_ACCOUNT"; key: string = "";
          objectIds: JsonNode = nil; prettyPrint: bool = true;
          userProfileIds: JsonNode = nil): Recallable =
  ## dfareportingChangeLogsList
  ## Retrieves a list of change logs. This method supports paging.
  ##   action: string
  ##         : Select only change logs with the specified action.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   minChangeTime: string
  ##                : Select only change logs whose change time is before the specified minChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Select only change logs whose object ID, user name, old or new values match the search string.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   maxChangeTime: string
  ##                : Select only change logs whose change time is before the specified maxChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   ids: JArray
  ##      : Select only change logs with these IDs.
  ##   objectType: string
  ##             : Select only change logs with the specified object type.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   objectIds: JArray
  ##            : Select only change logs with these object IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userProfileIds: JArray
  ##                 : Select only change logs with these user profile IDs.
  var path_589876 = newJObject()
  var query_589877 = newJObject()
  add(query_589877, "action", newJString(action))
  add(path_589876, "profileId", newJString(profileId))
  add(query_589877, "fields", newJString(fields))
  add(query_589877, "pageToken", newJString(pageToken))
  add(query_589877, "quotaUser", newJString(quotaUser))
  add(query_589877, "minChangeTime", newJString(minChangeTime))
  add(query_589877, "alt", newJString(alt))
  add(query_589877, "searchString", newJString(searchString))
  add(query_589877, "oauth_token", newJString(oauthToken))
  add(query_589877, "userIp", newJString(userIp))
  add(query_589877, "maxResults", newJInt(maxResults))
  add(query_589877, "maxChangeTime", newJString(maxChangeTime))
  if ids != nil:
    query_589877.add "ids", ids
  add(query_589877, "objectType", newJString(objectType))
  add(query_589877, "key", newJString(key))
  if objectIds != nil:
    query_589877.add "objectIds", objectIds
  add(query_589877, "prettyPrint", newJBool(prettyPrint))
  if userProfileIds != nil:
    query_589877.add "userProfileIds", userProfileIds
  result = call_589875.call(path_589876, query_589877, nil, nil, nil)

var dfareportingChangeLogsList* = Call_DfareportingChangeLogsList_589853(
    name: "dfareportingChangeLogsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/changeLogs",
    validator: validate_DfareportingChangeLogsList_589854,
    base: "/dfareporting/v2.7", url: url_DfareportingChangeLogsList_589855,
    schemes: {Scheme.Https})
type
  Call_DfareportingChangeLogsGet_589878 = ref object of OpenApiRestCall_588466
proc url_DfareportingChangeLogsGet_589880(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/changeLogs/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingChangeLogsGet_589879(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one change log by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Change log ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589881 = path.getOrDefault("profileId")
  valid_589881 = validateParameter(valid_589881, JString, required = true,
                                 default = nil)
  if valid_589881 != nil:
    section.add "profileId", valid_589881
  var valid_589882 = path.getOrDefault("id")
  valid_589882 = validateParameter(valid_589882, JString, required = true,
                                 default = nil)
  if valid_589882 != nil:
    section.add "id", valid_589882
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589883 = query.getOrDefault("fields")
  valid_589883 = validateParameter(valid_589883, JString, required = false,
                                 default = nil)
  if valid_589883 != nil:
    section.add "fields", valid_589883
  var valid_589884 = query.getOrDefault("quotaUser")
  valid_589884 = validateParameter(valid_589884, JString, required = false,
                                 default = nil)
  if valid_589884 != nil:
    section.add "quotaUser", valid_589884
  var valid_589885 = query.getOrDefault("alt")
  valid_589885 = validateParameter(valid_589885, JString, required = false,
                                 default = newJString("json"))
  if valid_589885 != nil:
    section.add "alt", valid_589885
  var valid_589886 = query.getOrDefault("oauth_token")
  valid_589886 = validateParameter(valid_589886, JString, required = false,
                                 default = nil)
  if valid_589886 != nil:
    section.add "oauth_token", valid_589886
  var valid_589887 = query.getOrDefault("userIp")
  valid_589887 = validateParameter(valid_589887, JString, required = false,
                                 default = nil)
  if valid_589887 != nil:
    section.add "userIp", valid_589887
  var valid_589888 = query.getOrDefault("key")
  valid_589888 = validateParameter(valid_589888, JString, required = false,
                                 default = nil)
  if valid_589888 != nil:
    section.add "key", valid_589888
  var valid_589889 = query.getOrDefault("prettyPrint")
  valid_589889 = validateParameter(valid_589889, JBool, required = false,
                                 default = newJBool(true))
  if valid_589889 != nil:
    section.add "prettyPrint", valid_589889
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589890: Call_DfareportingChangeLogsGet_589878; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one change log by ID.
  ## 
  let valid = call_589890.validator(path, query, header, formData, body)
  let scheme = call_589890.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589890.url(scheme.get, call_589890.host, call_589890.base,
                         call_589890.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589890, url, valid)

proc call*(call_589891: Call_DfareportingChangeLogsGet_589878; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingChangeLogsGet
  ## Gets one change log by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Change log ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589892 = newJObject()
  var query_589893 = newJObject()
  add(path_589892, "profileId", newJString(profileId))
  add(query_589893, "fields", newJString(fields))
  add(query_589893, "quotaUser", newJString(quotaUser))
  add(query_589893, "alt", newJString(alt))
  add(query_589893, "oauth_token", newJString(oauthToken))
  add(query_589893, "userIp", newJString(userIp))
  add(path_589892, "id", newJString(id))
  add(query_589893, "key", newJString(key))
  add(query_589893, "prettyPrint", newJBool(prettyPrint))
  result = call_589891.call(path_589892, query_589893, nil, nil, nil)

var dfareportingChangeLogsGet* = Call_DfareportingChangeLogsGet_589878(
    name: "dfareportingChangeLogsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/changeLogs/{id}",
    validator: validate_DfareportingChangeLogsGet_589879,
    base: "/dfareporting/v2.7", url: url_DfareportingChangeLogsGet_589880,
    schemes: {Scheme.Https})
type
  Call_DfareportingCitiesList_589894 = ref object of OpenApiRestCall_588466
proc url_DfareportingCitiesList_589896(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/cities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCitiesList_589895(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of cities, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589897 = path.getOrDefault("profileId")
  valid_589897 = validateParameter(valid_589897, JString, required = true,
                                 default = nil)
  if valid_589897 != nil:
    section.add "profileId", valid_589897
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   namePrefix: JString
  ##             : Select only cities with names starting with this prefix.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   countryDartIds: JArray
  ##                 : Select only cities from these countries.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   regionDartIds: JArray
  ##                : Select only cities from these regions.
  ##   dartIds: JArray
  ##          : Select only cities with these DART IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589898 = query.getOrDefault("fields")
  valid_589898 = validateParameter(valid_589898, JString, required = false,
                                 default = nil)
  if valid_589898 != nil:
    section.add "fields", valid_589898
  var valid_589899 = query.getOrDefault("quotaUser")
  valid_589899 = validateParameter(valid_589899, JString, required = false,
                                 default = nil)
  if valid_589899 != nil:
    section.add "quotaUser", valid_589899
  var valid_589900 = query.getOrDefault("alt")
  valid_589900 = validateParameter(valid_589900, JString, required = false,
                                 default = newJString("json"))
  if valid_589900 != nil:
    section.add "alt", valid_589900
  var valid_589901 = query.getOrDefault("namePrefix")
  valid_589901 = validateParameter(valid_589901, JString, required = false,
                                 default = nil)
  if valid_589901 != nil:
    section.add "namePrefix", valid_589901
  var valid_589902 = query.getOrDefault("oauth_token")
  valid_589902 = validateParameter(valid_589902, JString, required = false,
                                 default = nil)
  if valid_589902 != nil:
    section.add "oauth_token", valid_589902
  var valid_589903 = query.getOrDefault("userIp")
  valid_589903 = validateParameter(valid_589903, JString, required = false,
                                 default = nil)
  if valid_589903 != nil:
    section.add "userIp", valid_589903
  var valid_589904 = query.getOrDefault("countryDartIds")
  valid_589904 = validateParameter(valid_589904, JArray, required = false,
                                 default = nil)
  if valid_589904 != nil:
    section.add "countryDartIds", valid_589904
  var valid_589905 = query.getOrDefault("key")
  valid_589905 = validateParameter(valid_589905, JString, required = false,
                                 default = nil)
  if valid_589905 != nil:
    section.add "key", valid_589905
  var valid_589906 = query.getOrDefault("regionDartIds")
  valid_589906 = validateParameter(valid_589906, JArray, required = false,
                                 default = nil)
  if valid_589906 != nil:
    section.add "regionDartIds", valid_589906
  var valid_589907 = query.getOrDefault("dartIds")
  valid_589907 = validateParameter(valid_589907, JArray, required = false,
                                 default = nil)
  if valid_589907 != nil:
    section.add "dartIds", valid_589907
  var valid_589908 = query.getOrDefault("prettyPrint")
  valid_589908 = validateParameter(valid_589908, JBool, required = false,
                                 default = newJBool(true))
  if valid_589908 != nil:
    section.add "prettyPrint", valid_589908
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589909: Call_DfareportingCitiesList_589894; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of cities, possibly filtered.
  ## 
  let valid = call_589909.validator(path, query, header, formData, body)
  let scheme = call_589909.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589909.url(scheme.get, call_589909.host, call_589909.base,
                         call_589909.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589909, url, valid)

proc call*(call_589910: Call_DfareportingCitiesList_589894; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          namePrefix: string = ""; oauthToken: string = ""; userIp: string = "";
          countryDartIds: JsonNode = nil; key: string = "";
          regionDartIds: JsonNode = nil; dartIds: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCitiesList
  ## Retrieves a list of cities, possibly filtered.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   namePrefix: string
  ##             : Select only cities with names starting with this prefix.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   countryDartIds: JArray
  ##                 : Select only cities from these countries.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   regionDartIds: JArray
  ##                : Select only cities from these regions.
  ##   dartIds: JArray
  ##          : Select only cities with these DART IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589911 = newJObject()
  var query_589912 = newJObject()
  add(path_589911, "profileId", newJString(profileId))
  add(query_589912, "fields", newJString(fields))
  add(query_589912, "quotaUser", newJString(quotaUser))
  add(query_589912, "alt", newJString(alt))
  add(query_589912, "namePrefix", newJString(namePrefix))
  add(query_589912, "oauth_token", newJString(oauthToken))
  add(query_589912, "userIp", newJString(userIp))
  if countryDartIds != nil:
    query_589912.add "countryDartIds", countryDartIds
  add(query_589912, "key", newJString(key))
  if regionDartIds != nil:
    query_589912.add "regionDartIds", regionDartIds
  if dartIds != nil:
    query_589912.add "dartIds", dartIds
  add(query_589912, "prettyPrint", newJBool(prettyPrint))
  result = call_589910.call(path_589911, query_589912, nil, nil, nil)

var dfareportingCitiesList* = Call_DfareportingCitiesList_589894(
    name: "dfareportingCitiesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/cities",
    validator: validate_DfareportingCitiesList_589895, base: "/dfareporting/v2.7",
    url: url_DfareportingCitiesList_589896, schemes: {Scheme.Https})
type
  Call_DfareportingConnectionTypesList_589913 = ref object of OpenApiRestCall_588466
proc url_DfareportingConnectionTypesList_589915(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/connectionTypes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingConnectionTypesList_589914(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of connection types.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589916 = path.getOrDefault("profileId")
  valid_589916 = validateParameter(valid_589916, JString, required = true,
                                 default = nil)
  if valid_589916 != nil:
    section.add "profileId", valid_589916
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589917 = query.getOrDefault("fields")
  valid_589917 = validateParameter(valid_589917, JString, required = false,
                                 default = nil)
  if valid_589917 != nil:
    section.add "fields", valid_589917
  var valid_589918 = query.getOrDefault("quotaUser")
  valid_589918 = validateParameter(valid_589918, JString, required = false,
                                 default = nil)
  if valid_589918 != nil:
    section.add "quotaUser", valid_589918
  var valid_589919 = query.getOrDefault("alt")
  valid_589919 = validateParameter(valid_589919, JString, required = false,
                                 default = newJString("json"))
  if valid_589919 != nil:
    section.add "alt", valid_589919
  var valid_589920 = query.getOrDefault("oauth_token")
  valid_589920 = validateParameter(valid_589920, JString, required = false,
                                 default = nil)
  if valid_589920 != nil:
    section.add "oauth_token", valid_589920
  var valid_589921 = query.getOrDefault("userIp")
  valid_589921 = validateParameter(valid_589921, JString, required = false,
                                 default = nil)
  if valid_589921 != nil:
    section.add "userIp", valid_589921
  var valid_589922 = query.getOrDefault("key")
  valid_589922 = validateParameter(valid_589922, JString, required = false,
                                 default = nil)
  if valid_589922 != nil:
    section.add "key", valid_589922
  var valid_589923 = query.getOrDefault("prettyPrint")
  valid_589923 = validateParameter(valid_589923, JBool, required = false,
                                 default = newJBool(true))
  if valid_589923 != nil:
    section.add "prettyPrint", valid_589923
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589924: Call_DfareportingConnectionTypesList_589913;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of connection types.
  ## 
  let valid = call_589924.validator(path, query, header, formData, body)
  let scheme = call_589924.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589924.url(scheme.get, call_589924.host, call_589924.base,
                         call_589924.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589924, url, valid)

proc call*(call_589925: Call_DfareportingConnectionTypesList_589913;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingConnectionTypesList
  ## Retrieves a list of connection types.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589926 = newJObject()
  var query_589927 = newJObject()
  add(path_589926, "profileId", newJString(profileId))
  add(query_589927, "fields", newJString(fields))
  add(query_589927, "quotaUser", newJString(quotaUser))
  add(query_589927, "alt", newJString(alt))
  add(query_589927, "oauth_token", newJString(oauthToken))
  add(query_589927, "userIp", newJString(userIp))
  add(query_589927, "key", newJString(key))
  add(query_589927, "prettyPrint", newJBool(prettyPrint))
  result = call_589925.call(path_589926, query_589927, nil, nil, nil)

var dfareportingConnectionTypesList* = Call_DfareportingConnectionTypesList_589913(
    name: "dfareportingConnectionTypesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/connectionTypes",
    validator: validate_DfareportingConnectionTypesList_589914,
    base: "/dfareporting/v2.7", url: url_DfareportingConnectionTypesList_589915,
    schemes: {Scheme.Https})
type
  Call_DfareportingConnectionTypesGet_589928 = ref object of OpenApiRestCall_588466
proc url_DfareportingConnectionTypesGet_589930(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/connectionTypes/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingConnectionTypesGet_589929(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one connection type by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Connection type ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589931 = path.getOrDefault("profileId")
  valid_589931 = validateParameter(valid_589931, JString, required = true,
                                 default = nil)
  if valid_589931 != nil:
    section.add "profileId", valid_589931
  var valid_589932 = path.getOrDefault("id")
  valid_589932 = validateParameter(valid_589932, JString, required = true,
                                 default = nil)
  if valid_589932 != nil:
    section.add "id", valid_589932
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589933 = query.getOrDefault("fields")
  valid_589933 = validateParameter(valid_589933, JString, required = false,
                                 default = nil)
  if valid_589933 != nil:
    section.add "fields", valid_589933
  var valid_589934 = query.getOrDefault("quotaUser")
  valid_589934 = validateParameter(valid_589934, JString, required = false,
                                 default = nil)
  if valid_589934 != nil:
    section.add "quotaUser", valid_589934
  var valid_589935 = query.getOrDefault("alt")
  valid_589935 = validateParameter(valid_589935, JString, required = false,
                                 default = newJString("json"))
  if valid_589935 != nil:
    section.add "alt", valid_589935
  var valid_589936 = query.getOrDefault("oauth_token")
  valid_589936 = validateParameter(valid_589936, JString, required = false,
                                 default = nil)
  if valid_589936 != nil:
    section.add "oauth_token", valid_589936
  var valid_589937 = query.getOrDefault("userIp")
  valid_589937 = validateParameter(valid_589937, JString, required = false,
                                 default = nil)
  if valid_589937 != nil:
    section.add "userIp", valid_589937
  var valid_589938 = query.getOrDefault("key")
  valid_589938 = validateParameter(valid_589938, JString, required = false,
                                 default = nil)
  if valid_589938 != nil:
    section.add "key", valid_589938
  var valid_589939 = query.getOrDefault("prettyPrint")
  valid_589939 = validateParameter(valid_589939, JBool, required = false,
                                 default = newJBool(true))
  if valid_589939 != nil:
    section.add "prettyPrint", valid_589939
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589940: Call_DfareportingConnectionTypesGet_589928; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one connection type by ID.
  ## 
  let valid = call_589940.validator(path, query, header, formData, body)
  let scheme = call_589940.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589940.url(scheme.get, call_589940.host, call_589940.base,
                         call_589940.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589940, url, valid)

proc call*(call_589941: Call_DfareportingConnectionTypesGet_589928;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingConnectionTypesGet
  ## Gets one connection type by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Connection type ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589942 = newJObject()
  var query_589943 = newJObject()
  add(path_589942, "profileId", newJString(profileId))
  add(query_589943, "fields", newJString(fields))
  add(query_589943, "quotaUser", newJString(quotaUser))
  add(query_589943, "alt", newJString(alt))
  add(query_589943, "oauth_token", newJString(oauthToken))
  add(query_589943, "userIp", newJString(userIp))
  add(path_589942, "id", newJString(id))
  add(query_589943, "key", newJString(key))
  add(query_589943, "prettyPrint", newJBool(prettyPrint))
  result = call_589941.call(path_589942, query_589943, nil, nil, nil)

var dfareportingConnectionTypesGet* = Call_DfareportingConnectionTypesGet_589928(
    name: "dfareportingConnectionTypesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/connectionTypes/{id}",
    validator: validate_DfareportingConnectionTypesGet_589929,
    base: "/dfareporting/v2.7", url: url_DfareportingConnectionTypesGet_589930,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesUpdate_589965 = ref object of OpenApiRestCall_588466
proc url_DfareportingContentCategoriesUpdate_589967(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesUpdate_589966(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing content category.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589968 = path.getOrDefault("profileId")
  valid_589968 = validateParameter(valid_589968, JString, required = true,
                                 default = nil)
  if valid_589968 != nil:
    section.add "profileId", valid_589968
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589969 = query.getOrDefault("fields")
  valid_589969 = validateParameter(valid_589969, JString, required = false,
                                 default = nil)
  if valid_589969 != nil:
    section.add "fields", valid_589969
  var valid_589970 = query.getOrDefault("quotaUser")
  valid_589970 = validateParameter(valid_589970, JString, required = false,
                                 default = nil)
  if valid_589970 != nil:
    section.add "quotaUser", valid_589970
  var valid_589971 = query.getOrDefault("alt")
  valid_589971 = validateParameter(valid_589971, JString, required = false,
                                 default = newJString("json"))
  if valid_589971 != nil:
    section.add "alt", valid_589971
  var valid_589972 = query.getOrDefault("oauth_token")
  valid_589972 = validateParameter(valid_589972, JString, required = false,
                                 default = nil)
  if valid_589972 != nil:
    section.add "oauth_token", valid_589972
  var valid_589973 = query.getOrDefault("userIp")
  valid_589973 = validateParameter(valid_589973, JString, required = false,
                                 default = nil)
  if valid_589973 != nil:
    section.add "userIp", valid_589973
  var valid_589974 = query.getOrDefault("key")
  valid_589974 = validateParameter(valid_589974, JString, required = false,
                                 default = nil)
  if valid_589974 != nil:
    section.add "key", valid_589974
  var valid_589975 = query.getOrDefault("prettyPrint")
  valid_589975 = validateParameter(valid_589975, JBool, required = false,
                                 default = newJBool(true))
  if valid_589975 != nil:
    section.add "prettyPrint", valid_589975
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589977: Call_DfareportingContentCategoriesUpdate_589965;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing content category.
  ## 
  let valid = call_589977.validator(path, query, header, formData, body)
  let scheme = call_589977.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589977.url(scheme.get, call_589977.host, call_589977.base,
                         call_589977.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589977, url, valid)

proc call*(call_589978: Call_DfareportingContentCategoriesUpdate_589965;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesUpdate
  ## Updates an existing content category.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589979 = newJObject()
  var query_589980 = newJObject()
  var body_589981 = newJObject()
  add(path_589979, "profileId", newJString(profileId))
  add(query_589980, "fields", newJString(fields))
  add(query_589980, "quotaUser", newJString(quotaUser))
  add(query_589980, "alt", newJString(alt))
  add(query_589980, "oauth_token", newJString(oauthToken))
  add(query_589980, "userIp", newJString(userIp))
  add(query_589980, "key", newJString(key))
  if body != nil:
    body_589981 = body
  add(query_589980, "prettyPrint", newJBool(prettyPrint))
  result = call_589978.call(path_589979, query_589980, nil, nil, body_589981)

var dfareportingContentCategoriesUpdate* = Call_DfareportingContentCategoriesUpdate_589965(
    name: "dfareportingContentCategoriesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesUpdate_589966,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesUpdate_589967,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesInsert_589982 = ref object of OpenApiRestCall_588466
proc url_DfareportingContentCategoriesInsert_589984(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesInsert_589983(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new content category.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589985 = path.getOrDefault("profileId")
  valid_589985 = validateParameter(valid_589985, JString, required = true,
                                 default = nil)
  if valid_589985 != nil:
    section.add "profileId", valid_589985
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589986 = query.getOrDefault("fields")
  valid_589986 = validateParameter(valid_589986, JString, required = false,
                                 default = nil)
  if valid_589986 != nil:
    section.add "fields", valid_589986
  var valid_589987 = query.getOrDefault("quotaUser")
  valid_589987 = validateParameter(valid_589987, JString, required = false,
                                 default = nil)
  if valid_589987 != nil:
    section.add "quotaUser", valid_589987
  var valid_589988 = query.getOrDefault("alt")
  valid_589988 = validateParameter(valid_589988, JString, required = false,
                                 default = newJString("json"))
  if valid_589988 != nil:
    section.add "alt", valid_589988
  var valid_589989 = query.getOrDefault("oauth_token")
  valid_589989 = validateParameter(valid_589989, JString, required = false,
                                 default = nil)
  if valid_589989 != nil:
    section.add "oauth_token", valid_589989
  var valid_589990 = query.getOrDefault("userIp")
  valid_589990 = validateParameter(valid_589990, JString, required = false,
                                 default = nil)
  if valid_589990 != nil:
    section.add "userIp", valid_589990
  var valid_589991 = query.getOrDefault("key")
  valid_589991 = validateParameter(valid_589991, JString, required = false,
                                 default = nil)
  if valid_589991 != nil:
    section.add "key", valid_589991
  var valid_589992 = query.getOrDefault("prettyPrint")
  valid_589992 = validateParameter(valid_589992, JBool, required = false,
                                 default = newJBool(true))
  if valid_589992 != nil:
    section.add "prettyPrint", valid_589992
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_589994: Call_DfareportingContentCategoriesInsert_589982;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new content category.
  ## 
  let valid = call_589994.validator(path, query, header, formData, body)
  let scheme = call_589994.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589994.url(scheme.get, call_589994.host, call_589994.base,
                         call_589994.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589994, url, valid)

proc call*(call_589995: Call_DfareportingContentCategoriesInsert_589982;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesInsert
  ## Inserts a new content category.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589996 = newJObject()
  var query_589997 = newJObject()
  var body_589998 = newJObject()
  add(path_589996, "profileId", newJString(profileId))
  add(query_589997, "fields", newJString(fields))
  add(query_589997, "quotaUser", newJString(quotaUser))
  add(query_589997, "alt", newJString(alt))
  add(query_589997, "oauth_token", newJString(oauthToken))
  add(query_589997, "userIp", newJString(userIp))
  add(query_589997, "key", newJString(key))
  if body != nil:
    body_589998 = body
  add(query_589997, "prettyPrint", newJBool(prettyPrint))
  result = call_589995.call(path_589996, query_589997, nil, nil, body_589998)

var dfareportingContentCategoriesInsert* = Call_DfareportingContentCategoriesInsert_589982(
    name: "dfareportingContentCategoriesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesInsert_589983,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesInsert_589984,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesList_589944 = ref object of OpenApiRestCall_588466
proc url_DfareportingContentCategoriesList_589946(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesList_589945(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of content categories, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_589947 = path.getOrDefault("profileId")
  valid_589947 = validateParameter(valid_589947, JString, required = true,
                                 default = nil)
  if valid_589947 != nil:
    section.add "profileId", valid_589947
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "contentcategory*2015" will return objects with names like "contentcategory June 2015", "contentcategory April 2015", or simply "contentcategory 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "contentcategory" will match objects with name "my contentcategory", "contentcategory 2015", or simply "contentcategory".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only content categories with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_589948 = query.getOrDefault("fields")
  valid_589948 = validateParameter(valid_589948, JString, required = false,
                                 default = nil)
  if valid_589948 != nil:
    section.add "fields", valid_589948
  var valid_589949 = query.getOrDefault("pageToken")
  valid_589949 = validateParameter(valid_589949, JString, required = false,
                                 default = nil)
  if valid_589949 != nil:
    section.add "pageToken", valid_589949
  var valid_589950 = query.getOrDefault("quotaUser")
  valid_589950 = validateParameter(valid_589950, JString, required = false,
                                 default = nil)
  if valid_589950 != nil:
    section.add "quotaUser", valid_589950
  var valid_589951 = query.getOrDefault("sortField")
  valid_589951 = validateParameter(valid_589951, JString, required = false,
                                 default = newJString("ID"))
  if valid_589951 != nil:
    section.add "sortField", valid_589951
  var valid_589952 = query.getOrDefault("alt")
  valid_589952 = validateParameter(valid_589952, JString, required = false,
                                 default = newJString("json"))
  if valid_589952 != nil:
    section.add "alt", valid_589952
  var valid_589953 = query.getOrDefault("searchString")
  valid_589953 = validateParameter(valid_589953, JString, required = false,
                                 default = nil)
  if valid_589953 != nil:
    section.add "searchString", valid_589953
  var valid_589954 = query.getOrDefault("oauth_token")
  valid_589954 = validateParameter(valid_589954, JString, required = false,
                                 default = nil)
  if valid_589954 != nil:
    section.add "oauth_token", valid_589954
  var valid_589955 = query.getOrDefault("userIp")
  valid_589955 = validateParameter(valid_589955, JString, required = false,
                                 default = nil)
  if valid_589955 != nil:
    section.add "userIp", valid_589955
  var valid_589956 = query.getOrDefault("maxResults")
  valid_589956 = validateParameter(valid_589956, JInt, required = false,
                                 default = newJInt(1000))
  if valid_589956 != nil:
    section.add "maxResults", valid_589956
  var valid_589957 = query.getOrDefault("ids")
  valid_589957 = validateParameter(valid_589957, JArray, required = false,
                                 default = nil)
  if valid_589957 != nil:
    section.add "ids", valid_589957
  var valid_589958 = query.getOrDefault("key")
  valid_589958 = validateParameter(valid_589958, JString, required = false,
                                 default = nil)
  if valid_589958 != nil:
    section.add "key", valid_589958
  var valid_589959 = query.getOrDefault("sortOrder")
  valid_589959 = validateParameter(valid_589959, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_589959 != nil:
    section.add "sortOrder", valid_589959
  var valid_589960 = query.getOrDefault("prettyPrint")
  valid_589960 = validateParameter(valid_589960, JBool, required = false,
                                 default = newJBool(true))
  if valid_589960 != nil:
    section.add "prettyPrint", valid_589960
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_589961: Call_DfareportingContentCategoriesList_589944;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of content categories, possibly filtered. This method supports paging.
  ## 
  let valid = call_589961.validator(path, query, header, formData, body)
  let scheme = call_589961.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_589961.url(scheme.get, call_589961.host, call_589961.base,
                         call_589961.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_589961, url, valid)

proc call*(call_589962: Call_DfareportingContentCategoriesList_589944;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesList
  ## Retrieves a list of content categories, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "contentcategory*2015" will return objects with names like "contentcategory June 2015", "contentcategory April 2015", or simply "contentcategory 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "contentcategory" will match objects with name "my contentcategory", "contentcategory 2015", or simply "contentcategory".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only content categories with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_589963 = newJObject()
  var query_589964 = newJObject()
  add(path_589963, "profileId", newJString(profileId))
  add(query_589964, "fields", newJString(fields))
  add(query_589964, "pageToken", newJString(pageToken))
  add(query_589964, "quotaUser", newJString(quotaUser))
  add(query_589964, "sortField", newJString(sortField))
  add(query_589964, "alt", newJString(alt))
  add(query_589964, "searchString", newJString(searchString))
  add(query_589964, "oauth_token", newJString(oauthToken))
  add(query_589964, "userIp", newJString(userIp))
  add(query_589964, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_589964.add "ids", ids
  add(query_589964, "key", newJString(key))
  add(query_589964, "sortOrder", newJString(sortOrder))
  add(query_589964, "prettyPrint", newJBool(prettyPrint))
  result = call_589962.call(path_589963, query_589964, nil, nil, nil)

var dfareportingContentCategoriesList* = Call_DfareportingContentCategoriesList_589944(
    name: "dfareportingContentCategoriesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesList_589945,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesList_589946,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesPatch_589999 = ref object of OpenApiRestCall_588466
proc url_DfareportingContentCategoriesPatch_590001(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesPatch_590000(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing content category. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590002 = path.getOrDefault("profileId")
  valid_590002 = validateParameter(valid_590002, JString, required = true,
                                 default = nil)
  if valid_590002 != nil:
    section.add "profileId", valid_590002
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Content category ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590003 = query.getOrDefault("fields")
  valid_590003 = validateParameter(valid_590003, JString, required = false,
                                 default = nil)
  if valid_590003 != nil:
    section.add "fields", valid_590003
  var valid_590004 = query.getOrDefault("quotaUser")
  valid_590004 = validateParameter(valid_590004, JString, required = false,
                                 default = nil)
  if valid_590004 != nil:
    section.add "quotaUser", valid_590004
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_590005 = query.getOrDefault("id")
  valid_590005 = validateParameter(valid_590005, JString, required = true,
                                 default = nil)
  if valid_590005 != nil:
    section.add "id", valid_590005
  var valid_590006 = query.getOrDefault("alt")
  valid_590006 = validateParameter(valid_590006, JString, required = false,
                                 default = newJString("json"))
  if valid_590006 != nil:
    section.add "alt", valid_590006
  var valid_590007 = query.getOrDefault("oauth_token")
  valid_590007 = validateParameter(valid_590007, JString, required = false,
                                 default = nil)
  if valid_590007 != nil:
    section.add "oauth_token", valid_590007
  var valid_590008 = query.getOrDefault("userIp")
  valid_590008 = validateParameter(valid_590008, JString, required = false,
                                 default = nil)
  if valid_590008 != nil:
    section.add "userIp", valid_590008
  var valid_590009 = query.getOrDefault("key")
  valid_590009 = validateParameter(valid_590009, JString, required = false,
                                 default = nil)
  if valid_590009 != nil:
    section.add "key", valid_590009
  var valid_590010 = query.getOrDefault("prettyPrint")
  valid_590010 = validateParameter(valid_590010, JBool, required = false,
                                 default = newJBool(true))
  if valid_590010 != nil:
    section.add "prettyPrint", valid_590010
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590012: Call_DfareportingContentCategoriesPatch_589999;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing content category. This method supports patch semantics.
  ## 
  let valid = call_590012.validator(path, query, header, formData, body)
  let scheme = call_590012.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590012.url(scheme.get, call_590012.host, call_590012.base,
                         call_590012.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590012, url, valid)

proc call*(call_590013: Call_DfareportingContentCategoriesPatch_589999;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesPatch
  ## Updates an existing content category. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Content category ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590014 = newJObject()
  var query_590015 = newJObject()
  var body_590016 = newJObject()
  add(path_590014, "profileId", newJString(profileId))
  add(query_590015, "fields", newJString(fields))
  add(query_590015, "quotaUser", newJString(quotaUser))
  add(query_590015, "id", newJString(id))
  add(query_590015, "alt", newJString(alt))
  add(query_590015, "oauth_token", newJString(oauthToken))
  add(query_590015, "userIp", newJString(userIp))
  add(query_590015, "key", newJString(key))
  if body != nil:
    body_590016 = body
  add(query_590015, "prettyPrint", newJBool(prettyPrint))
  result = call_590013.call(path_590014, query_590015, nil, nil, body_590016)

var dfareportingContentCategoriesPatch* = Call_DfareportingContentCategoriesPatch_589999(
    name: "dfareportingContentCategoriesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesPatch_590000,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesPatch_590001,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesGet_590017 = ref object of OpenApiRestCall_588466
proc url_DfareportingContentCategoriesGet_590019(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesGet_590018(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one content category by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Content category ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590020 = path.getOrDefault("profileId")
  valid_590020 = validateParameter(valid_590020, JString, required = true,
                                 default = nil)
  if valid_590020 != nil:
    section.add "profileId", valid_590020
  var valid_590021 = path.getOrDefault("id")
  valid_590021 = validateParameter(valid_590021, JString, required = true,
                                 default = nil)
  if valid_590021 != nil:
    section.add "id", valid_590021
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590022 = query.getOrDefault("fields")
  valid_590022 = validateParameter(valid_590022, JString, required = false,
                                 default = nil)
  if valid_590022 != nil:
    section.add "fields", valid_590022
  var valid_590023 = query.getOrDefault("quotaUser")
  valid_590023 = validateParameter(valid_590023, JString, required = false,
                                 default = nil)
  if valid_590023 != nil:
    section.add "quotaUser", valid_590023
  var valid_590024 = query.getOrDefault("alt")
  valid_590024 = validateParameter(valid_590024, JString, required = false,
                                 default = newJString("json"))
  if valid_590024 != nil:
    section.add "alt", valid_590024
  var valid_590025 = query.getOrDefault("oauth_token")
  valid_590025 = validateParameter(valid_590025, JString, required = false,
                                 default = nil)
  if valid_590025 != nil:
    section.add "oauth_token", valid_590025
  var valid_590026 = query.getOrDefault("userIp")
  valid_590026 = validateParameter(valid_590026, JString, required = false,
                                 default = nil)
  if valid_590026 != nil:
    section.add "userIp", valid_590026
  var valid_590027 = query.getOrDefault("key")
  valid_590027 = validateParameter(valid_590027, JString, required = false,
                                 default = nil)
  if valid_590027 != nil:
    section.add "key", valid_590027
  var valid_590028 = query.getOrDefault("prettyPrint")
  valid_590028 = validateParameter(valid_590028, JBool, required = false,
                                 default = newJBool(true))
  if valid_590028 != nil:
    section.add "prettyPrint", valid_590028
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590029: Call_DfareportingContentCategoriesGet_590017;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one content category by ID.
  ## 
  let valid = call_590029.validator(path, query, header, formData, body)
  let scheme = call_590029.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590029.url(scheme.get, call_590029.host, call_590029.base,
                         call_590029.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590029, url, valid)

proc call*(call_590030: Call_DfareportingContentCategoriesGet_590017;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesGet
  ## Gets one content category by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Content category ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590031 = newJObject()
  var query_590032 = newJObject()
  add(path_590031, "profileId", newJString(profileId))
  add(query_590032, "fields", newJString(fields))
  add(query_590032, "quotaUser", newJString(quotaUser))
  add(query_590032, "alt", newJString(alt))
  add(query_590032, "oauth_token", newJString(oauthToken))
  add(query_590032, "userIp", newJString(userIp))
  add(path_590031, "id", newJString(id))
  add(query_590032, "key", newJString(key))
  add(query_590032, "prettyPrint", newJBool(prettyPrint))
  result = call_590030.call(path_590031, query_590032, nil, nil, nil)

var dfareportingContentCategoriesGet* = Call_DfareportingContentCategoriesGet_590017(
    name: "dfareportingContentCategoriesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories/{id}",
    validator: validate_DfareportingContentCategoriesGet_590018,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesGet_590019,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesDelete_590033 = ref object of OpenApiRestCall_588466
proc url_DfareportingContentCategoriesDelete_590035(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesDelete_590034(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing content category.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Content category ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590036 = path.getOrDefault("profileId")
  valid_590036 = validateParameter(valid_590036, JString, required = true,
                                 default = nil)
  if valid_590036 != nil:
    section.add "profileId", valid_590036
  var valid_590037 = path.getOrDefault("id")
  valid_590037 = validateParameter(valid_590037, JString, required = true,
                                 default = nil)
  if valid_590037 != nil:
    section.add "id", valid_590037
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590038 = query.getOrDefault("fields")
  valid_590038 = validateParameter(valid_590038, JString, required = false,
                                 default = nil)
  if valid_590038 != nil:
    section.add "fields", valid_590038
  var valid_590039 = query.getOrDefault("quotaUser")
  valid_590039 = validateParameter(valid_590039, JString, required = false,
                                 default = nil)
  if valid_590039 != nil:
    section.add "quotaUser", valid_590039
  var valid_590040 = query.getOrDefault("alt")
  valid_590040 = validateParameter(valid_590040, JString, required = false,
                                 default = newJString("json"))
  if valid_590040 != nil:
    section.add "alt", valid_590040
  var valid_590041 = query.getOrDefault("oauth_token")
  valid_590041 = validateParameter(valid_590041, JString, required = false,
                                 default = nil)
  if valid_590041 != nil:
    section.add "oauth_token", valid_590041
  var valid_590042 = query.getOrDefault("userIp")
  valid_590042 = validateParameter(valid_590042, JString, required = false,
                                 default = nil)
  if valid_590042 != nil:
    section.add "userIp", valid_590042
  var valid_590043 = query.getOrDefault("key")
  valid_590043 = validateParameter(valid_590043, JString, required = false,
                                 default = nil)
  if valid_590043 != nil:
    section.add "key", valid_590043
  var valid_590044 = query.getOrDefault("prettyPrint")
  valid_590044 = validateParameter(valid_590044, JBool, required = false,
                                 default = newJBool(true))
  if valid_590044 != nil:
    section.add "prettyPrint", valid_590044
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590045: Call_DfareportingContentCategoriesDelete_590033;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing content category.
  ## 
  let valid = call_590045.validator(path, query, header, formData, body)
  let scheme = call_590045.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590045.url(scheme.get, call_590045.host, call_590045.base,
                         call_590045.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590045, url, valid)

proc call*(call_590046: Call_DfareportingContentCategoriesDelete_590033;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesDelete
  ## Deletes an existing content category.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Content category ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590047 = newJObject()
  var query_590048 = newJObject()
  add(path_590047, "profileId", newJString(profileId))
  add(query_590048, "fields", newJString(fields))
  add(query_590048, "quotaUser", newJString(quotaUser))
  add(query_590048, "alt", newJString(alt))
  add(query_590048, "oauth_token", newJString(oauthToken))
  add(query_590048, "userIp", newJString(userIp))
  add(path_590047, "id", newJString(id))
  add(query_590048, "key", newJString(key))
  add(query_590048, "prettyPrint", newJBool(prettyPrint))
  result = call_590046.call(path_590047, query_590048, nil, nil, nil)

var dfareportingContentCategoriesDelete* = Call_DfareportingContentCategoriesDelete_590033(
    name: "dfareportingContentCategoriesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories/{id}",
    validator: validate_DfareportingContentCategoriesDelete_590034,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesDelete_590035,
    schemes: {Scheme.Https})
type
  Call_DfareportingConversionsBatchinsert_590049 = ref object of OpenApiRestCall_588466
proc url_DfareportingConversionsBatchinsert_590051(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/conversions/batchinsert")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingConversionsBatchinsert_590050(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts conversions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590052 = path.getOrDefault("profileId")
  valid_590052 = validateParameter(valid_590052, JString, required = true,
                                 default = nil)
  if valid_590052 != nil:
    section.add "profileId", valid_590052
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590053 = query.getOrDefault("fields")
  valid_590053 = validateParameter(valid_590053, JString, required = false,
                                 default = nil)
  if valid_590053 != nil:
    section.add "fields", valid_590053
  var valid_590054 = query.getOrDefault("quotaUser")
  valid_590054 = validateParameter(valid_590054, JString, required = false,
                                 default = nil)
  if valid_590054 != nil:
    section.add "quotaUser", valid_590054
  var valid_590055 = query.getOrDefault("alt")
  valid_590055 = validateParameter(valid_590055, JString, required = false,
                                 default = newJString("json"))
  if valid_590055 != nil:
    section.add "alt", valid_590055
  var valid_590056 = query.getOrDefault("oauth_token")
  valid_590056 = validateParameter(valid_590056, JString, required = false,
                                 default = nil)
  if valid_590056 != nil:
    section.add "oauth_token", valid_590056
  var valid_590057 = query.getOrDefault("userIp")
  valid_590057 = validateParameter(valid_590057, JString, required = false,
                                 default = nil)
  if valid_590057 != nil:
    section.add "userIp", valid_590057
  var valid_590058 = query.getOrDefault("key")
  valid_590058 = validateParameter(valid_590058, JString, required = false,
                                 default = nil)
  if valid_590058 != nil:
    section.add "key", valid_590058
  var valid_590059 = query.getOrDefault("prettyPrint")
  valid_590059 = validateParameter(valid_590059, JBool, required = false,
                                 default = newJBool(true))
  if valid_590059 != nil:
    section.add "prettyPrint", valid_590059
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590061: Call_DfareportingConversionsBatchinsert_590049;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts conversions.
  ## 
  let valid = call_590061.validator(path, query, header, formData, body)
  let scheme = call_590061.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590061.url(scheme.get, call_590061.host, call_590061.base,
                         call_590061.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590061, url, valid)

proc call*(call_590062: Call_DfareportingConversionsBatchinsert_590049;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingConversionsBatchinsert
  ## Inserts conversions.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590063 = newJObject()
  var query_590064 = newJObject()
  var body_590065 = newJObject()
  add(path_590063, "profileId", newJString(profileId))
  add(query_590064, "fields", newJString(fields))
  add(query_590064, "quotaUser", newJString(quotaUser))
  add(query_590064, "alt", newJString(alt))
  add(query_590064, "oauth_token", newJString(oauthToken))
  add(query_590064, "userIp", newJString(userIp))
  add(query_590064, "key", newJString(key))
  if body != nil:
    body_590065 = body
  add(query_590064, "prettyPrint", newJBool(prettyPrint))
  result = call_590062.call(path_590063, query_590064, nil, nil, body_590065)

var dfareportingConversionsBatchinsert* = Call_DfareportingConversionsBatchinsert_590049(
    name: "dfareportingConversionsBatchinsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/conversions/batchinsert",
    validator: validate_DfareportingConversionsBatchinsert_590050,
    base: "/dfareporting/v2.7", url: url_DfareportingConversionsBatchinsert_590051,
    schemes: {Scheme.Https})
type
  Call_DfareportingCountriesList_590066 = ref object of OpenApiRestCall_588466
proc url_DfareportingCountriesList_590068(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/countries")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCountriesList_590067(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of countries.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590069 = path.getOrDefault("profileId")
  valid_590069 = validateParameter(valid_590069, JString, required = true,
                                 default = nil)
  if valid_590069 != nil:
    section.add "profileId", valid_590069
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590070 = query.getOrDefault("fields")
  valid_590070 = validateParameter(valid_590070, JString, required = false,
                                 default = nil)
  if valid_590070 != nil:
    section.add "fields", valid_590070
  var valid_590071 = query.getOrDefault("quotaUser")
  valid_590071 = validateParameter(valid_590071, JString, required = false,
                                 default = nil)
  if valid_590071 != nil:
    section.add "quotaUser", valid_590071
  var valid_590072 = query.getOrDefault("alt")
  valid_590072 = validateParameter(valid_590072, JString, required = false,
                                 default = newJString("json"))
  if valid_590072 != nil:
    section.add "alt", valid_590072
  var valid_590073 = query.getOrDefault("oauth_token")
  valid_590073 = validateParameter(valid_590073, JString, required = false,
                                 default = nil)
  if valid_590073 != nil:
    section.add "oauth_token", valid_590073
  var valid_590074 = query.getOrDefault("userIp")
  valid_590074 = validateParameter(valid_590074, JString, required = false,
                                 default = nil)
  if valid_590074 != nil:
    section.add "userIp", valid_590074
  var valid_590075 = query.getOrDefault("key")
  valid_590075 = validateParameter(valid_590075, JString, required = false,
                                 default = nil)
  if valid_590075 != nil:
    section.add "key", valid_590075
  var valid_590076 = query.getOrDefault("prettyPrint")
  valid_590076 = validateParameter(valid_590076, JBool, required = false,
                                 default = newJBool(true))
  if valid_590076 != nil:
    section.add "prettyPrint", valid_590076
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590077: Call_DfareportingCountriesList_590066; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of countries.
  ## 
  let valid = call_590077.validator(path, query, header, formData, body)
  let scheme = call_590077.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590077.url(scheme.get, call_590077.host, call_590077.base,
                         call_590077.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590077, url, valid)

proc call*(call_590078: Call_DfareportingCountriesList_590066; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingCountriesList
  ## Retrieves a list of countries.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590079 = newJObject()
  var query_590080 = newJObject()
  add(path_590079, "profileId", newJString(profileId))
  add(query_590080, "fields", newJString(fields))
  add(query_590080, "quotaUser", newJString(quotaUser))
  add(query_590080, "alt", newJString(alt))
  add(query_590080, "oauth_token", newJString(oauthToken))
  add(query_590080, "userIp", newJString(userIp))
  add(query_590080, "key", newJString(key))
  add(query_590080, "prettyPrint", newJBool(prettyPrint))
  result = call_590078.call(path_590079, query_590080, nil, nil, nil)

var dfareportingCountriesList* = Call_DfareportingCountriesList_590066(
    name: "dfareportingCountriesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/countries",
    validator: validate_DfareportingCountriesList_590067,
    base: "/dfareporting/v2.7", url: url_DfareportingCountriesList_590068,
    schemes: {Scheme.Https})
type
  Call_DfareportingCountriesGet_590081 = ref object of OpenApiRestCall_588466
proc url_DfareportingCountriesGet_590083(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "dartId" in path, "`dartId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/countries/"),
               (kind: VariableSegment, value: "dartId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCountriesGet_590082(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one country by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   dartId: JString (required)
  ##         : Country DART ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590084 = path.getOrDefault("profileId")
  valid_590084 = validateParameter(valid_590084, JString, required = true,
                                 default = nil)
  if valid_590084 != nil:
    section.add "profileId", valid_590084
  var valid_590085 = path.getOrDefault("dartId")
  valid_590085 = validateParameter(valid_590085, JString, required = true,
                                 default = nil)
  if valid_590085 != nil:
    section.add "dartId", valid_590085
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590086 = query.getOrDefault("fields")
  valid_590086 = validateParameter(valid_590086, JString, required = false,
                                 default = nil)
  if valid_590086 != nil:
    section.add "fields", valid_590086
  var valid_590087 = query.getOrDefault("quotaUser")
  valid_590087 = validateParameter(valid_590087, JString, required = false,
                                 default = nil)
  if valid_590087 != nil:
    section.add "quotaUser", valid_590087
  var valid_590088 = query.getOrDefault("alt")
  valid_590088 = validateParameter(valid_590088, JString, required = false,
                                 default = newJString("json"))
  if valid_590088 != nil:
    section.add "alt", valid_590088
  var valid_590089 = query.getOrDefault("oauth_token")
  valid_590089 = validateParameter(valid_590089, JString, required = false,
                                 default = nil)
  if valid_590089 != nil:
    section.add "oauth_token", valid_590089
  var valid_590090 = query.getOrDefault("userIp")
  valid_590090 = validateParameter(valid_590090, JString, required = false,
                                 default = nil)
  if valid_590090 != nil:
    section.add "userIp", valid_590090
  var valid_590091 = query.getOrDefault("key")
  valid_590091 = validateParameter(valid_590091, JString, required = false,
                                 default = nil)
  if valid_590091 != nil:
    section.add "key", valid_590091
  var valid_590092 = query.getOrDefault("prettyPrint")
  valid_590092 = validateParameter(valid_590092, JBool, required = false,
                                 default = newJBool(true))
  if valid_590092 != nil:
    section.add "prettyPrint", valid_590092
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590093: Call_DfareportingCountriesGet_590081; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one country by ID.
  ## 
  let valid = call_590093.validator(path, query, header, formData, body)
  let scheme = call_590093.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590093.url(scheme.get, call_590093.host, call_590093.base,
                         call_590093.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590093, url, valid)

proc call*(call_590094: Call_DfareportingCountriesGet_590081; profileId: string;
          dartId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCountriesGet
  ## Gets one country by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   dartId: string (required)
  ##         : Country DART ID.
  var path_590095 = newJObject()
  var query_590096 = newJObject()
  add(path_590095, "profileId", newJString(profileId))
  add(query_590096, "fields", newJString(fields))
  add(query_590096, "quotaUser", newJString(quotaUser))
  add(query_590096, "alt", newJString(alt))
  add(query_590096, "oauth_token", newJString(oauthToken))
  add(query_590096, "userIp", newJString(userIp))
  add(query_590096, "key", newJString(key))
  add(query_590096, "prettyPrint", newJBool(prettyPrint))
  add(path_590095, "dartId", newJString(dartId))
  result = call_590094.call(path_590095, query_590096, nil, nil, nil)

var dfareportingCountriesGet* = Call_DfareportingCountriesGet_590081(
    name: "dfareportingCountriesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/countries/{dartId}",
    validator: validate_DfareportingCountriesGet_590082,
    base: "/dfareporting/v2.7", url: url_DfareportingCountriesGet_590083,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeAssetsInsert_590097 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeAssetsInsert_590099(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "advertiserId" in path, "`advertiserId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeAssets/"),
               (kind: VariableSegment, value: "advertiserId"),
               (kind: ConstantSegment, value: "/creativeAssets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeAssetsInsert_590098(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative asset.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   advertiserId: JString (required)
  ##               : Advertiser ID of this creative. This is a required field.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590100 = path.getOrDefault("profileId")
  valid_590100 = validateParameter(valid_590100, JString, required = true,
                                 default = nil)
  if valid_590100 != nil:
    section.add "profileId", valid_590100
  var valid_590101 = path.getOrDefault("advertiserId")
  valid_590101 = validateParameter(valid_590101, JString, required = true,
                                 default = nil)
  if valid_590101 != nil:
    section.add "advertiserId", valid_590101
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590102 = query.getOrDefault("fields")
  valid_590102 = validateParameter(valid_590102, JString, required = false,
                                 default = nil)
  if valid_590102 != nil:
    section.add "fields", valid_590102
  var valid_590103 = query.getOrDefault("quotaUser")
  valid_590103 = validateParameter(valid_590103, JString, required = false,
                                 default = nil)
  if valid_590103 != nil:
    section.add "quotaUser", valid_590103
  var valid_590104 = query.getOrDefault("alt")
  valid_590104 = validateParameter(valid_590104, JString, required = false,
                                 default = newJString("json"))
  if valid_590104 != nil:
    section.add "alt", valid_590104
  var valid_590105 = query.getOrDefault("oauth_token")
  valid_590105 = validateParameter(valid_590105, JString, required = false,
                                 default = nil)
  if valid_590105 != nil:
    section.add "oauth_token", valid_590105
  var valid_590106 = query.getOrDefault("userIp")
  valid_590106 = validateParameter(valid_590106, JString, required = false,
                                 default = nil)
  if valid_590106 != nil:
    section.add "userIp", valid_590106
  var valid_590107 = query.getOrDefault("key")
  valid_590107 = validateParameter(valid_590107, JString, required = false,
                                 default = nil)
  if valid_590107 != nil:
    section.add "key", valid_590107
  var valid_590108 = query.getOrDefault("prettyPrint")
  valid_590108 = validateParameter(valid_590108, JBool, required = false,
                                 default = newJBool(true))
  if valid_590108 != nil:
    section.add "prettyPrint", valid_590108
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590110: Call_DfareportingCreativeAssetsInsert_590097;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative asset.
  ## 
  let valid = call_590110.validator(path, query, header, formData, body)
  let scheme = call_590110.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590110.url(scheme.get, call_590110.host, call_590110.base,
                         call_590110.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590110, url, valid)

proc call*(call_590111: Call_DfareportingCreativeAssetsInsert_590097;
          profileId: string; advertiserId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeAssetsInsert
  ## Inserts a new creative asset.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserId: string (required)
  ##               : Advertiser ID of this creative. This is a required field.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590112 = newJObject()
  var query_590113 = newJObject()
  var body_590114 = newJObject()
  add(path_590112, "profileId", newJString(profileId))
  add(query_590113, "fields", newJString(fields))
  add(query_590113, "quotaUser", newJString(quotaUser))
  add(query_590113, "alt", newJString(alt))
  add(query_590113, "oauth_token", newJString(oauthToken))
  add(query_590113, "userIp", newJString(userIp))
  add(query_590113, "key", newJString(key))
  add(path_590112, "advertiserId", newJString(advertiserId))
  if body != nil:
    body_590114 = body
  add(query_590113, "prettyPrint", newJBool(prettyPrint))
  result = call_590111.call(path_590112, query_590113, nil, nil, body_590114)

var dfareportingCreativeAssetsInsert* = Call_DfareportingCreativeAssetsInsert_590097(
    name: "dfareportingCreativeAssetsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeAssets/{advertiserId}/creativeAssets",
    validator: validate_DfareportingCreativeAssetsInsert_590098,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeAssetsInsert_590099,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsUpdate_590137 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeFieldsUpdate_590139(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsUpdate_590138(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590140 = path.getOrDefault("profileId")
  valid_590140 = validateParameter(valid_590140, JString, required = true,
                                 default = nil)
  if valid_590140 != nil:
    section.add "profileId", valid_590140
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590141 = query.getOrDefault("fields")
  valid_590141 = validateParameter(valid_590141, JString, required = false,
                                 default = nil)
  if valid_590141 != nil:
    section.add "fields", valid_590141
  var valid_590142 = query.getOrDefault("quotaUser")
  valid_590142 = validateParameter(valid_590142, JString, required = false,
                                 default = nil)
  if valid_590142 != nil:
    section.add "quotaUser", valid_590142
  var valid_590143 = query.getOrDefault("alt")
  valid_590143 = validateParameter(valid_590143, JString, required = false,
                                 default = newJString("json"))
  if valid_590143 != nil:
    section.add "alt", valid_590143
  var valid_590144 = query.getOrDefault("oauth_token")
  valid_590144 = validateParameter(valid_590144, JString, required = false,
                                 default = nil)
  if valid_590144 != nil:
    section.add "oauth_token", valid_590144
  var valid_590145 = query.getOrDefault("userIp")
  valid_590145 = validateParameter(valid_590145, JString, required = false,
                                 default = nil)
  if valid_590145 != nil:
    section.add "userIp", valid_590145
  var valid_590146 = query.getOrDefault("key")
  valid_590146 = validateParameter(valid_590146, JString, required = false,
                                 default = nil)
  if valid_590146 != nil:
    section.add "key", valid_590146
  var valid_590147 = query.getOrDefault("prettyPrint")
  valid_590147 = validateParameter(valid_590147, JBool, required = false,
                                 default = newJBool(true))
  if valid_590147 != nil:
    section.add "prettyPrint", valid_590147
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590149: Call_DfareportingCreativeFieldsUpdate_590137;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field.
  ## 
  let valid = call_590149.validator(path, query, header, formData, body)
  let scheme = call_590149.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590149.url(scheme.get, call_590149.host, call_590149.base,
                         call_590149.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590149, url, valid)

proc call*(call_590150: Call_DfareportingCreativeFieldsUpdate_590137;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsUpdate
  ## Updates an existing creative field.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590151 = newJObject()
  var query_590152 = newJObject()
  var body_590153 = newJObject()
  add(path_590151, "profileId", newJString(profileId))
  add(query_590152, "fields", newJString(fields))
  add(query_590152, "quotaUser", newJString(quotaUser))
  add(query_590152, "alt", newJString(alt))
  add(query_590152, "oauth_token", newJString(oauthToken))
  add(query_590152, "userIp", newJString(userIp))
  add(query_590152, "key", newJString(key))
  if body != nil:
    body_590153 = body
  add(query_590152, "prettyPrint", newJBool(prettyPrint))
  result = call_590150.call(path_590151, query_590152, nil, nil, body_590153)

var dfareportingCreativeFieldsUpdate* = Call_DfareportingCreativeFieldsUpdate_590137(
    name: "dfareportingCreativeFieldsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsUpdate_590138,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsUpdate_590139,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsInsert_590154 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeFieldsInsert_590156(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsInsert_590155(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative field.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590157 = path.getOrDefault("profileId")
  valid_590157 = validateParameter(valid_590157, JString, required = true,
                                 default = nil)
  if valid_590157 != nil:
    section.add "profileId", valid_590157
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590158 = query.getOrDefault("fields")
  valid_590158 = validateParameter(valid_590158, JString, required = false,
                                 default = nil)
  if valid_590158 != nil:
    section.add "fields", valid_590158
  var valid_590159 = query.getOrDefault("quotaUser")
  valid_590159 = validateParameter(valid_590159, JString, required = false,
                                 default = nil)
  if valid_590159 != nil:
    section.add "quotaUser", valid_590159
  var valid_590160 = query.getOrDefault("alt")
  valid_590160 = validateParameter(valid_590160, JString, required = false,
                                 default = newJString("json"))
  if valid_590160 != nil:
    section.add "alt", valid_590160
  var valid_590161 = query.getOrDefault("oauth_token")
  valid_590161 = validateParameter(valid_590161, JString, required = false,
                                 default = nil)
  if valid_590161 != nil:
    section.add "oauth_token", valid_590161
  var valid_590162 = query.getOrDefault("userIp")
  valid_590162 = validateParameter(valid_590162, JString, required = false,
                                 default = nil)
  if valid_590162 != nil:
    section.add "userIp", valid_590162
  var valid_590163 = query.getOrDefault("key")
  valid_590163 = validateParameter(valid_590163, JString, required = false,
                                 default = nil)
  if valid_590163 != nil:
    section.add "key", valid_590163
  var valid_590164 = query.getOrDefault("prettyPrint")
  valid_590164 = validateParameter(valid_590164, JBool, required = false,
                                 default = newJBool(true))
  if valid_590164 != nil:
    section.add "prettyPrint", valid_590164
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590166: Call_DfareportingCreativeFieldsInsert_590154;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative field.
  ## 
  let valid = call_590166.validator(path, query, header, formData, body)
  let scheme = call_590166.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590166.url(scheme.get, call_590166.host, call_590166.base,
                         call_590166.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590166, url, valid)

proc call*(call_590167: Call_DfareportingCreativeFieldsInsert_590154;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsInsert
  ## Inserts a new creative field.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590168 = newJObject()
  var query_590169 = newJObject()
  var body_590170 = newJObject()
  add(path_590168, "profileId", newJString(profileId))
  add(query_590169, "fields", newJString(fields))
  add(query_590169, "quotaUser", newJString(quotaUser))
  add(query_590169, "alt", newJString(alt))
  add(query_590169, "oauth_token", newJString(oauthToken))
  add(query_590169, "userIp", newJString(userIp))
  add(query_590169, "key", newJString(key))
  if body != nil:
    body_590170 = body
  add(query_590169, "prettyPrint", newJBool(prettyPrint))
  result = call_590167.call(path_590168, query_590169, nil, nil, body_590170)

var dfareportingCreativeFieldsInsert* = Call_DfareportingCreativeFieldsInsert_590154(
    name: "dfareportingCreativeFieldsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsInsert_590155,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsInsert_590156,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsList_590115 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeFieldsList_590117(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsList_590116(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creative fields, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590118 = path.getOrDefault("profileId")
  valid_590118 = validateParameter(valid_590118, JString, required = true,
                                 default = nil)
  if valid_590118 != nil:
    section.add "profileId", valid_590118
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for creative fields by name or ID. Wildcards (*) are allowed. For example, "creativefield*2015" will return creative fields with names like "creativefield June 2015", "creativefield April 2015", or simply "creativefield 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativefield" will match creative fields with the name "my creativefield", "creativefield 2015", or simply "creativefield".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative fields with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only creative fields that belong to these advertisers.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590119 = query.getOrDefault("fields")
  valid_590119 = validateParameter(valid_590119, JString, required = false,
                                 default = nil)
  if valid_590119 != nil:
    section.add "fields", valid_590119
  var valid_590120 = query.getOrDefault("pageToken")
  valid_590120 = validateParameter(valid_590120, JString, required = false,
                                 default = nil)
  if valid_590120 != nil:
    section.add "pageToken", valid_590120
  var valid_590121 = query.getOrDefault("quotaUser")
  valid_590121 = validateParameter(valid_590121, JString, required = false,
                                 default = nil)
  if valid_590121 != nil:
    section.add "quotaUser", valid_590121
  var valid_590122 = query.getOrDefault("sortField")
  valid_590122 = validateParameter(valid_590122, JString, required = false,
                                 default = newJString("ID"))
  if valid_590122 != nil:
    section.add "sortField", valid_590122
  var valid_590123 = query.getOrDefault("alt")
  valid_590123 = validateParameter(valid_590123, JString, required = false,
                                 default = newJString("json"))
  if valid_590123 != nil:
    section.add "alt", valid_590123
  var valid_590124 = query.getOrDefault("searchString")
  valid_590124 = validateParameter(valid_590124, JString, required = false,
                                 default = nil)
  if valid_590124 != nil:
    section.add "searchString", valid_590124
  var valid_590125 = query.getOrDefault("oauth_token")
  valid_590125 = validateParameter(valid_590125, JString, required = false,
                                 default = nil)
  if valid_590125 != nil:
    section.add "oauth_token", valid_590125
  var valid_590126 = query.getOrDefault("userIp")
  valid_590126 = validateParameter(valid_590126, JString, required = false,
                                 default = nil)
  if valid_590126 != nil:
    section.add "userIp", valid_590126
  var valid_590127 = query.getOrDefault("maxResults")
  valid_590127 = validateParameter(valid_590127, JInt, required = false,
                                 default = newJInt(1000))
  if valid_590127 != nil:
    section.add "maxResults", valid_590127
  var valid_590128 = query.getOrDefault("ids")
  valid_590128 = validateParameter(valid_590128, JArray, required = false,
                                 default = nil)
  if valid_590128 != nil:
    section.add "ids", valid_590128
  var valid_590129 = query.getOrDefault("key")
  valid_590129 = validateParameter(valid_590129, JString, required = false,
                                 default = nil)
  if valid_590129 != nil:
    section.add "key", valid_590129
  var valid_590130 = query.getOrDefault("advertiserIds")
  valid_590130 = validateParameter(valid_590130, JArray, required = false,
                                 default = nil)
  if valid_590130 != nil:
    section.add "advertiserIds", valid_590130
  var valid_590131 = query.getOrDefault("sortOrder")
  valid_590131 = validateParameter(valid_590131, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_590131 != nil:
    section.add "sortOrder", valid_590131
  var valid_590132 = query.getOrDefault("prettyPrint")
  valid_590132 = validateParameter(valid_590132, JBool, required = false,
                                 default = newJBool(true))
  if valid_590132 != nil:
    section.add "prettyPrint", valid_590132
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590133: Call_DfareportingCreativeFieldsList_590115; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of creative fields, possibly filtered. This method supports paging.
  ## 
  let valid = call_590133.validator(path, query, header, formData, body)
  let scheme = call_590133.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590133.url(scheme.get, call_590133.host, call_590133.base,
                         call_590133.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590133, url, valid)

proc call*(call_590134: Call_DfareportingCreativeFieldsList_590115;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          advertiserIds: JsonNode = nil; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsList
  ## Retrieves a list of creative fields, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for creative fields by name or ID. Wildcards (*) are allowed. For example, "creativefield*2015" will return creative fields with names like "creativefield June 2015", "creativefield April 2015", or simply "creativefield 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativefield" will match creative fields with the name "my creativefield", "creativefield 2015", or simply "creativefield".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative fields with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only creative fields that belong to these advertisers.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590135 = newJObject()
  var query_590136 = newJObject()
  add(path_590135, "profileId", newJString(profileId))
  add(query_590136, "fields", newJString(fields))
  add(query_590136, "pageToken", newJString(pageToken))
  add(query_590136, "quotaUser", newJString(quotaUser))
  add(query_590136, "sortField", newJString(sortField))
  add(query_590136, "alt", newJString(alt))
  add(query_590136, "searchString", newJString(searchString))
  add(query_590136, "oauth_token", newJString(oauthToken))
  add(query_590136, "userIp", newJString(userIp))
  add(query_590136, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_590136.add "ids", ids
  add(query_590136, "key", newJString(key))
  if advertiserIds != nil:
    query_590136.add "advertiserIds", advertiserIds
  add(query_590136, "sortOrder", newJString(sortOrder))
  add(query_590136, "prettyPrint", newJBool(prettyPrint))
  result = call_590134.call(path_590135, query_590136, nil, nil, nil)

var dfareportingCreativeFieldsList* = Call_DfareportingCreativeFieldsList_590115(
    name: "dfareportingCreativeFieldsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsList_590116,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsList_590117,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsPatch_590171 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeFieldsPatch_590173(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsPatch_590172(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590174 = path.getOrDefault("profileId")
  valid_590174 = validateParameter(valid_590174, JString, required = true,
                                 default = nil)
  if valid_590174 != nil:
    section.add "profileId", valid_590174
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative Field ID
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590175 = query.getOrDefault("fields")
  valid_590175 = validateParameter(valid_590175, JString, required = false,
                                 default = nil)
  if valid_590175 != nil:
    section.add "fields", valid_590175
  var valid_590176 = query.getOrDefault("quotaUser")
  valid_590176 = validateParameter(valid_590176, JString, required = false,
                                 default = nil)
  if valid_590176 != nil:
    section.add "quotaUser", valid_590176
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_590177 = query.getOrDefault("id")
  valid_590177 = validateParameter(valid_590177, JString, required = true,
                                 default = nil)
  if valid_590177 != nil:
    section.add "id", valid_590177
  var valid_590178 = query.getOrDefault("alt")
  valid_590178 = validateParameter(valid_590178, JString, required = false,
                                 default = newJString("json"))
  if valid_590178 != nil:
    section.add "alt", valid_590178
  var valid_590179 = query.getOrDefault("oauth_token")
  valid_590179 = validateParameter(valid_590179, JString, required = false,
                                 default = nil)
  if valid_590179 != nil:
    section.add "oauth_token", valid_590179
  var valid_590180 = query.getOrDefault("userIp")
  valid_590180 = validateParameter(valid_590180, JString, required = false,
                                 default = nil)
  if valid_590180 != nil:
    section.add "userIp", valid_590180
  var valid_590181 = query.getOrDefault("key")
  valid_590181 = validateParameter(valid_590181, JString, required = false,
                                 default = nil)
  if valid_590181 != nil:
    section.add "key", valid_590181
  var valid_590182 = query.getOrDefault("prettyPrint")
  valid_590182 = validateParameter(valid_590182, JBool, required = false,
                                 default = newJBool(true))
  if valid_590182 != nil:
    section.add "prettyPrint", valid_590182
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590184: Call_DfareportingCreativeFieldsPatch_590171;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field. This method supports patch semantics.
  ## 
  let valid = call_590184.validator(path, query, header, formData, body)
  let scheme = call_590184.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590184.url(scheme.get, call_590184.host, call_590184.base,
                         call_590184.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590184, url, valid)

proc call*(call_590185: Call_DfareportingCreativeFieldsPatch_590171;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsPatch
  ## Updates an existing creative field. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative Field ID
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590186 = newJObject()
  var query_590187 = newJObject()
  var body_590188 = newJObject()
  add(path_590186, "profileId", newJString(profileId))
  add(query_590187, "fields", newJString(fields))
  add(query_590187, "quotaUser", newJString(quotaUser))
  add(query_590187, "id", newJString(id))
  add(query_590187, "alt", newJString(alt))
  add(query_590187, "oauth_token", newJString(oauthToken))
  add(query_590187, "userIp", newJString(userIp))
  add(query_590187, "key", newJString(key))
  if body != nil:
    body_590188 = body
  add(query_590187, "prettyPrint", newJBool(prettyPrint))
  result = call_590185.call(path_590186, query_590187, nil, nil, body_590188)

var dfareportingCreativeFieldsPatch* = Call_DfareportingCreativeFieldsPatch_590171(
    name: "dfareportingCreativeFieldsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsPatch_590172,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsPatch_590173,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesUpdate_590211 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeFieldValuesUpdate_590213(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesUpdate_590212(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field value.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590214 = path.getOrDefault("profileId")
  valid_590214 = validateParameter(valid_590214, JString, required = true,
                                 default = nil)
  if valid_590214 != nil:
    section.add "profileId", valid_590214
  var valid_590215 = path.getOrDefault("creativeFieldId")
  valid_590215 = validateParameter(valid_590215, JString, required = true,
                                 default = nil)
  if valid_590215 != nil:
    section.add "creativeFieldId", valid_590215
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590216 = query.getOrDefault("fields")
  valid_590216 = validateParameter(valid_590216, JString, required = false,
                                 default = nil)
  if valid_590216 != nil:
    section.add "fields", valid_590216
  var valid_590217 = query.getOrDefault("quotaUser")
  valid_590217 = validateParameter(valid_590217, JString, required = false,
                                 default = nil)
  if valid_590217 != nil:
    section.add "quotaUser", valid_590217
  var valid_590218 = query.getOrDefault("alt")
  valid_590218 = validateParameter(valid_590218, JString, required = false,
                                 default = newJString("json"))
  if valid_590218 != nil:
    section.add "alt", valid_590218
  var valid_590219 = query.getOrDefault("oauth_token")
  valid_590219 = validateParameter(valid_590219, JString, required = false,
                                 default = nil)
  if valid_590219 != nil:
    section.add "oauth_token", valid_590219
  var valid_590220 = query.getOrDefault("userIp")
  valid_590220 = validateParameter(valid_590220, JString, required = false,
                                 default = nil)
  if valid_590220 != nil:
    section.add "userIp", valid_590220
  var valid_590221 = query.getOrDefault("key")
  valid_590221 = validateParameter(valid_590221, JString, required = false,
                                 default = nil)
  if valid_590221 != nil:
    section.add "key", valid_590221
  var valid_590222 = query.getOrDefault("prettyPrint")
  valid_590222 = validateParameter(valid_590222, JBool, required = false,
                                 default = newJBool(true))
  if valid_590222 != nil:
    section.add "prettyPrint", valid_590222
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590224: Call_DfareportingCreativeFieldValuesUpdate_590211;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field value.
  ## 
  let valid = call_590224.validator(path, query, header, formData, body)
  let scheme = call_590224.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590224.url(scheme.get, call_590224.host, call_590224.base,
                         call_590224.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590224, url, valid)

proc call*(call_590225: Call_DfareportingCreativeFieldValuesUpdate_590211;
          profileId: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesUpdate
  ## Updates an existing creative field value.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590226 = newJObject()
  var query_590227 = newJObject()
  var body_590228 = newJObject()
  add(path_590226, "profileId", newJString(profileId))
  add(query_590227, "fields", newJString(fields))
  add(query_590227, "quotaUser", newJString(quotaUser))
  add(query_590227, "alt", newJString(alt))
  add(query_590227, "oauth_token", newJString(oauthToken))
  add(query_590227, "userIp", newJString(userIp))
  add(query_590227, "key", newJString(key))
  add(path_590226, "creativeFieldId", newJString(creativeFieldId))
  if body != nil:
    body_590228 = body
  add(query_590227, "prettyPrint", newJBool(prettyPrint))
  result = call_590225.call(path_590226, query_590227, nil, nil, body_590228)

var dfareportingCreativeFieldValuesUpdate* = Call_DfareportingCreativeFieldValuesUpdate_590211(
    name: "dfareportingCreativeFieldValuesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesUpdate_590212,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesUpdate_590213,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesInsert_590229 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeFieldValuesInsert_590231(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesInsert_590230(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative field value.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590232 = path.getOrDefault("profileId")
  valid_590232 = validateParameter(valid_590232, JString, required = true,
                                 default = nil)
  if valid_590232 != nil:
    section.add "profileId", valid_590232
  var valid_590233 = path.getOrDefault("creativeFieldId")
  valid_590233 = validateParameter(valid_590233, JString, required = true,
                                 default = nil)
  if valid_590233 != nil:
    section.add "creativeFieldId", valid_590233
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590234 = query.getOrDefault("fields")
  valid_590234 = validateParameter(valid_590234, JString, required = false,
                                 default = nil)
  if valid_590234 != nil:
    section.add "fields", valid_590234
  var valid_590235 = query.getOrDefault("quotaUser")
  valid_590235 = validateParameter(valid_590235, JString, required = false,
                                 default = nil)
  if valid_590235 != nil:
    section.add "quotaUser", valid_590235
  var valid_590236 = query.getOrDefault("alt")
  valid_590236 = validateParameter(valid_590236, JString, required = false,
                                 default = newJString("json"))
  if valid_590236 != nil:
    section.add "alt", valid_590236
  var valid_590237 = query.getOrDefault("oauth_token")
  valid_590237 = validateParameter(valid_590237, JString, required = false,
                                 default = nil)
  if valid_590237 != nil:
    section.add "oauth_token", valid_590237
  var valid_590238 = query.getOrDefault("userIp")
  valid_590238 = validateParameter(valid_590238, JString, required = false,
                                 default = nil)
  if valid_590238 != nil:
    section.add "userIp", valid_590238
  var valid_590239 = query.getOrDefault("key")
  valid_590239 = validateParameter(valid_590239, JString, required = false,
                                 default = nil)
  if valid_590239 != nil:
    section.add "key", valid_590239
  var valid_590240 = query.getOrDefault("prettyPrint")
  valid_590240 = validateParameter(valid_590240, JBool, required = false,
                                 default = newJBool(true))
  if valid_590240 != nil:
    section.add "prettyPrint", valid_590240
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590242: Call_DfareportingCreativeFieldValuesInsert_590229;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative field value.
  ## 
  let valid = call_590242.validator(path, query, header, formData, body)
  let scheme = call_590242.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590242.url(scheme.get, call_590242.host, call_590242.base,
                         call_590242.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590242, url, valid)

proc call*(call_590243: Call_DfareportingCreativeFieldValuesInsert_590229;
          profileId: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesInsert
  ## Inserts a new creative field value.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590244 = newJObject()
  var query_590245 = newJObject()
  var body_590246 = newJObject()
  add(path_590244, "profileId", newJString(profileId))
  add(query_590245, "fields", newJString(fields))
  add(query_590245, "quotaUser", newJString(quotaUser))
  add(query_590245, "alt", newJString(alt))
  add(query_590245, "oauth_token", newJString(oauthToken))
  add(query_590245, "userIp", newJString(userIp))
  add(query_590245, "key", newJString(key))
  add(path_590244, "creativeFieldId", newJString(creativeFieldId))
  if body != nil:
    body_590246 = body
  add(query_590245, "prettyPrint", newJBool(prettyPrint))
  result = call_590243.call(path_590244, query_590245, nil, nil, body_590246)

var dfareportingCreativeFieldValuesInsert* = Call_DfareportingCreativeFieldValuesInsert_590229(
    name: "dfareportingCreativeFieldValuesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesInsert_590230,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesInsert_590231,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesList_590189 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeFieldValuesList_590191(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesList_590190(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creative field values, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590192 = path.getOrDefault("profileId")
  valid_590192 = validateParameter(valid_590192, JString, required = true,
                                 default = nil)
  if valid_590192 != nil:
    section.add "profileId", valid_590192
  var valid_590193 = path.getOrDefault("creativeFieldId")
  valid_590193 = validateParameter(valid_590193, JString, required = true,
                                 default = nil)
  if valid_590193 != nil:
    section.add "creativeFieldId", valid_590193
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for creative field values by their values. Wildcards (e.g. *) are not allowed.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative field values with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590194 = query.getOrDefault("fields")
  valid_590194 = validateParameter(valid_590194, JString, required = false,
                                 default = nil)
  if valid_590194 != nil:
    section.add "fields", valid_590194
  var valid_590195 = query.getOrDefault("pageToken")
  valid_590195 = validateParameter(valid_590195, JString, required = false,
                                 default = nil)
  if valid_590195 != nil:
    section.add "pageToken", valid_590195
  var valid_590196 = query.getOrDefault("quotaUser")
  valid_590196 = validateParameter(valid_590196, JString, required = false,
                                 default = nil)
  if valid_590196 != nil:
    section.add "quotaUser", valid_590196
  var valid_590197 = query.getOrDefault("sortField")
  valid_590197 = validateParameter(valid_590197, JString, required = false,
                                 default = newJString("ID"))
  if valid_590197 != nil:
    section.add "sortField", valid_590197
  var valid_590198 = query.getOrDefault("alt")
  valid_590198 = validateParameter(valid_590198, JString, required = false,
                                 default = newJString("json"))
  if valid_590198 != nil:
    section.add "alt", valid_590198
  var valid_590199 = query.getOrDefault("searchString")
  valid_590199 = validateParameter(valid_590199, JString, required = false,
                                 default = nil)
  if valid_590199 != nil:
    section.add "searchString", valid_590199
  var valid_590200 = query.getOrDefault("oauth_token")
  valid_590200 = validateParameter(valid_590200, JString, required = false,
                                 default = nil)
  if valid_590200 != nil:
    section.add "oauth_token", valid_590200
  var valid_590201 = query.getOrDefault("userIp")
  valid_590201 = validateParameter(valid_590201, JString, required = false,
                                 default = nil)
  if valid_590201 != nil:
    section.add "userIp", valid_590201
  var valid_590202 = query.getOrDefault("maxResults")
  valid_590202 = validateParameter(valid_590202, JInt, required = false,
                                 default = newJInt(1000))
  if valid_590202 != nil:
    section.add "maxResults", valid_590202
  var valid_590203 = query.getOrDefault("ids")
  valid_590203 = validateParameter(valid_590203, JArray, required = false,
                                 default = nil)
  if valid_590203 != nil:
    section.add "ids", valid_590203
  var valid_590204 = query.getOrDefault("key")
  valid_590204 = validateParameter(valid_590204, JString, required = false,
                                 default = nil)
  if valid_590204 != nil:
    section.add "key", valid_590204
  var valid_590205 = query.getOrDefault("sortOrder")
  valid_590205 = validateParameter(valid_590205, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_590205 != nil:
    section.add "sortOrder", valid_590205
  var valid_590206 = query.getOrDefault("prettyPrint")
  valid_590206 = validateParameter(valid_590206, JBool, required = false,
                                 default = newJBool(true))
  if valid_590206 != nil:
    section.add "prettyPrint", valid_590206
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590207: Call_DfareportingCreativeFieldValuesList_590189;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of creative field values, possibly filtered. This method supports paging.
  ## 
  let valid = call_590207.validator(path, query, header, formData, body)
  let scheme = call_590207.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590207.url(scheme.get, call_590207.host, call_590207.base,
                         call_590207.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590207, url, valid)

proc call*(call_590208: Call_DfareportingCreativeFieldValuesList_590189;
          profileId: string; creativeFieldId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; searchString: string = ""; oauthToken: string = "";
          userIp: string = ""; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesList
  ## Retrieves a list of creative field values, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for creative field values by their values. Wildcards (e.g. *) are not allowed.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative field values with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590209 = newJObject()
  var query_590210 = newJObject()
  add(path_590209, "profileId", newJString(profileId))
  add(query_590210, "fields", newJString(fields))
  add(query_590210, "pageToken", newJString(pageToken))
  add(query_590210, "quotaUser", newJString(quotaUser))
  add(query_590210, "sortField", newJString(sortField))
  add(query_590210, "alt", newJString(alt))
  add(query_590210, "searchString", newJString(searchString))
  add(query_590210, "oauth_token", newJString(oauthToken))
  add(query_590210, "userIp", newJString(userIp))
  add(query_590210, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_590210.add "ids", ids
  add(query_590210, "key", newJString(key))
  add(query_590210, "sortOrder", newJString(sortOrder))
  add(path_590209, "creativeFieldId", newJString(creativeFieldId))
  add(query_590210, "prettyPrint", newJBool(prettyPrint))
  result = call_590208.call(path_590209, query_590210, nil, nil, nil)

var dfareportingCreativeFieldValuesList* = Call_DfareportingCreativeFieldValuesList_590189(
    name: "dfareportingCreativeFieldValuesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesList_590190,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesList_590191,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesPatch_590247 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeFieldValuesPatch_590249(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesPatch_590248(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field value. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590250 = path.getOrDefault("profileId")
  valid_590250 = validateParameter(valid_590250, JString, required = true,
                                 default = nil)
  if valid_590250 != nil:
    section.add "profileId", valid_590250
  var valid_590251 = path.getOrDefault("creativeFieldId")
  valid_590251 = validateParameter(valid_590251, JString, required = true,
                                 default = nil)
  if valid_590251 != nil:
    section.add "creativeFieldId", valid_590251
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative Field Value ID
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590252 = query.getOrDefault("fields")
  valid_590252 = validateParameter(valid_590252, JString, required = false,
                                 default = nil)
  if valid_590252 != nil:
    section.add "fields", valid_590252
  var valid_590253 = query.getOrDefault("quotaUser")
  valid_590253 = validateParameter(valid_590253, JString, required = false,
                                 default = nil)
  if valid_590253 != nil:
    section.add "quotaUser", valid_590253
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_590254 = query.getOrDefault("id")
  valid_590254 = validateParameter(valid_590254, JString, required = true,
                                 default = nil)
  if valid_590254 != nil:
    section.add "id", valid_590254
  var valid_590255 = query.getOrDefault("alt")
  valid_590255 = validateParameter(valid_590255, JString, required = false,
                                 default = newJString("json"))
  if valid_590255 != nil:
    section.add "alt", valid_590255
  var valid_590256 = query.getOrDefault("oauth_token")
  valid_590256 = validateParameter(valid_590256, JString, required = false,
                                 default = nil)
  if valid_590256 != nil:
    section.add "oauth_token", valid_590256
  var valid_590257 = query.getOrDefault("userIp")
  valid_590257 = validateParameter(valid_590257, JString, required = false,
                                 default = nil)
  if valid_590257 != nil:
    section.add "userIp", valid_590257
  var valid_590258 = query.getOrDefault("key")
  valid_590258 = validateParameter(valid_590258, JString, required = false,
                                 default = nil)
  if valid_590258 != nil:
    section.add "key", valid_590258
  var valid_590259 = query.getOrDefault("prettyPrint")
  valid_590259 = validateParameter(valid_590259, JBool, required = false,
                                 default = newJBool(true))
  if valid_590259 != nil:
    section.add "prettyPrint", valid_590259
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590261: Call_DfareportingCreativeFieldValuesPatch_590247;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field value. This method supports patch semantics.
  ## 
  let valid = call_590261.validator(path, query, header, formData, body)
  let scheme = call_590261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590261.url(scheme.get, call_590261.host, call_590261.base,
                         call_590261.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590261, url, valid)

proc call*(call_590262: Call_DfareportingCreativeFieldValuesPatch_590247;
          profileId: string; id: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesPatch
  ## Updates an existing creative field value. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative Field Value ID
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590263 = newJObject()
  var query_590264 = newJObject()
  var body_590265 = newJObject()
  add(path_590263, "profileId", newJString(profileId))
  add(query_590264, "fields", newJString(fields))
  add(query_590264, "quotaUser", newJString(quotaUser))
  add(query_590264, "id", newJString(id))
  add(query_590264, "alt", newJString(alt))
  add(query_590264, "oauth_token", newJString(oauthToken))
  add(query_590264, "userIp", newJString(userIp))
  add(query_590264, "key", newJString(key))
  add(path_590263, "creativeFieldId", newJString(creativeFieldId))
  if body != nil:
    body_590265 = body
  add(query_590264, "prettyPrint", newJBool(prettyPrint))
  result = call_590262.call(path_590263, query_590264, nil, nil, body_590265)

var dfareportingCreativeFieldValuesPatch* = Call_DfareportingCreativeFieldValuesPatch_590247(
    name: "dfareportingCreativeFieldValuesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesPatch_590248,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesPatch_590249,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesGet_590266 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeFieldValuesGet_590268(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesGet_590267(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative field value by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field Value ID
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590269 = path.getOrDefault("profileId")
  valid_590269 = validateParameter(valid_590269, JString, required = true,
                                 default = nil)
  if valid_590269 != nil:
    section.add "profileId", valid_590269
  var valid_590270 = path.getOrDefault("id")
  valid_590270 = validateParameter(valid_590270, JString, required = true,
                                 default = nil)
  if valid_590270 != nil:
    section.add "id", valid_590270
  var valid_590271 = path.getOrDefault("creativeFieldId")
  valid_590271 = validateParameter(valid_590271, JString, required = true,
                                 default = nil)
  if valid_590271 != nil:
    section.add "creativeFieldId", valid_590271
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590272 = query.getOrDefault("fields")
  valid_590272 = validateParameter(valid_590272, JString, required = false,
                                 default = nil)
  if valid_590272 != nil:
    section.add "fields", valid_590272
  var valid_590273 = query.getOrDefault("quotaUser")
  valid_590273 = validateParameter(valid_590273, JString, required = false,
                                 default = nil)
  if valid_590273 != nil:
    section.add "quotaUser", valid_590273
  var valid_590274 = query.getOrDefault("alt")
  valid_590274 = validateParameter(valid_590274, JString, required = false,
                                 default = newJString("json"))
  if valid_590274 != nil:
    section.add "alt", valid_590274
  var valid_590275 = query.getOrDefault("oauth_token")
  valid_590275 = validateParameter(valid_590275, JString, required = false,
                                 default = nil)
  if valid_590275 != nil:
    section.add "oauth_token", valid_590275
  var valid_590276 = query.getOrDefault("userIp")
  valid_590276 = validateParameter(valid_590276, JString, required = false,
                                 default = nil)
  if valid_590276 != nil:
    section.add "userIp", valid_590276
  var valid_590277 = query.getOrDefault("key")
  valid_590277 = validateParameter(valid_590277, JString, required = false,
                                 default = nil)
  if valid_590277 != nil:
    section.add "key", valid_590277
  var valid_590278 = query.getOrDefault("prettyPrint")
  valid_590278 = validateParameter(valid_590278, JBool, required = false,
                                 default = newJBool(true))
  if valid_590278 != nil:
    section.add "prettyPrint", valid_590278
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590279: Call_DfareportingCreativeFieldValuesGet_590266;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one creative field value by ID.
  ## 
  let valid = call_590279.validator(path, query, header, formData, body)
  let scheme = call_590279.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590279.url(scheme.get, call_590279.host, call_590279.base,
                         call_590279.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590279, url, valid)

proc call*(call_590280: Call_DfareportingCreativeFieldValuesGet_590266;
          profileId: string; id: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesGet
  ## Gets one creative field value by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative Field Value ID
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590281 = newJObject()
  var query_590282 = newJObject()
  add(path_590281, "profileId", newJString(profileId))
  add(query_590282, "fields", newJString(fields))
  add(query_590282, "quotaUser", newJString(quotaUser))
  add(query_590282, "alt", newJString(alt))
  add(query_590282, "oauth_token", newJString(oauthToken))
  add(query_590282, "userIp", newJString(userIp))
  add(path_590281, "id", newJString(id))
  add(query_590282, "key", newJString(key))
  add(path_590281, "creativeFieldId", newJString(creativeFieldId))
  add(query_590282, "prettyPrint", newJBool(prettyPrint))
  result = call_590280.call(path_590281, query_590282, nil, nil, nil)

var dfareportingCreativeFieldValuesGet* = Call_DfareportingCreativeFieldValuesGet_590266(
    name: "dfareportingCreativeFieldValuesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues/{id}",
    validator: validate_DfareportingCreativeFieldValuesGet_590267,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesGet_590268,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesDelete_590283 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeFieldValuesDelete_590285(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesDelete_590284(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing creative field value.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field Value ID
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590286 = path.getOrDefault("profileId")
  valid_590286 = validateParameter(valid_590286, JString, required = true,
                                 default = nil)
  if valid_590286 != nil:
    section.add "profileId", valid_590286
  var valid_590287 = path.getOrDefault("id")
  valid_590287 = validateParameter(valid_590287, JString, required = true,
                                 default = nil)
  if valid_590287 != nil:
    section.add "id", valid_590287
  var valid_590288 = path.getOrDefault("creativeFieldId")
  valid_590288 = validateParameter(valid_590288, JString, required = true,
                                 default = nil)
  if valid_590288 != nil:
    section.add "creativeFieldId", valid_590288
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590289 = query.getOrDefault("fields")
  valid_590289 = validateParameter(valid_590289, JString, required = false,
                                 default = nil)
  if valid_590289 != nil:
    section.add "fields", valid_590289
  var valid_590290 = query.getOrDefault("quotaUser")
  valid_590290 = validateParameter(valid_590290, JString, required = false,
                                 default = nil)
  if valid_590290 != nil:
    section.add "quotaUser", valid_590290
  var valid_590291 = query.getOrDefault("alt")
  valid_590291 = validateParameter(valid_590291, JString, required = false,
                                 default = newJString("json"))
  if valid_590291 != nil:
    section.add "alt", valid_590291
  var valid_590292 = query.getOrDefault("oauth_token")
  valid_590292 = validateParameter(valid_590292, JString, required = false,
                                 default = nil)
  if valid_590292 != nil:
    section.add "oauth_token", valid_590292
  var valid_590293 = query.getOrDefault("userIp")
  valid_590293 = validateParameter(valid_590293, JString, required = false,
                                 default = nil)
  if valid_590293 != nil:
    section.add "userIp", valid_590293
  var valid_590294 = query.getOrDefault("key")
  valid_590294 = validateParameter(valid_590294, JString, required = false,
                                 default = nil)
  if valid_590294 != nil:
    section.add "key", valid_590294
  var valid_590295 = query.getOrDefault("prettyPrint")
  valid_590295 = validateParameter(valid_590295, JBool, required = false,
                                 default = newJBool(true))
  if valid_590295 != nil:
    section.add "prettyPrint", valid_590295
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590296: Call_DfareportingCreativeFieldValuesDelete_590283;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing creative field value.
  ## 
  let valid = call_590296.validator(path, query, header, formData, body)
  let scheme = call_590296.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590296.url(scheme.get, call_590296.host, call_590296.base,
                         call_590296.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590296, url, valid)

proc call*(call_590297: Call_DfareportingCreativeFieldValuesDelete_590283;
          profileId: string; id: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesDelete
  ## Deletes an existing creative field value.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative Field Value ID
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590298 = newJObject()
  var query_590299 = newJObject()
  add(path_590298, "profileId", newJString(profileId))
  add(query_590299, "fields", newJString(fields))
  add(query_590299, "quotaUser", newJString(quotaUser))
  add(query_590299, "alt", newJString(alt))
  add(query_590299, "oauth_token", newJString(oauthToken))
  add(query_590299, "userIp", newJString(userIp))
  add(path_590298, "id", newJString(id))
  add(query_590299, "key", newJString(key))
  add(path_590298, "creativeFieldId", newJString(creativeFieldId))
  add(query_590299, "prettyPrint", newJBool(prettyPrint))
  result = call_590297.call(path_590298, query_590299, nil, nil, nil)

var dfareportingCreativeFieldValuesDelete* = Call_DfareportingCreativeFieldValuesDelete_590283(
    name: "dfareportingCreativeFieldValuesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues/{id}",
    validator: validate_DfareportingCreativeFieldValuesDelete_590284,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesDelete_590285,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsGet_590300 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeFieldsGet_590302(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsGet_590301(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative field by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590303 = path.getOrDefault("profileId")
  valid_590303 = validateParameter(valid_590303, JString, required = true,
                                 default = nil)
  if valid_590303 != nil:
    section.add "profileId", valid_590303
  var valid_590304 = path.getOrDefault("id")
  valid_590304 = validateParameter(valid_590304, JString, required = true,
                                 default = nil)
  if valid_590304 != nil:
    section.add "id", valid_590304
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590305 = query.getOrDefault("fields")
  valid_590305 = validateParameter(valid_590305, JString, required = false,
                                 default = nil)
  if valid_590305 != nil:
    section.add "fields", valid_590305
  var valid_590306 = query.getOrDefault("quotaUser")
  valid_590306 = validateParameter(valid_590306, JString, required = false,
                                 default = nil)
  if valid_590306 != nil:
    section.add "quotaUser", valid_590306
  var valid_590307 = query.getOrDefault("alt")
  valid_590307 = validateParameter(valid_590307, JString, required = false,
                                 default = newJString("json"))
  if valid_590307 != nil:
    section.add "alt", valid_590307
  var valid_590308 = query.getOrDefault("oauth_token")
  valid_590308 = validateParameter(valid_590308, JString, required = false,
                                 default = nil)
  if valid_590308 != nil:
    section.add "oauth_token", valid_590308
  var valid_590309 = query.getOrDefault("userIp")
  valid_590309 = validateParameter(valid_590309, JString, required = false,
                                 default = nil)
  if valid_590309 != nil:
    section.add "userIp", valid_590309
  var valid_590310 = query.getOrDefault("key")
  valid_590310 = validateParameter(valid_590310, JString, required = false,
                                 default = nil)
  if valid_590310 != nil:
    section.add "key", valid_590310
  var valid_590311 = query.getOrDefault("prettyPrint")
  valid_590311 = validateParameter(valid_590311, JBool, required = false,
                                 default = newJBool(true))
  if valid_590311 != nil:
    section.add "prettyPrint", valid_590311
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590312: Call_DfareportingCreativeFieldsGet_590300; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one creative field by ID.
  ## 
  let valid = call_590312.validator(path, query, header, formData, body)
  let scheme = call_590312.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590312.url(scheme.get, call_590312.host, call_590312.base,
                         call_590312.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590312, url, valid)

proc call*(call_590313: Call_DfareportingCreativeFieldsGet_590300;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsGet
  ## Gets one creative field by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative Field ID
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590314 = newJObject()
  var query_590315 = newJObject()
  add(path_590314, "profileId", newJString(profileId))
  add(query_590315, "fields", newJString(fields))
  add(query_590315, "quotaUser", newJString(quotaUser))
  add(query_590315, "alt", newJString(alt))
  add(query_590315, "oauth_token", newJString(oauthToken))
  add(query_590315, "userIp", newJString(userIp))
  add(path_590314, "id", newJString(id))
  add(query_590315, "key", newJString(key))
  add(query_590315, "prettyPrint", newJBool(prettyPrint))
  result = call_590313.call(path_590314, query_590315, nil, nil, nil)

var dfareportingCreativeFieldsGet* = Call_DfareportingCreativeFieldsGet_590300(
    name: "dfareportingCreativeFieldsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/creativeFields/{id}",
    validator: validate_DfareportingCreativeFieldsGet_590301,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsGet_590302,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsDelete_590316 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeFieldsDelete_590318(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsDelete_590317(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing creative field.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590319 = path.getOrDefault("profileId")
  valid_590319 = validateParameter(valid_590319, JString, required = true,
                                 default = nil)
  if valid_590319 != nil:
    section.add "profileId", valid_590319
  var valid_590320 = path.getOrDefault("id")
  valid_590320 = validateParameter(valid_590320, JString, required = true,
                                 default = nil)
  if valid_590320 != nil:
    section.add "id", valid_590320
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590321 = query.getOrDefault("fields")
  valid_590321 = validateParameter(valid_590321, JString, required = false,
                                 default = nil)
  if valid_590321 != nil:
    section.add "fields", valid_590321
  var valid_590322 = query.getOrDefault("quotaUser")
  valid_590322 = validateParameter(valid_590322, JString, required = false,
                                 default = nil)
  if valid_590322 != nil:
    section.add "quotaUser", valid_590322
  var valid_590323 = query.getOrDefault("alt")
  valid_590323 = validateParameter(valid_590323, JString, required = false,
                                 default = newJString("json"))
  if valid_590323 != nil:
    section.add "alt", valid_590323
  var valid_590324 = query.getOrDefault("oauth_token")
  valid_590324 = validateParameter(valid_590324, JString, required = false,
                                 default = nil)
  if valid_590324 != nil:
    section.add "oauth_token", valid_590324
  var valid_590325 = query.getOrDefault("userIp")
  valid_590325 = validateParameter(valid_590325, JString, required = false,
                                 default = nil)
  if valid_590325 != nil:
    section.add "userIp", valid_590325
  var valid_590326 = query.getOrDefault("key")
  valid_590326 = validateParameter(valid_590326, JString, required = false,
                                 default = nil)
  if valid_590326 != nil:
    section.add "key", valid_590326
  var valid_590327 = query.getOrDefault("prettyPrint")
  valid_590327 = validateParameter(valid_590327, JBool, required = false,
                                 default = newJBool(true))
  if valid_590327 != nil:
    section.add "prettyPrint", valid_590327
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590328: Call_DfareportingCreativeFieldsDelete_590316;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing creative field.
  ## 
  let valid = call_590328.validator(path, query, header, formData, body)
  let scheme = call_590328.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590328.url(scheme.get, call_590328.host, call_590328.base,
                         call_590328.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590328, url, valid)

proc call*(call_590329: Call_DfareportingCreativeFieldsDelete_590316;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsDelete
  ## Deletes an existing creative field.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative Field ID
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590330 = newJObject()
  var query_590331 = newJObject()
  add(path_590330, "profileId", newJString(profileId))
  add(query_590331, "fields", newJString(fields))
  add(query_590331, "quotaUser", newJString(quotaUser))
  add(query_590331, "alt", newJString(alt))
  add(query_590331, "oauth_token", newJString(oauthToken))
  add(query_590331, "userIp", newJString(userIp))
  add(path_590330, "id", newJString(id))
  add(query_590331, "key", newJString(key))
  add(query_590331, "prettyPrint", newJBool(prettyPrint))
  result = call_590329.call(path_590330, query_590331, nil, nil, nil)

var dfareportingCreativeFieldsDelete* = Call_DfareportingCreativeFieldsDelete_590316(
    name: "dfareportingCreativeFieldsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/creativeFields/{id}",
    validator: validate_DfareportingCreativeFieldsDelete_590317,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsDelete_590318,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsUpdate_590355 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeGroupsUpdate_590357(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsUpdate_590356(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590358 = path.getOrDefault("profileId")
  valid_590358 = validateParameter(valid_590358, JString, required = true,
                                 default = nil)
  if valid_590358 != nil:
    section.add "profileId", valid_590358
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590359 = query.getOrDefault("fields")
  valid_590359 = validateParameter(valid_590359, JString, required = false,
                                 default = nil)
  if valid_590359 != nil:
    section.add "fields", valid_590359
  var valid_590360 = query.getOrDefault("quotaUser")
  valid_590360 = validateParameter(valid_590360, JString, required = false,
                                 default = nil)
  if valid_590360 != nil:
    section.add "quotaUser", valid_590360
  var valid_590361 = query.getOrDefault("alt")
  valid_590361 = validateParameter(valid_590361, JString, required = false,
                                 default = newJString("json"))
  if valid_590361 != nil:
    section.add "alt", valid_590361
  var valid_590362 = query.getOrDefault("oauth_token")
  valid_590362 = validateParameter(valid_590362, JString, required = false,
                                 default = nil)
  if valid_590362 != nil:
    section.add "oauth_token", valid_590362
  var valid_590363 = query.getOrDefault("userIp")
  valid_590363 = validateParameter(valid_590363, JString, required = false,
                                 default = nil)
  if valid_590363 != nil:
    section.add "userIp", valid_590363
  var valid_590364 = query.getOrDefault("key")
  valid_590364 = validateParameter(valid_590364, JString, required = false,
                                 default = nil)
  if valid_590364 != nil:
    section.add "key", valid_590364
  var valid_590365 = query.getOrDefault("prettyPrint")
  valid_590365 = validateParameter(valid_590365, JBool, required = false,
                                 default = newJBool(true))
  if valid_590365 != nil:
    section.add "prettyPrint", valid_590365
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590367: Call_DfareportingCreativeGroupsUpdate_590355;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative group.
  ## 
  let valid = call_590367.validator(path, query, header, formData, body)
  let scheme = call_590367.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590367.url(scheme.get, call_590367.host, call_590367.base,
                         call_590367.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590367, url, valid)

proc call*(call_590368: Call_DfareportingCreativeGroupsUpdate_590355;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsUpdate
  ## Updates an existing creative group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590369 = newJObject()
  var query_590370 = newJObject()
  var body_590371 = newJObject()
  add(path_590369, "profileId", newJString(profileId))
  add(query_590370, "fields", newJString(fields))
  add(query_590370, "quotaUser", newJString(quotaUser))
  add(query_590370, "alt", newJString(alt))
  add(query_590370, "oauth_token", newJString(oauthToken))
  add(query_590370, "userIp", newJString(userIp))
  add(query_590370, "key", newJString(key))
  if body != nil:
    body_590371 = body
  add(query_590370, "prettyPrint", newJBool(prettyPrint))
  result = call_590368.call(path_590369, query_590370, nil, nil, body_590371)

var dfareportingCreativeGroupsUpdate* = Call_DfareportingCreativeGroupsUpdate_590355(
    name: "dfareportingCreativeGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsUpdate_590356,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsUpdate_590357,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsInsert_590372 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeGroupsInsert_590374(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsInsert_590373(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590375 = path.getOrDefault("profileId")
  valid_590375 = validateParameter(valid_590375, JString, required = true,
                                 default = nil)
  if valid_590375 != nil:
    section.add "profileId", valid_590375
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590376 = query.getOrDefault("fields")
  valid_590376 = validateParameter(valid_590376, JString, required = false,
                                 default = nil)
  if valid_590376 != nil:
    section.add "fields", valid_590376
  var valid_590377 = query.getOrDefault("quotaUser")
  valid_590377 = validateParameter(valid_590377, JString, required = false,
                                 default = nil)
  if valid_590377 != nil:
    section.add "quotaUser", valid_590377
  var valid_590378 = query.getOrDefault("alt")
  valid_590378 = validateParameter(valid_590378, JString, required = false,
                                 default = newJString("json"))
  if valid_590378 != nil:
    section.add "alt", valid_590378
  var valid_590379 = query.getOrDefault("oauth_token")
  valid_590379 = validateParameter(valid_590379, JString, required = false,
                                 default = nil)
  if valid_590379 != nil:
    section.add "oauth_token", valid_590379
  var valid_590380 = query.getOrDefault("userIp")
  valid_590380 = validateParameter(valid_590380, JString, required = false,
                                 default = nil)
  if valid_590380 != nil:
    section.add "userIp", valid_590380
  var valid_590381 = query.getOrDefault("key")
  valid_590381 = validateParameter(valid_590381, JString, required = false,
                                 default = nil)
  if valid_590381 != nil:
    section.add "key", valid_590381
  var valid_590382 = query.getOrDefault("prettyPrint")
  valid_590382 = validateParameter(valid_590382, JBool, required = false,
                                 default = newJBool(true))
  if valid_590382 != nil:
    section.add "prettyPrint", valid_590382
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590384: Call_DfareportingCreativeGroupsInsert_590372;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative group.
  ## 
  let valid = call_590384.validator(path, query, header, formData, body)
  let scheme = call_590384.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590384.url(scheme.get, call_590384.host, call_590384.base,
                         call_590384.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590384, url, valid)

proc call*(call_590385: Call_DfareportingCreativeGroupsInsert_590372;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsInsert
  ## Inserts a new creative group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590386 = newJObject()
  var query_590387 = newJObject()
  var body_590388 = newJObject()
  add(path_590386, "profileId", newJString(profileId))
  add(query_590387, "fields", newJString(fields))
  add(query_590387, "quotaUser", newJString(quotaUser))
  add(query_590387, "alt", newJString(alt))
  add(query_590387, "oauth_token", newJString(oauthToken))
  add(query_590387, "userIp", newJString(userIp))
  add(query_590387, "key", newJString(key))
  if body != nil:
    body_590388 = body
  add(query_590387, "prettyPrint", newJBool(prettyPrint))
  result = call_590385.call(path_590386, query_590387, nil, nil, body_590388)

var dfareportingCreativeGroupsInsert* = Call_DfareportingCreativeGroupsInsert_590372(
    name: "dfareportingCreativeGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsInsert_590373,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsInsert_590374,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsList_590332 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeGroupsList_590334(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsList_590333(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creative groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590335 = path.getOrDefault("profileId")
  valid_590335 = validateParameter(valid_590335, JString, required = true,
                                 default = nil)
  if valid_590335 != nil:
    section.add "profileId", valid_590335
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for creative groups by name or ID. Wildcards (*) are allowed. For example, "creativegroup*2015" will return creative groups with names like "creativegroup June 2015", "creativegroup April 2015", or simply "creativegroup 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativegroup" will match creative groups with the name "my creativegroup", "creativegroup 2015", or simply "creativegroup".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative groups with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only creative groups that belong to these advertisers.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   groupNumber: JInt
  ##              : Select only creative groups that belong to this subgroup.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590336 = query.getOrDefault("fields")
  valid_590336 = validateParameter(valid_590336, JString, required = false,
                                 default = nil)
  if valid_590336 != nil:
    section.add "fields", valid_590336
  var valid_590337 = query.getOrDefault("pageToken")
  valid_590337 = validateParameter(valid_590337, JString, required = false,
                                 default = nil)
  if valid_590337 != nil:
    section.add "pageToken", valid_590337
  var valid_590338 = query.getOrDefault("quotaUser")
  valid_590338 = validateParameter(valid_590338, JString, required = false,
                                 default = nil)
  if valid_590338 != nil:
    section.add "quotaUser", valid_590338
  var valid_590339 = query.getOrDefault("sortField")
  valid_590339 = validateParameter(valid_590339, JString, required = false,
                                 default = newJString("ID"))
  if valid_590339 != nil:
    section.add "sortField", valid_590339
  var valid_590340 = query.getOrDefault("alt")
  valid_590340 = validateParameter(valid_590340, JString, required = false,
                                 default = newJString("json"))
  if valid_590340 != nil:
    section.add "alt", valid_590340
  var valid_590341 = query.getOrDefault("searchString")
  valid_590341 = validateParameter(valid_590341, JString, required = false,
                                 default = nil)
  if valid_590341 != nil:
    section.add "searchString", valid_590341
  var valid_590342 = query.getOrDefault("oauth_token")
  valid_590342 = validateParameter(valid_590342, JString, required = false,
                                 default = nil)
  if valid_590342 != nil:
    section.add "oauth_token", valid_590342
  var valid_590343 = query.getOrDefault("userIp")
  valid_590343 = validateParameter(valid_590343, JString, required = false,
                                 default = nil)
  if valid_590343 != nil:
    section.add "userIp", valid_590343
  var valid_590344 = query.getOrDefault("maxResults")
  valid_590344 = validateParameter(valid_590344, JInt, required = false,
                                 default = newJInt(1000))
  if valid_590344 != nil:
    section.add "maxResults", valid_590344
  var valid_590345 = query.getOrDefault("ids")
  valid_590345 = validateParameter(valid_590345, JArray, required = false,
                                 default = nil)
  if valid_590345 != nil:
    section.add "ids", valid_590345
  var valid_590346 = query.getOrDefault("key")
  valid_590346 = validateParameter(valid_590346, JString, required = false,
                                 default = nil)
  if valid_590346 != nil:
    section.add "key", valid_590346
  var valid_590347 = query.getOrDefault("advertiserIds")
  valid_590347 = validateParameter(valid_590347, JArray, required = false,
                                 default = nil)
  if valid_590347 != nil:
    section.add "advertiserIds", valid_590347
  var valid_590348 = query.getOrDefault("sortOrder")
  valid_590348 = validateParameter(valid_590348, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_590348 != nil:
    section.add "sortOrder", valid_590348
  var valid_590349 = query.getOrDefault("groupNumber")
  valid_590349 = validateParameter(valid_590349, JInt, required = false, default = nil)
  if valid_590349 != nil:
    section.add "groupNumber", valid_590349
  var valid_590350 = query.getOrDefault("prettyPrint")
  valid_590350 = validateParameter(valid_590350, JBool, required = false,
                                 default = newJBool(true))
  if valid_590350 != nil:
    section.add "prettyPrint", valid_590350
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590351: Call_DfareportingCreativeGroupsList_590332; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of creative groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_590351.validator(path, query, header, formData, body)
  let scheme = call_590351.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590351.url(scheme.get, call_590351.host, call_590351.base,
                         call_590351.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590351, url, valid)

proc call*(call_590352: Call_DfareportingCreativeGroupsList_590332;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          advertiserIds: JsonNode = nil; sortOrder: string = "ASCENDING";
          groupNumber: int = 0; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsList
  ## Retrieves a list of creative groups, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for creative groups by name or ID. Wildcards (*) are allowed. For example, "creativegroup*2015" will return creative groups with names like "creativegroup June 2015", "creativegroup April 2015", or simply "creativegroup 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativegroup" will match creative groups with the name "my creativegroup", "creativegroup 2015", or simply "creativegroup".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative groups with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only creative groups that belong to these advertisers.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   groupNumber: int
  ##              : Select only creative groups that belong to this subgroup.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590353 = newJObject()
  var query_590354 = newJObject()
  add(path_590353, "profileId", newJString(profileId))
  add(query_590354, "fields", newJString(fields))
  add(query_590354, "pageToken", newJString(pageToken))
  add(query_590354, "quotaUser", newJString(quotaUser))
  add(query_590354, "sortField", newJString(sortField))
  add(query_590354, "alt", newJString(alt))
  add(query_590354, "searchString", newJString(searchString))
  add(query_590354, "oauth_token", newJString(oauthToken))
  add(query_590354, "userIp", newJString(userIp))
  add(query_590354, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_590354.add "ids", ids
  add(query_590354, "key", newJString(key))
  if advertiserIds != nil:
    query_590354.add "advertiserIds", advertiserIds
  add(query_590354, "sortOrder", newJString(sortOrder))
  add(query_590354, "groupNumber", newJInt(groupNumber))
  add(query_590354, "prettyPrint", newJBool(prettyPrint))
  result = call_590352.call(path_590353, query_590354, nil, nil, nil)

var dfareportingCreativeGroupsList* = Call_DfareportingCreativeGroupsList_590332(
    name: "dfareportingCreativeGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsList_590333,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsList_590334,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsPatch_590389 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeGroupsPatch_590391(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsPatch_590390(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590392 = path.getOrDefault("profileId")
  valid_590392 = validateParameter(valid_590392, JString, required = true,
                                 default = nil)
  if valid_590392 != nil:
    section.add "profileId", valid_590392
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative group ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590393 = query.getOrDefault("fields")
  valid_590393 = validateParameter(valid_590393, JString, required = false,
                                 default = nil)
  if valid_590393 != nil:
    section.add "fields", valid_590393
  var valid_590394 = query.getOrDefault("quotaUser")
  valid_590394 = validateParameter(valid_590394, JString, required = false,
                                 default = nil)
  if valid_590394 != nil:
    section.add "quotaUser", valid_590394
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_590395 = query.getOrDefault("id")
  valid_590395 = validateParameter(valid_590395, JString, required = true,
                                 default = nil)
  if valid_590395 != nil:
    section.add "id", valid_590395
  var valid_590396 = query.getOrDefault("alt")
  valid_590396 = validateParameter(valid_590396, JString, required = false,
                                 default = newJString("json"))
  if valid_590396 != nil:
    section.add "alt", valid_590396
  var valid_590397 = query.getOrDefault("oauth_token")
  valid_590397 = validateParameter(valid_590397, JString, required = false,
                                 default = nil)
  if valid_590397 != nil:
    section.add "oauth_token", valid_590397
  var valid_590398 = query.getOrDefault("userIp")
  valid_590398 = validateParameter(valid_590398, JString, required = false,
                                 default = nil)
  if valid_590398 != nil:
    section.add "userIp", valid_590398
  var valid_590399 = query.getOrDefault("key")
  valid_590399 = validateParameter(valid_590399, JString, required = false,
                                 default = nil)
  if valid_590399 != nil:
    section.add "key", valid_590399
  var valid_590400 = query.getOrDefault("prettyPrint")
  valid_590400 = validateParameter(valid_590400, JBool, required = false,
                                 default = newJBool(true))
  if valid_590400 != nil:
    section.add "prettyPrint", valid_590400
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590402: Call_DfareportingCreativeGroupsPatch_590389;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative group. This method supports patch semantics.
  ## 
  let valid = call_590402.validator(path, query, header, formData, body)
  let scheme = call_590402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590402.url(scheme.get, call_590402.host, call_590402.base,
                         call_590402.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590402, url, valid)

proc call*(call_590403: Call_DfareportingCreativeGroupsPatch_590389;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsPatch
  ## Updates an existing creative group. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590404 = newJObject()
  var query_590405 = newJObject()
  var body_590406 = newJObject()
  add(path_590404, "profileId", newJString(profileId))
  add(query_590405, "fields", newJString(fields))
  add(query_590405, "quotaUser", newJString(quotaUser))
  add(query_590405, "id", newJString(id))
  add(query_590405, "alt", newJString(alt))
  add(query_590405, "oauth_token", newJString(oauthToken))
  add(query_590405, "userIp", newJString(userIp))
  add(query_590405, "key", newJString(key))
  if body != nil:
    body_590406 = body
  add(query_590405, "prettyPrint", newJBool(prettyPrint))
  result = call_590403.call(path_590404, query_590405, nil, nil, body_590406)

var dfareportingCreativeGroupsPatch* = Call_DfareportingCreativeGroupsPatch_590389(
    name: "dfareportingCreativeGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsPatch_590390,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsPatch_590391,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsGet_590407 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativeGroupsGet_590409(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsGet_590408(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590410 = path.getOrDefault("profileId")
  valid_590410 = validateParameter(valid_590410, JString, required = true,
                                 default = nil)
  if valid_590410 != nil:
    section.add "profileId", valid_590410
  var valid_590411 = path.getOrDefault("id")
  valid_590411 = validateParameter(valid_590411, JString, required = true,
                                 default = nil)
  if valid_590411 != nil:
    section.add "id", valid_590411
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590412 = query.getOrDefault("fields")
  valid_590412 = validateParameter(valid_590412, JString, required = false,
                                 default = nil)
  if valid_590412 != nil:
    section.add "fields", valid_590412
  var valid_590413 = query.getOrDefault("quotaUser")
  valid_590413 = validateParameter(valid_590413, JString, required = false,
                                 default = nil)
  if valid_590413 != nil:
    section.add "quotaUser", valid_590413
  var valid_590414 = query.getOrDefault("alt")
  valid_590414 = validateParameter(valid_590414, JString, required = false,
                                 default = newJString("json"))
  if valid_590414 != nil:
    section.add "alt", valid_590414
  var valid_590415 = query.getOrDefault("oauth_token")
  valid_590415 = validateParameter(valid_590415, JString, required = false,
                                 default = nil)
  if valid_590415 != nil:
    section.add "oauth_token", valid_590415
  var valid_590416 = query.getOrDefault("userIp")
  valid_590416 = validateParameter(valid_590416, JString, required = false,
                                 default = nil)
  if valid_590416 != nil:
    section.add "userIp", valid_590416
  var valid_590417 = query.getOrDefault("key")
  valid_590417 = validateParameter(valid_590417, JString, required = false,
                                 default = nil)
  if valid_590417 != nil:
    section.add "key", valid_590417
  var valid_590418 = query.getOrDefault("prettyPrint")
  valid_590418 = validateParameter(valid_590418, JBool, required = false,
                                 default = newJBool(true))
  if valid_590418 != nil:
    section.add "prettyPrint", valid_590418
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590419: Call_DfareportingCreativeGroupsGet_590407; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one creative group by ID.
  ## 
  let valid = call_590419.validator(path, query, header, formData, body)
  let scheme = call_590419.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590419.url(scheme.get, call_590419.host, call_590419.base,
                         call_590419.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590419, url, valid)

proc call*(call_590420: Call_DfareportingCreativeGroupsGet_590407;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsGet
  ## Gets one creative group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590421 = newJObject()
  var query_590422 = newJObject()
  add(path_590421, "profileId", newJString(profileId))
  add(query_590422, "fields", newJString(fields))
  add(query_590422, "quotaUser", newJString(quotaUser))
  add(query_590422, "alt", newJString(alt))
  add(query_590422, "oauth_token", newJString(oauthToken))
  add(query_590422, "userIp", newJString(userIp))
  add(path_590421, "id", newJString(id))
  add(query_590422, "key", newJString(key))
  add(query_590422, "prettyPrint", newJBool(prettyPrint))
  result = call_590420.call(path_590421, query_590422, nil, nil, nil)

var dfareportingCreativeGroupsGet* = Call_DfareportingCreativeGroupsGet_590407(
    name: "dfareportingCreativeGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/creativeGroups/{id}",
    validator: validate_DfareportingCreativeGroupsGet_590408,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsGet_590409,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesUpdate_590454 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativesUpdate_590456(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesUpdate_590455(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590457 = path.getOrDefault("profileId")
  valid_590457 = validateParameter(valid_590457, JString, required = true,
                                 default = nil)
  if valid_590457 != nil:
    section.add "profileId", valid_590457
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590458 = query.getOrDefault("fields")
  valid_590458 = validateParameter(valid_590458, JString, required = false,
                                 default = nil)
  if valid_590458 != nil:
    section.add "fields", valid_590458
  var valid_590459 = query.getOrDefault("quotaUser")
  valid_590459 = validateParameter(valid_590459, JString, required = false,
                                 default = nil)
  if valid_590459 != nil:
    section.add "quotaUser", valid_590459
  var valid_590460 = query.getOrDefault("alt")
  valid_590460 = validateParameter(valid_590460, JString, required = false,
                                 default = newJString("json"))
  if valid_590460 != nil:
    section.add "alt", valid_590460
  var valid_590461 = query.getOrDefault("oauth_token")
  valid_590461 = validateParameter(valid_590461, JString, required = false,
                                 default = nil)
  if valid_590461 != nil:
    section.add "oauth_token", valid_590461
  var valid_590462 = query.getOrDefault("userIp")
  valid_590462 = validateParameter(valid_590462, JString, required = false,
                                 default = nil)
  if valid_590462 != nil:
    section.add "userIp", valid_590462
  var valid_590463 = query.getOrDefault("key")
  valid_590463 = validateParameter(valid_590463, JString, required = false,
                                 default = nil)
  if valid_590463 != nil:
    section.add "key", valid_590463
  var valid_590464 = query.getOrDefault("prettyPrint")
  valid_590464 = validateParameter(valid_590464, JBool, required = false,
                                 default = newJBool(true))
  if valid_590464 != nil:
    section.add "prettyPrint", valid_590464
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590466: Call_DfareportingCreativesUpdate_590454; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing creative.
  ## 
  let valid = call_590466.validator(path, query, header, formData, body)
  let scheme = call_590466.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590466.url(scheme.get, call_590466.host, call_590466.base,
                         call_590466.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590466, url, valid)

proc call*(call_590467: Call_DfareportingCreativesUpdate_590454; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativesUpdate
  ## Updates an existing creative.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590468 = newJObject()
  var query_590469 = newJObject()
  var body_590470 = newJObject()
  add(path_590468, "profileId", newJString(profileId))
  add(query_590469, "fields", newJString(fields))
  add(query_590469, "quotaUser", newJString(quotaUser))
  add(query_590469, "alt", newJString(alt))
  add(query_590469, "oauth_token", newJString(oauthToken))
  add(query_590469, "userIp", newJString(userIp))
  add(query_590469, "key", newJString(key))
  if body != nil:
    body_590470 = body
  add(query_590469, "prettyPrint", newJBool(prettyPrint))
  result = call_590467.call(path_590468, query_590469, nil, nil, body_590470)

var dfareportingCreativesUpdate* = Call_DfareportingCreativesUpdate_590454(
    name: "dfareportingCreativesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesUpdate_590455,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesUpdate_590456,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesInsert_590471 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativesInsert_590473(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesInsert_590472(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590474 = path.getOrDefault("profileId")
  valid_590474 = validateParameter(valid_590474, JString, required = true,
                                 default = nil)
  if valid_590474 != nil:
    section.add "profileId", valid_590474
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590475 = query.getOrDefault("fields")
  valid_590475 = validateParameter(valid_590475, JString, required = false,
                                 default = nil)
  if valid_590475 != nil:
    section.add "fields", valid_590475
  var valid_590476 = query.getOrDefault("quotaUser")
  valid_590476 = validateParameter(valid_590476, JString, required = false,
                                 default = nil)
  if valid_590476 != nil:
    section.add "quotaUser", valid_590476
  var valid_590477 = query.getOrDefault("alt")
  valid_590477 = validateParameter(valid_590477, JString, required = false,
                                 default = newJString("json"))
  if valid_590477 != nil:
    section.add "alt", valid_590477
  var valid_590478 = query.getOrDefault("oauth_token")
  valid_590478 = validateParameter(valid_590478, JString, required = false,
                                 default = nil)
  if valid_590478 != nil:
    section.add "oauth_token", valid_590478
  var valid_590479 = query.getOrDefault("userIp")
  valid_590479 = validateParameter(valid_590479, JString, required = false,
                                 default = nil)
  if valid_590479 != nil:
    section.add "userIp", valid_590479
  var valid_590480 = query.getOrDefault("key")
  valid_590480 = validateParameter(valid_590480, JString, required = false,
                                 default = nil)
  if valid_590480 != nil:
    section.add "key", valid_590480
  var valid_590481 = query.getOrDefault("prettyPrint")
  valid_590481 = validateParameter(valid_590481, JBool, required = false,
                                 default = newJBool(true))
  if valid_590481 != nil:
    section.add "prettyPrint", valid_590481
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590483: Call_DfareportingCreativesInsert_590471; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new creative.
  ## 
  let valid = call_590483.validator(path, query, header, formData, body)
  let scheme = call_590483.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590483.url(scheme.get, call_590483.host, call_590483.base,
                         call_590483.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590483, url, valid)

proc call*(call_590484: Call_DfareportingCreativesInsert_590471; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativesInsert
  ## Inserts a new creative.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590485 = newJObject()
  var query_590486 = newJObject()
  var body_590487 = newJObject()
  add(path_590485, "profileId", newJString(profileId))
  add(query_590486, "fields", newJString(fields))
  add(query_590486, "quotaUser", newJString(quotaUser))
  add(query_590486, "alt", newJString(alt))
  add(query_590486, "oauth_token", newJString(oauthToken))
  add(query_590486, "userIp", newJString(userIp))
  add(query_590486, "key", newJString(key))
  if body != nil:
    body_590487 = body
  add(query_590486, "prettyPrint", newJBool(prettyPrint))
  result = call_590484.call(path_590485, query_590486, nil, nil, body_590487)

var dfareportingCreativesInsert* = Call_DfareportingCreativesInsert_590471(
    name: "dfareportingCreativesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesInsert_590472,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesInsert_590473,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesList_590423 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativesList_590425(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesList_590424(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creatives, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590426 = path.getOrDefault("profileId")
  valid_590426 = validateParameter(valid_590426, JString, required = true,
                                 default = nil)
  if valid_590426 != nil:
    section.add "profileId", valid_590426
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "creative*2015" will return objects with names like "creative June 2015", "creative April 2015", or simply "creative 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "creative" will match objects with name "my creative", "creative 2015", or simply "creative".
  ##   advertiserId: JString
  ##               : Select only creatives with this advertiser ID.
  ##   types: JArray
  ##        : Select only creatives with these creative types.
  ##   sizeIds: JArray
  ##          : Select only creatives with these size IDs.
  ##   active: JBool
  ##         : Select only active creatives. Leave blank to select active and inactive creatives.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   studioCreativeId: JString
  ##                   : Select only creatives corresponding to this Studio creative ID.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   renderingIds: JArray
  ##               : Select only creatives with these rendering IDs.
  ##   archived: JBool
  ##           : Select only archived creatives. Leave blank to select archived and unarchived creatives.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creatives with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldIds: JArray
  ##                   : Select only creatives with these creative field IDs.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   companionCreativeIds: JArray
  ##                       : Select only in-stream video creatives with these companion IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: JString
  ##             : Select only creatives with this campaign ID.
  section = newJObject()
  var valid_590427 = query.getOrDefault("fields")
  valid_590427 = validateParameter(valid_590427, JString, required = false,
                                 default = nil)
  if valid_590427 != nil:
    section.add "fields", valid_590427
  var valid_590428 = query.getOrDefault("pageToken")
  valid_590428 = validateParameter(valid_590428, JString, required = false,
                                 default = nil)
  if valid_590428 != nil:
    section.add "pageToken", valid_590428
  var valid_590429 = query.getOrDefault("quotaUser")
  valid_590429 = validateParameter(valid_590429, JString, required = false,
                                 default = nil)
  if valid_590429 != nil:
    section.add "quotaUser", valid_590429
  var valid_590430 = query.getOrDefault("sortField")
  valid_590430 = validateParameter(valid_590430, JString, required = false,
                                 default = newJString("ID"))
  if valid_590430 != nil:
    section.add "sortField", valid_590430
  var valid_590431 = query.getOrDefault("alt")
  valid_590431 = validateParameter(valid_590431, JString, required = false,
                                 default = newJString("json"))
  if valid_590431 != nil:
    section.add "alt", valid_590431
  var valid_590432 = query.getOrDefault("searchString")
  valid_590432 = validateParameter(valid_590432, JString, required = false,
                                 default = nil)
  if valid_590432 != nil:
    section.add "searchString", valid_590432
  var valid_590433 = query.getOrDefault("advertiserId")
  valid_590433 = validateParameter(valid_590433, JString, required = false,
                                 default = nil)
  if valid_590433 != nil:
    section.add "advertiserId", valid_590433
  var valid_590434 = query.getOrDefault("types")
  valid_590434 = validateParameter(valid_590434, JArray, required = false,
                                 default = nil)
  if valid_590434 != nil:
    section.add "types", valid_590434
  var valid_590435 = query.getOrDefault("sizeIds")
  valid_590435 = validateParameter(valid_590435, JArray, required = false,
                                 default = nil)
  if valid_590435 != nil:
    section.add "sizeIds", valid_590435
  var valid_590436 = query.getOrDefault("active")
  valid_590436 = validateParameter(valid_590436, JBool, required = false, default = nil)
  if valid_590436 != nil:
    section.add "active", valid_590436
  var valid_590437 = query.getOrDefault("oauth_token")
  valid_590437 = validateParameter(valid_590437, JString, required = false,
                                 default = nil)
  if valid_590437 != nil:
    section.add "oauth_token", valid_590437
  var valid_590438 = query.getOrDefault("studioCreativeId")
  valid_590438 = validateParameter(valid_590438, JString, required = false,
                                 default = nil)
  if valid_590438 != nil:
    section.add "studioCreativeId", valid_590438
  var valid_590439 = query.getOrDefault("userIp")
  valid_590439 = validateParameter(valid_590439, JString, required = false,
                                 default = nil)
  if valid_590439 != nil:
    section.add "userIp", valid_590439
  var valid_590440 = query.getOrDefault("renderingIds")
  valid_590440 = validateParameter(valid_590440, JArray, required = false,
                                 default = nil)
  if valid_590440 != nil:
    section.add "renderingIds", valid_590440
  var valid_590441 = query.getOrDefault("archived")
  valid_590441 = validateParameter(valid_590441, JBool, required = false, default = nil)
  if valid_590441 != nil:
    section.add "archived", valid_590441
  var valid_590442 = query.getOrDefault("maxResults")
  valid_590442 = validateParameter(valid_590442, JInt, required = false,
                                 default = newJInt(1000))
  if valid_590442 != nil:
    section.add "maxResults", valid_590442
  var valid_590443 = query.getOrDefault("ids")
  valid_590443 = validateParameter(valid_590443, JArray, required = false,
                                 default = nil)
  if valid_590443 != nil:
    section.add "ids", valid_590443
  var valid_590444 = query.getOrDefault("key")
  valid_590444 = validateParameter(valid_590444, JString, required = false,
                                 default = nil)
  if valid_590444 != nil:
    section.add "key", valid_590444
  var valid_590445 = query.getOrDefault("creativeFieldIds")
  valid_590445 = validateParameter(valid_590445, JArray, required = false,
                                 default = nil)
  if valid_590445 != nil:
    section.add "creativeFieldIds", valid_590445
  var valid_590446 = query.getOrDefault("sortOrder")
  valid_590446 = validateParameter(valid_590446, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_590446 != nil:
    section.add "sortOrder", valid_590446
  var valid_590447 = query.getOrDefault("companionCreativeIds")
  valid_590447 = validateParameter(valid_590447, JArray, required = false,
                                 default = nil)
  if valid_590447 != nil:
    section.add "companionCreativeIds", valid_590447
  var valid_590448 = query.getOrDefault("prettyPrint")
  valid_590448 = validateParameter(valid_590448, JBool, required = false,
                                 default = newJBool(true))
  if valid_590448 != nil:
    section.add "prettyPrint", valid_590448
  var valid_590449 = query.getOrDefault("campaignId")
  valid_590449 = validateParameter(valid_590449, JString, required = false,
                                 default = nil)
  if valid_590449 != nil:
    section.add "campaignId", valid_590449
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590450: Call_DfareportingCreativesList_590423; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of creatives, possibly filtered. This method supports paging.
  ## 
  let valid = call_590450.validator(path, query, header, formData, body)
  let scheme = call_590450.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590450.url(scheme.get, call_590450.host, call_590450.base,
                         call_590450.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590450, url, valid)

proc call*(call_590451: Call_DfareportingCreativesList_590423; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; searchString: string = "";
          advertiserId: string = ""; types: JsonNode = nil; sizeIds: JsonNode = nil;
          active: bool = false; oauthToken: string = ""; studioCreativeId: string = "";
          userIp: string = ""; renderingIds: JsonNode = nil; archived: bool = false;
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          creativeFieldIds: JsonNode = nil; sortOrder: string = "ASCENDING";
          companionCreativeIds: JsonNode = nil; prettyPrint: bool = true;
          campaignId: string = ""): Recallable =
  ## dfareportingCreativesList
  ## Retrieves a list of creatives, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "creative*2015" will return objects with names like "creative June 2015", "creative April 2015", or simply "creative 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "creative" will match objects with name "my creative", "creative 2015", or simply "creative".
  ##   advertiserId: string
  ##               : Select only creatives with this advertiser ID.
  ##   types: JArray
  ##        : Select only creatives with these creative types.
  ##   sizeIds: JArray
  ##          : Select only creatives with these size IDs.
  ##   active: bool
  ##         : Select only active creatives. Leave blank to select active and inactive creatives.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   studioCreativeId: string
  ##                   : Select only creatives corresponding to this Studio creative ID.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   renderingIds: JArray
  ##               : Select only creatives with these rendering IDs.
  ##   archived: bool
  ##           : Select only archived creatives. Leave blank to select archived and unarchived creatives.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creatives with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldIds: JArray
  ##                   : Select only creatives with these creative field IDs.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   companionCreativeIds: JArray
  ##                       : Select only in-stream video creatives with these companion IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: string
  ##             : Select only creatives with this campaign ID.
  var path_590452 = newJObject()
  var query_590453 = newJObject()
  add(path_590452, "profileId", newJString(profileId))
  add(query_590453, "fields", newJString(fields))
  add(query_590453, "pageToken", newJString(pageToken))
  add(query_590453, "quotaUser", newJString(quotaUser))
  add(query_590453, "sortField", newJString(sortField))
  add(query_590453, "alt", newJString(alt))
  add(query_590453, "searchString", newJString(searchString))
  add(query_590453, "advertiserId", newJString(advertiserId))
  if types != nil:
    query_590453.add "types", types
  if sizeIds != nil:
    query_590453.add "sizeIds", sizeIds
  add(query_590453, "active", newJBool(active))
  add(query_590453, "oauth_token", newJString(oauthToken))
  add(query_590453, "studioCreativeId", newJString(studioCreativeId))
  add(query_590453, "userIp", newJString(userIp))
  if renderingIds != nil:
    query_590453.add "renderingIds", renderingIds
  add(query_590453, "archived", newJBool(archived))
  add(query_590453, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_590453.add "ids", ids
  add(query_590453, "key", newJString(key))
  if creativeFieldIds != nil:
    query_590453.add "creativeFieldIds", creativeFieldIds
  add(query_590453, "sortOrder", newJString(sortOrder))
  if companionCreativeIds != nil:
    query_590453.add "companionCreativeIds", companionCreativeIds
  add(query_590453, "prettyPrint", newJBool(prettyPrint))
  add(query_590453, "campaignId", newJString(campaignId))
  result = call_590451.call(path_590452, query_590453, nil, nil, nil)

var dfareportingCreativesList* = Call_DfareportingCreativesList_590423(
    name: "dfareportingCreativesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesList_590424,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesList_590425,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesPatch_590488 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativesPatch_590490(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesPatch_590489(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590491 = path.getOrDefault("profileId")
  valid_590491 = validateParameter(valid_590491, JString, required = true,
                                 default = nil)
  if valid_590491 != nil:
    section.add "profileId", valid_590491
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590492 = query.getOrDefault("fields")
  valid_590492 = validateParameter(valid_590492, JString, required = false,
                                 default = nil)
  if valid_590492 != nil:
    section.add "fields", valid_590492
  var valid_590493 = query.getOrDefault("quotaUser")
  valid_590493 = validateParameter(valid_590493, JString, required = false,
                                 default = nil)
  if valid_590493 != nil:
    section.add "quotaUser", valid_590493
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_590494 = query.getOrDefault("id")
  valid_590494 = validateParameter(valid_590494, JString, required = true,
                                 default = nil)
  if valid_590494 != nil:
    section.add "id", valid_590494
  var valid_590495 = query.getOrDefault("alt")
  valid_590495 = validateParameter(valid_590495, JString, required = false,
                                 default = newJString("json"))
  if valid_590495 != nil:
    section.add "alt", valid_590495
  var valid_590496 = query.getOrDefault("oauth_token")
  valid_590496 = validateParameter(valid_590496, JString, required = false,
                                 default = nil)
  if valid_590496 != nil:
    section.add "oauth_token", valid_590496
  var valid_590497 = query.getOrDefault("userIp")
  valid_590497 = validateParameter(valid_590497, JString, required = false,
                                 default = nil)
  if valid_590497 != nil:
    section.add "userIp", valid_590497
  var valid_590498 = query.getOrDefault("key")
  valid_590498 = validateParameter(valid_590498, JString, required = false,
                                 default = nil)
  if valid_590498 != nil:
    section.add "key", valid_590498
  var valid_590499 = query.getOrDefault("prettyPrint")
  valid_590499 = validateParameter(valid_590499, JBool, required = false,
                                 default = newJBool(true))
  if valid_590499 != nil:
    section.add "prettyPrint", valid_590499
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590501: Call_DfareportingCreativesPatch_590488; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing creative. This method supports patch semantics.
  ## 
  let valid = call_590501.validator(path, query, header, formData, body)
  let scheme = call_590501.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590501.url(scheme.get, call_590501.host, call_590501.base,
                         call_590501.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590501, url, valid)

proc call*(call_590502: Call_DfareportingCreativesPatch_590488; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativesPatch
  ## Updates an existing creative. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590503 = newJObject()
  var query_590504 = newJObject()
  var body_590505 = newJObject()
  add(path_590503, "profileId", newJString(profileId))
  add(query_590504, "fields", newJString(fields))
  add(query_590504, "quotaUser", newJString(quotaUser))
  add(query_590504, "id", newJString(id))
  add(query_590504, "alt", newJString(alt))
  add(query_590504, "oauth_token", newJString(oauthToken))
  add(query_590504, "userIp", newJString(userIp))
  add(query_590504, "key", newJString(key))
  if body != nil:
    body_590505 = body
  add(query_590504, "prettyPrint", newJBool(prettyPrint))
  result = call_590502.call(path_590503, query_590504, nil, nil, body_590505)

var dfareportingCreativesPatch* = Call_DfareportingCreativesPatch_590488(
    name: "dfareportingCreativesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesPatch_590489,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesPatch_590490,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesGet_590506 = ref object of OpenApiRestCall_588466
proc url_DfareportingCreativesGet_590508(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesGet_590507(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590509 = path.getOrDefault("profileId")
  valid_590509 = validateParameter(valid_590509, JString, required = true,
                                 default = nil)
  if valid_590509 != nil:
    section.add "profileId", valid_590509
  var valid_590510 = path.getOrDefault("id")
  valid_590510 = validateParameter(valid_590510, JString, required = true,
                                 default = nil)
  if valid_590510 != nil:
    section.add "id", valid_590510
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590511 = query.getOrDefault("fields")
  valid_590511 = validateParameter(valid_590511, JString, required = false,
                                 default = nil)
  if valid_590511 != nil:
    section.add "fields", valid_590511
  var valid_590512 = query.getOrDefault("quotaUser")
  valid_590512 = validateParameter(valid_590512, JString, required = false,
                                 default = nil)
  if valid_590512 != nil:
    section.add "quotaUser", valid_590512
  var valid_590513 = query.getOrDefault("alt")
  valid_590513 = validateParameter(valid_590513, JString, required = false,
                                 default = newJString("json"))
  if valid_590513 != nil:
    section.add "alt", valid_590513
  var valid_590514 = query.getOrDefault("oauth_token")
  valid_590514 = validateParameter(valid_590514, JString, required = false,
                                 default = nil)
  if valid_590514 != nil:
    section.add "oauth_token", valid_590514
  var valid_590515 = query.getOrDefault("userIp")
  valid_590515 = validateParameter(valid_590515, JString, required = false,
                                 default = nil)
  if valid_590515 != nil:
    section.add "userIp", valid_590515
  var valid_590516 = query.getOrDefault("key")
  valid_590516 = validateParameter(valid_590516, JString, required = false,
                                 default = nil)
  if valid_590516 != nil:
    section.add "key", valid_590516
  var valid_590517 = query.getOrDefault("prettyPrint")
  valid_590517 = validateParameter(valid_590517, JBool, required = false,
                                 default = newJBool(true))
  if valid_590517 != nil:
    section.add "prettyPrint", valid_590517
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590518: Call_DfareportingCreativesGet_590506; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one creative by ID.
  ## 
  let valid = call_590518.validator(path, query, header, formData, body)
  let scheme = call_590518.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590518.url(scheme.get, call_590518.host, call_590518.base,
                         call_590518.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590518, url, valid)

proc call*(call_590519: Call_DfareportingCreativesGet_590506; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativesGet
  ## Gets one creative by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590520 = newJObject()
  var query_590521 = newJObject()
  add(path_590520, "profileId", newJString(profileId))
  add(query_590521, "fields", newJString(fields))
  add(query_590521, "quotaUser", newJString(quotaUser))
  add(query_590521, "alt", newJString(alt))
  add(query_590521, "oauth_token", newJString(oauthToken))
  add(query_590521, "userIp", newJString(userIp))
  add(path_590520, "id", newJString(id))
  add(query_590521, "key", newJString(key))
  add(query_590521, "prettyPrint", newJBool(prettyPrint))
  result = call_590519.call(path_590520, query_590521, nil, nil, nil)

var dfareportingCreativesGet* = Call_DfareportingCreativesGet_590506(
    name: "dfareportingCreativesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives/{id}",
    validator: validate_DfareportingCreativesGet_590507,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesGet_590508,
    schemes: {Scheme.Https})
type
  Call_DfareportingDimensionValuesQuery_590522 = ref object of OpenApiRestCall_588466
proc url_DfareportingDimensionValuesQuery_590524(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dimensionvalues/query")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDimensionValuesQuery_590523(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves list of report dimension values for a list of filters.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590525 = path.getOrDefault("profileId")
  valid_590525 = validateParameter(valid_590525, JString, required = true,
                                 default = nil)
  if valid_590525 != nil:
    section.add "profileId", valid_590525
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590526 = query.getOrDefault("fields")
  valid_590526 = validateParameter(valid_590526, JString, required = false,
                                 default = nil)
  if valid_590526 != nil:
    section.add "fields", valid_590526
  var valid_590527 = query.getOrDefault("pageToken")
  valid_590527 = validateParameter(valid_590527, JString, required = false,
                                 default = nil)
  if valid_590527 != nil:
    section.add "pageToken", valid_590527
  var valid_590528 = query.getOrDefault("quotaUser")
  valid_590528 = validateParameter(valid_590528, JString, required = false,
                                 default = nil)
  if valid_590528 != nil:
    section.add "quotaUser", valid_590528
  var valid_590529 = query.getOrDefault("alt")
  valid_590529 = validateParameter(valid_590529, JString, required = false,
                                 default = newJString("json"))
  if valid_590529 != nil:
    section.add "alt", valid_590529
  var valid_590530 = query.getOrDefault("oauth_token")
  valid_590530 = validateParameter(valid_590530, JString, required = false,
                                 default = nil)
  if valid_590530 != nil:
    section.add "oauth_token", valid_590530
  var valid_590531 = query.getOrDefault("userIp")
  valid_590531 = validateParameter(valid_590531, JString, required = false,
                                 default = nil)
  if valid_590531 != nil:
    section.add "userIp", valid_590531
  var valid_590532 = query.getOrDefault("maxResults")
  valid_590532 = validateParameter(valid_590532, JInt, required = false,
                                 default = newJInt(100))
  if valid_590532 != nil:
    section.add "maxResults", valid_590532
  var valid_590533 = query.getOrDefault("key")
  valid_590533 = validateParameter(valid_590533, JString, required = false,
                                 default = nil)
  if valid_590533 != nil:
    section.add "key", valid_590533
  var valid_590534 = query.getOrDefault("prettyPrint")
  valid_590534 = validateParameter(valid_590534, JBool, required = false,
                                 default = newJBool(true))
  if valid_590534 != nil:
    section.add "prettyPrint", valid_590534
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590536: Call_DfareportingDimensionValuesQuery_590522;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves list of report dimension values for a list of filters.
  ## 
  let valid = call_590536.validator(path, query, header, formData, body)
  let scheme = call_590536.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590536.url(scheme.get, call_590536.host, call_590536.base,
                         call_590536.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590536, url, valid)

proc call*(call_590537: Call_DfareportingDimensionValuesQuery_590522;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; maxResults: int = 100; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingDimensionValuesQuery
  ## Retrieves list of report dimension values for a list of filters.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590538 = newJObject()
  var query_590539 = newJObject()
  var body_590540 = newJObject()
  add(path_590538, "profileId", newJString(profileId))
  add(query_590539, "fields", newJString(fields))
  add(query_590539, "pageToken", newJString(pageToken))
  add(query_590539, "quotaUser", newJString(quotaUser))
  add(query_590539, "alt", newJString(alt))
  add(query_590539, "oauth_token", newJString(oauthToken))
  add(query_590539, "userIp", newJString(userIp))
  add(query_590539, "maxResults", newJInt(maxResults))
  add(query_590539, "key", newJString(key))
  if body != nil:
    body_590540 = body
  add(query_590539, "prettyPrint", newJBool(prettyPrint))
  result = call_590537.call(path_590538, query_590539, nil, nil, body_590540)

var dfareportingDimensionValuesQuery* = Call_DfareportingDimensionValuesQuery_590522(
    name: "dfareportingDimensionValuesQuery", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dimensionvalues/query",
    validator: validate_DfareportingDimensionValuesQuery_590523,
    base: "/dfareporting/v2.7", url: url_DfareportingDimensionValuesQuery_590524,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySiteContactsList_590541 = ref object of OpenApiRestCall_588466
proc url_DfareportingDirectorySiteContactsList_590543(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySiteContacts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySiteContactsList_590542(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of directory site contacts, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590544 = path.getOrDefault("profileId")
  valid_590544 = validateParameter(valid_590544, JString, required = true,
                                 default = nil)
  if valid_590544 != nil:
    section.add "profileId", valid_590544
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "directory site contact*2015" will return objects with names like "directory site contact June 2015", "directory site contact April 2015", or simply "directory site contact 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site contact" will match objects with name "my directory site contact", "directory site contact 2015", or simply "directory site contact".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only directory site contacts with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only directory site contacts with these directory site IDs. This is a required field.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590545 = query.getOrDefault("fields")
  valid_590545 = validateParameter(valid_590545, JString, required = false,
                                 default = nil)
  if valid_590545 != nil:
    section.add "fields", valid_590545
  var valid_590546 = query.getOrDefault("pageToken")
  valid_590546 = validateParameter(valid_590546, JString, required = false,
                                 default = nil)
  if valid_590546 != nil:
    section.add "pageToken", valid_590546
  var valid_590547 = query.getOrDefault("quotaUser")
  valid_590547 = validateParameter(valid_590547, JString, required = false,
                                 default = nil)
  if valid_590547 != nil:
    section.add "quotaUser", valid_590547
  var valid_590548 = query.getOrDefault("sortField")
  valid_590548 = validateParameter(valid_590548, JString, required = false,
                                 default = newJString("ID"))
  if valid_590548 != nil:
    section.add "sortField", valid_590548
  var valid_590549 = query.getOrDefault("alt")
  valid_590549 = validateParameter(valid_590549, JString, required = false,
                                 default = newJString("json"))
  if valid_590549 != nil:
    section.add "alt", valid_590549
  var valid_590550 = query.getOrDefault("searchString")
  valid_590550 = validateParameter(valid_590550, JString, required = false,
                                 default = nil)
  if valid_590550 != nil:
    section.add "searchString", valid_590550
  var valid_590551 = query.getOrDefault("oauth_token")
  valid_590551 = validateParameter(valid_590551, JString, required = false,
                                 default = nil)
  if valid_590551 != nil:
    section.add "oauth_token", valid_590551
  var valid_590552 = query.getOrDefault("userIp")
  valid_590552 = validateParameter(valid_590552, JString, required = false,
                                 default = nil)
  if valid_590552 != nil:
    section.add "userIp", valid_590552
  var valid_590553 = query.getOrDefault("maxResults")
  valid_590553 = validateParameter(valid_590553, JInt, required = false,
                                 default = newJInt(1000))
  if valid_590553 != nil:
    section.add "maxResults", valid_590553
  var valid_590554 = query.getOrDefault("ids")
  valid_590554 = validateParameter(valid_590554, JArray, required = false,
                                 default = nil)
  if valid_590554 != nil:
    section.add "ids", valid_590554
  var valid_590555 = query.getOrDefault("key")
  valid_590555 = validateParameter(valid_590555, JString, required = false,
                                 default = nil)
  if valid_590555 != nil:
    section.add "key", valid_590555
  var valid_590556 = query.getOrDefault("sortOrder")
  valid_590556 = validateParameter(valid_590556, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_590556 != nil:
    section.add "sortOrder", valid_590556
  var valid_590557 = query.getOrDefault("directorySiteIds")
  valid_590557 = validateParameter(valid_590557, JArray, required = false,
                                 default = nil)
  if valid_590557 != nil:
    section.add "directorySiteIds", valid_590557
  var valid_590558 = query.getOrDefault("prettyPrint")
  valid_590558 = validateParameter(valid_590558, JBool, required = false,
                                 default = newJBool(true))
  if valid_590558 != nil:
    section.add "prettyPrint", valid_590558
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590559: Call_DfareportingDirectorySiteContactsList_590541;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of directory site contacts, possibly filtered. This method supports paging.
  ## 
  let valid = call_590559.validator(path, query, header, formData, body)
  let scheme = call_590559.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590559.url(scheme.get, call_590559.host, call_590559.base,
                         call_590559.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590559, url, valid)

proc call*(call_590560: Call_DfareportingDirectorySiteContactsList_590541;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; directorySiteIds: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySiteContactsList
  ## Retrieves a list of directory site contacts, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "directory site contact*2015" will return objects with names like "directory site contact June 2015", "directory site contact April 2015", or simply "directory site contact 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site contact" will match objects with name "my directory site contact", "directory site contact 2015", or simply "directory site contact".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only directory site contacts with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only directory site contacts with these directory site IDs. This is a required field.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590561 = newJObject()
  var query_590562 = newJObject()
  add(path_590561, "profileId", newJString(profileId))
  add(query_590562, "fields", newJString(fields))
  add(query_590562, "pageToken", newJString(pageToken))
  add(query_590562, "quotaUser", newJString(quotaUser))
  add(query_590562, "sortField", newJString(sortField))
  add(query_590562, "alt", newJString(alt))
  add(query_590562, "searchString", newJString(searchString))
  add(query_590562, "oauth_token", newJString(oauthToken))
  add(query_590562, "userIp", newJString(userIp))
  add(query_590562, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_590562.add "ids", ids
  add(query_590562, "key", newJString(key))
  add(query_590562, "sortOrder", newJString(sortOrder))
  if directorySiteIds != nil:
    query_590562.add "directorySiteIds", directorySiteIds
  add(query_590562, "prettyPrint", newJBool(prettyPrint))
  result = call_590560.call(path_590561, query_590562, nil, nil, nil)

var dfareportingDirectorySiteContactsList* = Call_DfareportingDirectorySiteContactsList_590541(
    name: "dfareportingDirectorySiteContactsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/directorySiteContacts",
    validator: validate_DfareportingDirectorySiteContactsList_590542,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySiteContactsList_590543,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySiteContactsGet_590563 = ref object of OpenApiRestCall_588466
proc url_DfareportingDirectorySiteContactsGet_590565(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySiteContacts/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySiteContactsGet_590564(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one directory site contact by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Directory site contact ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590566 = path.getOrDefault("profileId")
  valid_590566 = validateParameter(valid_590566, JString, required = true,
                                 default = nil)
  if valid_590566 != nil:
    section.add "profileId", valid_590566
  var valid_590567 = path.getOrDefault("id")
  valid_590567 = validateParameter(valid_590567, JString, required = true,
                                 default = nil)
  if valid_590567 != nil:
    section.add "id", valid_590567
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590568 = query.getOrDefault("fields")
  valid_590568 = validateParameter(valid_590568, JString, required = false,
                                 default = nil)
  if valid_590568 != nil:
    section.add "fields", valid_590568
  var valid_590569 = query.getOrDefault("quotaUser")
  valid_590569 = validateParameter(valid_590569, JString, required = false,
                                 default = nil)
  if valid_590569 != nil:
    section.add "quotaUser", valid_590569
  var valid_590570 = query.getOrDefault("alt")
  valid_590570 = validateParameter(valid_590570, JString, required = false,
                                 default = newJString("json"))
  if valid_590570 != nil:
    section.add "alt", valid_590570
  var valid_590571 = query.getOrDefault("oauth_token")
  valid_590571 = validateParameter(valid_590571, JString, required = false,
                                 default = nil)
  if valid_590571 != nil:
    section.add "oauth_token", valid_590571
  var valid_590572 = query.getOrDefault("userIp")
  valid_590572 = validateParameter(valid_590572, JString, required = false,
                                 default = nil)
  if valid_590572 != nil:
    section.add "userIp", valid_590572
  var valid_590573 = query.getOrDefault("key")
  valid_590573 = validateParameter(valid_590573, JString, required = false,
                                 default = nil)
  if valid_590573 != nil:
    section.add "key", valid_590573
  var valid_590574 = query.getOrDefault("prettyPrint")
  valid_590574 = validateParameter(valid_590574, JBool, required = false,
                                 default = newJBool(true))
  if valid_590574 != nil:
    section.add "prettyPrint", valid_590574
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590575: Call_DfareportingDirectorySiteContactsGet_590563;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one directory site contact by ID.
  ## 
  let valid = call_590575.validator(path, query, header, formData, body)
  let scheme = call_590575.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590575.url(scheme.get, call_590575.host, call_590575.base,
                         call_590575.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590575, url, valid)

proc call*(call_590576: Call_DfareportingDirectorySiteContactsGet_590563;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySiteContactsGet
  ## Gets one directory site contact by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Directory site contact ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590577 = newJObject()
  var query_590578 = newJObject()
  add(path_590577, "profileId", newJString(profileId))
  add(query_590578, "fields", newJString(fields))
  add(query_590578, "quotaUser", newJString(quotaUser))
  add(query_590578, "alt", newJString(alt))
  add(query_590578, "oauth_token", newJString(oauthToken))
  add(query_590578, "userIp", newJString(userIp))
  add(path_590577, "id", newJString(id))
  add(query_590578, "key", newJString(key))
  add(query_590578, "prettyPrint", newJBool(prettyPrint))
  result = call_590576.call(path_590577, query_590578, nil, nil, nil)

var dfareportingDirectorySiteContactsGet* = Call_DfareportingDirectorySiteContactsGet_590563(
    name: "dfareportingDirectorySiteContactsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/directorySiteContacts/{id}",
    validator: validate_DfareportingDirectorySiteContactsGet_590564,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySiteContactsGet_590565,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySitesInsert_590607 = ref object of OpenApiRestCall_588466
proc url_DfareportingDirectorySitesInsert_590609(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySitesInsert_590608(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new directory site.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590610 = path.getOrDefault("profileId")
  valid_590610 = validateParameter(valid_590610, JString, required = true,
                                 default = nil)
  if valid_590610 != nil:
    section.add "profileId", valid_590610
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590611 = query.getOrDefault("fields")
  valid_590611 = validateParameter(valid_590611, JString, required = false,
                                 default = nil)
  if valid_590611 != nil:
    section.add "fields", valid_590611
  var valid_590612 = query.getOrDefault("quotaUser")
  valid_590612 = validateParameter(valid_590612, JString, required = false,
                                 default = nil)
  if valid_590612 != nil:
    section.add "quotaUser", valid_590612
  var valid_590613 = query.getOrDefault("alt")
  valid_590613 = validateParameter(valid_590613, JString, required = false,
                                 default = newJString("json"))
  if valid_590613 != nil:
    section.add "alt", valid_590613
  var valid_590614 = query.getOrDefault("oauth_token")
  valid_590614 = validateParameter(valid_590614, JString, required = false,
                                 default = nil)
  if valid_590614 != nil:
    section.add "oauth_token", valid_590614
  var valid_590615 = query.getOrDefault("userIp")
  valid_590615 = validateParameter(valid_590615, JString, required = false,
                                 default = nil)
  if valid_590615 != nil:
    section.add "userIp", valid_590615
  var valid_590616 = query.getOrDefault("key")
  valid_590616 = validateParameter(valid_590616, JString, required = false,
                                 default = nil)
  if valid_590616 != nil:
    section.add "key", valid_590616
  var valid_590617 = query.getOrDefault("prettyPrint")
  valid_590617 = validateParameter(valid_590617, JBool, required = false,
                                 default = newJBool(true))
  if valid_590617 != nil:
    section.add "prettyPrint", valid_590617
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590619: Call_DfareportingDirectorySitesInsert_590607;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new directory site.
  ## 
  let valid = call_590619.validator(path, query, header, formData, body)
  let scheme = call_590619.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590619.url(scheme.get, call_590619.host, call_590619.base,
                         call_590619.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590619, url, valid)

proc call*(call_590620: Call_DfareportingDirectorySitesInsert_590607;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySitesInsert
  ## Inserts a new directory site.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590621 = newJObject()
  var query_590622 = newJObject()
  var body_590623 = newJObject()
  add(path_590621, "profileId", newJString(profileId))
  add(query_590622, "fields", newJString(fields))
  add(query_590622, "quotaUser", newJString(quotaUser))
  add(query_590622, "alt", newJString(alt))
  add(query_590622, "oauth_token", newJString(oauthToken))
  add(query_590622, "userIp", newJString(userIp))
  add(query_590622, "key", newJString(key))
  if body != nil:
    body_590623 = body
  add(query_590622, "prettyPrint", newJBool(prettyPrint))
  result = call_590620.call(path_590621, query_590622, nil, nil, body_590623)

var dfareportingDirectorySitesInsert* = Call_DfareportingDirectorySitesInsert_590607(
    name: "dfareportingDirectorySitesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/directorySites",
    validator: validate_DfareportingDirectorySitesInsert_590608,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySitesInsert_590609,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySitesList_590579 = ref object of OpenApiRestCall_588466
proc url_DfareportingDirectorySitesList_590581(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySitesList_590580(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of directory sites, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590582 = path.getOrDefault("profileId")
  valid_590582 = validateParameter(valid_590582, JString, required = true,
                                 default = nil)
  if valid_590582 != nil:
    section.add "profileId", valid_590582
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or URL. Wildcards (*) are allowed. For example, "directory site*2015" will return objects with names like "directory site June 2015", "directory site April 2015", or simply "directory site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site" will match objects with name "my directory site", "directory site 2015" or simply, "directory site".
  ##   countryId: JString
  ##            : Select only directory sites with this country ID.
  ##   active: JBool
  ##         : Select only active directory sites. Leave blank to retrieve both active and inactive directory sites.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   dfp_network_code: JString
  ##                   : Select only directory sites with this DFP network code.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only directory sites with these IDs.
  ##   parentId: JString
  ##           : Select only directory sites with this parent ID.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsInterstitialPlacements: JBool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   acceptsInStreamVideoPlacements: JBool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   acceptsPublisherPaidPlacements: JBool
  ##                                 : Select only directory sites that accept publisher paid placements. This field can be left blank.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590583 = query.getOrDefault("fields")
  valid_590583 = validateParameter(valid_590583, JString, required = false,
                                 default = nil)
  if valid_590583 != nil:
    section.add "fields", valid_590583
  var valid_590584 = query.getOrDefault("pageToken")
  valid_590584 = validateParameter(valid_590584, JString, required = false,
                                 default = nil)
  if valid_590584 != nil:
    section.add "pageToken", valid_590584
  var valid_590585 = query.getOrDefault("quotaUser")
  valid_590585 = validateParameter(valid_590585, JString, required = false,
                                 default = nil)
  if valid_590585 != nil:
    section.add "quotaUser", valid_590585
  var valid_590586 = query.getOrDefault("sortField")
  valid_590586 = validateParameter(valid_590586, JString, required = false,
                                 default = newJString("ID"))
  if valid_590586 != nil:
    section.add "sortField", valid_590586
  var valid_590587 = query.getOrDefault("alt")
  valid_590587 = validateParameter(valid_590587, JString, required = false,
                                 default = newJString("json"))
  if valid_590587 != nil:
    section.add "alt", valid_590587
  var valid_590588 = query.getOrDefault("searchString")
  valid_590588 = validateParameter(valid_590588, JString, required = false,
                                 default = nil)
  if valid_590588 != nil:
    section.add "searchString", valid_590588
  var valid_590589 = query.getOrDefault("countryId")
  valid_590589 = validateParameter(valid_590589, JString, required = false,
                                 default = nil)
  if valid_590589 != nil:
    section.add "countryId", valid_590589
  var valid_590590 = query.getOrDefault("active")
  valid_590590 = validateParameter(valid_590590, JBool, required = false, default = nil)
  if valid_590590 != nil:
    section.add "active", valid_590590
  var valid_590591 = query.getOrDefault("oauth_token")
  valid_590591 = validateParameter(valid_590591, JString, required = false,
                                 default = nil)
  if valid_590591 != nil:
    section.add "oauth_token", valid_590591
  var valid_590592 = query.getOrDefault("userIp")
  valid_590592 = validateParameter(valid_590592, JString, required = false,
                                 default = nil)
  if valid_590592 != nil:
    section.add "userIp", valid_590592
  var valid_590593 = query.getOrDefault("dfp_network_code")
  valid_590593 = validateParameter(valid_590593, JString, required = false,
                                 default = nil)
  if valid_590593 != nil:
    section.add "dfp_network_code", valid_590593
  var valid_590594 = query.getOrDefault("maxResults")
  valid_590594 = validateParameter(valid_590594, JInt, required = false,
                                 default = newJInt(1000))
  if valid_590594 != nil:
    section.add "maxResults", valid_590594
  var valid_590595 = query.getOrDefault("ids")
  valid_590595 = validateParameter(valid_590595, JArray, required = false,
                                 default = nil)
  if valid_590595 != nil:
    section.add "ids", valid_590595
  var valid_590596 = query.getOrDefault("parentId")
  valid_590596 = validateParameter(valid_590596, JString, required = false,
                                 default = nil)
  if valid_590596 != nil:
    section.add "parentId", valid_590596
  var valid_590597 = query.getOrDefault("key")
  valid_590597 = validateParameter(valid_590597, JString, required = false,
                                 default = nil)
  if valid_590597 != nil:
    section.add "key", valid_590597
  var valid_590598 = query.getOrDefault("acceptsInterstitialPlacements")
  valid_590598 = validateParameter(valid_590598, JBool, required = false, default = nil)
  if valid_590598 != nil:
    section.add "acceptsInterstitialPlacements", valid_590598
  var valid_590599 = query.getOrDefault("acceptsInStreamVideoPlacements")
  valid_590599 = validateParameter(valid_590599, JBool, required = false, default = nil)
  if valid_590599 != nil:
    section.add "acceptsInStreamVideoPlacements", valid_590599
  var valid_590600 = query.getOrDefault("sortOrder")
  valid_590600 = validateParameter(valid_590600, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_590600 != nil:
    section.add "sortOrder", valid_590600
  var valid_590601 = query.getOrDefault("acceptsPublisherPaidPlacements")
  valid_590601 = validateParameter(valid_590601, JBool, required = false, default = nil)
  if valid_590601 != nil:
    section.add "acceptsPublisherPaidPlacements", valid_590601
  var valid_590602 = query.getOrDefault("prettyPrint")
  valid_590602 = validateParameter(valid_590602, JBool, required = false,
                                 default = newJBool(true))
  if valid_590602 != nil:
    section.add "prettyPrint", valid_590602
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590603: Call_DfareportingDirectorySitesList_590579; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of directory sites, possibly filtered. This method supports paging.
  ## 
  let valid = call_590603.validator(path, query, header, formData, body)
  let scheme = call_590603.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590603.url(scheme.get, call_590603.host, call_590603.base,
                         call_590603.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590603, url, valid)

proc call*(call_590604: Call_DfareportingDirectorySitesList_590579;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; countryId: string = ""; active: bool = false;
          oauthToken: string = ""; userIp: string = ""; dfpNetworkCode: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; parentId: string = "";
          key: string = ""; acceptsInterstitialPlacements: bool = false;
          acceptsInStreamVideoPlacements: bool = false;
          sortOrder: string = "ASCENDING";
          acceptsPublisherPaidPlacements: bool = false; prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySitesList
  ## Retrieves a list of directory sites, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or URL. Wildcards (*) are allowed. For example, "directory site*2015" will return objects with names like "directory site June 2015", "directory site April 2015", or simply "directory site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site" will match objects with name "my directory site", "directory site 2015" or simply, "directory site".
  ##   countryId: string
  ##            : Select only directory sites with this country ID.
  ##   active: bool
  ##         : Select only active directory sites. Leave blank to retrieve both active and inactive directory sites.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   dfpNetworkCode: string
  ##                 : Select only directory sites with this DFP network code.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only directory sites with these IDs.
  ##   parentId: string
  ##           : Select only directory sites with this parent ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsInterstitialPlacements: bool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   acceptsInStreamVideoPlacements: bool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   acceptsPublisherPaidPlacements: bool
  ##                                 : Select only directory sites that accept publisher paid placements. This field can be left blank.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590605 = newJObject()
  var query_590606 = newJObject()
  add(path_590605, "profileId", newJString(profileId))
  add(query_590606, "fields", newJString(fields))
  add(query_590606, "pageToken", newJString(pageToken))
  add(query_590606, "quotaUser", newJString(quotaUser))
  add(query_590606, "sortField", newJString(sortField))
  add(query_590606, "alt", newJString(alt))
  add(query_590606, "searchString", newJString(searchString))
  add(query_590606, "countryId", newJString(countryId))
  add(query_590606, "active", newJBool(active))
  add(query_590606, "oauth_token", newJString(oauthToken))
  add(query_590606, "userIp", newJString(userIp))
  add(query_590606, "dfp_network_code", newJString(dfpNetworkCode))
  add(query_590606, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_590606.add "ids", ids
  add(query_590606, "parentId", newJString(parentId))
  add(query_590606, "key", newJString(key))
  add(query_590606, "acceptsInterstitialPlacements",
      newJBool(acceptsInterstitialPlacements))
  add(query_590606, "acceptsInStreamVideoPlacements",
      newJBool(acceptsInStreamVideoPlacements))
  add(query_590606, "sortOrder", newJString(sortOrder))
  add(query_590606, "acceptsPublisherPaidPlacements",
      newJBool(acceptsPublisherPaidPlacements))
  add(query_590606, "prettyPrint", newJBool(prettyPrint))
  result = call_590604.call(path_590605, query_590606, nil, nil, nil)

var dfareportingDirectorySitesList* = Call_DfareportingDirectorySitesList_590579(
    name: "dfareportingDirectorySitesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/directorySites",
    validator: validate_DfareportingDirectorySitesList_590580,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySitesList_590581,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySitesGet_590624 = ref object of OpenApiRestCall_588466
proc url_DfareportingDirectorySitesGet_590626(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySites/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySitesGet_590625(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one directory site by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Directory site ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590627 = path.getOrDefault("profileId")
  valid_590627 = validateParameter(valid_590627, JString, required = true,
                                 default = nil)
  if valid_590627 != nil:
    section.add "profileId", valid_590627
  var valid_590628 = path.getOrDefault("id")
  valid_590628 = validateParameter(valid_590628, JString, required = true,
                                 default = nil)
  if valid_590628 != nil:
    section.add "id", valid_590628
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590629 = query.getOrDefault("fields")
  valid_590629 = validateParameter(valid_590629, JString, required = false,
                                 default = nil)
  if valid_590629 != nil:
    section.add "fields", valid_590629
  var valid_590630 = query.getOrDefault("quotaUser")
  valid_590630 = validateParameter(valid_590630, JString, required = false,
                                 default = nil)
  if valid_590630 != nil:
    section.add "quotaUser", valid_590630
  var valid_590631 = query.getOrDefault("alt")
  valid_590631 = validateParameter(valid_590631, JString, required = false,
                                 default = newJString("json"))
  if valid_590631 != nil:
    section.add "alt", valid_590631
  var valid_590632 = query.getOrDefault("oauth_token")
  valid_590632 = validateParameter(valid_590632, JString, required = false,
                                 default = nil)
  if valid_590632 != nil:
    section.add "oauth_token", valid_590632
  var valid_590633 = query.getOrDefault("userIp")
  valid_590633 = validateParameter(valid_590633, JString, required = false,
                                 default = nil)
  if valid_590633 != nil:
    section.add "userIp", valid_590633
  var valid_590634 = query.getOrDefault("key")
  valid_590634 = validateParameter(valid_590634, JString, required = false,
                                 default = nil)
  if valid_590634 != nil:
    section.add "key", valid_590634
  var valid_590635 = query.getOrDefault("prettyPrint")
  valid_590635 = validateParameter(valid_590635, JBool, required = false,
                                 default = newJBool(true))
  if valid_590635 != nil:
    section.add "prettyPrint", valid_590635
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590636: Call_DfareportingDirectorySitesGet_590624; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one directory site by ID.
  ## 
  let valid = call_590636.validator(path, query, header, formData, body)
  let scheme = call_590636.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590636.url(scheme.get, call_590636.host, call_590636.base,
                         call_590636.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590636, url, valid)

proc call*(call_590637: Call_DfareportingDirectorySitesGet_590624;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySitesGet
  ## Gets one directory site by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Directory site ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590638 = newJObject()
  var query_590639 = newJObject()
  add(path_590638, "profileId", newJString(profileId))
  add(query_590639, "fields", newJString(fields))
  add(query_590639, "quotaUser", newJString(quotaUser))
  add(query_590639, "alt", newJString(alt))
  add(query_590639, "oauth_token", newJString(oauthToken))
  add(query_590639, "userIp", newJString(userIp))
  add(path_590638, "id", newJString(id))
  add(query_590639, "key", newJString(key))
  add(query_590639, "prettyPrint", newJBool(prettyPrint))
  result = call_590637.call(path_590638, query_590639, nil, nil, nil)

var dfareportingDirectorySitesGet* = Call_DfareportingDirectorySitesGet_590624(
    name: "dfareportingDirectorySitesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/directorySites/{id}",
    validator: validate_DfareportingDirectorySitesGet_590625,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySitesGet_590626,
    schemes: {Scheme.Https})
type
  Call_DfareportingDynamicTargetingKeysInsert_590659 = ref object of OpenApiRestCall_588466
proc url_DfareportingDynamicTargetingKeysInsert_590661(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dynamicTargetingKeys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDynamicTargetingKeysInsert_590660(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new dynamic targeting key. Keys must be created at the advertiser level before being assigned to the advertiser's ads, creatives, or placements. There is a maximum of 1000 keys per advertiser, out of which a maximum of 20 keys can be assigned per ad, creative, or placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590662 = path.getOrDefault("profileId")
  valid_590662 = validateParameter(valid_590662, JString, required = true,
                                 default = nil)
  if valid_590662 != nil:
    section.add "profileId", valid_590662
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590663 = query.getOrDefault("fields")
  valid_590663 = validateParameter(valid_590663, JString, required = false,
                                 default = nil)
  if valid_590663 != nil:
    section.add "fields", valid_590663
  var valid_590664 = query.getOrDefault("quotaUser")
  valid_590664 = validateParameter(valid_590664, JString, required = false,
                                 default = nil)
  if valid_590664 != nil:
    section.add "quotaUser", valid_590664
  var valid_590665 = query.getOrDefault("alt")
  valid_590665 = validateParameter(valid_590665, JString, required = false,
                                 default = newJString("json"))
  if valid_590665 != nil:
    section.add "alt", valid_590665
  var valid_590666 = query.getOrDefault("oauth_token")
  valid_590666 = validateParameter(valid_590666, JString, required = false,
                                 default = nil)
  if valid_590666 != nil:
    section.add "oauth_token", valid_590666
  var valid_590667 = query.getOrDefault("userIp")
  valid_590667 = validateParameter(valid_590667, JString, required = false,
                                 default = nil)
  if valid_590667 != nil:
    section.add "userIp", valid_590667
  var valid_590668 = query.getOrDefault("key")
  valid_590668 = validateParameter(valid_590668, JString, required = false,
                                 default = nil)
  if valid_590668 != nil:
    section.add "key", valid_590668
  var valid_590669 = query.getOrDefault("prettyPrint")
  valid_590669 = validateParameter(valid_590669, JBool, required = false,
                                 default = newJBool(true))
  if valid_590669 != nil:
    section.add "prettyPrint", valid_590669
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590671: Call_DfareportingDynamicTargetingKeysInsert_590659;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new dynamic targeting key. Keys must be created at the advertiser level before being assigned to the advertiser's ads, creatives, or placements. There is a maximum of 1000 keys per advertiser, out of which a maximum of 20 keys can be assigned per ad, creative, or placement.
  ## 
  let valid = call_590671.validator(path, query, header, formData, body)
  let scheme = call_590671.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590671.url(scheme.get, call_590671.host, call_590671.base,
                         call_590671.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590671, url, valid)

proc call*(call_590672: Call_DfareportingDynamicTargetingKeysInsert_590659;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingDynamicTargetingKeysInsert
  ## Inserts a new dynamic targeting key. Keys must be created at the advertiser level before being assigned to the advertiser's ads, creatives, or placements. There is a maximum of 1000 keys per advertiser, out of which a maximum of 20 keys can be assigned per ad, creative, or placement.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590673 = newJObject()
  var query_590674 = newJObject()
  var body_590675 = newJObject()
  add(path_590673, "profileId", newJString(profileId))
  add(query_590674, "fields", newJString(fields))
  add(query_590674, "quotaUser", newJString(quotaUser))
  add(query_590674, "alt", newJString(alt))
  add(query_590674, "oauth_token", newJString(oauthToken))
  add(query_590674, "userIp", newJString(userIp))
  add(query_590674, "key", newJString(key))
  if body != nil:
    body_590675 = body
  add(query_590674, "prettyPrint", newJBool(prettyPrint))
  result = call_590672.call(path_590673, query_590674, nil, nil, body_590675)

var dfareportingDynamicTargetingKeysInsert* = Call_DfareportingDynamicTargetingKeysInsert_590659(
    name: "dfareportingDynamicTargetingKeysInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dynamicTargetingKeys",
    validator: validate_DfareportingDynamicTargetingKeysInsert_590660,
    base: "/dfareporting/v2.7", url: url_DfareportingDynamicTargetingKeysInsert_590661,
    schemes: {Scheme.Https})
type
  Call_DfareportingDynamicTargetingKeysList_590640 = ref object of OpenApiRestCall_588466
proc url_DfareportingDynamicTargetingKeysList_590642(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dynamicTargetingKeys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDynamicTargetingKeysList_590641(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of dynamic targeting keys.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590643 = path.getOrDefault("profileId")
  valid_590643 = validateParameter(valid_590643, JString, required = true,
                                 default = nil)
  if valid_590643 != nil:
    section.add "profileId", valid_590643
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   advertiserId: JString
  ##               : Select only dynamic targeting keys whose object has this advertiser ID.
  ##   names: JArray
  ##        : Select only dynamic targeting keys exactly matching these names.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   objectId: JString
  ##           : Select only dynamic targeting keys with this object ID.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   objectType: JString
  ##             : Select only dynamic targeting keys with this object type.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590644 = query.getOrDefault("fields")
  valid_590644 = validateParameter(valid_590644, JString, required = false,
                                 default = nil)
  if valid_590644 != nil:
    section.add "fields", valid_590644
  var valid_590645 = query.getOrDefault("quotaUser")
  valid_590645 = validateParameter(valid_590645, JString, required = false,
                                 default = nil)
  if valid_590645 != nil:
    section.add "quotaUser", valid_590645
  var valid_590646 = query.getOrDefault("alt")
  valid_590646 = validateParameter(valid_590646, JString, required = false,
                                 default = newJString("json"))
  if valid_590646 != nil:
    section.add "alt", valid_590646
  var valid_590647 = query.getOrDefault("advertiserId")
  valid_590647 = validateParameter(valid_590647, JString, required = false,
                                 default = nil)
  if valid_590647 != nil:
    section.add "advertiserId", valid_590647
  var valid_590648 = query.getOrDefault("names")
  valid_590648 = validateParameter(valid_590648, JArray, required = false,
                                 default = nil)
  if valid_590648 != nil:
    section.add "names", valid_590648
  var valid_590649 = query.getOrDefault("oauth_token")
  valid_590649 = validateParameter(valid_590649, JString, required = false,
                                 default = nil)
  if valid_590649 != nil:
    section.add "oauth_token", valid_590649
  var valid_590650 = query.getOrDefault("objectId")
  valid_590650 = validateParameter(valid_590650, JString, required = false,
                                 default = nil)
  if valid_590650 != nil:
    section.add "objectId", valid_590650
  var valid_590651 = query.getOrDefault("userIp")
  valid_590651 = validateParameter(valid_590651, JString, required = false,
                                 default = nil)
  if valid_590651 != nil:
    section.add "userIp", valid_590651
  var valid_590652 = query.getOrDefault("objectType")
  valid_590652 = validateParameter(valid_590652, JString, required = false,
                                 default = newJString("OBJECT_AD"))
  if valid_590652 != nil:
    section.add "objectType", valid_590652
  var valid_590653 = query.getOrDefault("key")
  valid_590653 = validateParameter(valid_590653, JString, required = false,
                                 default = nil)
  if valid_590653 != nil:
    section.add "key", valid_590653
  var valid_590654 = query.getOrDefault("prettyPrint")
  valid_590654 = validateParameter(valid_590654, JBool, required = false,
                                 default = newJBool(true))
  if valid_590654 != nil:
    section.add "prettyPrint", valid_590654
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590655: Call_DfareportingDynamicTargetingKeysList_590640;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of dynamic targeting keys.
  ## 
  let valid = call_590655.validator(path, query, header, formData, body)
  let scheme = call_590655.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590655.url(scheme.get, call_590655.host, call_590655.base,
                         call_590655.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590655, url, valid)

proc call*(call_590656: Call_DfareportingDynamicTargetingKeysList_590640;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; advertiserId: string = ""; names: JsonNode = nil;
          oauthToken: string = ""; objectId: string = ""; userIp: string = "";
          objectType: string = "OBJECT_AD"; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingDynamicTargetingKeysList
  ## Retrieves a list of dynamic targeting keys.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   advertiserId: string
  ##               : Select only dynamic targeting keys whose object has this advertiser ID.
  ##   names: JArray
  ##        : Select only dynamic targeting keys exactly matching these names.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   objectId: string
  ##           : Select only dynamic targeting keys with this object ID.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   objectType: string
  ##             : Select only dynamic targeting keys with this object type.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590657 = newJObject()
  var query_590658 = newJObject()
  add(path_590657, "profileId", newJString(profileId))
  add(query_590658, "fields", newJString(fields))
  add(query_590658, "quotaUser", newJString(quotaUser))
  add(query_590658, "alt", newJString(alt))
  add(query_590658, "advertiserId", newJString(advertiserId))
  if names != nil:
    query_590658.add "names", names
  add(query_590658, "oauth_token", newJString(oauthToken))
  add(query_590658, "objectId", newJString(objectId))
  add(query_590658, "userIp", newJString(userIp))
  add(query_590658, "objectType", newJString(objectType))
  add(query_590658, "key", newJString(key))
  add(query_590658, "prettyPrint", newJBool(prettyPrint))
  result = call_590656.call(path_590657, query_590658, nil, nil, nil)

var dfareportingDynamicTargetingKeysList* = Call_DfareportingDynamicTargetingKeysList_590640(
    name: "dfareportingDynamicTargetingKeysList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dynamicTargetingKeys",
    validator: validate_DfareportingDynamicTargetingKeysList_590641,
    base: "/dfareporting/v2.7", url: url_DfareportingDynamicTargetingKeysList_590642,
    schemes: {Scheme.Https})
type
  Call_DfareportingDynamicTargetingKeysDelete_590676 = ref object of OpenApiRestCall_588466
proc url_DfareportingDynamicTargetingKeysDelete_590678(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "objectId" in path, "`objectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dynamicTargetingKeys/"),
               (kind: VariableSegment, value: "objectId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDynamicTargetingKeysDelete_590677(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing dynamic targeting key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   objectId: JString (required)
  ##           : ID of the object of this dynamic targeting key. This is a required field.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590679 = path.getOrDefault("profileId")
  valid_590679 = validateParameter(valid_590679, JString, required = true,
                                 default = nil)
  if valid_590679 != nil:
    section.add "profileId", valid_590679
  var valid_590680 = path.getOrDefault("objectId")
  valid_590680 = validateParameter(valid_590680, JString, required = true,
                                 default = nil)
  if valid_590680 != nil:
    section.add "objectId", valid_590680
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   objectType: JString (required)
  ##             : Type of the object of this dynamic targeting key. This is a required field.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: JString (required)
  ##       : Name of this dynamic targeting key. This is a required field. Must be less than 256 characters long and cannot contain commas. All characters are converted to lowercase.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590681 = query.getOrDefault("fields")
  valid_590681 = validateParameter(valid_590681, JString, required = false,
                                 default = nil)
  if valid_590681 != nil:
    section.add "fields", valid_590681
  var valid_590682 = query.getOrDefault("quotaUser")
  valid_590682 = validateParameter(valid_590682, JString, required = false,
                                 default = nil)
  if valid_590682 != nil:
    section.add "quotaUser", valid_590682
  var valid_590683 = query.getOrDefault("alt")
  valid_590683 = validateParameter(valid_590683, JString, required = false,
                                 default = newJString("json"))
  if valid_590683 != nil:
    section.add "alt", valid_590683
  var valid_590684 = query.getOrDefault("oauth_token")
  valid_590684 = validateParameter(valid_590684, JString, required = false,
                                 default = nil)
  if valid_590684 != nil:
    section.add "oauth_token", valid_590684
  var valid_590685 = query.getOrDefault("userIp")
  valid_590685 = validateParameter(valid_590685, JString, required = false,
                                 default = nil)
  if valid_590685 != nil:
    section.add "userIp", valid_590685
  assert query != nil,
        "query argument is necessary due to required `objectType` field"
  var valid_590686 = query.getOrDefault("objectType")
  valid_590686 = validateParameter(valid_590686, JString, required = true,
                                 default = newJString("OBJECT_AD"))
  if valid_590686 != nil:
    section.add "objectType", valid_590686
  var valid_590687 = query.getOrDefault("key")
  valid_590687 = validateParameter(valid_590687, JString, required = false,
                                 default = nil)
  if valid_590687 != nil:
    section.add "key", valid_590687
  var valid_590688 = query.getOrDefault("name")
  valid_590688 = validateParameter(valid_590688, JString, required = true,
                                 default = nil)
  if valid_590688 != nil:
    section.add "name", valid_590688
  var valid_590689 = query.getOrDefault("prettyPrint")
  valid_590689 = validateParameter(valid_590689, JBool, required = false,
                                 default = newJBool(true))
  if valid_590689 != nil:
    section.add "prettyPrint", valid_590689
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590690: Call_DfareportingDynamicTargetingKeysDelete_590676;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing dynamic targeting key.
  ## 
  let valid = call_590690.validator(path, query, header, formData, body)
  let scheme = call_590690.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590690.url(scheme.get, call_590690.host, call_590690.base,
                         call_590690.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590690, url, valid)

proc call*(call_590691: Call_DfareportingDynamicTargetingKeysDelete_590676;
          profileId: string; objectId: string; name: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; objectType: string = "OBJECT_AD"; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingDynamicTargetingKeysDelete
  ## Deletes an existing dynamic targeting key.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   objectId: string (required)
  ##           : ID of the object of this dynamic targeting key. This is a required field.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   objectType: string (required)
  ##             : Type of the object of this dynamic targeting key. This is a required field.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: string (required)
  ##       : Name of this dynamic targeting key. This is a required field. Must be less than 256 characters long and cannot contain commas. All characters are converted to lowercase.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590692 = newJObject()
  var query_590693 = newJObject()
  add(path_590692, "profileId", newJString(profileId))
  add(query_590693, "fields", newJString(fields))
  add(query_590693, "quotaUser", newJString(quotaUser))
  add(query_590693, "alt", newJString(alt))
  add(path_590692, "objectId", newJString(objectId))
  add(query_590693, "oauth_token", newJString(oauthToken))
  add(query_590693, "userIp", newJString(userIp))
  add(query_590693, "objectType", newJString(objectType))
  add(query_590693, "key", newJString(key))
  add(query_590693, "name", newJString(name))
  add(query_590693, "prettyPrint", newJBool(prettyPrint))
  result = call_590691.call(path_590692, query_590693, nil, nil, nil)

var dfareportingDynamicTargetingKeysDelete* = Call_DfareportingDynamicTargetingKeysDelete_590676(
    name: "dfareportingDynamicTargetingKeysDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dynamicTargetingKeys/{objectId}",
    validator: validate_DfareportingDynamicTargetingKeysDelete_590677,
    base: "/dfareporting/v2.7", url: url_DfareportingDynamicTargetingKeysDelete_590678,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsUpdate_590719 = ref object of OpenApiRestCall_588466
proc url_DfareportingEventTagsUpdate_590721(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsUpdate_590720(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing event tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590722 = path.getOrDefault("profileId")
  valid_590722 = validateParameter(valid_590722, JString, required = true,
                                 default = nil)
  if valid_590722 != nil:
    section.add "profileId", valid_590722
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590723 = query.getOrDefault("fields")
  valid_590723 = validateParameter(valid_590723, JString, required = false,
                                 default = nil)
  if valid_590723 != nil:
    section.add "fields", valid_590723
  var valid_590724 = query.getOrDefault("quotaUser")
  valid_590724 = validateParameter(valid_590724, JString, required = false,
                                 default = nil)
  if valid_590724 != nil:
    section.add "quotaUser", valid_590724
  var valid_590725 = query.getOrDefault("alt")
  valid_590725 = validateParameter(valid_590725, JString, required = false,
                                 default = newJString("json"))
  if valid_590725 != nil:
    section.add "alt", valid_590725
  var valid_590726 = query.getOrDefault("oauth_token")
  valid_590726 = validateParameter(valid_590726, JString, required = false,
                                 default = nil)
  if valid_590726 != nil:
    section.add "oauth_token", valid_590726
  var valid_590727 = query.getOrDefault("userIp")
  valid_590727 = validateParameter(valid_590727, JString, required = false,
                                 default = nil)
  if valid_590727 != nil:
    section.add "userIp", valid_590727
  var valid_590728 = query.getOrDefault("key")
  valid_590728 = validateParameter(valid_590728, JString, required = false,
                                 default = nil)
  if valid_590728 != nil:
    section.add "key", valid_590728
  var valid_590729 = query.getOrDefault("prettyPrint")
  valid_590729 = validateParameter(valid_590729, JBool, required = false,
                                 default = newJBool(true))
  if valid_590729 != nil:
    section.add "prettyPrint", valid_590729
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590731: Call_DfareportingEventTagsUpdate_590719; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing event tag.
  ## 
  let valid = call_590731.validator(path, query, header, formData, body)
  let scheme = call_590731.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590731.url(scheme.get, call_590731.host, call_590731.base,
                         call_590731.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590731, url, valid)

proc call*(call_590732: Call_DfareportingEventTagsUpdate_590719; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsUpdate
  ## Updates an existing event tag.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590733 = newJObject()
  var query_590734 = newJObject()
  var body_590735 = newJObject()
  add(path_590733, "profileId", newJString(profileId))
  add(query_590734, "fields", newJString(fields))
  add(query_590734, "quotaUser", newJString(quotaUser))
  add(query_590734, "alt", newJString(alt))
  add(query_590734, "oauth_token", newJString(oauthToken))
  add(query_590734, "userIp", newJString(userIp))
  add(query_590734, "key", newJString(key))
  if body != nil:
    body_590735 = body
  add(query_590734, "prettyPrint", newJBool(prettyPrint))
  result = call_590732.call(path_590733, query_590734, nil, nil, body_590735)

var dfareportingEventTagsUpdate* = Call_DfareportingEventTagsUpdate_590719(
    name: "dfareportingEventTagsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsUpdate_590720,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsUpdate_590721,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsInsert_590736 = ref object of OpenApiRestCall_588466
proc url_DfareportingEventTagsInsert_590738(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsInsert_590737(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new event tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590739 = path.getOrDefault("profileId")
  valid_590739 = validateParameter(valid_590739, JString, required = true,
                                 default = nil)
  if valid_590739 != nil:
    section.add "profileId", valid_590739
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590740 = query.getOrDefault("fields")
  valid_590740 = validateParameter(valid_590740, JString, required = false,
                                 default = nil)
  if valid_590740 != nil:
    section.add "fields", valid_590740
  var valid_590741 = query.getOrDefault("quotaUser")
  valid_590741 = validateParameter(valid_590741, JString, required = false,
                                 default = nil)
  if valid_590741 != nil:
    section.add "quotaUser", valid_590741
  var valid_590742 = query.getOrDefault("alt")
  valid_590742 = validateParameter(valid_590742, JString, required = false,
                                 default = newJString("json"))
  if valid_590742 != nil:
    section.add "alt", valid_590742
  var valid_590743 = query.getOrDefault("oauth_token")
  valid_590743 = validateParameter(valid_590743, JString, required = false,
                                 default = nil)
  if valid_590743 != nil:
    section.add "oauth_token", valid_590743
  var valid_590744 = query.getOrDefault("userIp")
  valid_590744 = validateParameter(valid_590744, JString, required = false,
                                 default = nil)
  if valid_590744 != nil:
    section.add "userIp", valid_590744
  var valid_590745 = query.getOrDefault("key")
  valid_590745 = validateParameter(valid_590745, JString, required = false,
                                 default = nil)
  if valid_590745 != nil:
    section.add "key", valid_590745
  var valid_590746 = query.getOrDefault("prettyPrint")
  valid_590746 = validateParameter(valid_590746, JBool, required = false,
                                 default = newJBool(true))
  if valid_590746 != nil:
    section.add "prettyPrint", valid_590746
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590748: Call_DfareportingEventTagsInsert_590736; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new event tag.
  ## 
  let valid = call_590748.validator(path, query, header, formData, body)
  let scheme = call_590748.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590748.url(scheme.get, call_590748.host, call_590748.base,
                         call_590748.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590748, url, valid)

proc call*(call_590749: Call_DfareportingEventTagsInsert_590736; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsInsert
  ## Inserts a new event tag.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590750 = newJObject()
  var query_590751 = newJObject()
  var body_590752 = newJObject()
  add(path_590750, "profileId", newJString(profileId))
  add(query_590751, "fields", newJString(fields))
  add(query_590751, "quotaUser", newJString(quotaUser))
  add(query_590751, "alt", newJString(alt))
  add(query_590751, "oauth_token", newJString(oauthToken))
  add(query_590751, "userIp", newJString(userIp))
  add(query_590751, "key", newJString(key))
  if body != nil:
    body_590752 = body
  add(query_590751, "prettyPrint", newJBool(prettyPrint))
  result = call_590749.call(path_590750, query_590751, nil, nil, body_590752)

var dfareportingEventTagsInsert* = Call_DfareportingEventTagsInsert_590736(
    name: "dfareportingEventTagsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsInsert_590737,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsInsert_590738,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsList_590694 = ref object of OpenApiRestCall_588466
proc url_DfareportingEventTagsList_590696(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsList_590695(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of event tags, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590697 = path.getOrDefault("profileId")
  valid_590697 = validateParameter(valid_590697, JString, required = true,
                                 default = nil)
  if valid_590697 != nil:
    section.add "profileId", valid_590697
  result.add "path", section
  ## parameters in `query` object:
  ##   enabled: JBool
  ##          : Select only enabled event tags. What is considered enabled or disabled depends on the definitionsOnly parameter. When definitionsOnly is set to true, only the specified advertiser or campaign's event tags' enabledByDefault field is examined. When definitionsOnly is set to false, the specified ad or specified campaign's parent advertiser's or parent campaign's event tags' enabledByDefault and status fields are examined as well.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   definitionsOnly: JBool
  ##                  : Examine only the specified campaign or advertiser's event tags for matching selector criteria. When set to false, the parent advertiser and parent campaign of the specified ad or campaign is examined as well. In addition, when set to false, the status field is examined as well, along with the enabledByDefault field. This parameter can not be set to true when adId is specified as ads do not define their own even tags.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "eventtag*2015" will return objects with names like "eventtag June 2015", "eventtag April 2015", or simply "eventtag 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "eventtag" will match objects with name "my eventtag", "eventtag 2015", or simply "eventtag".
  ##   advertiserId: JString
  ##               : Select only event tags that belong to this advertiser.
  ##   eventTagTypes: JArray
  ##                : Select only event tags with the specified event tag types. Event tag types can be used to specify whether to use a third-party pixel, a third-party JavaScript URL, or a third-party click-through URL for either impression or click tracking.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   adId: JString
  ##       : Select only event tags that belong to this ad.
  ##   ids: JArray
  ##      : Select only event tags with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: JString
  ##             : Select only event tags that belong to this campaign.
  section = newJObject()
  var valid_590698 = query.getOrDefault("enabled")
  valid_590698 = validateParameter(valid_590698, JBool, required = false, default = nil)
  if valid_590698 != nil:
    section.add "enabled", valid_590698
  var valid_590699 = query.getOrDefault("fields")
  valid_590699 = validateParameter(valid_590699, JString, required = false,
                                 default = nil)
  if valid_590699 != nil:
    section.add "fields", valid_590699
  var valid_590700 = query.getOrDefault("quotaUser")
  valid_590700 = validateParameter(valid_590700, JString, required = false,
                                 default = nil)
  if valid_590700 != nil:
    section.add "quotaUser", valid_590700
  var valid_590701 = query.getOrDefault("sortField")
  valid_590701 = validateParameter(valid_590701, JString, required = false,
                                 default = newJString("ID"))
  if valid_590701 != nil:
    section.add "sortField", valid_590701
  var valid_590702 = query.getOrDefault("alt")
  valid_590702 = validateParameter(valid_590702, JString, required = false,
                                 default = newJString("json"))
  if valid_590702 != nil:
    section.add "alt", valid_590702
  var valid_590703 = query.getOrDefault("definitionsOnly")
  valid_590703 = validateParameter(valid_590703, JBool, required = false, default = nil)
  if valid_590703 != nil:
    section.add "definitionsOnly", valid_590703
  var valid_590704 = query.getOrDefault("searchString")
  valid_590704 = validateParameter(valid_590704, JString, required = false,
                                 default = nil)
  if valid_590704 != nil:
    section.add "searchString", valid_590704
  var valid_590705 = query.getOrDefault("advertiserId")
  valid_590705 = validateParameter(valid_590705, JString, required = false,
                                 default = nil)
  if valid_590705 != nil:
    section.add "advertiserId", valid_590705
  var valid_590706 = query.getOrDefault("eventTagTypes")
  valid_590706 = validateParameter(valid_590706, JArray, required = false,
                                 default = nil)
  if valid_590706 != nil:
    section.add "eventTagTypes", valid_590706
  var valid_590707 = query.getOrDefault("oauth_token")
  valid_590707 = validateParameter(valid_590707, JString, required = false,
                                 default = nil)
  if valid_590707 != nil:
    section.add "oauth_token", valid_590707
  var valid_590708 = query.getOrDefault("userIp")
  valid_590708 = validateParameter(valid_590708, JString, required = false,
                                 default = nil)
  if valid_590708 != nil:
    section.add "userIp", valid_590708
  var valid_590709 = query.getOrDefault("adId")
  valid_590709 = validateParameter(valid_590709, JString, required = false,
                                 default = nil)
  if valid_590709 != nil:
    section.add "adId", valid_590709
  var valid_590710 = query.getOrDefault("ids")
  valid_590710 = validateParameter(valid_590710, JArray, required = false,
                                 default = nil)
  if valid_590710 != nil:
    section.add "ids", valid_590710
  var valid_590711 = query.getOrDefault("key")
  valid_590711 = validateParameter(valid_590711, JString, required = false,
                                 default = nil)
  if valid_590711 != nil:
    section.add "key", valid_590711
  var valid_590712 = query.getOrDefault("sortOrder")
  valid_590712 = validateParameter(valid_590712, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_590712 != nil:
    section.add "sortOrder", valid_590712
  var valid_590713 = query.getOrDefault("prettyPrint")
  valid_590713 = validateParameter(valid_590713, JBool, required = false,
                                 default = newJBool(true))
  if valid_590713 != nil:
    section.add "prettyPrint", valid_590713
  var valid_590714 = query.getOrDefault("campaignId")
  valid_590714 = validateParameter(valid_590714, JString, required = false,
                                 default = nil)
  if valid_590714 != nil:
    section.add "campaignId", valid_590714
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590715: Call_DfareportingEventTagsList_590694; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of event tags, possibly filtered.
  ## 
  let valid = call_590715.validator(path, query, header, formData, body)
  let scheme = call_590715.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590715.url(scheme.get, call_590715.host, call_590715.base,
                         call_590715.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590715, url, valid)

proc call*(call_590716: Call_DfareportingEventTagsList_590694; profileId: string;
          enabled: bool = false; fields: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; definitionsOnly: bool = false;
          searchString: string = ""; advertiserId: string = "";
          eventTagTypes: JsonNode = nil; oauthToken: string = ""; userIp: string = "";
          adId: string = ""; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true;
          campaignId: string = ""): Recallable =
  ## dfareportingEventTagsList
  ## Retrieves a list of event tags, possibly filtered.
  ##   enabled: bool
  ##          : Select only enabled event tags. What is considered enabled or disabled depends on the definitionsOnly parameter. When definitionsOnly is set to true, only the specified advertiser or campaign's event tags' enabledByDefault field is examined. When definitionsOnly is set to false, the specified ad or specified campaign's parent advertiser's or parent campaign's event tags' enabledByDefault and status fields are examined as well.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   definitionsOnly: bool
  ##                  : Examine only the specified campaign or advertiser's event tags for matching selector criteria. When set to false, the parent advertiser and parent campaign of the specified ad or campaign is examined as well. In addition, when set to false, the status field is examined as well, along with the enabledByDefault field. This parameter can not be set to true when adId is specified as ads do not define their own even tags.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "eventtag*2015" will return objects with names like "eventtag June 2015", "eventtag April 2015", or simply "eventtag 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "eventtag" will match objects with name "my eventtag", "eventtag 2015", or simply "eventtag".
  ##   advertiserId: string
  ##               : Select only event tags that belong to this advertiser.
  ##   eventTagTypes: JArray
  ##                : Select only event tags with the specified event tag types. Event tag types can be used to specify whether to use a third-party pixel, a third-party JavaScript URL, or a third-party click-through URL for either impression or click tracking.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   adId: string
  ##       : Select only event tags that belong to this ad.
  ##   ids: JArray
  ##      : Select only event tags with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: string
  ##             : Select only event tags that belong to this campaign.
  var path_590717 = newJObject()
  var query_590718 = newJObject()
  add(query_590718, "enabled", newJBool(enabled))
  add(path_590717, "profileId", newJString(profileId))
  add(query_590718, "fields", newJString(fields))
  add(query_590718, "quotaUser", newJString(quotaUser))
  add(query_590718, "sortField", newJString(sortField))
  add(query_590718, "alt", newJString(alt))
  add(query_590718, "definitionsOnly", newJBool(definitionsOnly))
  add(query_590718, "searchString", newJString(searchString))
  add(query_590718, "advertiserId", newJString(advertiserId))
  if eventTagTypes != nil:
    query_590718.add "eventTagTypes", eventTagTypes
  add(query_590718, "oauth_token", newJString(oauthToken))
  add(query_590718, "userIp", newJString(userIp))
  add(query_590718, "adId", newJString(adId))
  if ids != nil:
    query_590718.add "ids", ids
  add(query_590718, "key", newJString(key))
  add(query_590718, "sortOrder", newJString(sortOrder))
  add(query_590718, "prettyPrint", newJBool(prettyPrint))
  add(query_590718, "campaignId", newJString(campaignId))
  result = call_590716.call(path_590717, query_590718, nil, nil, nil)

var dfareportingEventTagsList* = Call_DfareportingEventTagsList_590694(
    name: "dfareportingEventTagsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsList_590695,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsList_590696,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsPatch_590753 = ref object of OpenApiRestCall_588466
proc url_DfareportingEventTagsPatch_590755(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsPatch_590754(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing event tag. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590756 = path.getOrDefault("profileId")
  valid_590756 = validateParameter(valid_590756, JString, required = true,
                                 default = nil)
  if valid_590756 != nil:
    section.add "profileId", valid_590756
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Event tag ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590757 = query.getOrDefault("fields")
  valid_590757 = validateParameter(valid_590757, JString, required = false,
                                 default = nil)
  if valid_590757 != nil:
    section.add "fields", valid_590757
  var valid_590758 = query.getOrDefault("quotaUser")
  valid_590758 = validateParameter(valid_590758, JString, required = false,
                                 default = nil)
  if valid_590758 != nil:
    section.add "quotaUser", valid_590758
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_590759 = query.getOrDefault("id")
  valid_590759 = validateParameter(valid_590759, JString, required = true,
                                 default = nil)
  if valid_590759 != nil:
    section.add "id", valid_590759
  var valid_590760 = query.getOrDefault("alt")
  valid_590760 = validateParameter(valid_590760, JString, required = false,
                                 default = newJString("json"))
  if valid_590760 != nil:
    section.add "alt", valid_590760
  var valid_590761 = query.getOrDefault("oauth_token")
  valid_590761 = validateParameter(valid_590761, JString, required = false,
                                 default = nil)
  if valid_590761 != nil:
    section.add "oauth_token", valid_590761
  var valid_590762 = query.getOrDefault("userIp")
  valid_590762 = validateParameter(valid_590762, JString, required = false,
                                 default = nil)
  if valid_590762 != nil:
    section.add "userIp", valid_590762
  var valid_590763 = query.getOrDefault("key")
  valid_590763 = validateParameter(valid_590763, JString, required = false,
                                 default = nil)
  if valid_590763 != nil:
    section.add "key", valid_590763
  var valid_590764 = query.getOrDefault("prettyPrint")
  valid_590764 = validateParameter(valid_590764, JBool, required = false,
                                 default = newJBool(true))
  if valid_590764 != nil:
    section.add "prettyPrint", valid_590764
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590766: Call_DfareportingEventTagsPatch_590753; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing event tag. This method supports patch semantics.
  ## 
  let valid = call_590766.validator(path, query, header, formData, body)
  let scheme = call_590766.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590766.url(scheme.get, call_590766.host, call_590766.base,
                         call_590766.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590766, url, valid)

proc call*(call_590767: Call_DfareportingEventTagsPatch_590753; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsPatch
  ## Updates an existing event tag. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Event tag ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590768 = newJObject()
  var query_590769 = newJObject()
  var body_590770 = newJObject()
  add(path_590768, "profileId", newJString(profileId))
  add(query_590769, "fields", newJString(fields))
  add(query_590769, "quotaUser", newJString(quotaUser))
  add(query_590769, "id", newJString(id))
  add(query_590769, "alt", newJString(alt))
  add(query_590769, "oauth_token", newJString(oauthToken))
  add(query_590769, "userIp", newJString(userIp))
  add(query_590769, "key", newJString(key))
  if body != nil:
    body_590770 = body
  add(query_590769, "prettyPrint", newJBool(prettyPrint))
  result = call_590767.call(path_590768, query_590769, nil, nil, body_590770)

var dfareportingEventTagsPatch* = Call_DfareportingEventTagsPatch_590753(
    name: "dfareportingEventTagsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsPatch_590754,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsPatch_590755,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsGet_590771 = ref object of OpenApiRestCall_588466
proc url_DfareportingEventTagsGet_590773(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsGet_590772(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one event tag by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Event tag ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590774 = path.getOrDefault("profileId")
  valid_590774 = validateParameter(valid_590774, JString, required = true,
                                 default = nil)
  if valid_590774 != nil:
    section.add "profileId", valid_590774
  var valid_590775 = path.getOrDefault("id")
  valid_590775 = validateParameter(valid_590775, JString, required = true,
                                 default = nil)
  if valid_590775 != nil:
    section.add "id", valid_590775
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590776 = query.getOrDefault("fields")
  valid_590776 = validateParameter(valid_590776, JString, required = false,
                                 default = nil)
  if valid_590776 != nil:
    section.add "fields", valid_590776
  var valid_590777 = query.getOrDefault("quotaUser")
  valid_590777 = validateParameter(valid_590777, JString, required = false,
                                 default = nil)
  if valid_590777 != nil:
    section.add "quotaUser", valid_590777
  var valid_590778 = query.getOrDefault("alt")
  valid_590778 = validateParameter(valid_590778, JString, required = false,
                                 default = newJString("json"))
  if valid_590778 != nil:
    section.add "alt", valid_590778
  var valid_590779 = query.getOrDefault("oauth_token")
  valid_590779 = validateParameter(valid_590779, JString, required = false,
                                 default = nil)
  if valid_590779 != nil:
    section.add "oauth_token", valid_590779
  var valid_590780 = query.getOrDefault("userIp")
  valid_590780 = validateParameter(valid_590780, JString, required = false,
                                 default = nil)
  if valid_590780 != nil:
    section.add "userIp", valid_590780
  var valid_590781 = query.getOrDefault("key")
  valid_590781 = validateParameter(valid_590781, JString, required = false,
                                 default = nil)
  if valid_590781 != nil:
    section.add "key", valid_590781
  var valid_590782 = query.getOrDefault("prettyPrint")
  valid_590782 = validateParameter(valid_590782, JBool, required = false,
                                 default = newJBool(true))
  if valid_590782 != nil:
    section.add "prettyPrint", valid_590782
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590783: Call_DfareportingEventTagsGet_590771; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one event tag by ID.
  ## 
  let valid = call_590783.validator(path, query, header, formData, body)
  let scheme = call_590783.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590783.url(scheme.get, call_590783.host, call_590783.base,
                         call_590783.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590783, url, valid)

proc call*(call_590784: Call_DfareportingEventTagsGet_590771; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsGet
  ## Gets one event tag by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Event tag ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590785 = newJObject()
  var query_590786 = newJObject()
  add(path_590785, "profileId", newJString(profileId))
  add(query_590786, "fields", newJString(fields))
  add(query_590786, "quotaUser", newJString(quotaUser))
  add(query_590786, "alt", newJString(alt))
  add(query_590786, "oauth_token", newJString(oauthToken))
  add(query_590786, "userIp", newJString(userIp))
  add(path_590785, "id", newJString(id))
  add(query_590786, "key", newJString(key))
  add(query_590786, "prettyPrint", newJBool(prettyPrint))
  result = call_590784.call(path_590785, query_590786, nil, nil, nil)

var dfareportingEventTagsGet* = Call_DfareportingEventTagsGet_590771(
    name: "dfareportingEventTagsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags/{id}",
    validator: validate_DfareportingEventTagsGet_590772,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsGet_590773,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsDelete_590787 = ref object of OpenApiRestCall_588466
proc url_DfareportingEventTagsDelete_590789(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsDelete_590788(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing event tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Event tag ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590790 = path.getOrDefault("profileId")
  valid_590790 = validateParameter(valid_590790, JString, required = true,
                                 default = nil)
  if valid_590790 != nil:
    section.add "profileId", valid_590790
  var valid_590791 = path.getOrDefault("id")
  valid_590791 = validateParameter(valid_590791, JString, required = true,
                                 default = nil)
  if valid_590791 != nil:
    section.add "id", valid_590791
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590792 = query.getOrDefault("fields")
  valid_590792 = validateParameter(valid_590792, JString, required = false,
                                 default = nil)
  if valid_590792 != nil:
    section.add "fields", valid_590792
  var valid_590793 = query.getOrDefault("quotaUser")
  valid_590793 = validateParameter(valid_590793, JString, required = false,
                                 default = nil)
  if valid_590793 != nil:
    section.add "quotaUser", valid_590793
  var valid_590794 = query.getOrDefault("alt")
  valid_590794 = validateParameter(valid_590794, JString, required = false,
                                 default = newJString("json"))
  if valid_590794 != nil:
    section.add "alt", valid_590794
  var valid_590795 = query.getOrDefault("oauth_token")
  valid_590795 = validateParameter(valid_590795, JString, required = false,
                                 default = nil)
  if valid_590795 != nil:
    section.add "oauth_token", valid_590795
  var valid_590796 = query.getOrDefault("userIp")
  valid_590796 = validateParameter(valid_590796, JString, required = false,
                                 default = nil)
  if valid_590796 != nil:
    section.add "userIp", valid_590796
  var valid_590797 = query.getOrDefault("key")
  valid_590797 = validateParameter(valid_590797, JString, required = false,
                                 default = nil)
  if valid_590797 != nil:
    section.add "key", valid_590797
  var valid_590798 = query.getOrDefault("prettyPrint")
  valid_590798 = validateParameter(valid_590798, JBool, required = false,
                                 default = newJBool(true))
  if valid_590798 != nil:
    section.add "prettyPrint", valid_590798
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590799: Call_DfareportingEventTagsDelete_590787; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing event tag.
  ## 
  let valid = call_590799.validator(path, query, header, formData, body)
  let scheme = call_590799.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590799.url(scheme.get, call_590799.host, call_590799.base,
                         call_590799.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590799, url, valid)

proc call*(call_590800: Call_DfareportingEventTagsDelete_590787; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsDelete
  ## Deletes an existing event tag.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Event tag ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590801 = newJObject()
  var query_590802 = newJObject()
  add(path_590801, "profileId", newJString(profileId))
  add(query_590802, "fields", newJString(fields))
  add(query_590802, "quotaUser", newJString(quotaUser))
  add(query_590802, "alt", newJString(alt))
  add(query_590802, "oauth_token", newJString(oauthToken))
  add(query_590802, "userIp", newJString(userIp))
  add(path_590801, "id", newJString(id))
  add(query_590802, "key", newJString(key))
  add(query_590802, "prettyPrint", newJBool(prettyPrint))
  result = call_590800.call(path_590801, query_590802, nil, nil, nil)

var dfareportingEventTagsDelete* = Call_DfareportingEventTagsDelete_590787(
    name: "dfareportingEventTagsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags/{id}",
    validator: validate_DfareportingEventTagsDelete_590788,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsDelete_590789,
    schemes: {Scheme.Https})
type
  Call_DfareportingFilesList_590803 = ref object of OpenApiRestCall_588466
proc url_DfareportingFilesList_590805(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFilesList_590804(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists files for a user profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590806 = path.getOrDefault("profileId")
  valid_590806 = validateParameter(valid_590806, JString, required = true,
                                 default = nil)
  if valid_590806 != nil:
    section.add "profileId", valid_590806
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : The field by which to sort the list.
  ##   scope: JString
  ##        : The scope that defines which results are returned.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590807 = query.getOrDefault("fields")
  valid_590807 = validateParameter(valid_590807, JString, required = false,
                                 default = nil)
  if valid_590807 != nil:
    section.add "fields", valid_590807
  var valid_590808 = query.getOrDefault("pageToken")
  valid_590808 = validateParameter(valid_590808, JString, required = false,
                                 default = nil)
  if valid_590808 != nil:
    section.add "pageToken", valid_590808
  var valid_590809 = query.getOrDefault("quotaUser")
  valid_590809 = validateParameter(valid_590809, JString, required = false,
                                 default = nil)
  if valid_590809 != nil:
    section.add "quotaUser", valid_590809
  var valid_590810 = query.getOrDefault("sortField")
  valid_590810 = validateParameter(valid_590810, JString, required = false,
                                 default = newJString("LAST_MODIFIED_TIME"))
  if valid_590810 != nil:
    section.add "sortField", valid_590810
  var valid_590811 = query.getOrDefault("scope")
  valid_590811 = validateParameter(valid_590811, JString, required = false,
                                 default = newJString("MINE"))
  if valid_590811 != nil:
    section.add "scope", valid_590811
  var valid_590812 = query.getOrDefault("alt")
  valid_590812 = validateParameter(valid_590812, JString, required = false,
                                 default = newJString("json"))
  if valid_590812 != nil:
    section.add "alt", valid_590812
  var valid_590813 = query.getOrDefault("oauth_token")
  valid_590813 = validateParameter(valid_590813, JString, required = false,
                                 default = nil)
  if valid_590813 != nil:
    section.add "oauth_token", valid_590813
  var valid_590814 = query.getOrDefault("userIp")
  valid_590814 = validateParameter(valid_590814, JString, required = false,
                                 default = nil)
  if valid_590814 != nil:
    section.add "userIp", valid_590814
  var valid_590815 = query.getOrDefault("maxResults")
  valid_590815 = validateParameter(valid_590815, JInt, required = false,
                                 default = newJInt(10))
  if valid_590815 != nil:
    section.add "maxResults", valid_590815
  var valid_590816 = query.getOrDefault("key")
  valid_590816 = validateParameter(valid_590816, JString, required = false,
                                 default = nil)
  if valid_590816 != nil:
    section.add "key", valid_590816
  var valid_590817 = query.getOrDefault("sortOrder")
  valid_590817 = validateParameter(valid_590817, JString, required = false,
                                 default = newJString("DESCENDING"))
  if valid_590817 != nil:
    section.add "sortOrder", valid_590817
  var valid_590818 = query.getOrDefault("prettyPrint")
  valid_590818 = validateParameter(valid_590818, JBool, required = false,
                                 default = newJBool(true))
  if valid_590818 != nil:
    section.add "prettyPrint", valid_590818
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590819: Call_DfareportingFilesList_590803; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists files for a user profile.
  ## 
  let valid = call_590819.validator(path, query, header, formData, body)
  let scheme = call_590819.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590819.url(scheme.get, call_590819.host, call_590819.base,
                         call_590819.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590819, url, valid)

proc call*(call_590820: Call_DfareportingFilesList_590803; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "LAST_MODIFIED_TIME"; scope: string = "MINE";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 10; key: string = ""; sortOrder: string = "DESCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingFilesList
  ## Lists files for a user profile.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : The field by which to sort the list.
  ##   scope: string
  ##        : The scope that defines which results are returned.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590821 = newJObject()
  var query_590822 = newJObject()
  add(path_590821, "profileId", newJString(profileId))
  add(query_590822, "fields", newJString(fields))
  add(query_590822, "pageToken", newJString(pageToken))
  add(query_590822, "quotaUser", newJString(quotaUser))
  add(query_590822, "sortField", newJString(sortField))
  add(query_590822, "scope", newJString(scope))
  add(query_590822, "alt", newJString(alt))
  add(query_590822, "oauth_token", newJString(oauthToken))
  add(query_590822, "userIp", newJString(userIp))
  add(query_590822, "maxResults", newJInt(maxResults))
  add(query_590822, "key", newJString(key))
  add(query_590822, "sortOrder", newJString(sortOrder))
  add(query_590822, "prettyPrint", newJBool(prettyPrint))
  result = call_590820.call(path_590821, query_590822, nil, nil, nil)

var dfareportingFilesList* = Call_DfareportingFilesList_590803(
    name: "dfareportingFilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/files",
    validator: validate_DfareportingFilesList_590804, base: "/dfareporting/v2.7",
    url: url_DfareportingFilesList_590805, schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesUpdate_590851 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightActivitiesUpdate_590853(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesUpdate_590852(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590854 = path.getOrDefault("profileId")
  valid_590854 = validateParameter(valid_590854, JString, required = true,
                                 default = nil)
  if valid_590854 != nil:
    section.add "profileId", valid_590854
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590855 = query.getOrDefault("fields")
  valid_590855 = validateParameter(valid_590855, JString, required = false,
                                 default = nil)
  if valid_590855 != nil:
    section.add "fields", valid_590855
  var valid_590856 = query.getOrDefault("quotaUser")
  valid_590856 = validateParameter(valid_590856, JString, required = false,
                                 default = nil)
  if valid_590856 != nil:
    section.add "quotaUser", valid_590856
  var valid_590857 = query.getOrDefault("alt")
  valid_590857 = validateParameter(valid_590857, JString, required = false,
                                 default = newJString("json"))
  if valid_590857 != nil:
    section.add "alt", valid_590857
  var valid_590858 = query.getOrDefault("oauth_token")
  valid_590858 = validateParameter(valid_590858, JString, required = false,
                                 default = nil)
  if valid_590858 != nil:
    section.add "oauth_token", valid_590858
  var valid_590859 = query.getOrDefault("userIp")
  valid_590859 = validateParameter(valid_590859, JString, required = false,
                                 default = nil)
  if valid_590859 != nil:
    section.add "userIp", valid_590859
  var valid_590860 = query.getOrDefault("key")
  valid_590860 = validateParameter(valid_590860, JString, required = false,
                                 default = nil)
  if valid_590860 != nil:
    section.add "key", valid_590860
  var valid_590861 = query.getOrDefault("prettyPrint")
  valid_590861 = validateParameter(valid_590861, JBool, required = false,
                                 default = newJBool(true))
  if valid_590861 != nil:
    section.add "prettyPrint", valid_590861
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590863: Call_DfareportingFloodlightActivitiesUpdate_590851;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity.
  ## 
  let valid = call_590863.validator(path, query, header, formData, body)
  let scheme = call_590863.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590863.url(scheme.get, call_590863.host, call_590863.base,
                         call_590863.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590863, url, valid)

proc call*(call_590864: Call_DfareportingFloodlightActivitiesUpdate_590851;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesUpdate
  ## Updates an existing floodlight activity.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590865 = newJObject()
  var query_590866 = newJObject()
  var body_590867 = newJObject()
  add(path_590865, "profileId", newJString(profileId))
  add(query_590866, "fields", newJString(fields))
  add(query_590866, "quotaUser", newJString(quotaUser))
  add(query_590866, "alt", newJString(alt))
  add(query_590866, "oauth_token", newJString(oauthToken))
  add(query_590866, "userIp", newJString(userIp))
  add(query_590866, "key", newJString(key))
  if body != nil:
    body_590867 = body
  add(query_590866, "prettyPrint", newJBool(prettyPrint))
  result = call_590864.call(path_590865, query_590866, nil, nil, body_590867)

var dfareportingFloodlightActivitiesUpdate* = Call_DfareportingFloodlightActivitiesUpdate_590851(
    name: "dfareportingFloodlightActivitiesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesUpdate_590852,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesUpdate_590853,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesInsert_590868 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightActivitiesInsert_590870(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesInsert_590869(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590871 = path.getOrDefault("profileId")
  valid_590871 = validateParameter(valid_590871, JString, required = true,
                                 default = nil)
  if valid_590871 != nil:
    section.add "profileId", valid_590871
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590872 = query.getOrDefault("fields")
  valid_590872 = validateParameter(valid_590872, JString, required = false,
                                 default = nil)
  if valid_590872 != nil:
    section.add "fields", valid_590872
  var valid_590873 = query.getOrDefault("quotaUser")
  valid_590873 = validateParameter(valid_590873, JString, required = false,
                                 default = nil)
  if valid_590873 != nil:
    section.add "quotaUser", valid_590873
  var valid_590874 = query.getOrDefault("alt")
  valid_590874 = validateParameter(valid_590874, JString, required = false,
                                 default = newJString("json"))
  if valid_590874 != nil:
    section.add "alt", valid_590874
  var valid_590875 = query.getOrDefault("oauth_token")
  valid_590875 = validateParameter(valid_590875, JString, required = false,
                                 default = nil)
  if valid_590875 != nil:
    section.add "oauth_token", valid_590875
  var valid_590876 = query.getOrDefault("userIp")
  valid_590876 = validateParameter(valid_590876, JString, required = false,
                                 default = nil)
  if valid_590876 != nil:
    section.add "userIp", valid_590876
  var valid_590877 = query.getOrDefault("key")
  valid_590877 = validateParameter(valid_590877, JString, required = false,
                                 default = nil)
  if valid_590877 != nil:
    section.add "key", valid_590877
  var valid_590878 = query.getOrDefault("prettyPrint")
  valid_590878 = validateParameter(valid_590878, JBool, required = false,
                                 default = newJBool(true))
  if valid_590878 != nil:
    section.add "prettyPrint", valid_590878
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590880: Call_DfareportingFloodlightActivitiesInsert_590868;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new floodlight activity.
  ## 
  let valid = call_590880.validator(path, query, header, formData, body)
  let scheme = call_590880.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590880.url(scheme.get, call_590880.host, call_590880.base,
                         call_590880.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590880, url, valid)

proc call*(call_590881: Call_DfareportingFloodlightActivitiesInsert_590868;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesInsert
  ## Inserts a new floodlight activity.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590882 = newJObject()
  var query_590883 = newJObject()
  var body_590884 = newJObject()
  add(path_590882, "profileId", newJString(profileId))
  add(query_590883, "fields", newJString(fields))
  add(query_590883, "quotaUser", newJString(quotaUser))
  add(query_590883, "alt", newJString(alt))
  add(query_590883, "oauth_token", newJString(oauthToken))
  add(query_590883, "userIp", newJString(userIp))
  add(query_590883, "key", newJString(key))
  if body != nil:
    body_590884 = body
  add(query_590883, "prettyPrint", newJBool(prettyPrint))
  result = call_590881.call(path_590882, query_590883, nil, nil, body_590884)

var dfareportingFloodlightActivitiesInsert* = Call_DfareportingFloodlightActivitiesInsert_590868(
    name: "dfareportingFloodlightActivitiesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesInsert_590869,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesInsert_590870,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesList_590823 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightActivitiesList_590825(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesList_590824(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of floodlight activities, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590826 = path.getOrDefault("profileId")
  valid_590826 = validateParameter(valid_590826, JString, required = true,
                                 default = nil)
  if valid_590826 != nil:
    section.add "profileId", valid_590826
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   tagString: JString
  ##            : Select only floodlight activities with the specified tag string.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivity*2015" will return objects with names like "floodlightactivity June 2015", "floodlightactivity April 2015", or simply "floodlightactivity 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivity" will match objects with name "my floodlightactivity activity", "floodlightactivity 2015", or simply "floodlightactivity".
  ##   advertiserId: JString
  ##               : Select only floodlight activities for the specified advertiser ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   floodlightActivityGroupIds: JArray
  ##                             : Select only floodlight activities with the specified floodlight activity group IDs.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   floodlightActivityGroupType: JString
  ##                              : Select only floodlight activities with the specified floodlight activity group type.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   floodlightConfigurationId: JString
  ##                            : Select only floodlight activities for the specified floodlight configuration ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   floodlightActivityGroupTagString: JString
  ##                                   : Select only floodlight activities with the specified floodlight activity group tag string.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only floodlight activities with the specified IDs. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   floodlightActivityGroupName: JString
  ##                              : Select only floodlight activities with the specified floodlight activity group name.
  section = newJObject()
  var valid_590827 = query.getOrDefault("fields")
  valid_590827 = validateParameter(valid_590827, JString, required = false,
                                 default = nil)
  if valid_590827 != nil:
    section.add "fields", valid_590827
  var valid_590828 = query.getOrDefault("pageToken")
  valid_590828 = validateParameter(valid_590828, JString, required = false,
                                 default = nil)
  if valid_590828 != nil:
    section.add "pageToken", valid_590828
  var valid_590829 = query.getOrDefault("quotaUser")
  valid_590829 = validateParameter(valid_590829, JString, required = false,
                                 default = nil)
  if valid_590829 != nil:
    section.add "quotaUser", valid_590829
  var valid_590830 = query.getOrDefault("sortField")
  valid_590830 = validateParameter(valid_590830, JString, required = false,
                                 default = newJString("ID"))
  if valid_590830 != nil:
    section.add "sortField", valid_590830
  var valid_590831 = query.getOrDefault("tagString")
  valid_590831 = validateParameter(valid_590831, JString, required = false,
                                 default = nil)
  if valid_590831 != nil:
    section.add "tagString", valid_590831
  var valid_590832 = query.getOrDefault("alt")
  valid_590832 = validateParameter(valid_590832, JString, required = false,
                                 default = newJString("json"))
  if valid_590832 != nil:
    section.add "alt", valid_590832
  var valid_590833 = query.getOrDefault("searchString")
  valid_590833 = validateParameter(valid_590833, JString, required = false,
                                 default = nil)
  if valid_590833 != nil:
    section.add "searchString", valid_590833
  var valid_590834 = query.getOrDefault("advertiserId")
  valid_590834 = validateParameter(valid_590834, JString, required = false,
                                 default = nil)
  if valid_590834 != nil:
    section.add "advertiserId", valid_590834
  var valid_590835 = query.getOrDefault("floodlightActivityGroupIds")
  valid_590835 = validateParameter(valid_590835, JArray, required = false,
                                 default = nil)
  if valid_590835 != nil:
    section.add "floodlightActivityGroupIds", valid_590835
  var valid_590836 = query.getOrDefault("oauth_token")
  valid_590836 = validateParameter(valid_590836, JString, required = false,
                                 default = nil)
  if valid_590836 != nil:
    section.add "oauth_token", valid_590836
  var valid_590837 = query.getOrDefault("floodlightActivityGroupType")
  valid_590837 = validateParameter(valid_590837, JString, required = false,
                                 default = newJString("COUNTER"))
  if valid_590837 != nil:
    section.add "floodlightActivityGroupType", valid_590837
  var valid_590838 = query.getOrDefault("userIp")
  valid_590838 = validateParameter(valid_590838, JString, required = false,
                                 default = nil)
  if valid_590838 != nil:
    section.add "userIp", valid_590838
  var valid_590839 = query.getOrDefault("floodlightConfigurationId")
  valid_590839 = validateParameter(valid_590839, JString, required = false,
                                 default = nil)
  if valid_590839 != nil:
    section.add "floodlightConfigurationId", valid_590839
  var valid_590840 = query.getOrDefault("floodlightActivityGroupTagString")
  valid_590840 = validateParameter(valid_590840, JString, required = false,
                                 default = nil)
  if valid_590840 != nil:
    section.add "floodlightActivityGroupTagString", valid_590840
  var valid_590841 = query.getOrDefault("maxResults")
  valid_590841 = validateParameter(valid_590841, JInt, required = false,
                                 default = newJInt(1000))
  if valid_590841 != nil:
    section.add "maxResults", valid_590841
  var valid_590842 = query.getOrDefault("ids")
  valid_590842 = validateParameter(valid_590842, JArray, required = false,
                                 default = nil)
  if valid_590842 != nil:
    section.add "ids", valid_590842
  var valid_590843 = query.getOrDefault("key")
  valid_590843 = validateParameter(valid_590843, JString, required = false,
                                 default = nil)
  if valid_590843 != nil:
    section.add "key", valid_590843
  var valid_590844 = query.getOrDefault("sortOrder")
  valid_590844 = validateParameter(valid_590844, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_590844 != nil:
    section.add "sortOrder", valid_590844
  var valid_590845 = query.getOrDefault("prettyPrint")
  valid_590845 = validateParameter(valid_590845, JBool, required = false,
                                 default = newJBool(true))
  if valid_590845 != nil:
    section.add "prettyPrint", valid_590845
  var valid_590846 = query.getOrDefault("floodlightActivityGroupName")
  valid_590846 = validateParameter(valid_590846, JString, required = false,
                                 default = nil)
  if valid_590846 != nil:
    section.add "floodlightActivityGroupName", valid_590846
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590847: Call_DfareportingFloodlightActivitiesList_590823;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of floodlight activities, possibly filtered. This method supports paging.
  ## 
  let valid = call_590847.validator(path, query, header, formData, body)
  let scheme = call_590847.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590847.url(scheme.get, call_590847.host, call_590847.base,
                         call_590847.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590847, url, valid)

proc call*(call_590848: Call_DfareportingFloodlightActivitiesList_590823;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; tagString: string = "";
          alt: string = "json"; searchString: string = ""; advertiserId: string = "";
          floodlightActivityGroupIds: JsonNode = nil; oauthToken: string = "";
          floodlightActivityGroupType: string = "COUNTER"; userIp: string = "";
          floodlightConfigurationId: string = "";
          floodlightActivityGroupTagString: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true; floodlightActivityGroupName: string = ""): Recallable =
  ## dfareportingFloodlightActivitiesList
  ## Retrieves a list of floodlight activities, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   tagString: string
  ##            : Select only floodlight activities with the specified tag string.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivity*2015" will return objects with names like "floodlightactivity June 2015", "floodlightactivity April 2015", or simply "floodlightactivity 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivity" will match objects with name "my floodlightactivity activity", "floodlightactivity 2015", or simply "floodlightactivity".
  ##   advertiserId: string
  ##               : Select only floodlight activities for the specified advertiser ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   floodlightActivityGroupIds: JArray
  ##                             : Select only floodlight activities with the specified floodlight activity group IDs.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   floodlightActivityGroupType: string
  ##                              : Select only floodlight activities with the specified floodlight activity group type.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   floodlightConfigurationId: string
  ##                            : Select only floodlight activities for the specified floodlight configuration ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   floodlightActivityGroupTagString: string
  ##                                   : Select only floodlight activities with the specified floodlight activity group tag string.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only floodlight activities with the specified IDs. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   floodlightActivityGroupName: string
  ##                              : Select only floodlight activities with the specified floodlight activity group name.
  var path_590849 = newJObject()
  var query_590850 = newJObject()
  add(path_590849, "profileId", newJString(profileId))
  add(query_590850, "fields", newJString(fields))
  add(query_590850, "pageToken", newJString(pageToken))
  add(query_590850, "quotaUser", newJString(quotaUser))
  add(query_590850, "sortField", newJString(sortField))
  add(query_590850, "tagString", newJString(tagString))
  add(query_590850, "alt", newJString(alt))
  add(query_590850, "searchString", newJString(searchString))
  add(query_590850, "advertiserId", newJString(advertiserId))
  if floodlightActivityGroupIds != nil:
    query_590850.add "floodlightActivityGroupIds", floodlightActivityGroupIds
  add(query_590850, "oauth_token", newJString(oauthToken))
  add(query_590850, "floodlightActivityGroupType",
      newJString(floodlightActivityGroupType))
  add(query_590850, "userIp", newJString(userIp))
  add(query_590850, "floodlightConfigurationId",
      newJString(floodlightConfigurationId))
  add(query_590850, "floodlightActivityGroupTagString",
      newJString(floodlightActivityGroupTagString))
  add(query_590850, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_590850.add "ids", ids
  add(query_590850, "key", newJString(key))
  add(query_590850, "sortOrder", newJString(sortOrder))
  add(query_590850, "prettyPrint", newJBool(prettyPrint))
  add(query_590850, "floodlightActivityGroupName",
      newJString(floodlightActivityGroupName))
  result = call_590848.call(path_590849, query_590850, nil, nil, nil)

var dfareportingFloodlightActivitiesList* = Call_DfareportingFloodlightActivitiesList_590823(
    name: "dfareportingFloodlightActivitiesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesList_590824,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesList_590825,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesPatch_590885 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightActivitiesPatch_590887(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesPatch_590886(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590888 = path.getOrDefault("profileId")
  valid_590888 = validateParameter(valid_590888, JString, required = true,
                                 default = nil)
  if valid_590888 != nil:
    section.add "profileId", valid_590888
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Floodlight activity ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590889 = query.getOrDefault("fields")
  valid_590889 = validateParameter(valid_590889, JString, required = false,
                                 default = nil)
  if valid_590889 != nil:
    section.add "fields", valid_590889
  var valid_590890 = query.getOrDefault("quotaUser")
  valid_590890 = validateParameter(valid_590890, JString, required = false,
                                 default = nil)
  if valid_590890 != nil:
    section.add "quotaUser", valid_590890
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_590891 = query.getOrDefault("id")
  valid_590891 = validateParameter(valid_590891, JString, required = true,
                                 default = nil)
  if valid_590891 != nil:
    section.add "id", valid_590891
  var valid_590892 = query.getOrDefault("alt")
  valid_590892 = validateParameter(valid_590892, JString, required = false,
                                 default = newJString("json"))
  if valid_590892 != nil:
    section.add "alt", valid_590892
  var valid_590893 = query.getOrDefault("oauth_token")
  valid_590893 = validateParameter(valid_590893, JString, required = false,
                                 default = nil)
  if valid_590893 != nil:
    section.add "oauth_token", valid_590893
  var valid_590894 = query.getOrDefault("userIp")
  valid_590894 = validateParameter(valid_590894, JString, required = false,
                                 default = nil)
  if valid_590894 != nil:
    section.add "userIp", valid_590894
  var valid_590895 = query.getOrDefault("key")
  valid_590895 = validateParameter(valid_590895, JString, required = false,
                                 default = nil)
  if valid_590895 != nil:
    section.add "key", valid_590895
  var valid_590896 = query.getOrDefault("prettyPrint")
  valid_590896 = validateParameter(valid_590896, JBool, required = false,
                                 default = newJBool(true))
  if valid_590896 != nil:
    section.add "prettyPrint", valid_590896
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590898: Call_DfareportingFloodlightActivitiesPatch_590885;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity. This method supports patch semantics.
  ## 
  let valid = call_590898.validator(path, query, header, formData, body)
  let scheme = call_590898.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590898.url(scheme.get, call_590898.host, call_590898.base,
                         call_590898.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590898, url, valid)

proc call*(call_590899: Call_DfareportingFloodlightActivitiesPatch_590885;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesPatch
  ## Updates an existing floodlight activity. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Floodlight activity ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590900 = newJObject()
  var query_590901 = newJObject()
  var body_590902 = newJObject()
  add(path_590900, "profileId", newJString(profileId))
  add(query_590901, "fields", newJString(fields))
  add(query_590901, "quotaUser", newJString(quotaUser))
  add(query_590901, "id", newJString(id))
  add(query_590901, "alt", newJString(alt))
  add(query_590901, "oauth_token", newJString(oauthToken))
  add(query_590901, "userIp", newJString(userIp))
  add(query_590901, "key", newJString(key))
  if body != nil:
    body_590902 = body
  add(query_590901, "prettyPrint", newJBool(prettyPrint))
  result = call_590899.call(path_590900, query_590901, nil, nil, body_590902)

var dfareportingFloodlightActivitiesPatch* = Call_DfareportingFloodlightActivitiesPatch_590885(
    name: "dfareportingFloodlightActivitiesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesPatch_590886,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesPatch_590887,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesGeneratetag_590903 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightActivitiesGeneratetag_590905(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"), (kind: ConstantSegment,
        value: "/floodlightActivities/generatetag")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesGeneratetag_590904(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Generates a tag for a floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590906 = path.getOrDefault("profileId")
  valid_590906 = validateParameter(valid_590906, JString, required = true,
                                 default = nil)
  if valid_590906 != nil:
    section.add "profileId", valid_590906
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   floodlightActivityId: JString
  ##                       : Floodlight activity ID for which we want to generate a tag.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590907 = query.getOrDefault("fields")
  valid_590907 = validateParameter(valid_590907, JString, required = false,
                                 default = nil)
  if valid_590907 != nil:
    section.add "fields", valid_590907
  var valid_590908 = query.getOrDefault("quotaUser")
  valid_590908 = validateParameter(valid_590908, JString, required = false,
                                 default = nil)
  if valid_590908 != nil:
    section.add "quotaUser", valid_590908
  var valid_590909 = query.getOrDefault("alt")
  valid_590909 = validateParameter(valid_590909, JString, required = false,
                                 default = newJString("json"))
  if valid_590909 != nil:
    section.add "alt", valid_590909
  var valid_590910 = query.getOrDefault("oauth_token")
  valid_590910 = validateParameter(valid_590910, JString, required = false,
                                 default = nil)
  if valid_590910 != nil:
    section.add "oauth_token", valid_590910
  var valid_590911 = query.getOrDefault("floodlightActivityId")
  valid_590911 = validateParameter(valid_590911, JString, required = false,
                                 default = nil)
  if valid_590911 != nil:
    section.add "floodlightActivityId", valid_590911
  var valid_590912 = query.getOrDefault("userIp")
  valid_590912 = validateParameter(valid_590912, JString, required = false,
                                 default = nil)
  if valid_590912 != nil:
    section.add "userIp", valid_590912
  var valid_590913 = query.getOrDefault("key")
  valid_590913 = validateParameter(valid_590913, JString, required = false,
                                 default = nil)
  if valid_590913 != nil:
    section.add "key", valid_590913
  var valid_590914 = query.getOrDefault("prettyPrint")
  valid_590914 = validateParameter(valid_590914, JBool, required = false,
                                 default = newJBool(true))
  if valid_590914 != nil:
    section.add "prettyPrint", valid_590914
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590915: Call_DfareportingFloodlightActivitiesGeneratetag_590903;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Generates a tag for a floodlight activity.
  ## 
  let valid = call_590915.validator(path, query, header, formData, body)
  let scheme = call_590915.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590915.url(scheme.get, call_590915.host, call_590915.base,
                         call_590915.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590915, url, valid)

proc call*(call_590916: Call_DfareportingFloodlightActivitiesGeneratetag_590903;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = "";
          floodlightActivityId: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesGeneratetag
  ## Generates a tag for a floodlight activity.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   floodlightActivityId: string
  ##                       : Floodlight activity ID for which we want to generate a tag.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590917 = newJObject()
  var query_590918 = newJObject()
  add(path_590917, "profileId", newJString(profileId))
  add(query_590918, "fields", newJString(fields))
  add(query_590918, "quotaUser", newJString(quotaUser))
  add(query_590918, "alt", newJString(alt))
  add(query_590918, "oauth_token", newJString(oauthToken))
  add(query_590918, "floodlightActivityId", newJString(floodlightActivityId))
  add(query_590918, "userIp", newJString(userIp))
  add(query_590918, "key", newJString(key))
  add(query_590918, "prettyPrint", newJBool(prettyPrint))
  result = call_590916.call(path_590917, query_590918, nil, nil, nil)

var dfareportingFloodlightActivitiesGeneratetag* = Call_DfareportingFloodlightActivitiesGeneratetag_590903(
    name: "dfareportingFloodlightActivitiesGeneratetag",
    meth: HttpMethod.HttpPost, host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities/generatetag",
    validator: validate_DfareportingFloodlightActivitiesGeneratetag_590904,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivitiesGeneratetag_590905,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesGet_590919 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightActivitiesGet_590921(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesGet_590920(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one floodlight activity by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight activity ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590922 = path.getOrDefault("profileId")
  valid_590922 = validateParameter(valid_590922, JString, required = true,
                                 default = nil)
  if valid_590922 != nil:
    section.add "profileId", valid_590922
  var valid_590923 = path.getOrDefault("id")
  valid_590923 = validateParameter(valid_590923, JString, required = true,
                                 default = nil)
  if valid_590923 != nil:
    section.add "id", valid_590923
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590924 = query.getOrDefault("fields")
  valid_590924 = validateParameter(valid_590924, JString, required = false,
                                 default = nil)
  if valid_590924 != nil:
    section.add "fields", valid_590924
  var valid_590925 = query.getOrDefault("quotaUser")
  valid_590925 = validateParameter(valid_590925, JString, required = false,
                                 default = nil)
  if valid_590925 != nil:
    section.add "quotaUser", valid_590925
  var valid_590926 = query.getOrDefault("alt")
  valid_590926 = validateParameter(valid_590926, JString, required = false,
                                 default = newJString("json"))
  if valid_590926 != nil:
    section.add "alt", valid_590926
  var valid_590927 = query.getOrDefault("oauth_token")
  valid_590927 = validateParameter(valid_590927, JString, required = false,
                                 default = nil)
  if valid_590927 != nil:
    section.add "oauth_token", valid_590927
  var valid_590928 = query.getOrDefault("userIp")
  valid_590928 = validateParameter(valid_590928, JString, required = false,
                                 default = nil)
  if valid_590928 != nil:
    section.add "userIp", valid_590928
  var valid_590929 = query.getOrDefault("key")
  valid_590929 = validateParameter(valid_590929, JString, required = false,
                                 default = nil)
  if valid_590929 != nil:
    section.add "key", valid_590929
  var valid_590930 = query.getOrDefault("prettyPrint")
  valid_590930 = validateParameter(valid_590930, JBool, required = false,
                                 default = newJBool(true))
  if valid_590930 != nil:
    section.add "prettyPrint", valid_590930
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590931: Call_DfareportingFloodlightActivitiesGet_590919;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one floodlight activity by ID.
  ## 
  let valid = call_590931.validator(path, query, header, formData, body)
  let scheme = call_590931.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590931.url(scheme.get, call_590931.host, call_590931.base,
                         call_590931.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590931, url, valid)

proc call*(call_590932: Call_DfareportingFloodlightActivitiesGet_590919;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesGet
  ## Gets one floodlight activity by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Floodlight activity ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590933 = newJObject()
  var query_590934 = newJObject()
  add(path_590933, "profileId", newJString(profileId))
  add(query_590934, "fields", newJString(fields))
  add(query_590934, "quotaUser", newJString(quotaUser))
  add(query_590934, "alt", newJString(alt))
  add(query_590934, "oauth_token", newJString(oauthToken))
  add(query_590934, "userIp", newJString(userIp))
  add(path_590933, "id", newJString(id))
  add(query_590934, "key", newJString(key))
  add(query_590934, "prettyPrint", newJBool(prettyPrint))
  result = call_590932.call(path_590933, query_590934, nil, nil, nil)

var dfareportingFloodlightActivitiesGet* = Call_DfareportingFloodlightActivitiesGet_590919(
    name: "dfareportingFloodlightActivitiesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities/{id}",
    validator: validate_DfareportingFloodlightActivitiesGet_590920,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesGet_590921,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesDelete_590935 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightActivitiesDelete_590937(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesDelete_590936(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight activity ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590938 = path.getOrDefault("profileId")
  valid_590938 = validateParameter(valid_590938, JString, required = true,
                                 default = nil)
  if valid_590938 != nil:
    section.add "profileId", valid_590938
  var valid_590939 = path.getOrDefault("id")
  valid_590939 = validateParameter(valid_590939, JString, required = true,
                                 default = nil)
  if valid_590939 != nil:
    section.add "id", valid_590939
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590940 = query.getOrDefault("fields")
  valid_590940 = validateParameter(valid_590940, JString, required = false,
                                 default = nil)
  if valid_590940 != nil:
    section.add "fields", valid_590940
  var valid_590941 = query.getOrDefault("quotaUser")
  valid_590941 = validateParameter(valid_590941, JString, required = false,
                                 default = nil)
  if valid_590941 != nil:
    section.add "quotaUser", valid_590941
  var valid_590942 = query.getOrDefault("alt")
  valid_590942 = validateParameter(valid_590942, JString, required = false,
                                 default = newJString("json"))
  if valid_590942 != nil:
    section.add "alt", valid_590942
  var valid_590943 = query.getOrDefault("oauth_token")
  valid_590943 = validateParameter(valid_590943, JString, required = false,
                                 default = nil)
  if valid_590943 != nil:
    section.add "oauth_token", valid_590943
  var valid_590944 = query.getOrDefault("userIp")
  valid_590944 = validateParameter(valid_590944, JString, required = false,
                                 default = nil)
  if valid_590944 != nil:
    section.add "userIp", valid_590944
  var valid_590945 = query.getOrDefault("key")
  valid_590945 = validateParameter(valid_590945, JString, required = false,
                                 default = nil)
  if valid_590945 != nil:
    section.add "key", valid_590945
  var valid_590946 = query.getOrDefault("prettyPrint")
  valid_590946 = validateParameter(valid_590946, JBool, required = false,
                                 default = newJBool(true))
  if valid_590946 != nil:
    section.add "prettyPrint", valid_590946
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590947: Call_DfareportingFloodlightActivitiesDelete_590935;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing floodlight activity.
  ## 
  let valid = call_590947.validator(path, query, header, formData, body)
  let scheme = call_590947.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590947.url(scheme.get, call_590947.host, call_590947.base,
                         call_590947.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590947, url, valid)

proc call*(call_590948: Call_DfareportingFloodlightActivitiesDelete_590935;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesDelete
  ## Deletes an existing floodlight activity.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Floodlight activity ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590949 = newJObject()
  var query_590950 = newJObject()
  add(path_590949, "profileId", newJString(profileId))
  add(query_590950, "fields", newJString(fields))
  add(query_590950, "quotaUser", newJString(quotaUser))
  add(query_590950, "alt", newJString(alt))
  add(query_590950, "oauth_token", newJString(oauthToken))
  add(query_590950, "userIp", newJString(userIp))
  add(path_590949, "id", newJString(id))
  add(query_590950, "key", newJString(key))
  add(query_590950, "prettyPrint", newJBool(prettyPrint))
  result = call_590948.call(path_590949, query_590950, nil, nil, nil)

var dfareportingFloodlightActivitiesDelete* = Call_DfareportingFloodlightActivitiesDelete_590935(
    name: "dfareportingFloodlightActivitiesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities/{id}",
    validator: validate_DfareportingFloodlightActivitiesDelete_590936,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesDelete_590937,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsUpdate_590975 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightActivityGroupsUpdate_590977(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsUpdate_590976(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590978 = path.getOrDefault("profileId")
  valid_590978 = validateParameter(valid_590978, JString, required = true,
                                 default = nil)
  if valid_590978 != nil:
    section.add "profileId", valid_590978
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590979 = query.getOrDefault("fields")
  valid_590979 = validateParameter(valid_590979, JString, required = false,
                                 default = nil)
  if valid_590979 != nil:
    section.add "fields", valid_590979
  var valid_590980 = query.getOrDefault("quotaUser")
  valid_590980 = validateParameter(valid_590980, JString, required = false,
                                 default = nil)
  if valid_590980 != nil:
    section.add "quotaUser", valid_590980
  var valid_590981 = query.getOrDefault("alt")
  valid_590981 = validateParameter(valid_590981, JString, required = false,
                                 default = newJString("json"))
  if valid_590981 != nil:
    section.add "alt", valid_590981
  var valid_590982 = query.getOrDefault("oauth_token")
  valid_590982 = validateParameter(valid_590982, JString, required = false,
                                 default = nil)
  if valid_590982 != nil:
    section.add "oauth_token", valid_590982
  var valid_590983 = query.getOrDefault("userIp")
  valid_590983 = validateParameter(valid_590983, JString, required = false,
                                 default = nil)
  if valid_590983 != nil:
    section.add "userIp", valid_590983
  var valid_590984 = query.getOrDefault("key")
  valid_590984 = validateParameter(valid_590984, JString, required = false,
                                 default = nil)
  if valid_590984 != nil:
    section.add "key", valid_590984
  var valid_590985 = query.getOrDefault("prettyPrint")
  valid_590985 = validateParameter(valid_590985, JBool, required = false,
                                 default = newJBool(true))
  if valid_590985 != nil:
    section.add "prettyPrint", valid_590985
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_590987: Call_DfareportingFloodlightActivityGroupsUpdate_590975;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity group.
  ## 
  let valid = call_590987.validator(path, query, header, formData, body)
  let scheme = call_590987.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590987.url(scheme.get, call_590987.host, call_590987.base,
                         call_590987.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590987, url, valid)

proc call*(call_590988: Call_DfareportingFloodlightActivityGroupsUpdate_590975;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsUpdate
  ## Updates an existing floodlight activity group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590989 = newJObject()
  var query_590990 = newJObject()
  var body_590991 = newJObject()
  add(path_590989, "profileId", newJString(profileId))
  add(query_590990, "fields", newJString(fields))
  add(query_590990, "quotaUser", newJString(quotaUser))
  add(query_590990, "alt", newJString(alt))
  add(query_590990, "oauth_token", newJString(oauthToken))
  add(query_590990, "userIp", newJString(userIp))
  add(query_590990, "key", newJString(key))
  if body != nil:
    body_590991 = body
  add(query_590990, "prettyPrint", newJBool(prettyPrint))
  result = call_590988.call(path_590989, query_590990, nil, nil, body_590991)

var dfareportingFloodlightActivityGroupsUpdate* = Call_DfareportingFloodlightActivityGroupsUpdate_590975(
    name: "dfareportingFloodlightActivityGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsUpdate_590976,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivityGroupsUpdate_590977,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsInsert_590992 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightActivityGroupsInsert_590994(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsInsert_590993(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new floodlight activity group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590995 = path.getOrDefault("profileId")
  valid_590995 = validateParameter(valid_590995, JString, required = true,
                                 default = nil)
  if valid_590995 != nil:
    section.add "profileId", valid_590995
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590996 = query.getOrDefault("fields")
  valid_590996 = validateParameter(valid_590996, JString, required = false,
                                 default = nil)
  if valid_590996 != nil:
    section.add "fields", valid_590996
  var valid_590997 = query.getOrDefault("quotaUser")
  valid_590997 = validateParameter(valid_590997, JString, required = false,
                                 default = nil)
  if valid_590997 != nil:
    section.add "quotaUser", valid_590997
  var valid_590998 = query.getOrDefault("alt")
  valid_590998 = validateParameter(valid_590998, JString, required = false,
                                 default = newJString("json"))
  if valid_590998 != nil:
    section.add "alt", valid_590998
  var valid_590999 = query.getOrDefault("oauth_token")
  valid_590999 = validateParameter(valid_590999, JString, required = false,
                                 default = nil)
  if valid_590999 != nil:
    section.add "oauth_token", valid_590999
  var valid_591000 = query.getOrDefault("userIp")
  valid_591000 = validateParameter(valid_591000, JString, required = false,
                                 default = nil)
  if valid_591000 != nil:
    section.add "userIp", valid_591000
  var valid_591001 = query.getOrDefault("key")
  valid_591001 = validateParameter(valid_591001, JString, required = false,
                                 default = nil)
  if valid_591001 != nil:
    section.add "key", valid_591001
  var valid_591002 = query.getOrDefault("prettyPrint")
  valid_591002 = validateParameter(valid_591002, JBool, required = false,
                                 default = newJBool(true))
  if valid_591002 != nil:
    section.add "prettyPrint", valid_591002
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591004: Call_DfareportingFloodlightActivityGroupsInsert_590992;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new floodlight activity group.
  ## 
  let valid = call_591004.validator(path, query, header, formData, body)
  let scheme = call_591004.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591004.url(scheme.get, call_591004.host, call_591004.base,
                         call_591004.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591004, url, valid)

proc call*(call_591005: Call_DfareportingFloodlightActivityGroupsInsert_590992;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsInsert
  ## Inserts a new floodlight activity group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591006 = newJObject()
  var query_591007 = newJObject()
  var body_591008 = newJObject()
  add(path_591006, "profileId", newJString(profileId))
  add(query_591007, "fields", newJString(fields))
  add(query_591007, "quotaUser", newJString(quotaUser))
  add(query_591007, "alt", newJString(alt))
  add(query_591007, "oauth_token", newJString(oauthToken))
  add(query_591007, "userIp", newJString(userIp))
  add(query_591007, "key", newJString(key))
  if body != nil:
    body_591008 = body
  add(query_591007, "prettyPrint", newJBool(prettyPrint))
  result = call_591005.call(path_591006, query_591007, nil, nil, body_591008)

var dfareportingFloodlightActivityGroupsInsert* = Call_DfareportingFloodlightActivityGroupsInsert_590992(
    name: "dfareportingFloodlightActivityGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsInsert_590993,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivityGroupsInsert_590994,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsList_590951 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightActivityGroupsList_590953(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsList_590952(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of floodlight activity groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_590954 = path.getOrDefault("profileId")
  valid_590954 = validateParameter(valid_590954, JString, required = true,
                                 default = nil)
  if valid_590954 != nil:
    section.add "profileId", valid_590954
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivitygroup*2015" will return objects with names like "floodlightactivitygroup June 2015", "floodlightactivitygroup April 2015", or simply "floodlightactivitygroup 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivitygroup" will match objects with name "my floodlightactivitygroup activity", "floodlightactivitygroup 2015", or simply "floodlightactivitygroup".
  ##   advertiserId: JString
  ##               : Select only floodlight activity groups with the specified advertiser ID. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   type: JString
  ##       : Select only floodlight activity groups with the specified floodlight activity group type.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   floodlightConfigurationId: JString
  ##                            : Select only floodlight activity groups with the specified floodlight configuration ID. Must specify either advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only floodlight activity groups with the specified IDs. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_590955 = query.getOrDefault("fields")
  valid_590955 = validateParameter(valid_590955, JString, required = false,
                                 default = nil)
  if valid_590955 != nil:
    section.add "fields", valid_590955
  var valid_590956 = query.getOrDefault("pageToken")
  valid_590956 = validateParameter(valid_590956, JString, required = false,
                                 default = nil)
  if valid_590956 != nil:
    section.add "pageToken", valid_590956
  var valid_590957 = query.getOrDefault("quotaUser")
  valid_590957 = validateParameter(valid_590957, JString, required = false,
                                 default = nil)
  if valid_590957 != nil:
    section.add "quotaUser", valid_590957
  var valid_590958 = query.getOrDefault("sortField")
  valid_590958 = validateParameter(valid_590958, JString, required = false,
                                 default = newJString("ID"))
  if valid_590958 != nil:
    section.add "sortField", valid_590958
  var valid_590959 = query.getOrDefault("alt")
  valid_590959 = validateParameter(valid_590959, JString, required = false,
                                 default = newJString("json"))
  if valid_590959 != nil:
    section.add "alt", valid_590959
  var valid_590960 = query.getOrDefault("searchString")
  valid_590960 = validateParameter(valid_590960, JString, required = false,
                                 default = nil)
  if valid_590960 != nil:
    section.add "searchString", valid_590960
  var valid_590961 = query.getOrDefault("advertiserId")
  valid_590961 = validateParameter(valid_590961, JString, required = false,
                                 default = nil)
  if valid_590961 != nil:
    section.add "advertiserId", valid_590961
  var valid_590962 = query.getOrDefault("type")
  valid_590962 = validateParameter(valid_590962, JString, required = false,
                                 default = newJString("COUNTER"))
  if valid_590962 != nil:
    section.add "type", valid_590962
  var valid_590963 = query.getOrDefault("oauth_token")
  valid_590963 = validateParameter(valid_590963, JString, required = false,
                                 default = nil)
  if valid_590963 != nil:
    section.add "oauth_token", valid_590963
  var valid_590964 = query.getOrDefault("userIp")
  valid_590964 = validateParameter(valid_590964, JString, required = false,
                                 default = nil)
  if valid_590964 != nil:
    section.add "userIp", valid_590964
  var valid_590965 = query.getOrDefault("floodlightConfigurationId")
  valid_590965 = validateParameter(valid_590965, JString, required = false,
                                 default = nil)
  if valid_590965 != nil:
    section.add "floodlightConfigurationId", valid_590965
  var valid_590966 = query.getOrDefault("maxResults")
  valid_590966 = validateParameter(valid_590966, JInt, required = false,
                                 default = newJInt(1000))
  if valid_590966 != nil:
    section.add "maxResults", valid_590966
  var valid_590967 = query.getOrDefault("ids")
  valid_590967 = validateParameter(valid_590967, JArray, required = false,
                                 default = nil)
  if valid_590967 != nil:
    section.add "ids", valid_590967
  var valid_590968 = query.getOrDefault("key")
  valid_590968 = validateParameter(valid_590968, JString, required = false,
                                 default = nil)
  if valid_590968 != nil:
    section.add "key", valid_590968
  var valid_590969 = query.getOrDefault("sortOrder")
  valid_590969 = validateParameter(valid_590969, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_590969 != nil:
    section.add "sortOrder", valid_590969
  var valid_590970 = query.getOrDefault("prettyPrint")
  valid_590970 = validateParameter(valid_590970, JBool, required = false,
                                 default = newJBool(true))
  if valid_590970 != nil:
    section.add "prettyPrint", valid_590970
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_590971: Call_DfareportingFloodlightActivityGroupsList_590951;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of floodlight activity groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_590971.validator(path, query, header, formData, body)
  let scheme = call_590971.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_590971.url(scheme.get, call_590971.host, call_590971.base,
                         call_590971.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_590971, url, valid)

proc call*(call_590972: Call_DfareportingFloodlightActivityGroupsList_590951;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; advertiserId: string = "";
          `type`: string = "COUNTER"; oauthToken: string = ""; userIp: string = "";
          floodlightConfigurationId: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsList
  ## Retrieves a list of floodlight activity groups, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivitygroup*2015" will return objects with names like "floodlightactivitygroup June 2015", "floodlightactivitygroup April 2015", or simply "floodlightactivitygroup 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivitygroup" will match objects with name "my floodlightactivitygroup activity", "floodlightactivitygroup 2015", or simply "floodlightactivitygroup".
  ##   advertiserId: string
  ##               : Select only floodlight activity groups with the specified advertiser ID. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   type: string
  ##       : Select only floodlight activity groups with the specified floodlight activity group type.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   floodlightConfigurationId: string
  ##                            : Select only floodlight activity groups with the specified floodlight configuration ID. Must specify either advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only floodlight activity groups with the specified IDs. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_590973 = newJObject()
  var query_590974 = newJObject()
  add(path_590973, "profileId", newJString(profileId))
  add(query_590974, "fields", newJString(fields))
  add(query_590974, "pageToken", newJString(pageToken))
  add(query_590974, "quotaUser", newJString(quotaUser))
  add(query_590974, "sortField", newJString(sortField))
  add(query_590974, "alt", newJString(alt))
  add(query_590974, "searchString", newJString(searchString))
  add(query_590974, "advertiserId", newJString(advertiserId))
  add(query_590974, "type", newJString(`type`))
  add(query_590974, "oauth_token", newJString(oauthToken))
  add(query_590974, "userIp", newJString(userIp))
  add(query_590974, "floodlightConfigurationId",
      newJString(floodlightConfigurationId))
  add(query_590974, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_590974.add "ids", ids
  add(query_590974, "key", newJString(key))
  add(query_590974, "sortOrder", newJString(sortOrder))
  add(query_590974, "prettyPrint", newJBool(prettyPrint))
  result = call_590972.call(path_590973, query_590974, nil, nil, nil)

var dfareportingFloodlightActivityGroupsList* = Call_DfareportingFloodlightActivityGroupsList_590951(
    name: "dfareportingFloodlightActivityGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsList_590952,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivityGroupsList_590953,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsPatch_591009 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightActivityGroupsPatch_591011(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsPatch_591010(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591012 = path.getOrDefault("profileId")
  valid_591012 = validateParameter(valid_591012, JString, required = true,
                                 default = nil)
  if valid_591012 != nil:
    section.add "profileId", valid_591012
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Floodlight activity Group ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591013 = query.getOrDefault("fields")
  valid_591013 = validateParameter(valid_591013, JString, required = false,
                                 default = nil)
  if valid_591013 != nil:
    section.add "fields", valid_591013
  var valid_591014 = query.getOrDefault("quotaUser")
  valid_591014 = validateParameter(valid_591014, JString, required = false,
                                 default = nil)
  if valid_591014 != nil:
    section.add "quotaUser", valid_591014
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_591015 = query.getOrDefault("id")
  valid_591015 = validateParameter(valid_591015, JString, required = true,
                                 default = nil)
  if valid_591015 != nil:
    section.add "id", valid_591015
  var valid_591016 = query.getOrDefault("alt")
  valid_591016 = validateParameter(valid_591016, JString, required = false,
                                 default = newJString("json"))
  if valid_591016 != nil:
    section.add "alt", valid_591016
  var valid_591017 = query.getOrDefault("oauth_token")
  valid_591017 = validateParameter(valid_591017, JString, required = false,
                                 default = nil)
  if valid_591017 != nil:
    section.add "oauth_token", valid_591017
  var valid_591018 = query.getOrDefault("userIp")
  valid_591018 = validateParameter(valid_591018, JString, required = false,
                                 default = nil)
  if valid_591018 != nil:
    section.add "userIp", valid_591018
  var valid_591019 = query.getOrDefault("key")
  valid_591019 = validateParameter(valid_591019, JString, required = false,
                                 default = nil)
  if valid_591019 != nil:
    section.add "key", valid_591019
  var valid_591020 = query.getOrDefault("prettyPrint")
  valid_591020 = validateParameter(valid_591020, JBool, required = false,
                                 default = newJBool(true))
  if valid_591020 != nil:
    section.add "prettyPrint", valid_591020
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591022: Call_DfareportingFloodlightActivityGroupsPatch_591009;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity group. This method supports patch semantics.
  ## 
  let valid = call_591022.validator(path, query, header, formData, body)
  let scheme = call_591022.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591022.url(scheme.get, call_591022.host, call_591022.base,
                         call_591022.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591022, url, valid)

proc call*(call_591023: Call_DfareportingFloodlightActivityGroupsPatch_591009;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsPatch
  ## Updates an existing floodlight activity group. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Floodlight activity Group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591024 = newJObject()
  var query_591025 = newJObject()
  var body_591026 = newJObject()
  add(path_591024, "profileId", newJString(profileId))
  add(query_591025, "fields", newJString(fields))
  add(query_591025, "quotaUser", newJString(quotaUser))
  add(query_591025, "id", newJString(id))
  add(query_591025, "alt", newJString(alt))
  add(query_591025, "oauth_token", newJString(oauthToken))
  add(query_591025, "userIp", newJString(userIp))
  add(query_591025, "key", newJString(key))
  if body != nil:
    body_591026 = body
  add(query_591025, "prettyPrint", newJBool(prettyPrint))
  result = call_591023.call(path_591024, query_591025, nil, nil, body_591026)

var dfareportingFloodlightActivityGroupsPatch* = Call_DfareportingFloodlightActivityGroupsPatch_591009(
    name: "dfareportingFloodlightActivityGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsPatch_591010,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivityGroupsPatch_591011,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsGet_591027 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightActivityGroupsGet_591029(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsGet_591028(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one floodlight activity group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight activity Group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591030 = path.getOrDefault("profileId")
  valid_591030 = validateParameter(valid_591030, JString, required = true,
                                 default = nil)
  if valid_591030 != nil:
    section.add "profileId", valid_591030
  var valid_591031 = path.getOrDefault("id")
  valid_591031 = validateParameter(valid_591031, JString, required = true,
                                 default = nil)
  if valid_591031 != nil:
    section.add "id", valid_591031
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591032 = query.getOrDefault("fields")
  valid_591032 = validateParameter(valid_591032, JString, required = false,
                                 default = nil)
  if valid_591032 != nil:
    section.add "fields", valid_591032
  var valid_591033 = query.getOrDefault("quotaUser")
  valid_591033 = validateParameter(valid_591033, JString, required = false,
                                 default = nil)
  if valid_591033 != nil:
    section.add "quotaUser", valid_591033
  var valid_591034 = query.getOrDefault("alt")
  valid_591034 = validateParameter(valid_591034, JString, required = false,
                                 default = newJString("json"))
  if valid_591034 != nil:
    section.add "alt", valid_591034
  var valid_591035 = query.getOrDefault("oauth_token")
  valid_591035 = validateParameter(valid_591035, JString, required = false,
                                 default = nil)
  if valid_591035 != nil:
    section.add "oauth_token", valid_591035
  var valid_591036 = query.getOrDefault("userIp")
  valid_591036 = validateParameter(valid_591036, JString, required = false,
                                 default = nil)
  if valid_591036 != nil:
    section.add "userIp", valid_591036
  var valid_591037 = query.getOrDefault("key")
  valid_591037 = validateParameter(valid_591037, JString, required = false,
                                 default = nil)
  if valid_591037 != nil:
    section.add "key", valid_591037
  var valid_591038 = query.getOrDefault("prettyPrint")
  valid_591038 = validateParameter(valid_591038, JBool, required = false,
                                 default = newJBool(true))
  if valid_591038 != nil:
    section.add "prettyPrint", valid_591038
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591039: Call_DfareportingFloodlightActivityGroupsGet_591027;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one floodlight activity group by ID.
  ## 
  let valid = call_591039.validator(path, query, header, formData, body)
  let scheme = call_591039.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591039.url(scheme.get, call_591039.host, call_591039.base,
                         call_591039.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591039, url, valid)

proc call*(call_591040: Call_DfareportingFloodlightActivityGroupsGet_591027;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsGet
  ## Gets one floodlight activity group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Floodlight activity Group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591041 = newJObject()
  var query_591042 = newJObject()
  add(path_591041, "profileId", newJString(profileId))
  add(query_591042, "fields", newJString(fields))
  add(query_591042, "quotaUser", newJString(quotaUser))
  add(query_591042, "alt", newJString(alt))
  add(query_591042, "oauth_token", newJString(oauthToken))
  add(query_591042, "userIp", newJString(userIp))
  add(path_591041, "id", newJString(id))
  add(query_591042, "key", newJString(key))
  add(query_591042, "prettyPrint", newJBool(prettyPrint))
  result = call_591040.call(path_591041, query_591042, nil, nil, nil)

var dfareportingFloodlightActivityGroupsGet* = Call_DfareportingFloodlightActivityGroupsGet_591027(
    name: "dfareportingFloodlightActivityGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups/{id}",
    validator: validate_DfareportingFloodlightActivityGroupsGet_591028,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivityGroupsGet_591029,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsUpdate_591059 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightConfigurationsUpdate_591061(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsUpdate_591060(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591062 = path.getOrDefault("profileId")
  valid_591062 = validateParameter(valid_591062, JString, required = true,
                                 default = nil)
  if valid_591062 != nil:
    section.add "profileId", valid_591062
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591063 = query.getOrDefault("fields")
  valid_591063 = validateParameter(valid_591063, JString, required = false,
                                 default = nil)
  if valid_591063 != nil:
    section.add "fields", valid_591063
  var valid_591064 = query.getOrDefault("quotaUser")
  valid_591064 = validateParameter(valid_591064, JString, required = false,
                                 default = nil)
  if valid_591064 != nil:
    section.add "quotaUser", valid_591064
  var valid_591065 = query.getOrDefault("alt")
  valid_591065 = validateParameter(valid_591065, JString, required = false,
                                 default = newJString("json"))
  if valid_591065 != nil:
    section.add "alt", valid_591065
  var valid_591066 = query.getOrDefault("oauth_token")
  valid_591066 = validateParameter(valid_591066, JString, required = false,
                                 default = nil)
  if valid_591066 != nil:
    section.add "oauth_token", valid_591066
  var valid_591067 = query.getOrDefault("userIp")
  valid_591067 = validateParameter(valid_591067, JString, required = false,
                                 default = nil)
  if valid_591067 != nil:
    section.add "userIp", valid_591067
  var valid_591068 = query.getOrDefault("key")
  valid_591068 = validateParameter(valid_591068, JString, required = false,
                                 default = nil)
  if valid_591068 != nil:
    section.add "key", valid_591068
  var valid_591069 = query.getOrDefault("prettyPrint")
  valid_591069 = validateParameter(valid_591069, JBool, required = false,
                                 default = newJBool(true))
  if valid_591069 != nil:
    section.add "prettyPrint", valid_591069
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591071: Call_DfareportingFloodlightConfigurationsUpdate_591059;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight configuration.
  ## 
  let valid = call_591071.validator(path, query, header, formData, body)
  let scheme = call_591071.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591071.url(scheme.get, call_591071.host, call_591071.base,
                         call_591071.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591071, url, valid)

proc call*(call_591072: Call_DfareportingFloodlightConfigurationsUpdate_591059;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightConfigurationsUpdate
  ## Updates an existing floodlight configuration.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591073 = newJObject()
  var query_591074 = newJObject()
  var body_591075 = newJObject()
  add(path_591073, "profileId", newJString(profileId))
  add(query_591074, "fields", newJString(fields))
  add(query_591074, "quotaUser", newJString(quotaUser))
  add(query_591074, "alt", newJString(alt))
  add(query_591074, "oauth_token", newJString(oauthToken))
  add(query_591074, "userIp", newJString(userIp))
  add(query_591074, "key", newJString(key))
  if body != nil:
    body_591075 = body
  add(query_591074, "prettyPrint", newJBool(prettyPrint))
  result = call_591072.call(path_591073, query_591074, nil, nil, body_591075)

var dfareportingFloodlightConfigurationsUpdate* = Call_DfareportingFloodlightConfigurationsUpdate_591059(
    name: "dfareportingFloodlightConfigurationsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations",
    validator: validate_DfareportingFloodlightConfigurationsUpdate_591060,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightConfigurationsUpdate_591061,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsList_591043 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightConfigurationsList_591045(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsList_591044(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of floodlight configurations, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591046 = path.getOrDefault("profileId")
  valid_591046 = validateParameter(valid_591046, JString, required = true,
                                 default = nil)
  if valid_591046 != nil:
    section.add "profileId", valid_591046
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Set of IDs of floodlight configurations to retrieve. Required field; otherwise an empty list will be returned.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591047 = query.getOrDefault("fields")
  valid_591047 = validateParameter(valid_591047, JString, required = false,
                                 default = nil)
  if valid_591047 != nil:
    section.add "fields", valid_591047
  var valid_591048 = query.getOrDefault("quotaUser")
  valid_591048 = validateParameter(valid_591048, JString, required = false,
                                 default = nil)
  if valid_591048 != nil:
    section.add "quotaUser", valid_591048
  var valid_591049 = query.getOrDefault("alt")
  valid_591049 = validateParameter(valid_591049, JString, required = false,
                                 default = newJString("json"))
  if valid_591049 != nil:
    section.add "alt", valid_591049
  var valid_591050 = query.getOrDefault("oauth_token")
  valid_591050 = validateParameter(valid_591050, JString, required = false,
                                 default = nil)
  if valid_591050 != nil:
    section.add "oauth_token", valid_591050
  var valid_591051 = query.getOrDefault("userIp")
  valid_591051 = validateParameter(valid_591051, JString, required = false,
                                 default = nil)
  if valid_591051 != nil:
    section.add "userIp", valid_591051
  var valid_591052 = query.getOrDefault("ids")
  valid_591052 = validateParameter(valid_591052, JArray, required = false,
                                 default = nil)
  if valid_591052 != nil:
    section.add "ids", valid_591052
  var valid_591053 = query.getOrDefault("key")
  valid_591053 = validateParameter(valid_591053, JString, required = false,
                                 default = nil)
  if valid_591053 != nil:
    section.add "key", valid_591053
  var valid_591054 = query.getOrDefault("prettyPrint")
  valid_591054 = validateParameter(valid_591054, JBool, required = false,
                                 default = newJBool(true))
  if valid_591054 != nil:
    section.add "prettyPrint", valid_591054
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591055: Call_DfareportingFloodlightConfigurationsList_591043;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of floodlight configurations, possibly filtered.
  ## 
  let valid = call_591055.validator(path, query, header, formData, body)
  let scheme = call_591055.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591055.url(scheme.get, call_591055.host, call_591055.base,
                         call_591055.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591055, url, valid)

proc call*(call_591056: Call_DfareportingFloodlightConfigurationsList_591043;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          ids: JsonNode = nil; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightConfigurationsList
  ## Retrieves a list of floodlight configurations, possibly filtered.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Set of IDs of floodlight configurations to retrieve. Required field; otherwise an empty list will be returned.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591057 = newJObject()
  var query_591058 = newJObject()
  add(path_591057, "profileId", newJString(profileId))
  add(query_591058, "fields", newJString(fields))
  add(query_591058, "quotaUser", newJString(quotaUser))
  add(query_591058, "alt", newJString(alt))
  add(query_591058, "oauth_token", newJString(oauthToken))
  add(query_591058, "userIp", newJString(userIp))
  if ids != nil:
    query_591058.add "ids", ids
  add(query_591058, "key", newJString(key))
  add(query_591058, "prettyPrint", newJBool(prettyPrint))
  result = call_591056.call(path_591057, query_591058, nil, nil, nil)

var dfareportingFloodlightConfigurationsList* = Call_DfareportingFloodlightConfigurationsList_591043(
    name: "dfareportingFloodlightConfigurationsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations",
    validator: validate_DfareportingFloodlightConfigurationsList_591044,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightConfigurationsList_591045,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsPatch_591076 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightConfigurationsPatch_591078(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsPatch_591077(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight configuration. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591079 = path.getOrDefault("profileId")
  valid_591079 = validateParameter(valid_591079, JString, required = true,
                                 default = nil)
  if valid_591079 != nil:
    section.add "profileId", valid_591079
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Floodlight configuration ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591080 = query.getOrDefault("fields")
  valid_591080 = validateParameter(valid_591080, JString, required = false,
                                 default = nil)
  if valid_591080 != nil:
    section.add "fields", valid_591080
  var valid_591081 = query.getOrDefault("quotaUser")
  valid_591081 = validateParameter(valid_591081, JString, required = false,
                                 default = nil)
  if valid_591081 != nil:
    section.add "quotaUser", valid_591081
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_591082 = query.getOrDefault("id")
  valid_591082 = validateParameter(valid_591082, JString, required = true,
                                 default = nil)
  if valid_591082 != nil:
    section.add "id", valid_591082
  var valid_591083 = query.getOrDefault("alt")
  valid_591083 = validateParameter(valid_591083, JString, required = false,
                                 default = newJString("json"))
  if valid_591083 != nil:
    section.add "alt", valid_591083
  var valid_591084 = query.getOrDefault("oauth_token")
  valid_591084 = validateParameter(valid_591084, JString, required = false,
                                 default = nil)
  if valid_591084 != nil:
    section.add "oauth_token", valid_591084
  var valid_591085 = query.getOrDefault("userIp")
  valid_591085 = validateParameter(valid_591085, JString, required = false,
                                 default = nil)
  if valid_591085 != nil:
    section.add "userIp", valid_591085
  var valid_591086 = query.getOrDefault("key")
  valid_591086 = validateParameter(valid_591086, JString, required = false,
                                 default = nil)
  if valid_591086 != nil:
    section.add "key", valid_591086
  var valid_591087 = query.getOrDefault("prettyPrint")
  valid_591087 = validateParameter(valid_591087, JBool, required = false,
                                 default = newJBool(true))
  if valid_591087 != nil:
    section.add "prettyPrint", valid_591087
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591089: Call_DfareportingFloodlightConfigurationsPatch_591076;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight configuration. This method supports patch semantics.
  ## 
  let valid = call_591089.validator(path, query, header, formData, body)
  let scheme = call_591089.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591089.url(scheme.get, call_591089.host, call_591089.base,
                         call_591089.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591089, url, valid)

proc call*(call_591090: Call_DfareportingFloodlightConfigurationsPatch_591076;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightConfigurationsPatch
  ## Updates an existing floodlight configuration. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Floodlight configuration ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591091 = newJObject()
  var query_591092 = newJObject()
  var body_591093 = newJObject()
  add(path_591091, "profileId", newJString(profileId))
  add(query_591092, "fields", newJString(fields))
  add(query_591092, "quotaUser", newJString(quotaUser))
  add(query_591092, "id", newJString(id))
  add(query_591092, "alt", newJString(alt))
  add(query_591092, "oauth_token", newJString(oauthToken))
  add(query_591092, "userIp", newJString(userIp))
  add(query_591092, "key", newJString(key))
  if body != nil:
    body_591093 = body
  add(query_591092, "prettyPrint", newJBool(prettyPrint))
  result = call_591090.call(path_591091, query_591092, nil, nil, body_591093)

var dfareportingFloodlightConfigurationsPatch* = Call_DfareportingFloodlightConfigurationsPatch_591076(
    name: "dfareportingFloodlightConfigurationsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations",
    validator: validate_DfareportingFloodlightConfigurationsPatch_591077,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightConfigurationsPatch_591078,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsGet_591094 = ref object of OpenApiRestCall_588466
proc url_DfareportingFloodlightConfigurationsGet_591096(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsGet_591095(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one floodlight configuration by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight configuration ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591097 = path.getOrDefault("profileId")
  valid_591097 = validateParameter(valid_591097, JString, required = true,
                                 default = nil)
  if valid_591097 != nil:
    section.add "profileId", valid_591097
  var valid_591098 = path.getOrDefault("id")
  valid_591098 = validateParameter(valid_591098, JString, required = true,
                                 default = nil)
  if valid_591098 != nil:
    section.add "id", valid_591098
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591099 = query.getOrDefault("fields")
  valid_591099 = validateParameter(valid_591099, JString, required = false,
                                 default = nil)
  if valid_591099 != nil:
    section.add "fields", valid_591099
  var valid_591100 = query.getOrDefault("quotaUser")
  valid_591100 = validateParameter(valid_591100, JString, required = false,
                                 default = nil)
  if valid_591100 != nil:
    section.add "quotaUser", valid_591100
  var valid_591101 = query.getOrDefault("alt")
  valid_591101 = validateParameter(valid_591101, JString, required = false,
                                 default = newJString("json"))
  if valid_591101 != nil:
    section.add "alt", valid_591101
  var valid_591102 = query.getOrDefault("oauth_token")
  valid_591102 = validateParameter(valid_591102, JString, required = false,
                                 default = nil)
  if valid_591102 != nil:
    section.add "oauth_token", valid_591102
  var valid_591103 = query.getOrDefault("userIp")
  valid_591103 = validateParameter(valid_591103, JString, required = false,
                                 default = nil)
  if valid_591103 != nil:
    section.add "userIp", valid_591103
  var valid_591104 = query.getOrDefault("key")
  valid_591104 = validateParameter(valid_591104, JString, required = false,
                                 default = nil)
  if valid_591104 != nil:
    section.add "key", valid_591104
  var valid_591105 = query.getOrDefault("prettyPrint")
  valid_591105 = validateParameter(valid_591105, JBool, required = false,
                                 default = newJBool(true))
  if valid_591105 != nil:
    section.add "prettyPrint", valid_591105
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591106: Call_DfareportingFloodlightConfigurationsGet_591094;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one floodlight configuration by ID.
  ## 
  let valid = call_591106.validator(path, query, header, formData, body)
  let scheme = call_591106.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591106.url(scheme.get, call_591106.host, call_591106.base,
                         call_591106.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591106, url, valid)

proc call*(call_591107: Call_DfareportingFloodlightConfigurationsGet_591094;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightConfigurationsGet
  ## Gets one floodlight configuration by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Floodlight configuration ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591108 = newJObject()
  var query_591109 = newJObject()
  add(path_591108, "profileId", newJString(profileId))
  add(query_591109, "fields", newJString(fields))
  add(query_591109, "quotaUser", newJString(quotaUser))
  add(query_591109, "alt", newJString(alt))
  add(query_591109, "oauth_token", newJString(oauthToken))
  add(query_591109, "userIp", newJString(userIp))
  add(path_591108, "id", newJString(id))
  add(query_591109, "key", newJString(key))
  add(query_591109, "prettyPrint", newJBool(prettyPrint))
  result = call_591107.call(path_591108, query_591109, nil, nil, nil)

var dfareportingFloodlightConfigurationsGet* = Call_DfareportingFloodlightConfigurationsGet_591094(
    name: "dfareportingFloodlightConfigurationsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations/{id}",
    validator: validate_DfareportingFloodlightConfigurationsGet_591095,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightConfigurationsGet_591096,
    schemes: {Scheme.Https})
type
  Call_DfareportingLanguagesList_591110 = ref object of OpenApiRestCall_588466
proc url_DfareportingLanguagesList_591112(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/languages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLanguagesList_591111(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of languages.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591113 = path.getOrDefault("profileId")
  valid_591113 = validateParameter(valid_591113, JString, required = true,
                                 default = nil)
  if valid_591113 != nil:
    section.add "profileId", valid_591113
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591114 = query.getOrDefault("fields")
  valid_591114 = validateParameter(valid_591114, JString, required = false,
                                 default = nil)
  if valid_591114 != nil:
    section.add "fields", valid_591114
  var valid_591115 = query.getOrDefault("quotaUser")
  valid_591115 = validateParameter(valid_591115, JString, required = false,
                                 default = nil)
  if valid_591115 != nil:
    section.add "quotaUser", valid_591115
  var valid_591116 = query.getOrDefault("alt")
  valid_591116 = validateParameter(valid_591116, JString, required = false,
                                 default = newJString("json"))
  if valid_591116 != nil:
    section.add "alt", valid_591116
  var valid_591117 = query.getOrDefault("oauth_token")
  valid_591117 = validateParameter(valid_591117, JString, required = false,
                                 default = nil)
  if valid_591117 != nil:
    section.add "oauth_token", valid_591117
  var valid_591118 = query.getOrDefault("userIp")
  valid_591118 = validateParameter(valid_591118, JString, required = false,
                                 default = nil)
  if valid_591118 != nil:
    section.add "userIp", valid_591118
  var valid_591119 = query.getOrDefault("key")
  valid_591119 = validateParameter(valid_591119, JString, required = false,
                                 default = nil)
  if valid_591119 != nil:
    section.add "key", valid_591119
  var valid_591120 = query.getOrDefault("prettyPrint")
  valid_591120 = validateParameter(valid_591120, JBool, required = false,
                                 default = newJBool(true))
  if valid_591120 != nil:
    section.add "prettyPrint", valid_591120
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591121: Call_DfareportingLanguagesList_591110; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of languages.
  ## 
  let valid = call_591121.validator(path, query, header, formData, body)
  let scheme = call_591121.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591121.url(scheme.get, call_591121.host, call_591121.base,
                         call_591121.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591121, url, valid)

proc call*(call_591122: Call_DfareportingLanguagesList_591110; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingLanguagesList
  ## Retrieves a list of languages.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591123 = newJObject()
  var query_591124 = newJObject()
  add(path_591123, "profileId", newJString(profileId))
  add(query_591124, "fields", newJString(fields))
  add(query_591124, "quotaUser", newJString(quotaUser))
  add(query_591124, "alt", newJString(alt))
  add(query_591124, "oauth_token", newJString(oauthToken))
  add(query_591124, "userIp", newJString(userIp))
  add(query_591124, "key", newJString(key))
  add(query_591124, "prettyPrint", newJBool(prettyPrint))
  result = call_591122.call(path_591123, query_591124, nil, nil, nil)

var dfareportingLanguagesList* = Call_DfareportingLanguagesList_591110(
    name: "dfareportingLanguagesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/languages",
    validator: validate_DfareportingLanguagesList_591111,
    base: "/dfareporting/v2.7", url: url_DfareportingLanguagesList_591112,
    schemes: {Scheme.Https})
type
  Call_DfareportingMetrosList_591125 = ref object of OpenApiRestCall_588466
proc url_DfareportingMetrosList_591127(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/metros")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingMetrosList_591126(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of metros.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591128 = path.getOrDefault("profileId")
  valid_591128 = validateParameter(valid_591128, JString, required = true,
                                 default = nil)
  if valid_591128 != nil:
    section.add "profileId", valid_591128
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591129 = query.getOrDefault("fields")
  valid_591129 = validateParameter(valid_591129, JString, required = false,
                                 default = nil)
  if valid_591129 != nil:
    section.add "fields", valid_591129
  var valid_591130 = query.getOrDefault("quotaUser")
  valid_591130 = validateParameter(valid_591130, JString, required = false,
                                 default = nil)
  if valid_591130 != nil:
    section.add "quotaUser", valid_591130
  var valid_591131 = query.getOrDefault("alt")
  valid_591131 = validateParameter(valid_591131, JString, required = false,
                                 default = newJString("json"))
  if valid_591131 != nil:
    section.add "alt", valid_591131
  var valid_591132 = query.getOrDefault("oauth_token")
  valid_591132 = validateParameter(valid_591132, JString, required = false,
                                 default = nil)
  if valid_591132 != nil:
    section.add "oauth_token", valid_591132
  var valid_591133 = query.getOrDefault("userIp")
  valid_591133 = validateParameter(valid_591133, JString, required = false,
                                 default = nil)
  if valid_591133 != nil:
    section.add "userIp", valid_591133
  var valid_591134 = query.getOrDefault("key")
  valid_591134 = validateParameter(valid_591134, JString, required = false,
                                 default = nil)
  if valid_591134 != nil:
    section.add "key", valid_591134
  var valid_591135 = query.getOrDefault("prettyPrint")
  valid_591135 = validateParameter(valid_591135, JBool, required = false,
                                 default = newJBool(true))
  if valid_591135 != nil:
    section.add "prettyPrint", valid_591135
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591136: Call_DfareportingMetrosList_591125; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of metros.
  ## 
  let valid = call_591136.validator(path, query, header, formData, body)
  let scheme = call_591136.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591136.url(scheme.get, call_591136.host, call_591136.base,
                         call_591136.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591136, url, valid)

proc call*(call_591137: Call_DfareportingMetrosList_591125; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingMetrosList
  ## Retrieves a list of metros.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591138 = newJObject()
  var query_591139 = newJObject()
  add(path_591138, "profileId", newJString(profileId))
  add(query_591139, "fields", newJString(fields))
  add(query_591139, "quotaUser", newJString(quotaUser))
  add(query_591139, "alt", newJString(alt))
  add(query_591139, "oauth_token", newJString(oauthToken))
  add(query_591139, "userIp", newJString(userIp))
  add(query_591139, "key", newJString(key))
  add(query_591139, "prettyPrint", newJBool(prettyPrint))
  result = call_591137.call(path_591138, query_591139, nil, nil, nil)

var dfareportingMetrosList* = Call_DfareportingMetrosList_591125(
    name: "dfareportingMetrosList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/metros",
    validator: validate_DfareportingMetrosList_591126, base: "/dfareporting/v2.7",
    url: url_DfareportingMetrosList_591127, schemes: {Scheme.Https})
type
  Call_DfareportingMobileCarriersList_591140 = ref object of OpenApiRestCall_588466
proc url_DfareportingMobileCarriersList_591142(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/mobileCarriers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingMobileCarriersList_591141(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of mobile carriers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591143 = path.getOrDefault("profileId")
  valid_591143 = validateParameter(valid_591143, JString, required = true,
                                 default = nil)
  if valid_591143 != nil:
    section.add "profileId", valid_591143
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591144 = query.getOrDefault("fields")
  valid_591144 = validateParameter(valid_591144, JString, required = false,
                                 default = nil)
  if valid_591144 != nil:
    section.add "fields", valid_591144
  var valid_591145 = query.getOrDefault("quotaUser")
  valid_591145 = validateParameter(valid_591145, JString, required = false,
                                 default = nil)
  if valid_591145 != nil:
    section.add "quotaUser", valid_591145
  var valid_591146 = query.getOrDefault("alt")
  valid_591146 = validateParameter(valid_591146, JString, required = false,
                                 default = newJString("json"))
  if valid_591146 != nil:
    section.add "alt", valid_591146
  var valid_591147 = query.getOrDefault("oauth_token")
  valid_591147 = validateParameter(valid_591147, JString, required = false,
                                 default = nil)
  if valid_591147 != nil:
    section.add "oauth_token", valid_591147
  var valid_591148 = query.getOrDefault("userIp")
  valid_591148 = validateParameter(valid_591148, JString, required = false,
                                 default = nil)
  if valid_591148 != nil:
    section.add "userIp", valid_591148
  var valid_591149 = query.getOrDefault("key")
  valid_591149 = validateParameter(valid_591149, JString, required = false,
                                 default = nil)
  if valid_591149 != nil:
    section.add "key", valid_591149
  var valid_591150 = query.getOrDefault("prettyPrint")
  valid_591150 = validateParameter(valid_591150, JBool, required = false,
                                 default = newJBool(true))
  if valid_591150 != nil:
    section.add "prettyPrint", valid_591150
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591151: Call_DfareportingMobileCarriersList_591140; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of mobile carriers.
  ## 
  let valid = call_591151.validator(path, query, header, formData, body)
  let scheme = call_591151.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591151.url(scheme.get, call_591151.host, call_591151.base,
                         call_591151.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591151, url, valid)

proc call*(call_591152: Call_DfareportingMobileCarriersList_591140;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingMobileCarriersList
  ## Retrieves a list of mobile carriers.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591153 = newJObject()
  var query_591154 = newJObject()
  add(path_591153, "profileId", newJString(profileId))
  add(query_591154, "fields", newJString(fields))
  add(query_591154, "quotaUser", newJString(quotaUser))
  add(query_591154, "alt", newJString(alt))
  add(query_591154, "oauth_token", newJString(oauthToken))
  add(query_591154, "userIp", newJString(userIp))
  add(query_591154, "key", newJString(key))
  add(query_591154, "prettyPrint", newJBool(prettyPrint))
  result = call_591152.call(path_591153, query_591154, nil, nil, nil)

var dfareportingMobileCarriersList* = Call_DfareportingMobileCarriersList_591140(
    name: "dfareportingMobileCarriersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/mobileCarriers",
    validator: validate_DfareportingMobileCarriersList_591141,
    base: "/dfareporting/v2.7", url: url_DfareportingMobileCarriersList_591142,
    schemes: {Scheme.Https})
type
  Call_DfareportingMobileCarriersGet_591155 = ref object of OpenApiRestCall_588466
proc url_DfareportingMobileCarriersGet_591157(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/mobileCarriers/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingMobileCarriersGet_591156(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one mobile carrier by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Mobile carrier ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591158 = path.getOrDefault("profileId")
  valid_591158 = validateParameter(valid_591158, JString, required = true,
                                 default = nil)
  if valid_591158 != nil:
    section.add "profileId", valid_591158
  var valid_591159 = path.getOrDefault("id")
  valid_591159 = validateParameter(valid_591159, JString, required = true,
                                 default = nil)
  if valid_591159 != nil:
    section.add "id", valid_591159
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591160 = query.getOrDefault("fields")
  valid_591160 = validateParameter(valid_591160, JString, required = false,
                                 default = nil)
  if valid_591160 != nil:
    section.add "fields", valid_591160
  var valid_591161 = query.getOrDefault("quotaUser")
  valid_591161 = validateParameter(valid_591161, JString, required = false,
                                 default = nil)
  if valid_591161 != nil:
    section.add "quotaUser", valid_591161
  var valid_591162 = query.getOrDefault("alt")
  valid_591162 = validateParameter(valid_591162, JString, required = false,
                                 default = newJString("json"))
  if valid_591162 != nil:
    section.add "alt", valid_591162
  var valid_591163 = query.getOrDefault("oauth_token")
  valid_591163 = validateParameter(valid_591163, JString, required = false,
                                 default = nil)
  if valid_591163 != nil:
    section.add "oauth_token", valid_591163
  var valid_591164 = query.getOrDefault("userIp")
  valid_591164 = validateParameter(valid_591164, JString, required = false,
                                 default = nil)
  if valid_591164 != nil:
    section.add "userIp", valid_591164
  var valid_591165 = query.getOrDefault("key")
  valid_591165 = validateParameter(valid_591165, JString, required = false,
                                 default = nil)
  if valid_591165 != nil:
    section.add "key", valid_591165
  var valid_591166 = query.getOrDefault("prettyPrint")
  valid_591166 = validateParameter(valid_591166, JBool, required = false,
                                 default = newJBool(true))
  if valid_591166 != nil:
    section.add "prettyPrint", valid_591166
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591167: Call_DfareportingMobileCarriersGet_591155; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one mobile carrier by ID.
  ## 
  let valid = call_591167.validator(path, query, header, formData, body)
  let scheme = call_591167.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591167.url(scheme.get, call_591167.host, call_591167.base,
                         call_591167.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591167, url, valid)

proc call*(call_591168: Call_DfareportingMobileCarriersGet_591155;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingMobileCarriersGet
  ## Gets one mobile carrier by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Mobile carrier ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591169 = newJObject()
  var query_591170 = newJObject()
  add(path_591169, "profileId", newJString(profileId))
  add(query_591170, "fields", newJString(fields))
  add(query_591170, "quotaUser", newJString(quotaUser))
  add(query_591170, "alt", newJString(alt))
  add(query_591170, "oauth_token", newJString(oauthToken))
  add(query_591170, "userIp", newJString(userIp))
  add(path_591169, "id", newJString(id))
  add(query_591170, "key", newJString(key))
  add(query_591170, "prettyPrint", newJBool(prettyPrint))
  result = call_591168.call(path_591169, query_591170, nil, nil, nil)

var dfareportingMobileCarriersGet* = Call_DfareportingMobileCarriersGet_591155(
    name: "dfareportingMobileCarriersGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/mobileCarriers/{id}",
    validator: validate_DfareportingMobileCarriersGet_591156,
    base: "/dfareporting/v2.7", url: url_DfareportingMobileCarriersGet_591157,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemVersionsList_591171 = ref object of OpenApiRestCall_588466
proc url_DfareportingOperatingSystemVersionsList_591173(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystemVersions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemVersionsList_591172(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of operating system versions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591174 = path.getOrDefault("profileId")
  valid_591174 = validateParameter(valid_591174, JString, required = true,
                                 default = nil)
  if valid_591174 != nil:
    section.add "profileId", valid_591174
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591175 = query.getOrDefault("fields")
  valid_591175 = validateParameter(valid_591175, JString, required = false,
                                 default = nil)
  if valid_591175 != nil:
    section.add "fields", valid_591175
  var valid_591176 = query.getOrDefault("quotaUser")
  valid_591176 = validateParameter(valid_591176, JString, required = false,
                                 default = nil)
  if valid_591176 != nil:
    section.add "quotaUser", valid_591176
  var valid_591177 = query.getOrDefault("alt")
  valid_591177 = validateParameter(valid_591177, JString, required = false,
                                 default = newJString("json"))
  if valid_591177 != nil:
    section.add "alt", valid_591177
  var valid_591178 = query.getOrDefault("oauth_token")
  valid_591178 = validateParameter(valid_591178, JString, required = false,
                                 default = nil)
  if valid_591178 != nil:
    section.add "oauth_token", valid_591178
  var valid_591179 = query.getOrDefault("userIp")
  valid_591179 = validateParameter(valid_591179, JString, required = false,
                                 default = nil)
  if valid_591179 != nil:
    section.add "userIp", valid_591179
  var valid_591180 = query.getOrDefault("key")
  valid_591180 = validateParameter(valid_591180, JString, required = false,
                                 default = nil)
  if valid_591180 != nil:
    section.add "key", valid_591180
  var valid_591181 = query.getOrDefault("prettyPrint")
  valid_591181 = validateParameter(valid_591181, JBool, required = false,
                                 default = newJBool(true))
  if valid_591181 != nil:
    section.add "prettyPrint", valid_591181
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591182: Call_DfareportingOperatingSystemVersionsList_591171;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of operating system versions.
  ## 
  let valid = call_591182.validator(path, query, header, formData, body)
  let scheme = call_591182.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591182.url(scheme.get, call_591182.host, call_591182.base,
                         call_591182.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591182, url, valid)

proc call*(call_591183: Call_DfareportingOperatingSystemVersionsList_591171;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOperatingSystemVersionsList
  ## Retrieves a list of operating system versions.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591184 = newJObject()
  var query_591185 = newJObject()
  add(path_591184, "profileId", newJString(profileId))
  add(query_591185, "fields", newJString(fields))
  add(query_591185, "quotaUser", newJString(quotaUser))
  add(query_591185, "alt", newJString(alt))
  add(query_591185, "oauth_token", newJString(oauthToken))
  add(query_591185, "userIp", newJString(userIp))
  add(query_591185, "key", newJString(key))
  add(query_591185, "prettyPrint", newJBool(prettyPrint))
  result = call_591183.call(path_591184, query_591185, nil, nil, nil)

var dfareportingOperatingSystemVersionsList* = Call_DfareportingOperatingSystemVersionsList_591171(
    name: "dfareportingOperatingSystemVersionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystemVersions",
    validator: validate_DfareportingOperatingSystemVersionsList_591172,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemVersionsList_591173,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemVersionsGet_591186 = ref object of OpenApiRestCall_588466
proc url_DfareportingOperatingSystemVersionsGet_591188(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystemVersions/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemVersionsGet_591187(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one operating system version by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Operating system version ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591189 = path.getOrDefault("profileId")
  valid_591189 = validateParameter(valid_591189, JString, required = true,
                                 default = nil)
  if valid_591189 != nil:
    section.add "profileId", valid_591189
  var valid_591190 = path.getOrDefault("id")
  valid_591190 = validateParameter(valid_591190, JString, required = true,
                                 default = nil)
  if valid_591190 != nil:
    section.add "id", valid_591190
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591191 = query.getOrDefault("fields")
  valid_591191 = validateParameter(valid_591191, JString, required = false,
                                 default = nil)
  if valid_591191 != nil:
    section.add "fields", valid_591191
  var valid_591192 = query.getOrDefault("quotaUser")
  valid_591192 = validateParameter(valid_591192, JString, required = false,
                                 default = nil)
  if valid_591192 != nil:
    section.add "quotaUser", valid_591192
  var valid_591193 = query.getOrDefault("alt")
  valid_591193 = validateParameter(valid_591193, JString, required = false,
                                 default = newJString("json"))
  if valid_591193 != nil:
    section.add "alt", valid_591193
  var valid_591194 = query.getOrDefault("oauth_token")
  valid_591194 = validateParameter(valid_591194, JString, required = false,
                                 default = nil)
  if valid_591194 != nil:
    section.add "oauth_token", valid_591194
  var valid_591195 = query.getOrDefault("userIp")
  valid_591195 = validateParameter(valid_591195, JString, required = false,
                                 default = nil)
  if valid_591195 != nil:
    section.add "userIp", valid_591195
  var valid_591196 = query.getOrDefault("key")
  valid_591196 = validateParameter(valid_591196, JString, required = false,
                                 default = nil)
  if valid_591196 != nil:
    section.add "key", valid_591196
  var valid_591197 = query.getOrDefault("prettyPrint")
  valid_591197 = validateParameter(valid_591197, JBool, required = false,
                                 default = newJBool(true))
  if valid_591197 != nil:
    section.add "prettyPrint", valid_591197
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591198: Call_DfareportingOperatingSystemVersionsGet_591186;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one operating system version by ID.
  ## 
  let valid = call_591198.validator(path, query, header, formData, body)
  let scheme = call_591198.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591198.url(scheme.get, call_591198.host, call_591198.base,
                         call_591198.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591198, url, valid)

proc call*(call_591199: Call_DfareportingOperatingSystemVersionsGet_591186;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOperatingSystemVersionsGet
  ## Gets one operating system version by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Operating system version ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591200 = newJObject()
  var query_591201 = newJObject()
  add(path_591200, "profileId", newJString(profileId))
  add(query_591201, "fields", newJString(fields))
  add(query_591201, "quotaUser", newJString(quotaUser))
  add(query_591201, "alt", newJString(alt))
  add(query_591201, "oauth_token", newJString(oauthToken))
  add(query_591201, "userIp", newJString(userIp))
  add(path_591200, "id", newJString(id))
  add(query_591201, "key", newJString(key))
  add(query_591201, "prettyPrint", newJBool(prettyPrint))
  result = call_591199.call(path_591200, query_591201, nil, nil, nil)

var dfareportingOperatingSystemVersionsGet* = Call_DfareportingOperatingSystemVersionsGet_591186(
    name: "dfareportingOperatingSystemVersionsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystemVersions/{id}",
    validator: validate_DfareportingOperatingSystemVersionsGet_591187,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemVersionsGet_591188,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemsList_591202 = ref object of OpenApiRestCall_588466
proc url_DfareportingOperatingSystemsList_591204(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystems")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemsList_591203(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of operating systems.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591205 = path.getOrDefault("profileId")
  valid_591205 = validateParameter(valid_591205, JString, required = true,
                                 default = nil)
  if valid_591205 != nil:
    section.add "profileId", valid_591205
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591206 = query.getOrDefault("fields")
  valid_591206 = validateParameter(valid_591206, JString, required = false,
                                 default = nil)
  if valid_591206 != nil:
    section.add "fields", valid_591206
  var valid_591207 = query.getOrDefault("quotaUser")
  valid_591207 = validateParameter(valid_591207, JString, required = false,
                                 default = nil)
  if valid_591207 != nil:
    section.add "quotaUser", valid_591207
  var valid_591208 = query.getOrDefault("alt")
  valid_591208 = validateParameter(valid_591208, JString, required = false,
                                 default = newJString("json"))
  if valid_591208 != nil:
    section.add "alt", valid_591208
  var valid_591209 = query.getOrDefault("oauth_token")
  valid_591209 = validateParameter(valid_591209, JString, required = false,
                                 default = nil)
  if valid_591209 != nil:
    section.add "oauth_token", valid_591209
  var valid_591210 = query.getOrDefault("userIp")
  valid_591210 = validateParameter(valid_591210, JString, required = false,
                                 default = nil)
  if valid_591210 != nil:
    section.add "userIp", valid_591210
  var valid_591211 = query.getOrDefault("key")
  valid_591211 = validateParameter(valid_591211, JString, required = false,
                                 default = nil)
  if valid_591211 != nil:
    section.add "key", valid_591211
  var valid_591212 = query.getOrDefault("prettyPrint")
  valid_591212 = validateParameter(valid_591212, JBool, required = false,
                                 default = newJBool(true))
  if valid_591212 != nil:
    section.add "prettyPrint", valid_591212
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591213: Call_DfareportingOperatingSystemsList_591202;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of operating systems.
  ## 
  let valid = call_591213.validator(path, query, header, formData, body)
  let scheme = call_591213.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591213.url(scheme.get, call_591213.host, call_591213.base,
                         call_591213.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591213, url, valid)

proc call*(call_591214: Call_DfareportingOperatingSystemsList_591202;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOperatingSystemsList
  ## Retrieves a list of operating systems.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591215 = newJObject()
  var query_591216 = newJObject()
  add(path_591215, "profileId", newJString(profileId))
  add(query_591216, "fields", newJString(fields))
  add(query_591216, "quotaUser", newJString(quotaUser))
  add(query_591216, "alt", newJString(alt))
  add(query_591216, "oauth_token", newJString(oauthToken))
  add(query_591216, "userIp", newJString(userIp))
  add(query_591216, "key", newJString(key))
  add(query_591216, "prettyPrint", newJBool(prettyPrint))
  result = call_591214.call(path_591215, query_591216, nil, nil, nil)

var dfareportingOperatingSystemsList* = Call_DfareportingOperatingSystemsList_591202(
    name: "dfareportingOperatingSystemsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystems",
    validator: validate_DfareportingOperatingSystemsList_591203,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemsList_591204,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemsGet_591217 = ref object of OpenApiRestCall_588466
proc url_DfareportingOperatingSystemsGet_591219(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "dartId" in path, "`dartId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystems/"),
               (kind: VariableSegment, value: "dartId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemsGet_591218(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one operating system by DART ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   dartId: JString (required)
  ##         : Operating system DART ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591220 = path.getOrDefault("profileId")
  valid_591220 = validateParameter(valid_591220, JString, required = true,
                                 default = nil)
  if valid_591220 != nil:
    section.add "profileId", valid_591220
  var valid_591221 = path.getOrDefault("dartId")
  valid_591221 = validateParameter(valid_591221, JString, required = true,
                                 default = nil)
  if valid_591221 != nil:
    section.add "dartId", valid_591221
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591222 = query.getOrDefault("fields")
  valid_591222 = validateParameter(valid_591222, JString, required = false,
                                 default = nil)
  if valid_591222 != nil:
    section.add "fields", valid_591222
  var valid_591223 = query.getOrDefault("quotaUser")
  valid_591223 = validateParameter(valid_591223, JString, required = false,
                                 default = nil)
  if valid_591223 != nil:
    section.add "quotaUser", valid_591223
  var valid_591224 = query.getOrDefault("alt")
  valid_591224 = validateParameter(valid_591224, JString, required = false,
                                 default = newJString("json"))
  if valid_591224 != nil:
    section.add "alt", valid_591224
  var valid_591225 = query.getOrDefault("oauth_token")
  valid_591225 = validateParameter(valid_591225, JString, required = false,
                                 default = nil)
  if valid_591225 != nil:
    section.add "oauth_token", valid_591225
  var valid_591226 = query.getOrDefault("userIp")
  valid_591226 = validateParameter(valid_591226, JString, required = false,
                                 default = nil)
  if valid_591226 != nil:
    section.add "userIp", valid_591226
  var valid_591227 = query.getOrDefault("key")
  valid_591227 = validateParameter(valid_591227, JString, required = false,
                                 default = nil)
  if valid_591227 != nil:
    section.add "key", valid_591227
  var valid_591228 = query.getOrDefault("prettyPrint")
  valid_591228 = validateParameter(valid_591228, JBool, required = false,
                                 default = newJBool(true))
  if valid_591228 != nil:
    section.add "prettyPrint", valid_591228
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591229: Call_DfareportingOperatingSystemsGet_591217;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one operating system by DART ID.
  ## 
  let valid = call_591229.validator(path, query, header, formData, body)
  let scheme = call_591229.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591229.url(scheme.get, call_591229.host, call_591229.base,
                         call_591229.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591229, url, valid)

proc call*(call_591230: Call_DfareportingOperatingSystemsGet_591217;
          profileId: string; dartId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOperatingSystemsGet
  ## Gets one operating system by DART ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   dartId: string (required)
  ##         : Operating system DART ID.
  var path_591231 = newJObject()
  var query_591232 = newJObject()
  add(path_591231, "profileId", newJString(profileId))
  add(query_591232, "fields", newJString(fields))
  add(query_591232, "quotaUser", newJString(quotaUser))
  add(query_591232, "alt", newJString(alt))
  add(query_591232, "oauth_token", newJString(oauthToken))
  add(query_591232, "userIp", newJString(userIp))
  add(query_591232, "key", newJString(key))
  add(query_591232, "prettyPrint", newJBool(prettyPrint))
  add(path_591231, "dartId", newJString(dartId))
  result = call_591230.call(path_591231, query_591232, nil, nil, nil)

var dfareportingOperatingSystemsGet* = Call_DfareportingOperatingSystemsGet_591217(
    name: "dfareportingOperatingSystemsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystems/{dartId}",
    validator: validate_DfareportingOperatingSystemsGet_591218,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemsGet_591219,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsUpdate_591267 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementGroupsUpdate_591269(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsUpdate_591268(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591270 = path.getOrDefault("profileId")
  valid_591270 = validateParameter(valid_591270, JString, required = true,
                                 default = nil)
  if valid_591270 != nil:
    section.add "profileId", valid_591270
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591271 = query.getOrDefault("fields")
  valid_591271 = validateParameter(valid_591271, JString, required = false,
                                 default = nil)
  if valid_591271 != nil:
    section.add "fields", valid_591271
  var valid_591272 = query.getOrDefault("quotaUser")
  valid_591272 = validateParameter(valid_591272, JString, required = false,
                                 default = nil)
  if valid_591272 != nil:
    section.add "quotaUser", valid_591272
  var valid_591273 = query.getOrDefault("alt")
  valid_591273 = validateParameter(valid_591273, JString, required = false,
                                 default = newJString("json"))
  if valid_591273 != nil:
    section.add "alt", valid_591273
  var valid_591274 = query.getOrDefault("oauth_token")
  valid_591274 = validateParameter(valid_591274, JString, required = false,
                                 default = nil)
  if valid_591274 != nil:
    section.add "oauth_token", valid_591274
  var valid_591275 = query.getOrDefault("userIp")
  valid_591275 = validateParameter(valid_591275, JString, required = false,
                                 default = nil)
  if valid_591275 != nil:
    section.add "userIp", valid_591275
  var valid_591276 = query.getOrDefault("key")
  valid_591276 = validateParameter(valid_591276, JString, required = false,
                                 default = nil)
  if valid_591276 != nil:
    section.add "key", valid_591276
  var valid_591277 = query.getOrDefault("prettyPrint")
  valid_591277 = validateParameter(valid_591277, JBool, required = false,
                                 default = newJBool(true))
  if valid_591277 != nil:
    section.add "prettyPrint", valid_591277
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591279: Call_DfareportingPlacementGroupsUpdate_591267;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement group.
  ## 
  let valid = call_591279.validator(path, query, header, formData, body)
  let scheme = call_591279.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591279.url(scheme.get, call_591279.host, call_591279.base,
                         call_591279.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591279, url, valid)

proc call*(call_591280: Call_DfareportingPlacementGroupsUpdate_591267;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementGroupsUpdate
  ## Updates an existing placement group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591281 = newJObject()
  var query_591282 = newJObject()
  var body_591283 = newJObject()
  add(path_591281, "profileId", newJString(profileId))
  add(query_591282, "fields", newJString(fields))
  add(query_591282, "quotaUser", newJString(quotaUser))
  add(query_591282, "alt", newJString(alt))
  add(query_591282, "oauth_token", newJString(oauthToken))
  add(query_591282, "userIp", newJString(userIp))
  add(query_591282, "key", newJString(key))
  if body != nil:
    body_591283 = body
  add(query_591282, "prettyPrint", newJBool(prettyPrint))
  result = call_591280.call(path_591281, query_591282, nil, nil, body_591283)

var dfareportingPlacementGroupsUpdate* = Call_DfareportingPlacementGroupsUpdate_591267(
    name: "dfareportingPlacementGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsUpdate_591268,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsUpdate_591269,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsInsert_591284 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementGroupsInsert_591286(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsInsert_591285(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new placement group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591287 = path.getOrDefault("profileId")
  valid_591287 = validateParameter(valid_591287, JString, required = true,
                                 default = nil)
  if valid_591287 != nil:
    section.add "profileId", valid_591287
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591288 = query.getOrDefault("fields")
  valid_591288 = validateParameter(valid_591288, JString, required = false,
                                 default = nil)
  if valid_591288 != nil:
    section.add "fields", valid_591288
  var valid_591289 = query.getOrDefault("quotaUser")
  valid_591289 = validateParameter(valid_591289, JString, required = false,
                                 default = nil)
  if valid_591289 != nil:
    section.add "quotaUser", valid_591289
  var valid_591290 = query.getOrDefault("alt")
  valid_591290 = validateParameter(valid_591290, JString, required = false,
                                 default = newJString("json"))
  if valid_591290 != nil:
    section.add "alt", valid_591290
  var valid_591291 = query.getOrDefault("oauth_token")
  valid_591291 = validateParameter(valid_591291, JString, required = false,
                                 default = nil)
  if valid_591291 != nil:
    section.add "oauth_token", valid_591291
  var valid_591292 = query.getOrDefault("userIp")
  valid_591292 = validateParameter(valid_591292, JString, required = false,
                                 default = nil)
  if valid_591292 != nil:
    section.add "userIp", valid_591292
  var valid_591293 = query.getOrDefault("key")
  valid_591293 = validateParameter(valid_591293, JString, required = false,
                                 default = nil)
  if valid_591293 != nil:
    section.add "key", valid_591293
  var valid_591294 = query.getOrDefault("prettyPrint")
  valid_591294 = validateParameter(valid_591294, JBool, required = false,
                                 default = newJBool(true))
  if valid_591294 != nil:
    section.add "prettyPrint", valid_591294
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591296: Call_DfareportingPlacementGroupsInsert_591284;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new placement group.
  ## 
  let valid = call_591296.validator(path, query, header, formData, body)
  let scheme = call_591296.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591296.url(scheme.get, call_591296.host, call_591296.base,
                         call_591296.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591296, url, valid)

proc call*(call_591297: Call_DfareportingPlacementGroupsInsert_591284;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementGroupsInsert
  ## Inserts a new placement group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591298 = newJObject()
  var query_591299 = newJObject()
  var body_591300 = newJObject()
  add(path_591298, "profileId", newJString(profileId))
  add(query_591299, "fields", newJString(fields))
  add(query_591299, "quotaUser", newJString(quotaUser))
  add(query_591299, "alt", newJString(alt))
  add(query_591299, "oauth_token", newJString(oauthToken))
  add(query_591299, "userIp", newJString(userIp))
  add(query_591299, "key", newJString(key))
  if body != nil:
    body_591300 = body
  add(query_591299, "prettyPrint", newJBool(prettyPrint))
  result = call_591297.call(path_591298, query_591299, nil, nil, body_591300)

var dfareportingPlacementGroupsInsert* = Call_DfareportingPlacementGroupsInsert_591284(
    name: "dfareportingPlacementGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsInsert_591285,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsInsert_591286,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsList_591233 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementGroupsList_591235(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsList_591234(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of placement groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591236 = path.getOrDefault("profileId")
  valid_591236 = validateParameter(valid_591236, JString, required = true,
                                 default = nil)
  if valid_591236 != nil:
    section.add "profileId", valid_591236
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placement groups that are associated with these content categories.
  ##   alt: JString
  ##      : Data format for the response.
  ##   placementGroupType: JString
  ##                     : Select only placement groups belonging with this group type. A package is a simple group of placements that acts as a single pricing point for a group of tags. A roadblock is a group of placements that not only acts as a single pricing point but also assumes that all the tags in it will be served at the same time. A roadblock requires one of its assigned placements to be marked as primary for reporting.
  ##   searchString: JString
  ##               : Allows searching for placement groups by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placement groups with names like "placement group June 2015", "placement group May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementgroup" will match placement groups with name "my placementgroup", "placementgroup 2015", or simply "placementgroup".
  ##   minEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   siteIds: JArray
  ##          : Select only placement groups that are associated with these sites.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   maxStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   campaignIds: JArray
  ##              : Select only placement groups that belong to these campaigns.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: JBool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   maxEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placement groups with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only placement groups that belong to these advertisers.
  ##   minStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only placement groups that are associated with these directory sites.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   placementStrategyIds: JArray
  ##                       : Select only placement groups that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placement groups with these pricing types.
  section = newJObject()
  var valid_591237 = query.getOrDefault("fields")
  valid_591237 = validateParameter(valid_591237, JString, required = false,
                                 default = nil)
  if valid_591237 != nil:
    section.add "fields", valid_591237
  var valid_591238 = query.getOrDefault("pageToken")
  valid_591238 = validateParameter(valid_591238, JString, required = false,
                                 default = nil)
  if valid_591238 != nil:
    section.add "pageToken", valid_591238
  var valid_591239 = query.getOrDefault("quotaUser")
  valid_591239 = validateParameter(valid_591239, JString, required = false,
                                 default = nil)
  if valid_591239 != nil:
    section.add "quotaUser", valid_591239
  var valid_591240 = query.getOrDefault("sortField")
  valid_591240 = validateParameter(valid_591240, JString, required = false,
                                 default = newJString("ID"))
  if valid_591240 != nil:
    section.add "sortField", valid_591240
  var valid_591241 = query.getOrDefault("contentCategoryIds")
  valid_591241 = validateParameter(valid_591241, JArray, required = false,
                                 default = nil)
  if valid_591241 != nil:
    section.add "contentCategoryIds", valid_591241
  var valid_591242 = query.getOrDefault("alt")
  valid_591242 = validateParameter(valid_591242, JString, required = false,
                                 default = newJString("json"))
  if valid_591242 != nil:
    section.add "alt", valid_591242
  var valid_591243 = query.getOrDefault("placementGroupType")
  valid_591243 = validateParameter(valid_591243, JString, required = false,
                                 default = newJString("PLACEMENT_PACKAGE"))
  if valid_591243 != nil:
    section.add "placementGroupType", valid_591243
  var valid_591244 = query.getOrDefault("searchString")
  valid_591244 = validateParameter(valid_591244, JString, required = false,
                                 default = nil)
  if valid_591244 != nil:
    section.add "searchString", valid_591244
  var valid_591245 = query.getOrDefault("minEndDate")
  valid_591245 = validateParameter(valid_591245, JString, required = false,
                                 default = nil)
  if valid_591245 != nil:
    section.add "minEndDate", valid_591245
  var valid_591246 = query.getOrDefault("siteIds")
  valid_591246 = validateParameter(valid_591246, JArray, required = false,
                                 default = nil)
  if valid_591246 != nil:
    section.add "siteIds", valid_591246
  var valid_591247 = query.getOrDefault("oauth_token")
  valid_591247 = validateParameter(valid_591247, JString, required = false,
                                 default = nil)
  if valid_591247 != nil:
    section.add "oauth_token", valid_591247
  var valid_591248 = query.getOrDefault("maxStartDate")
  valid_591248 = validateParameter(valid_591248, JString, required = false,
                                 default = nil)
  if valid_591248 != nil:
    section.add "maxStartDate", valid_591248
  var valid_591249 = query.getOrDefault("campaignIds")
  valid_591249 = validateParameter(valid_591249, JArray, required = false,
                                 default = nil)
  if valid_591249 != nil:
    section.add "campaignIds", valid_591249
  var valid_591250 = query.getOrDefault("userIp")
  valid_591250 = validateParameter(valid_591250, JString, required = false,
                                 default = nil)
  if valid_591250 != nil:
    section.add "userIp", valid_591250
  var valid_591251 = query.getOrDefault("archived")
  valid_591251 = validateParameter(valid_591251, JBool, required = false, default = nil)
  if valid_591251 != nil:
    section.add "archived", valid_591251
  var valid_591252 = query.getOrDefault("maxEndDate")
  valid_591252 = validateParameter(valid_591252, JString, required = false,
                                 default = nil)
  if valid_591252 != nil:
    section.add "maxEndDate", valid_591252
  var valid_591253 = query.getOrDefault("maxResults")
  valid_591253 = validateParameter(valid_591253, JInt, required = false,
                                 default = newJInt(800))
  if valid_591253 != nil:
    section.add "maxResults", valid_591253
  var valid_591254 = query.getOrDefault("ids")
  valid_591254 = validateParameter(valid_591254, JArray, required = false,
                                 default = nil)
  if valid_591254 != nil:
    section.add "ids", valid_591254
  var valid_591255 = query.getOrDefault("key")
  valid_591255 = validateParameter(valid_591255, JString, required = false,
                                 default = nil)
  if valid_591255 != nil:
    section.add "key", valid_591255
  var valid_591256 = query.getOrDefault("advertiserIds")
  valid_591256 = validateParameter(valid_591256, JArray, required = false,
                                 default = nil)
  if valid_591256 != nil:
    section.add "advertiserIds", valid_591256
  var valid_591257 = query.getOrDefault("minStartDate")
  valid_591257 = validateParameter(valid_591257, JString, required = false,
                                 default = nil)
  if valid_591257 != nil:
    section.add "minStartDate", valid_591257
  var valid_591258 = query.getOrDefault("sortOrder")
  valid_591258 = validateParameter(valid_591258, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_591258 != nil:
    section.add "sortOrder", valid_591258
  var valid_591259 = query.getOrDefault("directorySiteIds")
  valid_591259 = validateParameter(valid_591259, JArray, required = false,
                                 default = nil)
  if valid_591259 != nil:
    section.add "directorySiteIds", valid_591259
  var valid_591260 = query.getOrDefault("prettyPrint")
  valid_591260 = validateParameter(valid_591260, JBool, required = false,
                                 default = newJBool(true))
  if valid_591260 != nil:
    section.add "prettyPrint", valid_591260
  var valid_591261 = query.getOrDefault("placementStrategyIds")
  valid_591261 = validateParameter(valid_591261, JArray, required = false,
                                 default = nil)
  if valid_591261 != nil:
    section.add "placementStrategyIds", valid_591261
  var valid_591262 = query.getOrDefault("pricingTypes")
  valid_591262 = validateParameter(valid_591262, JArray, required = false,
                                 default = nil)
  if valid_591262 != nil:
    section.add "pricingTypes", valid_591262
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591263: Call_DfareportingPlacementGroupsList_591233;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of placement groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_591263.validator(path, query, header, formData, body)
  let scheme = call_591263.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591263.url(scheme.get, call_591263.host, call_591263.base,
                         call_591263.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591263, url, valid)

proc call*(call_591264: Call_DfareportingPlacementGroupsList_591233;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID";
          contentCategoryIds: JsonNode = nil; alt: string = "json";
          placementGroupType: string = "PLACEMENT_PACKAGE";
          searchString: string = ""; minEndDate: string = ""; siteIds: JsonNode = nil;
          oauthToken: string = ""; maxStartDate: string = "";
          campaignIds: JsonNode = nil; userIp: string = ""; archived: bool = false;
          maxEndDate: string = ""; maxResults: int = 800; ids: JsonNode = nil;
          key: string = ""; advertiserIds: JsonNode = nil; minStartDate: string = "";
          sortOrder: string = "ASCENDING"; directorySiteIds: JsonNode = nil;
          prettyPrint: bool = true; placementStrategyIds: JsonNode = nil;
          pricingTypes: JsonNode = nil): Recallable =
  ## dfareportingPlacementGroupsList
  ## Retrieves a list of placement groups, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placement groups that are associated with these content categories.
  ##   alt: string
  ##      : Data format for the response.
  ##   placementGroupType: string
  ##                     : Select only placement groups belonging with this group type. A package is a simple group of placements that acts as a single pricing point for a group of tags. A roadblock is a group of placements that not only acts as a single pricing point but also assumes that all the tags in it will be served at the same time. A roadblock requires one of its assigned placements to be marked as primary for reporting.
  ##   searchString: string
  ##               : Allows searching for placement groups by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placement groups with names like "placement group June 2015", "placement group May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementgroup" will match placement groups with name "my placementgroup", "placementgroup 2015", or simply "placementgroup".
  ##   minEndDate: string
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   siteIds: JArray
  ##          : Select only placement groups that are associated with these sites.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   maxStartDate: string
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   campaignIds: JArray
  ##              : Select only placement groups that belong to these campaigns.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: bool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   maxEndDate: string
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placement groups with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only placement groups that belong to these advertisers.
  ##   minStartDate: string
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only placement groups that are associated with these directory sites.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   placementStrategyIds: JArray
  ##                       : Select only placement groups that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placement groups with these pricing types.
  var path_591265 = newJObject()
  var query_591266 = newJObject()
  add(path_591265, "profileId", newJString(profileId))
  add(query_591266, "fields", newJString(fields))
  add(query_591266, "pageToken", newJString(pageToken))
  add(query_591266, "quotaUser", newJString(quotaUser))
  add(query_591266, "sortField", newJString(sortField))
  if contentCategoryIds != nil:
    query_591266.add "contentCategoryIds", contentCategoryIds
  add(query_591266, "alt", newJString(alt))
  add(query_591266, "placementGroupType", newJString(placementGroupType))
  add(query_591266, "searchString", newJString(searchString))
  add(query_591266, "minEndDate", newJString(minEndDate))
  if siteIds != nil:
    query_591266.add "siteIds", siteIds
  add(query_591266, "oauth_token", newJString(oauthToken))
  add(query_591266, "maxStartDate", newJString(maxStartDate))
  if campaignIds != nil:
    query_591266.add "campaignIds", campaignIds
  add(query_591266, "userIp", newJString(userIp))
  add(query_591266, "archived", newJBool(archived))
  add(query_591266, "maxEndDate", newJString(maxEndDate))
  add(query_591266, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_591266.add "ids", ids
  add(query_591266, "key", newJString(key))
  if advertiserIds != nil:
    query_591266.add "advertiserIds", advertiserIds
  add(query_591266, "minStartDate", newJString(minStartDate))
  add(query_591266, "sortOrder", newJString(sortOrder))
  if directorySiteIds != nil:
    query_591266.add "directorySiteIds", directorySiteIds
  add(query_591266, "prettyPrint", newJBool(prettyPrint))
  if placementStrategyIds != nil:
    query_591266.add "placementStrategyIds", placementStrategyIds
  if pricingTypes != nil:
    query_591266.add "pricingTypes", pricingTypes
  result = call_591264.call(path_591265, query_591266, nil, nil, nil)

var dfareportingPlacementGroupsList* = Call_DfareportingPlacementGroupsList_591233(
    name: "dfareportingPlacementGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsList_591234,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsList_591235,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsPatch_591301 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementGroupsPatch_591303(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsPatch_591302(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591304 = path.getOrDefault("profileId")
  valid_591304 = validateParameter(valid_591304, JString, required = true,
                                 default = nil)
  if valid_591304 != nil:
    section.add "profileId", valid_591304
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Placement group ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591305 = query.getOrDefault("fields")
  valid_591305 = validateParameter(valid_591305, JString, required = false,
                                 default = nil)
  if valid_591305 != nil:
    section.add "fields", valid_591305
  var valid_591306 = query.getOrDefault("quotaUser")
  valid_591306 = validateParameter(valid_591306, JString, required = false,
                                 default = nil)
  if valid_591306 != nil:
    section.add "quotaUser", valid_591306
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_591307 = query.getOrDefault("id")
  valid_591307 = validateParameter(valid_591307, JString, required = true,
                                 default = nil)
  if valid_591307 != nil:
    section.add "id", valid_591307
  var valid_591308 = query.getOrDefault("alt")
  valid_591308 = validateParameter(valid_591308, JString, required = false,
                                 default = newJString("json"))
  if valid_591308 != nil:
    section.add "alt", valid_591308
  var valid_591309 = query.getOrDefault("oauth_token")
  valid_591309 = validateParameter(valid_591309, JString, required = false,
                                 default = nil)
  if valid_591309 != nil:
    section.add "oauth_token", valid_591309
  var valid_591310 = query.getOrDefault("userIp")
  valid_591310 = validateParameter(valid_591310, JString, required = false,
                                 default = nil)
  if valid_591310 != nil:
    section.add "userIp", valid_591310
  var valid_591311 = query.getOrDefault("key")
  valid_591311 = validateParameter(valid_591311, JString, required = false,
                                 default = nil)
  if valid_591311 != nil:
    section.add "key", valid_591311
  var valid_591312 = query.getOrDefault("prettyPrint")
  valid_591312 = validateParameter(valid_591312, JBool, required = false,
                                 default = newJBool(true))
  if valid_591312 != nil:
    section.add "prettyPrint", valid_591312
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591314: Call_DfareportingPlacementGroupsPatch_591301;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement group. This method supports patch semantics.
  ## 
  let valid = call_591314.validator(path, query, header, formData, body)
  let scheme = call_591314.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591314.url(scheme.get, call_591314.host, call_591314.base,
                         call_591314.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591314, url, valid)

proc call*(call_591315: Call_DfareportingPlacementGroupsPatch_591301;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementGroupsPatch
  ## Updates an existing placement group. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Placement group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591316 = newJObject()
  var query_591317 = newJObject()
  var body_591318 = newJObject()
  add(path_591316, "profileId", newJString(profileId))
  add(query_591317, "fields", newJString(fields))
  add(query_591317, "quotaUser", newJString(quotaUser))
  add(query_591317, "id", newJString(id))
  add(query_591317, "alt", newJString(alt))
  add(query_591317, "oauth_token", newJString(oauthToken))
  add(query_591317, "userIp", newJString(userIp))
  add(query_591317, "key", newJString(key))
  if body != nil:
    body_591318 = body
  add(query_591317, "prettyPrint", newJBool(prettyPrint))
  result = call_591315.call(path_591316, query_591317, nil, nil, body_591318)

var dfareportingPlacementGroupsPatch* = Call_DfareportingPlacementGroupsPatch_591301(
    name: "dfareportingPlacementGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsPatch_591302,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsPatch_591303,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsGet_591319 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementGroupsGet_591321(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsGet_591320(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one placement group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591322 = path.getOrDefault("profileId")
  valid_591322 = validateParameter(valid_591322, JString, required = true,
                                 default = nil)
  if valid_591322 != nil:
    section.add "profileId", valid_591322
  var valid_591323 = path.getOrDefault("id")
  valid_591323 = validateParameter(valid_591323, JString, required = true,
                                 default = nil)
  if valid_591323 != nil:
    section.add "id", valid_591323
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591324 = query.getOrDefault("fields")
  valid_591324 = validateParameter(valid_591324, JString, required = false,
                                 default = nil)
  if valid_591324 != nil:
    section.add "fields", valid_591324
  var valid_591325 = query.getOrDefault("quotaUser")
  valid_591325 = validateParameter(valid_591325, JString, required = false,
                                 default = nil)
  if valid_591325 != nil:
    section.add "quotaUser", valid_591325
  var valid_591326 = query.getOrDefault("alt")
  valid_591326 = validateParameter(valid_591326, JString, required = false,
                                 default = newJString("json"))
  if valid_591326 != nil:
    section.add "alt", valid_591326
  var valid_591327 = query.getOrDefault("oauth_token")
  valid_591327 = validateParameter(valid_591327, JString, required = false,
                                 default = nil)
  if valid_591327 != nil:
    section.add "oauth_token", valid_591327
  var valid_591328 = query.getOrDefault("userIp")
  valid_591328 = validateParameter(valid_591328, JString, required = false,
                                 default = nil)
  if valid_591328 != nil:
    section.add "userIp", valid_591328
  var valid_591329 = query.getOrDefault("key")
  valid_591329 = validateParameter(valid_591329, JString, required = false,
                                 default = nil)
  if valid_591329 != nil:
    section.add "key", valid_591329
  var valid_591330 = query.getOrDefault("prettyPrint")
  valid_591330 = validateParameter(valid_591330, JBool, required = false,
                                 default = newJBool(true))
  if valid_591330 != nil:
    section.add "prettyPrint", valid_591330
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591331: Call_DfareportingPlacementGroupsGet_591319; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one placement group by ID.
  ## 
  let valid = call_591331.validator(path, query, header, formData, body)
  let scheme = call_591331.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591331.url(scheme.get, call_591331.host, call_591331.base,
                         call_591331.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591331, url, valid)

proc call*(call_591332: Call_DfareportingPlacementGroupsGet_591319;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementGroupsGet
  ## Gets one placement group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Placement group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591333 = newJObject()
  var query_591334 = newJObject()
  add(path_591333, "profileId", newJString(profileId))
  add(query_591334, "fields", newJString(fields))
  add(query_591334, "quotaUser", newJString(quotaUser))
  add(query_591334, "alt", newJString(alt))
  add(query_591334, "oauth_token", newJString(oauthToken))
  add(query_591334, "userIp", newJString(userIp))
  add(path_591333, "id", newJString(id))
  add(query_591334, "key", newJString(key))
  add(query_591334, "prettyPrint", newJBool(prettyPrint))
  result = call_591332.call(path_591333, query_591334, nil, nil, nil)

var dfareportingPlacementGroupsGet* = Call_DfareportingPlacementGroupsGet_591319(
    name: "dfareportingPlacementGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups/{id}",
    validator: validate_DfareportingPlacementGroupsGet_591320,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsGet_591321,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesUpdate_591356 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementStrategiesUpdate_591358(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesUpdate_591357(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement strategy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591359 = path.getOrDefault("profileId")
  valid_591359 = validateParameter(valid_591359, JString, required = true,
                                 default = nil)
  if valid_591359 != nil:
    section.add "profileId", valid_591359
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591360 = query.getOrDefault("fields")
  valid_591360 = validateParameter(valid_591360, JString, required = false,
                                 default = nil)
  if valid_591360 != nil:
    section.add "fields", valid_591360
  var valid_591361 = query.getOrDefault("quotaUser")
  valid_591361 = validateParameter(valid_591361, JString, required = false,
                                 default = nil)
  if valid_591361 != nil:
    section.add "quotaUser", valid_591361
  var valid_591362 = query.getOrDefault("alt")
  valid_591362 = validateParameter(valid_591362, JString, required = false,
                                 default = newJString("json"))
  if valid_591362 != nil:
    section.add "alt", valid_591362
  var valid_591363 = query.getOrDefault("oauth_token")
  valid_591363 = validateParameter(valid_591363, JString, required = false,
                                 default = nil)
  if valid_591363 != nil:
    section.add "oauth_token", valid_591363
  var valid_591364 = query.getOrDefault("userIp")
  valid_591364 = validateParameter(valid_591364, JString, required = false,
                                 default = nil)
  if valid_591364 != nil:
    section.add "userIp", valid_591364
  var valid_591365 = query.getOrDefault("key")
  valid_591365 = validateParameter(valid_591365, JString, required = false,
                                 default = nil)
  if valid_591365 != nil:
    section.add "key", valid_591365
  var valid_591366 = query.getOrDefault("prettyPrint")
  valid_591366 = validateParameter(valid_591366, JBool, required = false,
                                 default = newJBool(true))
  if valid_591366 != nil:
    section.add "prettyPrint", valid_591366
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591368: Call_DfareportingPlacementStrategiesUpdate_591356;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement strategy.
  ## 
  let valid = call_591368.validator(path, query, header, formData, body)
  let scheme = call_591368.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591368.url(scheme.get, call_591368.host, call_591368.base,
                         call_591368.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591368, url, valid)

proc call*(call_591369: Call_DfareportingPlacementStrategiesUpdate_591356;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesUpdate
  ## Updates an existing placement strategy.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591370 = newJObject()
  var query_591371 = newJObject()
  var body_591372 = newJObject()
  add(path_591370, "profileId", newJString(profileId))
  add(query_591371, "fields", newJString(fields))
  add(query_591371, "quotaUser", newJString(quotaUser))
  add(query_591371, "alt", newJString(alt))
  add(query_591371, "oauth_token", newJString(oauthToken))
  add(query_591371, "userIp", newJString(userIp))
  add(query_591371, "key", newJString(key))
  if body != nil:
    body_591372 = body
  add(query_591371, "prettyPrint", newJBool(prettyPrint))
  result = call_591369.call(path_591370, query_591371, nil, nil, body_591372)

var dfareportingPlacementStrategiesUpdate* = Call_DfareportingPlacementStrategiesUpdate_591356(
    name: "dfareportingPlacementStrategiesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesUpdate_591357,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesUpdate_591358,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesInsert_591373 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementStrategiesInsert_591375(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesInsert_591374(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new placement strategy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591376 = path.getOrDefault("profileId")
  valid_591376 = validateParameter(valid_591376, JString, required = true,
                                 default = nil)
  if valid_591376 != nil:
    section.add "profileId", valid_591376
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591377 = query.getOrDefault("fields")
  valid_591377 = validateParameter(valid_591377, JString, required = false,
                                 default = nil)
  if valid_591377 != nil:
    section.add "fields", valid_591377
  var valid_591378 = query.getOrDefault("quotaUser")
  valid_591378 = validateParameter(valid_591378, JString, required = false,
                                 default = nil)
  if valid_591378 != nil:
    section.add "quotaUser", valid_591378
  var valid_591379 = query.getOrDefault("alt")
  valid_591379 = validateParameter(valid_591379, JString, required = false,
                                 default = newJString("json"))
  if valid_591379 != nil:
    section.add "alt", valid_591379
  var valid_591380 = query.getOrDefault("oauth_token")
  valid_591380 = validateParameter(valid_591380, JString, required = false,
                                 default = nil)
  if valid_591380 != nil:
    section.add "oauth_token", valid_591380
  var valid_591381 = query.getOrDefault("userIp")
  valid_591381 = validateParameter(valid_591381, JString, required = false,
                                 default = nil)
  if valid_591381 != nil:
    section.add "userIp", valid_591381
  var valid_591382 = query.getOrDefault("key")
  valid_591382 = validateParameter(valid_591382, JString, required = false,
                                 default = nil)
  if valid_591382 != nil:
    section.add "key", valid_591382
  var valid_591383 = query.getOrDefault("prettyPrint")
  valid_591383 = validateParameter(valid_591383, JBool, required = false,
                                 default = newJBool(true))
  if valid_591383 != nil:
    section.add "prettyPrint", valid_591383
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591385: Call_DfareportingPlacementStrategiesInsert_591373;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new placement strategy.
  ## 
  let valid = call_591385.validator(path, query, header, formData, body)
  let scheme = call_591385.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591385.url(scheme.get, call_591385.host, call_591385.base,
                         call_591385.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591385, url, valid)

proc call*(call_591386: Call_DfareportingPlacementStrategiesInsert_591373;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesInsert
  ## Inserts a new placement strategy.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591387 = newJObject()
  var query_591388 = newJObject()
  var body_591389 = newJObject()
  add(path_591387, "profileId", newJString(profileId))
  add(query_591388, "fields", newJString(fields))
  add(query_591388, "quotaUser", newJString(quotaUser))
  add(query_591388, "alt", newJString(alt))
  add(query_591388, "oauth_token", newJString(oauthToken))
  add(query_591388, "userIp", newJString(userIp))
  add(query_591388, "key", newJString(key))
  if body != nil:
    body_591389 = body
  add(query_591388, "prettyPrint", newJBool(prettyPrint))
  result = call_591386.call(path_591387, query_591388, nil, nil, body_591389)

var dfareportingPlacementStrategiesInsert* = Call_DfareportingPlacementStrategiesInsert_591373(
    name: "dfareportingPlacementStrategiesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesInsert_591374,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesInsert_591375,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesList_591335 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementStrategiesList_591337(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesList_591336(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of placement strategies, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591338 = path.getOrDefault("profileId")
  valid_591338 = validateParameter(valid_591338, JString, required = true,
                                 default = nil)
  if valid_591338 != nil:
    section.add "profileId", valid_591338
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "placementstrategy*2015" will return objects with names like "placementstrategy June 2015", "placementstrategy April 2015", or simply "placementstrategy 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementstrategy" will match objects with name "my placementstrategy", "placementstrategy 2015", or simply "placementstrategy".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placement strategies with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591339 = query.getOrDefault("fields")
  valid_591339 = validateParameter(valid_591339, JString, required = false,
                                 default = nil)
  if valid_591339 != nil:
    section.add "fields", valid_591339
  var valid_591340 = query.getOrDefault("pageToken")
  valid_591340 = validateParameter(valid_591340, JString, required = false,
                                 default = nil)
  if valid_591340 != nil:
    section.add "pageToken", valid_591340
  var valid_591341 = query.getOrDefault("quotaUser")
  valid_591341 = validateParameter(valid_591341, JString, required = false,
                                 default = nil)
  if valid_591341 != nil:
    section.add "quotaUser", valid_591341
  var valid_591342 = query.getOrDefault("sortField")
  valid_591342 = validateParameter(valid_591342, JString, required = false,
                                 default = newJString("ID"))
  if valid_591342 != nil:
    section.add "sortField", valid_591342
  var valid_591343 = query.getOrDefault("alt")
  valid_591343 = validateParameter(valid_591343, JString, required = false,
                                 default = newJString("json"))
  if valid_591343 != nil:
    section.add "alt", valid_591343
  var valid_591344 = query.getOrDefault("searchString")
  valid_591344 = validateParameter(valid_591344, JString, required = false,
                                 default = nil)
  if valid_591344 != nil:
    section.add "searchString", valid_591344
  var valid_591345 = query.getOrDefault("oauth_token")
  valid_591345 = validateParameter(valid_591345, JString, required = false,
                                 default = nil)
  if valid_591345 != nil:
    section.add "oauth_token", valid_591345
  var valid_591346 = query.getOrDefault("userIp")
  valid_591346 = validateParameter(valid_591346, JString, required = false,
                                 default = nil)
  if valid_591346 != nil:
    section.add "userIp", valid_591346
  var valid_591347 = query.getOrDefault("maxResults")
  valid_591347 = validateParameter(valid_591347, JInt, required = false,
                                 default = newJInt(1000))
  if valid_591347 != nil:
    section.add "maxResults", valid_591347
  var valid_591348 = query.getOrDefault("ids")
  valid_591348 = validateParameter(valid_591348, JArray, required = false,
                                 default = nil)
  if valid_591348 != nil:
    section.add "ids", valid_591348
  var valid_591349 = query.getOrDefault("key")
  valid_591349 = validateParameter(valid_591349, JString, required = false,
                                 default = nil)
  if valid_591349 != nil:
    section.add "key", valid_591349
  var valid_591350 = query.getOrDefault("sortOrder")
  valid_591350 = validateParameter(valid_591350, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_591350 != nil:
    section.add "sortOrder", valid_591350
  var valid_591351 = query.getOrDefault("prettyPrint")
  valid_591351 = validateParameter(valid_591351, JBool, required = false,
                                 default = newJBool(true))
  if valid_591351 != nil:
    section.add "prettyPrint", valid_591351
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591352: Call_DfareportingPlacementStrategiesList_591335;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of placement strategies, possibly filtered. This method supports paging.
  ## 
  let valid = call_591352.validator(path, query, header, formData, body)
  let scheme = call_591352.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591352.url(scheme.get, call_591352.host, call_591352.base,
                         call_591352.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591352, url, valid)

proc call*(call_591353: Call_DfareportingPlacementStrategiesList_591335;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesList
  ## Retrieves a list of placement strategies, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "placementstrategy*2015" will return objects with names like "placementstrategy June 2015", "placementstrategy April 2015", or simply "placementstrategy 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementstrategy" will match objects with name "my placementstrategy", "placementstrategy 2015", or simply "placementstrategy".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placement strategies with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591354 = newJObject()
  var query_591355 = newJObject()
  add(path_591354, "profileId", newJString(profileId))
  add(query_591355, "fields", newJString(fields))
  add(query_591355, "pageToken", newJString(pageToken))
  add(query_591355, "quotaUser", newJString(quotaUser))
  add(query_591355, "sortField", newJString(sortField))
  add(query_591355, "alt", newJString(alt))
  add(query_591355, "searchString", newJString(searchString))
  add(query_591355, "oauth_token", newJString(oauthToken))
  add(query_591355, "userIp", newJString(userIp))
  add(query_591355, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_591355.add "ids", ids
  add(query_591355, "key", newJString(key))
  add(query_591355, "sortOrder", newJString(sortOrder))
  add(query_591355, "prettyPrint", newJBool(prettyPrint))
  result = call_591353.call(path_591354, query_591355, nil, nil, nil)

var dfareportingPlacementStrategiesList* = Call_DfareportingPlacementStrategiesList_591335(
    name: "dfareportingPlacementStrategiesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesList_591336,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesList_591337,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesPatch_591390 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementStrategiesPatch_591392(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesPatch_591391(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement strategy. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591393 = path.getOrDefault("profileId")
  valid_591393 = validateParameter(valid_591393, JString, required = true,
                                 default = nil)
  if valid_591393 != nil:
    section.add "profileId", valid_591393
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Placement strategy ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591394 = query.getOrDefault("fields")
  valid_591394 = validateParameter(valid_591394, JString, required = false,
                                 default = nil)
  if valid_591394 != nil:
    section.add "fields", valid_591394
  var valid_591395 = query.getOrDefault("quotaUser")
  valid_591395 = validateParameter(valid_591395, JString, required = false,
                                 default = nil)
  if valid_591395 != nil:
    section.add "quotaUser", valid_591395
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_591396 = query.getOrDefault("id")
  valid_591396 = validateParameter(valid_591396, JString, required = true,
                                 default = nil)
  if valid_591396 != nil:
    section.add "id", valid_591396
  var valid_591397 = query.getOrDefault("alt")
  valid_591397 = validateParameter(valid_591397, JString, required = false,
                                 default = newJString("json"))
  if valid_591397 != nil:
    section.add "alt", valid_591397
  var valid_591398 = query.getOrDefault("oauth_token")
  valid_591398 = validateParameter(valid_591398, JString, required = false,
                                 default = nil)
  if valid_591398 != nil:
    section.add "oauth_token", valid_591398
  var valid_591399 = query.getOrDefault("userIp")
  valid_591399 = validateParameter(valid_591399, JString, required = false,
                                 default = nil)
  if valid_591399 != nil:
    section.add "userIp", valid_591399
  var valid_591400 = query.getOrDefault("key")
  valid_591400 = validateParameter(valid_591400, JString, required = false,
                                 default = nil)
  if valid_591400 != nil:
    section.add "key", valid_591400
  var valid_591401 = query.getOrDefault("prettyPrint")
  valid_591401 = validateParameter(valid_591401, JBool, required = false,
                                 default = newJBool(true))
  if valid_591401 != nil:
    section.add "prettyPrint", valid_591401
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591403: Call_DfareportingPlacementStrategiesPatch_591390;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement strategy. This method supports patch semantics.
  ## 
  let valid = call_591403.validator(path, query, header, formData, body)
  let scheme = call_591403.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591403.url(scheme.get, call_591403.host, call_591403.base,
                         call_591403.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591403, url, valid)

proc call*(call_591404: Call_DfareportingPlacementStrategiesPatch_591390;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesPatch
  ## Updates an existing placement strategy. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Placement strategy ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591405 = newJObject()
  var query_591406 = newJObject()
  var body_591407 = newJObject()
  add(path_591405, "profileId", newJString(profileId))
  add(query_591406, "fields", newJString(fields))
  add(query_591406, "quotaUser", newJString(quotaUser))
  add(query_591406, "id", newJString(id))
  add(query_591406, "alt", newJString(alt))
  add(query_591406, "oauth_token", newJString(oauthToken))
  add(query_591406, "userIp", newJString(userIp))
  add(query_591406, "key", newJString(key))
  if body != nil:
    body_591407 = body
  add(query_591406, "prettyPrint", newJBool(prettyPrint))
  result = call_591404.call(path_591405, query_591406, nil, nil, body_591407)

var dfareportingPlacementStrategiesPatch* = Call_DfareportingPlacementStrategiesPatch_591390(
    name: "dfareportingPlacementStrategiesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesPatch_591391,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesPatch_591392,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesGet_591408 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementStrategiesGet_591410(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesGet_591409(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one placement strategy by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement strategy ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591411 = path.getOrDefault("profileId")
  valid_591411 = validateParameter(valid_591411, JString, required = true,
                                 default = nil)
  if valid_591411 != nil:
    section.add "profileId", valid_591411
  var valid_591412 = path.getOrDefault("id")
  valid_591412 = validateParameter(valid_591412, JString, required = true,
                                 default = nil)
  if valid_591412 != nil:
    section.add "id", valid_591412
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591413 = query.getOrDefault("fields")
  valid_591413 = validateParameter(valid_591413, JString, required = false,
                                 default = nil)
  if valid_591413 != nil:
    section.add "fields", valid_591413
  var valid_591414 = query.getOrDefault("quotaUser")
  valid_591414 = validateParameter(valid_591414, JString, required = false,
                                 default = nil)
  if valid_591414 != nil:
    section.add "quotaUser", valid_591414
  var valid_591415 = query.getOrDefault("alt")
  valid_591415 = validateParameter(valid_591415, JString, required = false,
                                 default = newJString("json"))
  if valid_591415 != nil:
    section.add "alt", valid_591415
  var valid_591416 = query.getOrDefault("oauth_token")
  valid_591416 = validateParameter(valid_591416, JString, required = false,
                                 default = nil)
  if valid_591416 != nil:
    section.add "oauth_token", valid_591416
  var valid_591417 = query.getOrDefault("userIp")
  valid_591417 = validateParameter(valid_591417, JString, required = false,
                                 default = nil)
  if valid_591417 != nil:
    section.add "userIp", valid_591417
  var valid_591418 = query.getOrDefault("key")
  valid_591418 = validateParameter(valid_591418, JString, required = false,
                                 default = nil)
  if valid_591418 != nil:
    section.add "key", valid_591418
  var valid_591419 = query.getOrDefault("prettyPrint")
  valid_591419 = validateParameter(valid_591419, JBool, required = false,
                                 default = newJBool(true))
  if valid_591419 != nil:
    section.add "prettyPrint", valid_591419
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591420: Call_DfareportingPlacementStrategiesGet_591408;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one placement strategy by ID.
  ## 
  let valid = call_591420.validator(path, query, header, formData, body)
  let scheme = call_591420.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591420.url(scheme.get, call_591420.host, call_591420.base,
                         call_591420.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591420, url, valid)

proc call*(call_591421: Call_DfareportingPlacementStrategiesGet_591408;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesGet
  ## Gets one placement strategy by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Placement strategy ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591422 = newJObject()
  var query_591423 = newJObject()
  add(path_591422, "profileId", newJString(profileId))
  add(query_591423, "fields", newJString(fields))
  add(query_591423, "quotaUser", newJString(quotaUser))
  add(query_591423, "alt", newJString(alt))
  add(query_591423, "oauth_token", newJString(oauthToken))
  add(query_591423, "userIp", newJString(userIp))
  add(path_591422, "id", newJString(id))
  add(query_591423, "key", newJString(key))
  add(query_591423, "prettyPrint", newJBool(prettyPrint))
  result = call_591421.call(path_591422, query_591423, nil, nil, nil)

var dfareportingPlacementStrategiesGet* = Call_DfareportingPlacementStrategiesGet_591408(
    name: "dfareportingPlacementStrategiesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies/{id}",
    validator: validate_DfareportingPlacementStrategiesGet_591409,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesGet_591410,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesDelete_591424 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementStrategiesDelete_591426(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesDelete_591425(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing placement strategy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement strategy ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591427 = path.getOrDefault("profileId")
  valid_591427 = validateParameter(valid_591427, JString, required = true,
                                 default = nil)
  if valid_591427 != nil:
    section.add "profileId", valid_591427
  var valid_591428 = path.getOrDefault("id")
  valid_591428 = validateParameter(valid_591428, JString, required = true,
                                 default = nil)
  if valid_591428 != nil:
    section.add "id", valid_591428
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591429 = query.getOrDefault("fields")
  valid_591429 = validateParameter(valid_591429, JString, required = false,
                                 default = nil)
  if valid_591429 != nil:
    section.add "fields", valid_591429
  var valid_591430 = query.getOrDefault("quotaUser")
  valid_591430 = validateParameter(valid_591430, JString, required = false,
                                 default = nil)
  if valid_591430 != nil:
    section.add "quotaUser", valid_591430
  var valid_591431 = query.getOrDefault("alt")
  valid_591431 = validateParameter(valid_591431, JString, required = false,
                                 default = newJString("json"))
  if valid_591431 != nil:
    section.add "alt", valid_591431
  var valid_591432 = query.getOrDefault("oauth_token")
  valid_591432 = validateParameter(valid_591432, JString, required = false,
                                 default = nil)
  if valid_591432 != nil:
    section.add "oauth_token", valid_591432
  var valid_591433 = query.getOrDefault("userIp")
  valid_591433 = validateParameter(valid_591433, JString, required = false,
                                 default = nil)
  if valid_591433 != nil:
    section.add "userIp", valid_591433
  var valid_591434 = query.getOrDefault("key")
  valid_591434 = validateParameter(valid_591434, JString, required = false,
                                 default = nil)
  if valid_591434 != nil:
    section.add "key", valid_591434
  var valid_591435 = query.getOrDefault("prettyPrint")
  valid_591435 = validateParameter(valid_591435, JBool, required = false,
                                 default = newJBool(true))
  if valid_591435 != nil:
    section.add "prettyPrint", valid_591435
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591436: Call_DfareportingPlacementStrategiesDelete_591424;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing placement strategy.
  ## 
  let valid = call_591436.validator(path, query, header, formData, body)
  let scheme = call_591436.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591436.url(scheme.get, call_591436.host, call_591436.base,
                         call_591436.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591436, url, valid)

proc call*(call_591437: Call_DfareportingPlacementStrategiesDelete_591424;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesDelete
  ## Deletes an existing placement strategy.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Placement strategy ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591438 = newJObject()
  var query_591439 = newJObject()
  add(path_591438, "profileId", newJString(profileId))
  add(query_591439, "fields", newJString(fields))
  add(query_591439, "quotaUser", newJString(quotaUser))
  add(query_591439, "alt", newJString(alt))
  add(query_591439, "oauth_token", newJString(oauthToken))
  add(query_591439, "userIp", newJString(userIp))
  add(path_591438, "id", newJString(id))
  add(query_591439, "key", newJString(key))
  add(query_591439, "prettyPrint", newJBool(prettyPrint))
  result = call_591437.call(path_591438, query_591439, nil, nil, nil)

var dfareportingPlacementStrategiesDelete* = Call_DfareportingPlacementStrategiesDelete_591424(
    name: "dfareportingPlacementStrategiesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies/{id}",
    validator: validate_DfareportingPlacementStrategiesDelete_591425,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesDelete_591426,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsUpdate_591477 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementsUpdate_591479(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsUpdate_591478(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591480 = path.getOrDefault("profileId")
  valid_591480 = validateParameter(valid_591480, JString, required = true,
                                 default = nil)
  if valid_591480 != nil:
    section.add "profileId", valid_591480
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591481 = query.getOrDefault("fields")
  valid_591481 = validateParameter(valid_591481, JString, required = false,
                                 default = nil)
  if valid_591481 != nil:
    section.add "fields", valid_591481
  var valid_591482 = query.getOrDefault("quotaUser")
  valid_591482 = validateParameter(valid_591482, JString, required = false,
                                 default = nil)
  if valid_591482 != nil:
    section.add "quotaUser", valid_591482
  var valid_591483 = query.getOrDefault("alt")
  valid_591483 = validateParameter(valid_591483, JString, required = false,
                                 default = newJString("json"))
  if valid_591483 != nil:
    section.add "alt", valid_591483
  var valid_591484 = query.getOrDefault("oauth_token")
  valid_591484 = validateParameter(valid_591484, JString, required = false,
                                 default = nil)
  if valid_591484 != nil:
    section.add "oauth_token", valid_591484
  var valid_591485 = query.getOrDefault("userIp")
  valid_591485 = validateParameter(valid_591485, JString, required = false,
                                 default = nil)
  if valid_591485 != nil:
    section.add "userIp", valid_591485
  var valid_591486 = query.getOrDefault("key")
  valid_591486 = validateParameter(valid_591486, JString, required = false,
                                 default = nil)
  if valid_591486 != nil:
    section.add "key", valid_591486
  var valid_591487 = query.getOrDefault("prettyPrint")
  valid_591487 = validateParameter(valid_591487, JBool, required = false,
                                 default = newJBool(true))
  if valid_591487 != nil:
    section.add "prettyPrint", valid_591487
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591489: Call_DfareportingPlacementsUpdate_591477; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing placement.
  ## 
  let valid = call_591489.validator(path, query, header, formData, body)
  let scheme = call_591489.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591489.url(scheme.get, call_591489.host, call_591489.base,
                         call_591489.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591489, url, valid)

proc call*(call_591490: Call_DfareportingPlacementsUpdate_591477;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementsUpdate
  ## Updates an existing placement.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591491 = newJObject()
  var query_591492 = newJObject()
  var body_591493 = newJObject()
  add(path_591491, "profileId", newJString(profileId))
  add(query_591492, "fields", newJString(fields))
  add(query_591492, "quotaUser", newJString(quotaUser))
  add(query_591492, "alt", newJString(alt))
  add(query_591492, "oauth_token", newJString(oauthToken))
  add(query_591492, "userIp", newJString(userIp))
  add(query_591492, "key", newJString(key))
  if body != nil:
    body_591493 = body
  add(query_591492, "prettyPrint", newJBool(prettyPrint))
  result = call_591490.call(path_591491, query_591492, nil, nil, body_591493)

var dfareportingPlacementsUpdate* = Call_DfareportingPlacementsUpdate_591477(
    name: "dfareportingPlacementsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsUpdate_591478,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsUpdate_591479,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsInsert_591494 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementsInsert_591496(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsInsert_591495(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591497 = path.getOrDefault("profileId")
  valid_591497 = validateParameter(valid_591497, JString, required = true,
                                 default = nil)
  if valid_591497 != nil:
    section.add "profileId", valid_591497
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591498 = query.getOrDefault("fields")
  valid_591498 = validateParameter(valid_591498, JString, required = false,
                                 default = nil)
  if valid_591498 != nil:
    section.add "fields", valid_591498
  var valid_591499 = query.getOrDefault("quotaUser")
  valid_591499 = validateParameter(valid_591499, JString, required = false,
                                 default = nil)
  if valid_591499 != nil:
    section.add "quotaUser", valid_591499
  var valid_591500 = query.getOrDefault("alt")
  valid_591500 = validateParameter(valid_591500, JString, required = false,
                                 default = newJString("json"))
  if valid_591500 != nil:
    section.add "alt", valid_591500
  var valid_591501 = query.getOrDefault("oauth_token")
  valid_591501 = validateParameter(valid_591501, JString, required = false,
                                 default = nil)
  if valid_591501 != nil:
    section.add "oauth_token", valid_591501
  var valid_591502 = query.getOrDefault("userIp")
  valid_591502 = validateParameter(valid_591502, JString, required = false,
                                 default = nil)
  if valid_591502 != nil:
    section.add "userIp", valid_591502
  var valid_591503 = query.getOrDefault("key")
  valid_591503 = validateParameter(valid_591503, JString, required = false,
                                 default = nil)
  if valid_591503 != nil:
    section.add "key", valid_591503
  var valid_591504 = query.getOrDefault("prettyPrint")
  valid_591504 = validateParameter(valid_591504, JBool, required = false,
                                 default = newJBool(true))
  if valid_591504 != nil:
    section.add "prettyPrint", valid_591504
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591506: Call_DfareportingPlacementsInsert_591494; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new placement.
  ## 
  let valid = call_591506.validator(path, query, header, formData, body)
  let scheme = call_591506.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591506.url(scheme.get, call_591506.host, call_591506.base,
                         call_591506.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591506, url, valid)

proc call*(call_591507: Call_DfareportingPlacementsInsert_591494;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementsInsert
  ## Inserts a new placement.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591508 = newJObject()
  var query_591509 = newJObject()
  var body_591510 = newJObject()
  add(path_591508, "profileId", newJString(profileId))
  add(query_591509, "fields", newJString(fields))
  add(query_591509, "quotaUser", newJString(quotaUser))
  add(query_591509, "alt", newJString(alt))
  add(query_591509, "oauth_token", newJString(oauthToken))
  add(query_591509, "userIp", newJString(userIp))
  add(query_591509, "key", newJString(key))
  if body != nil:
    body_591510 = body
  add(query_591509, "prettyPrint", newJBool(prettyPrint))
  result = call_591507.call(path_591508, query_591509, nil, nil, body_591510)

var dfareportingPlacementsInsert* = Call_DfareportingPlacementsInsert_591494(
    name: "dfareportingPlacementsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsInsert_591495,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsInsert_591496,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsList_591440 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementsList_591442(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsList_591441(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of placements, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591443 = path.getOrDefault("profileId")
  valid_591443 = validateParameter(valid_591443, JString, required = true,
                                 default = nil)
  if valid_591443 != nil:
    section.add "profileId", valid_591443
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placements that are associated with these content categories.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for placements by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placements with names like "placement June 2015", "placement May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placement" will match placements with name "my placement", "placement 2015", or simply "placement".
  ##   minEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   sizeIds: JArray
  ##          : Select only placements that are associated with these sizes.
  ##   siteIds: JArray
  ##          : Select only placements that are associated with these sites.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   maxStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   campaignIds: JArray
  ##              : Select only placements that belong to these campaigns.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: JBool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   maxEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placements with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only placements that belong to these advertisers.
  ##   minStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   paymentSource: JString
  ##                : Select only placements with this payment source.
  ##   compatibilities: JArray
  ##                  : Select only placements that are associated with these compatibilities. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering in in-stream video ads developed with the VAST standard.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only placements that are associated with these directory sites.
  ##   groupIds: JArray
  ##           : Select only placements that belong to these placement groups.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   placementStrategyIds: JArray
  ##                       : Select only placements that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placements with these pricing types.
  section = newJObject()
  var valid_591444 = query.getOrDefault("fields")
  valid_591444 = validateParameter(valid_591444, JString, required = false,
                                 default = nil)
  if valid_591444 != nil:
    section.add "fields", valid_591444
  var valid_591445 = query.getOrDefault("pageToken")
  valid_591445 = validateParameter(valid_591445, JString, required = false,
                                 default = nil)
  if valid_591445 != nil:
    section.add "pageToken", valid_591445
  var valid_591446 = query.getOrDefault("quotaUser")
  valid_591446 = validateParameter(valid_591446, JString, required = false,
                                 default = nil)
  if valid_591446 != nil:
    section.add "quotaUser", valid_591446
  var valid_591447 = query.getOrDefault("sortField")
  valid_591447 = validateParameter(valid_591447, JString, required = false,
                                 default = newJString("ID"))
  if valid_591447 != nil:
    section.add "sortField", valid_591447
  var valid_591448 = query.getOrDefault("contentCategoryIds")
  valid_591448 = validateParameter(valid_591448, JArray, required = false,
                                 default = nil)
  if valid_591448 != nil:
    section.add "contentCategoryIds", valid_591448
  var valid_591449 = query.getOrDefault("alt")
  valid_591449 = validateParameter(valid_591449, JString, required = false,
                                 default = newJString("json"))
  if valid_591449 != nil:
    section.add "alt", valid_591449
  var valid_591450 = query.getOrDefault("searchString")
  valid_591450 = validateParameter(valid_591450, JString, required = false,
                                 default = nil)
  if valid_591450 != nil:
    section.add "searchString", valid_591450
  var valid_591451 = query.getOrDefault("minEndDate")
  valid_591451 = validateParameter(valid_591451, JString, required = false,
                                 default = nil)
  if valid_591451 != nil:
    section.add "minEndDate", valid_591451
  var valid_591452 = query.getOrDefault("sizeIds")
  valid_591452 = validateParameter(valid_591452, JArray, required = false,
                                 default = nil)
  if valid_591452 != nil:
    section.add "sizeIds", valid_591452
  var valid_591453 = query.getOrDefault("siteIds")
  valid_591453 = validateParameter(valid_591453, JArray, required = false,
                                 default = nil)
  if valid_591453 != nil:
    section.add "siteIds", valid_591453
  var valid_591454 = query.getOrDefault("oauth_token")
  valid_591454 = validateParameter(valid_591454, JString, required = false,
                                 default = nil)
  if valid_591454 != nil:
    section.add "oauth_token", valid_591454
  var valid_591455 = query.getOrDefault("maxStartDate")
  valid_591455 = validateParameter(valid_591455, JString, required = false,
                                 default = nil)
  if valid_591455 != nil:
    section.add "maxStartDate", valid_591455
  var valid_591456 = query.getOrDefault("campaignIds")
  valid_591456 = validateParameter(valid_591456, JArray, required = false,
                                 default = nil)
  if valid_591456 != nil:
    section.add "campaignIds", valid_591456
  var valid_591457 = query.getOrDefault("userIp")
  valid_591457 = validateParameter(valid_591457, JString, required = false,
                                 default = nil)
  if valid_591457 != nil:
    section.add "userIp", valid_591457
  var valid_591458 = query.getOrDefault("archived")
  valid_591458 = validateParameter(valid_591458, JBool, required = false, default = nil)
  if valid_591458 != nil:
    section.add "archived", valid_591458
  var valid_591459 = query.getOrDefault("maxEndDate")
  valid_591459 = validateParameter(valid_591459, JString, required = false,
                                 default = nil)
  if valid_591459 != nil:
    section.add "maxEndDate", valid_591459
  var valid_591460 = query.getOrDefault("maxResults")
  valid_591460 = validateParameter(valid_591460, JInt, required = false,
                                 default = newJInt(1000))
  if valid_591460 != nil:
    section.add "maxResults", valid_591460
  var valid_591461 = query.getOrDefault("ids")
  valid_591461 = validateParameter(valid_591461, JArray, required = false,
                                 default = nil)
  if valid_591461 != nil:
    section.add "ids", valid_591461
  var valid_591462 = query.getOrDefault("key")
  valid_591462 = validateParameter(valid_591462, JString, required = false,
                                 default = nil)
  if valid_591462 != nil:
    section.add "key", valid_591462
  var valid_591463 = query.getOrDefault("advertiserIds")
  valid_591463 = validateParameter(valid_591463, JArray, required = false,
                                 default = nil)
  if valid_591463 != nil:
    section.add "advertiserIds", valid_591463
  var valid_591464 = query.getOrDefault("minStartDate")
  valid_591464 = validateParameter(valid_591464, JString, required = false,
                                 default = nil)
  if valid_591464 != nil:
    section.add "minStartDate", valid_591464
  var valid_591465 = query.getOrDefault("paymentSource")
  valid_591465 = validateParameter(valid_591465, JString, required = false,
                                 default = newJString("PLACEMENT_AGENCY_PAID"))
  if valid_591465 != nil:
    section.add "paymentSource", valid_591465
  var valid_591466 = query.getOrDefault("compatibilities")
  valid_591466 = validateParameter(valid_591466, JArray, required = false,
                                 default = nil)
  if valid_591466 != nil:
    section.add "compatibilities", valid_591466
  var valid_591467 = query.getOrDefault("sortOrder")
  valid_591467 = validateParameter(valid_591467, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_591467 != nil:
    section.add "sortOrder", valid_591467
  var valid_591468 = query.getOrDefault("directorySiteIds")
  valid_591468 = validateParameter(valid_591468, JArray, required = false,
                                 default = nil)
  if valid_591468 != nil:
    section.add "directorySiteIds", valid_591468
  var valid_591469 = query.getOrDefault("groupIds")
  valid_591469 = validateParameter(valid_591469, JArray, required = false,
                                 default = nil)
  if valid_591469 != nil:
    section.add "groupIds", valid_591469
  var valid_591470 = query.getOrDefault("prettyPrint")
  valid_591470 = validateParameter(valid_591470, JBool, required = false,
                                 default = newJBool(true))
  if valid_591470 != nil:
    section.add "prettyPrint", valid_591470
  var valid_591471 = query.getOrDefault("placementStrategyIds")
  valid_591471 = validateParameter(valid_591471, JArray, required = false,
                                 default = nil)
  if valid_591471 != nil:
    section.add "placementStrategyIds", valid_591471
  var valid_591472 = query.getOrDefault("pricingTypes")
  valid_591472 = validateParameter(valid_591472, JArray, required = false,
                                 default = nil)
  if valid_591472 != nil:
    section.add "pricingTypes", valid_591472
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591473: Call_DfareportingPlacementsList_591440; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of placements, possibly filtered. This method supports paging.
  ## 
  let valid = call_591473.validator(path, query, header, formData, body)
  let scheme = call_591473.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591473.url(scheme.get, call_591473.host, call_591473.base,
                         call_591473.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591473, url, valid)

proc call*(call_591474: Call_DfareportingPlacementsList_591440; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; contentCategoryIds: JsonNode = nil;
          alt: string = "json"; searchString: string = ""; minEndDate: string = "";
          sizeIds: JsonNode = nil; siteIds: JsonNode = nil; oauthToken: string = "";
          maxStartDate: string = ""; campaignIds: JsonNode = nil; userIp: string = "";
          archived: bool = false; maxEndDate: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; advertiserIds: JsonNode = nil;
          minStartDate: string = "";
          paymentSource: string = "PLACEMENT_AGENCY_PAID";
          compatibilities: JsonNode = nil; sortOrder: string = "ASCENDING";
          directorySiteIds: JsonNode = nil; groupIds: JsonNode = nil;
          prettyPrint: bool = true; placementStrategyIds: JsonNode = nil;
          pricingTypes: JsonNode = nil): Recallable =
  ## dfareportingPlacementsList
  ## Retrieves a list of placements, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placements that are associated with these content categories.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for placements by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placements with names like "placement June 2015", "placement May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placement" will match placements with name "my placement", "placement 2015", or simply "placement".
  ##   minEndDate: string
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   sizeIds: JArray
  ##          : Select only placements that are associated with these sizes.
  ##   siteIds: JArray
  ##          : Select only placements that are associated with these sites.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   maxStartDate: string
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   campaignIds: JArray
  ##              : Select only placements that belong to these campaigns.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: bool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   maxEndDate: string
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placements with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only placements that belong to these advertisers.
  ##   minStartDate: string
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   paymentSource: string
  ##                : Select only placements with this payment source.
  ##   compatibilities: JArray
  ##                  : Select only placements that are associated with these compatibilities. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering in in-stream video ads developed with the VAST standard.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only placements that are associated with these directory sites.
  ##   groupIds: JArray
  ##           : Select only placements that belong to these placement groups.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   placementStrategyIds: JArray
  ##                       : Select only placements that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placements with these pricing types.
  var path_591475 = newJObject()
  var query_591476 = newJObject()
  add(path_591475, "profileId", newJString(profileId))
  add(query_591476, "fields", newJString(fields))
  add(query_591476, "pageToken", newJString(pageToken))
  add(query_591476, "quotaUser", newJString(quotaUser))
  add(query_591476, "sortField", newJString(sortField))
  if contentCategoryIds != nil:
    query_591476.add "contentCategoryIds", contentCategoryIds
  add(query_591476, "alt", newJString(alt))
  add(query_591476, "searchString", newJString(searchString))
  add(query_591476, "minEndDate", newJString(minEndDate))
  if sizeIds != nil:
    query_591476.add "sizeIds", sizeIds
  if siteIds != nil:
    query_591476.add "siteIds", siteIds
  add(query_591476, "oauth_token", newJString(oauthToken))
  add(query_591476, "maxStartDate", newJString(maxStartDate))
  if campaignIds != nil:
    query_591476.add "campaignIds", campaignIds
  add(query_591476, "userIp", newJString(userIp))
  add(query_591476, "archived", newJBool(archived))
  add(query_591476, "maxEndDate", newJString(maxEndDate))
  add(query_591476, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_591476.add "ids", ids
  add(query_591476, "key", newJString(key))
  if advertiserIds != nil:
    query_591476.add "advertiserIds", advertiserIds
  add(query_591476, "minStartDate", newJString(minStartDate))
  add(query_591476, "paymentSource", newJString(paymentSource))
  if compatibilities != nil:
    query_591476.add "compatibilities", compatibilities
  add(query_591476, "sortOrder", newJString(sortOrder))
  if directorySiteIds != nil:
    query_591476.add "directorySiteIds", directorySiteIds
  if groupIds != nil:
    query_591476.add "groupIds", groupIds
  add(query_591476, "prettyPrint", newJBool(prettyPrint))
  if placementStrategyIds != nil:
    query_591476.add "placementStrategyIds", placementStrategyIds
  if pricingTypes != nil:
    query_591476.add "pricingTypes", pricingTypes
  result = call_591474.call(path_591475, query_591476, nil, nil, nil)

var dfareportingPlacementsList* = Call_DfareportingPlacementsList_591440(
    name: "dfareportingPlacementsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsList_591441,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsList_591442,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsPatch_591511 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementsPatch_591513(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsPatch_591512(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591514 = path.getOrDefault("profileId")
  valid_591514 = validateParameter(valid_591514, JString, required = true,
                                 default = nil)
  if valid_591514 != nil:
    section.add "profileId", valid_591514
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Placement ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591515 = query.getOrDefault("fields")
  valid_591515 = validateParameter(valid_591515, JString, required = false,
                                 default = nil)
  if valid_591515 != nil:
    section.add "fields", valid_591515
  var valid_591516 = query.getOrDefault("quotaUser")
  valid_591516 = validateParameter(valid_591516, JString, required = false,
                                 default = nil)
  if valid_591516 != nil:
    section.add "quotaUser", valid_591516
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_591517 = query.getOrDefault("id")
  valid_591517 = validateParameter(valid_591517, JString, required = true,
                                 default = nil)
  if valid_591517 != nil:
    section.add "id", valid_591517
  var valid_591518 = query.getOrDefault("alt")
  valid_591518 = validateParameter(valid_591518, JString, required = false,
                                 default = newJString("json"))
  if valid_591518 != nil:
    section.add "alt", valid_591518
  var valid_591519 = query.getOrDefault("oauth_token")
  valid_591519 = validateParameter(valid_591519, JString, required = false,
                                 default = nil)
  if valid_591519 != nil:
    section.add "oauth_token", valid_591519
  var valid_591520 = query.getOrDefault("userIp")
  valid_591520 = validateParameter(valid_591520, JString, required = false,
                                 default = nil)
  if valid_591520 != nil:
    section.add "userIp", valid_591520
  var valid_591521 = query.getOrDefault("key")
  valid_591521 = validateParameter(valid_591521, JString, required = false,
                                 default = nil)
  if valid_591521 != nil:
    section.add "key", valid_591521
  var valid_591522 = query.getOrDefault("prettyPrint")
  valid_591522 = validateParameter(valid_591522, JBool, required = false,
                                 default = newJBool(true))
  if valid_591522 != nil:
    section.add "prettyPrint", valid_591522
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591524: Call_DfareportingPlacementsPatch_591511; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing placement. This method supports patch semantics.
  ## 
  let valid = call_591524.validator(path, query, header, formData, body)
  let scheme = call_591524.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591524.url(scheme.get, call_591524.host, call_591524.base,
                         call_591524.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591524, url, valid)

proc call*(call_591525: Call_DfareportingPlacementsPatch_591511; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementsPatch
  ## Updates an existing placement. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Placement ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591526 = newJObject()
  var query_591527 = newJObject()
  var body_591528 = newJObject()
  add(path_591526, "profileId", newJString(profileId))
  add(query_591527, "fields", newJString(fields))
  add(query_591527, "quotaUser", newJString(quotaUser))
  add(query_591527, "id", newJString(id))
  add(query_591527, "alt", newJString(alt))
  add(query_591527, "oauth_token", newJString(oauthToken))
  add(query_591527, "userIp", newJString(userIp))
  add(query_591527, "key", newJString(key))
  if body != nil:
    body_591528 = body
  add(query_591527, "prettyPrint", newJBool(prettyPrint))
  result = call_591525.call(path_591526, query_591527, nil, nil, body_591528)

var dfareportingPlacementsPatch* = Call_DfareportingPlacementsPatch_591511(
    name: "dfareportingPlacementsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsPatch_591512,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsPatch_591513,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsGeneratetags_591529 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementsGeneratetags_591531(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements/generatetags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsGeneratetags_591530(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Generates tags for a placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591532 = path.getOrDefault("profileId")
  valid_591532 = validateParameter(valid_591532, JString, required = true,
                                 default = nil)
  if valid_591532 != nil:
    section.add "profileId", valid_591532
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: JString
  ##             : Generate placements belonging to this campaign. This is a required field.
  ##   tagFormats: JArray
  ##             : Tag formats to generate for these placements.
  ## 
  ## Note: PLACEMENT_TAG_STANDARD can only be generated for 1x1 placements.
  ##   placementIds: JArray
  ##               : Generate tags for these placements.
  section = newJObject()
  var valid_591533 = query.getOrDefault("fields")
  valid_591533 = validateParameter(valid_591533, JString, required = false,
                                 default = nil)
  if valid_591533 != nil:
    section.add "fields", valid_591533
  var valid_591534 = query.getOrDefault("quotaUser")
  valid_591534 = validateParameter(valid_591534, JString, required = false,
                                 default = nil)
  if valid_591534 != nil:
    section.add "quotaUser", valid_591534
  var valid_591535 = query.getOrDefault("alt")
  valid_591535 = validateParameter(valid_591535, JString, required = false,
                                 default = newJString("json"))
  if valid_591535 != nil:
    section.add "alt", valid_591535
  var valid_591536 = query.getOrDefault("oauth_token")
  valid_591536 = validateParameter(valid_591536, JString, required = false,
                                 default = nil)
  if valid_591536 != nil:
    section.add "oauth_token", valid_591536
  var valid_591537 = query.getOrDefault("userIp")
  valid_591537 = validateParameter(valid_591537, JString, required = false,
                                 default = nil)
  if valid_591537 != nil:
    section.add "userIp", valid_591537
  var valid_591538 = query.getOrDefault("key")
  valid_591538 = validateParameter(valid_591538, JString, required = false,
                                 default = nil)
  if valid_591538 != nil:
    section.add "key", valid_591538
  var valid_591539 = query.getOrDefault("prettyPrint")
  valid_591539 = validateParameter(valid_591539, JBool, required = false,
                                 default = newJBool(true))
  if valid_591539 != nil:
    section.add "prettyPrint", valid_591539
  var valid_591540 = query.getOrDefault("campaignId")
  valid_591540 = validateParameter(valid_591540, JString, required = false,
                                 default = nil)
  if valid_591540 != nil:
    section.add "campaignId", valid_591540
  var valid_591541 = query.getOrDefault("tagFormats")
  valid_591541 = validateParameter(valid_591541, JArray, required = false,
                                 default = nil)
  if valid_591541 != nil:
    section.add "tagFormats", valid_591541
  var valid_591542 = query.getOrDefault("placementIds")
  valid_591542 = validateParameter(valid_591542, JArray, required = false,
                                 default = nil)
  if valid_591542 != nil:
    section.add "placementIds", valid_591542
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591543: Call_DfareportingPlacementsGeneratetags_591529;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Generates tags for a placement.
  ## 
  let valid = call_591543.validator(path, query, header, formData, body)
  let scheme = call_591543.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591543.url(scheme.get, call_591543.host, call_591543.base,
                         call_591543.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591543, url, valid)

proc call*(call_591544: Call_DfareportingPlacementsGeneratetags_591529;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true; campaignId: string = "";
          tagFormats: JsonNode = nil; placementIds: JsonNode = nil): Recallable =
  ## dfareportingPlacementsGeneratetags
  ## Generates tags for a placement.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: string
  ##             : Generate placements belonging to this campaign. This is a required field.
  ##   tagFormats: JArray
  ##             : Tag formats to generate for these placements.
  ## 
  ## Note: PLACEMENT_TAG_STANDARD can only be generated for 1x1 placements.
  ##   placementIds: JArray
  ##               : Generate tags for these placements.
  var path_591545 = newJObject()
  var query_591546 = newJObject()
  add(path_591545, "profileId", newJString(profileId))
  add(query_591546, "fields", newJString(fields))
  add(query_591546, "quotaUser", newJString(quotaUser))
  add(query_591546, "alt", newJString(alt))
  add(query_591546, "oauth_token", newJString(oauthToken))
  add(query_591546, "userIp", newJString(userIp))
  add(query_591546, "key", newJString(key))
  add(query_591546, "prettyPrint", newJBool(prettyPrint))
  add(query_591546, "campaignId", newJString(campaignId))
  if tagFormats != nil:
    query_591546.add "tagFormats", tagFormats
  if placementIds != nil:
    query_591546.add "placementIds", placementIds
  result = call_591544.call(path_591545, query_591546, nil, nil, nil)

var dfareportingPlacementsGeneratetags* = Call_DfareportingPlacementsGeneratetags_591529(
    name: "dfareportingPlacementsGeneratetags", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placements/generatetags",
    validator: validate_DfareportingPlacementsGeneratetags_591530,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsGeneratetags_591531,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsGet_591547 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlacementsGet_591549(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsGet_591548(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one placement by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591550 = path.getOrDefault("profileId")
  valid_591550 = validateParameter(valid_591550, JString, required = true,
                                 default = nil)
  if valid_591550 != nil:
    section.add "profileId", valid_591550
  var valid_591551 = path.getOrDefault("id")
  valid_591551 = validateParameter(valid_591551, JString, required = true,
                                 default = nil)
  if valid_591551 != nil:
    section.add "id", valid_591551
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591552 = query.getOrDefault("fields")
  valid_591552 = validateParameter(valid_591552, JString, required = false,
                                 default = nil)
  if valid_591552 != nil:
    section.add "fields", valid_591552
  var valid_591553 = query.getOrDefault("quotaUser")
  valid_591553 = validateParameter(valid_591553, JString, required = false,
                                 default = nil)
  if valid_591553 != nil:
    section.add "quotaUser", valid_591553
  var valid_591554 = query.getOrDefault("alt")
  valid_591554 = validateParameter(valid_591554, JString, required = false,
                                 default = newJString("json"))
  if valid_591554 != nil:
    section.add "alt", valid_591554
  var valid_591555 = query.getOrDefault("oauth_token")
  valid_591555 = validateParameter(valid_591555, JString, required = false,
                                 default = nil)
  if valid_591555 != nil:
    section.add "oauth_token", valid_591555
  var valid_591556 = query.getOrDefault("userIp")
  valid_591556 = validateParameter(valid_591556, JString, required = false,
                                 default = nil)
  if valid_591556 != nil:
    section.add "userIp", valid_591556
  var valid_591557 = query.getOrDefault("key")
  valid_591557 = validateParameter(valid_591557, JString, required = false,
                                 default = nil)
  if valid_591557 != nil:
    section.add "key", valid_591557
  var valid_591558 = query.getOrDefault("prettyPrint")
  valid_591558 = validateParameter(valid_591558, JBool, required = false,
                                 default = newJBool(true))
  if valid_591558 != nil:
    section.add "prettyPrint", valid_591558
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591559: Call_DfareportingPlacementsGet_591547; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one placement by ID.
  ## 
  let valid = call_591559.validator(path, query, header, formData, body)
  let scheme = call_591559.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591559.url(scheme.get, call_591559.host, call_591559.base,
                         call_591559.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591559, url, valid)

proc call*(call_591560: Call_DfareportingPlacementsGet_591547; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementsGet
  ## Gets one placement by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Placement ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591561 = newJObject()
  var query_591562 = newJObject()
  add(path_591561, "profileId", newJString(profileId))
  add(query_591562, "fields", newJString(fields))
  add(query_591562, "quotaUser", newJString(quotaUser))
  add(query_591562, "alt", newJString(alt))
  add(query_591562, "oauth_token", newJString(oauthToken))
  add(query_591562, "userIp", newJString(userIp))
  add(path_591561, "id", newJString(id))
  add(query_591562, "key", newJString(key))
  add(query_591562, "prettyPrint", newJBool(prettyPrint))
  result = call_591560.call(path_591561, query_591562, nil, nil, nil)

var dfareportingPlacementsGet* = Call_DfareportingPlacementsGet_591547(
    name: "dfareportingPlacementsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placements/{id}",
    validator: validate_DfareportingPlacementsGet_591548,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsGet_591549,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlatformTypesList_591563 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlatformTypesList_591565(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/platformTypes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlatformTypesList_591564(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of platform types.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591566 = path.getOrDefault("profileId")
  valid_591566 = validateParameter(valid_591566, JString, required = true,
                                 default = nil)
  if valid_591566 != nil:
    section.add "profileId", valid_591566
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591567 = query.getOrDefault("fields")
  valid_591567 = validateParameter(valid_591567, JString, required = false,
                                 default = nil)
  if valid_591567 != nil:
    section.add "fields", valid_591567
  var valid_591568 = query.getOrDefault("quotaUser")
  valid_591568 = validateParameter(valid_591568, JString, required = false,
                                 default = nil)
  if valid_591568 != nil:
    section.add "quotaUser", valid_591568
  var valid_591569 = query.getOrDefault("alt")
  valid_591569 = validateParameter(valid_591569, JString, required = false,
                                 default = newJString("json"))
  if valid_591569 != nil:
    section.add "alt", valid_591569
  var valid_591570 = query.getOrDefault("oauth_token")
  valid_591570 = validateParameter(valid_591570, JString, required = false,
                                 default = nil)
  if valid_591570 != nil:
    section.add "oauth_token", valid_591570
  var valid_591571 = query.getOrDefault("userIp")
  valid_591571 = validateParameter(valid_591571, JString, required = false,
                                 default = nil)
  if valid_591571 != nil:
    section.add "userIp", valid_591571
  var valid_591572 = query.getOrDefault("key")
  valid_591572 = validateParameter(valid_591572, JString, required = false,
                                 default = nil)
  if valid_591572 != nil:
    section.add "key", valid_591572
  var valid_591573 = query.getOrDefault("prettyPrint")
  valid_591573 = validateParameter(valid_591573, JBool, required = false,
                                 default = newJBool(true))
  if valid_591573 != nil:
    section.add "prettyPrint", valid_591573
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591574: Call_DfareportingPlatformTypesList_591563; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of platform types.
  ## 
  let valid = call_591574.validator(path, query, header, formData, body)
  let scheme = call_591574.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591574.url(scheme.get, call_591574.host, call_591574.base,
                         call_591574.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591574, url, valid)

proc call*(call_591575: Call_DfareportingPlatformTypesList_591563;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlatformTypesList
  ## Retrieves a list of platform types.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591576 = newJObject()
  var query_591577 = newJObject()
  add(path_591576, "profileId", newJString(profileId))
  add(query_591577, "fields", newJString(fields))
  add(query_591577, "quotaUser", newJString(quotaUser))
  add(query_591577, "alt", newJString(alt))
  add(query_591577, "oauth_token", newJString(oauthToken))
  add(query_591577, "userIp", newJString(userIp))
  add(query_591577, "key", newJString(key))
  add(query_591577, "prettyPrint", newJBool(prettyPrint))
  result = call_591575.call(path_591576, query_591577, nil, nil, nil)

var dfareportingPlatformTypesList* = Call_DfareportingPlatformTypesList_591563(
    name: "dfareportingPlatformTypesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/platformTypes",
    validator: validate_DfareportingPlatformTypesList_591564,
    base: "/dfareporting/v2.7", url: url_DfareportingPlatformTypesList_591565,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlatformTypesGet_591578 = ref object of OpenApiRestCall_588466
proc url_DfareportingPlatformTypesGet_591580(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/platformTypes/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlatformTypesGet_591579(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one platform type by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Platform type ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591581 = path.getOrDefault("profileId")
  valid_591581 = validateParameter(valid_591581, JString, required = true,
                                 default = nil)
  if valid_591581 != nil:
    section.add "profileId", valid_591581
  var valid_591582 = path.getOrDefault("id")
  valid_591582 = validateParameter(valid_591582, JString, required = true,
                                 default = nil)
  if valid_591582 != nil:
    section.add "id", valid_591582
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591583 = query.getOrDefault("fields")
  valid_591583 = validateParameter(valid_591583, JString, required = false,
                                 default = nil)
  if valid_591583 != nil:
    section.add "fields", valid_591583
  var valid_591584 = query.getOrDefault("quotaUser")
  valid_591584 = validateParameter(valid_591584, JString, required = false,
                                 default = nil)
  if valid_591584 != nil:
    section.add "quotaUser", valid_591584
  var valid_591585 = query.getOrDefault("alt")
  valid_591585 = validateParameter(valid_591585, JString, required = false,
                                 default = newJString("json"))
  if valid_591585 != nil:
    section.add "alt", valid_591585
  var valid_591586 = query.getOrDefault("oauth_token")
  valid_591586 = validateParameter(valid_591586, JString, required = false,
                                 default = nil)
  if valid_591586 != nil:
    section.add "oauth_token", valid_591586
  var valid_591587 = query.getOrDefault("userIp")
  valid_591587 = validateParameter(valid_591587, JString, required = false,
                                 default = nil)
  if valid_591587 != nil:
    section.add "userIp", valid_591587
  var valid_591588 = query.getOrDefault("key")
  valid_591588 = validateParameter(valid_591588, JString, required = false,
                                 default = nil)
  if valid_591588 != nil:
    section.add "key", valid_591588
  var valid_591589 = query.getOrDefault("prettyPrint")
  valid_591589 = validateParameter(valid_591589, JBool, required = false,
                                 default = newJBool(true))
  if valid_591589 != nil:
    section.add "prettyPrint", valid_591589
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591590: Call_DfareportingPlatformTypesGet_591578; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one platform type by ID.
  ## 
  let valid = call_591590.validator(path, query, header, formData, body)
  let scheme = call_591590.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591590.url(scheme.get, call_591590.host, call_591590.base,
                         call_591590.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591590, url, valid)

proc call*(call_591591: Call_DfareportingPlatformTypesGet_591578;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlatformTypesGet
  ## Gets one platform type by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Platform type ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591592 = newJObject()
  var query_591593 = newJObject()
  add(path_591592, "profileId", newJString(profileId))
  add(query_591593, "fields", newJString(fields))
  add(query_591593, "quotaUser", newJString(quotaUser))
  add(query_591593, "alt", newJString(alt))
  add(query_591593, "oauth_token", newJString(oauthToken))
  add(query_591593, "userIp", newJString(userIp))
  add(path_591592, "id", newJString(id))
  add(query_591593, "key", newJString(key))
  add(query_591593, "prettyPrint", newJBool(prettyPrint))
  result = call_591591.call(path_591592, query_591593, nil, nil, nil)

var dfareportingPlatformTypesGet* = Call_DfareportingPlatformTypesGet_591578(
    name: "dfareportingPlatformTypesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/platformTypes/{id}",
    validator: validate_DfareportingPlatformTypesGet_591579,
    base: "/dfareporting/v2.7", url: url_DfareportingPlatformTypesGet_591580,
    schemes: {Scheme.Https})
type
  Call_DfareportingPostalCodesList_591594 = ref object of OpenApiRestCall_588466
proc url_DfareportingPostalCodesList_591596(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/postalCodes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPostalCodesList_591595(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of postal codes.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591597 = path.getOrDefault("profileId")
  valid_591597 = validateParameter(valid_591597, JString, required = true,
                                 default = nil)
  if valid_591597 != nil:
    section.add "profileId", valid_591597
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591598 = query.getOrDefault("fields")
  valid_591598 = validateParameter(valid_591598, JString, required = false,
                                 default = nil)
  if valid_591598 != nil:
    section.add "fields", valid_591598
  var valid_591599 = query.getOrDefault("quotaUser")
  valid_591599 = validateParameter(valid_591599, JString, required = false,
                                 default = nil)
  if valid_591599 != nil:
    section.add "quotaUser", valid_591599
  var valid_591600 = query.getOrDefault("alt")
  valid_591600 = validateParameter(valid_591600, JString, required = false,
                                 default = newJString("json"))
  if valid_591600 != nil:
    section.add "alt", valid_591600
  var valid_591601 = query.getOrDefault("oauth_token")
  valid_591601 = validateParameter(valid_591601, JString, required = false,
                                 default = nil)
  if valid_591601 != nil:
    section.add "oauth_token", valid_591601
  var valid_591602 = query.getOrDefault("userIp")
  valid_591602 = validateParameter(valid_591602, JString, required = false,
                                 default = nil)
  if valid_591602 != nil:
    section.add "userIp", valid_591602
  var valid_591603 = query.getOrDefault("key")
  valid_591603 = validateParameter(valid_591603, JString, required = false,
                                 default = nil)
  if valid_591603 != nil:
    section.add "key", valid_591603
  var valid_591604 = query.getOrDefault("prettyPrint")
  valid_591604 = validateParameter(valid_591604, JBool, required = false,
                                 default = newJBool(true))
  if valid_591604 != nil:
    section.add "prettyPrint", valid_591604
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591605: Call_DfareportingPostalCodesList_591594; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of postal codes.
  ## 
  let valid = call_591605.validator(path, query, header, formData, body)
  let scheme = call_591605.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591605.url(scheme.get, call_591605.host, call_591605.base,
                         call_591605.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591605, url, valid)

proc call*(call_591606: Call_DfareportingPostalCodesList_591594; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingPostalCodesList
  ## Retrieves a list of postal codes.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591607 = newJObject()
  var query_591608 = newJObject()
  add(path_591607, "profileId", newJString(profileId))
  add(query_591608, "fields", newJString(fields))
  add(query_591608, "quotaUser", newJString(quotaUser))
  add(query_591608, "alt", newJString(alt))
  add(query_591608, "oauth_token", newJString(oauthToken))
  add(query_591608, "userIp", newJString(userIp))
  add(query_591608, "key", newJString(key))
  add(query_591608, "prettyPrint", newJBool(prettyPrint))
  result = call_591606.call(path_591607, query_591608, nil, nil, nil)

var dfareportingPostalCodesList* = Call_DfareportingPostalCodesList_591594(
    name: "dfareportingPostalCodesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/postalCodes",
    validator: validate_DfareportingPostalCodesList_591595,
    base: "/dfareporting/v2.7", url: url_DfareportingPostalCodesList_591596,
    schemes: {Scheme.Https})
type
  Call_DfareportingPostalCodesGet_591609 = ref object of OpenApiRestCall_588466
proc url_DfareportingPostalCodesGet_591611(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "code" in path, "`code` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/postalCodes/"),
               (kind: VariableSegment, value: "code")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPostalCodesGet_591610(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one postal code by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   code: JString (required)
  ##       : Postal code ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591612 = path.getOrDefault("profileId")
  valid_591612 = validateParameter(valid_591612, JString, required = true,
                                 default = nil)
  if valid_591612 != nil:
    section.add "profileId", valid_591612
  var valid_591613 = path.getOrDefault("code")
  valid_591613 = validateParameter(valid_591613, JString, required = true,
                                 default = nil)
  if valid_591613 != nil:
    section.add "code", valid_591613
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591614 = query.getOrDefault("fields")
  valid_591614 = validateParameter(valid_591614, JString, required = false,
                                 default = nil)
  if valid_591614 != nil:
    section.add "fields", valid_591614
  var valid_591615 = query.getOrDefault("quotaUser")
  valid_591615 = validateParameter(valid_591615, JString, required = false,
                                 default = nil)
  if valid_591615 != nil:
    section.add "quotaUser", valid_591615
  var valid_591616 = query.getOrDefault("alt")
  valid_591616 = validateParameter(valid_591616, JString, required = false,
                                 default = newJString("json"))
  if valid_591616 != nil:
    section.add "alt", valid_591616
  var valid_591617 = query.getOrDefault("oauth_token")
  valid_591617 = validateParameter(valid_591617, JString, required = false,
                                 default = nil)
  if valid_591617 != nil:
    section.add "oauth_token", valid_591617
  var valid_591618 = query.getOrDefault("userIp")
  valid_591618 = validateParameter(valid_591618, JString, required = false,
                                 default = nil)
  if valid_591618 != nil:
    section.add "userIp", valid_591618
  var valid_591619 = query.getOrDefault("key")
  valid_591619 = validateParameter(valid_591619, JString, required = false,
                                 default = nil)
  if valid_591619 != nil:
    section.add "key", valid_591619
  var valid_591620 = query.getOrDefault("prettyPrint")
  valid_591620 = validateParameter(valid_591620, JBool, required = false,
                                 default = newJBool(true))
  if valid_591620 != nil:
    section.add "prettyPrint", valid_591620
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591621: Call_DfareportingPostalCodesGet_591609; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one postal code by ID.
  ## 
  let valid = call_591621.validator(path, query, header, formData, body)
  let scheme = call_591621.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591621.url(scheme.get, call_591621.host, call_591621.base,
                         call_591621.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591621, url, valid)

proc call*(call_591622: Call_DfareportingPostalCodesGet_591609; profileId: string;
          code: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingPostalCodesGet
  ## Gets one postal code by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   code: string (required)
  ##       : Postal code ID.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591623 = newJObject()
  var query_591624 = newJObject()
  add(path_591623, "profileId", newJString(profileId))
  add(query_591624, "fields", newJString(fields))
  add(query_591624, "quotaUser", newJString(quotaUser))
  add(query_591624, "alt", newJString(alt))
  add(query_591624, "oauth_token", newJString(oauthToken))
  add(query_591624, "userIp", newJString(userIp))
  add(query_591624, "key", newJString(key))
  add(path_591623, "code", newJString(code))
  add(query_591624, "prettyPrint", newJBool(prettyPrint))
  result = call_591622.call(path_591623, query_591624, nil, nil, nil)

var dfareportingPostalCodesGet* = Call_DfareportingPostalCodesGet_591609(
    name: "dfareportingPostalCodesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/postalCodes/{code}",
    validator: validate_DfareportingPostalCodesGet_591610,
    base: "/dfareporting/v2.7", url: url_DfareportingPostalCodesGet_591611,
    schemes: {Scheme.Https})
type
  Call_DfareportingProjectsList_591625 = ref object of OpenApiRestCall_588466
proc url_DfareportingProjectsList_591627(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingProjectsList_591626(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of projects, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591628 = path.getOrDefault("profileId")
  valid_591628 = validateParameter(valid_591628, JString, required = true,
                                 default = nil)
  if valid_591628 != nil:
    section.add "profileId", valid_591628
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for projects by name or ID. Wildcards (*) are allowed. For example, "project*2015" will return projects with names like "project June 2015", "project April 2015", or simply "project 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "project" will match projects with name "my project", "project 2015", or simply "project".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only projects with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only projects with these advertiser IDs.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591629 = query.getOrDefault("fields")
  valid_591629 = validateParameter(valid_591629, JString, required = false,
                                 default = nil)
  if valid_591629 != nil:
    section.add "fields", valid_591629
  var valid_591630 = query.getOrDefault("pageToken")
  valid_591630 = validateParameter(valid_591630, JString, required = false,
                                 default = nil)
  if valid_591630 != nil:
    section.add "pageToken", valid_591630
  var valid_591631 = query.getOrDefault("quotaUser")
  valid_591631 = validateParameter(valid_591631, JString, required = false,
                                 default = nil)
  if valid_591631 != nil:
    section.add "quotaUser", valid_591631
  var valid_591632 = query.getOrDefault("sortField")
  valid_591632 = validateParameter(valid_591632, JString, required = false,
                                 default = newJString("ID"))
  if valid_591632 != nil:
    section.add "sortField", valid_591632
  var valid_591633 = query.getOrDefault("alt")
  valid_591633 = validateParameter(valid_591633, JString, required = false,
                                 default = newJString("json"))
  if valid_591633 != nil:
    section.add "alt", valid_591633
  var valid_591634 = query.getOrDefault("searchString")
  valid_591634 = validateParameter(valid_591634, JString, required = false,
                                 default = nil)
  if valid_591634 != nil:
    section.add "searchString", valid_591634
  var valid_591635 = query.getOrDefault("oauth_token")
  valid_591635 = validateParameter(valid_591635, JString, required = false,
                                 default = nil)
  if valid_591635 != nil:
    section.add "oauth_token", valid_591635
  var valid_591636 = query.getOrDefault("userIp")
  valid_591636 = validateParameter(valid_591636, JString, required = false,
                                 default = nil)
  if valid_591636 != nil:
    section.add "userIp", valid_591636
  var valid_591637 = query.getOrDefault("maxResults")
  valid_591637 = validateParameter(valid_591637, JInt, required = false,
                                 default = newJInt(1000))
  if valid_591637 != nil:
    section.add "maxResults", valid_591637
  var valid_591638 = query.getOrDefault("ids")
  valid_591638 = validateParameter(valid_591638, JArray, required = false,
                                 default = nil)
  if valid_591638 != nil:
    section.add "ids", valid_591638
  var valid_591639 = query.getOrDefault("key")
  valid_591639 = validateParameter(valid_591639, JString, required = false,
                                 default = nil)
  if valid_591639 != nil:
    section.add "key", valid_591639
  var valid_591640 = query.getOrDefault("advertiserIds")
  valid_591640 = validateParameter(valid_591640, JArray, required = false,
                                 default = nil)
  if valid_591640 != nil:
    section.add "advertiserIds", valid_591640
  var valid_591641 = query.getOrDefault("sortOrder")
  valid_591641 = validateParameter(valid_591641, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_591641 != nil:
    section.add "sortOrder", valid_591641
  var valid_591642 = query.getOrDefault("prettyPrint")
  valid_591642 = validateParameter(valid_591642, JBool, required = false,
                                 default = newJBool(true))
  if valid_591642 != nil:
    section.add "prettyPrint", valid_591642
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591643: Call_DfareportingProjectsList_591625; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of projects, possibly filtered. This method supports paging.
  ## 
  let valid = call_591643.validator(path, query, header, formData, body)
  let scheme = call_591643.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591643.url(scheme.get, call_591643.host, call_591643.base,
                         call_591643.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591643, url, valid)

proc call*(call_591644: Call_DfareportingProjectsList_591625; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; searchString: string = "";
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; advertiserIds: JsonNode = nil;
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingProjectsList
  ## Retrieves a list of projects, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for projects by name or ID. Wildcards (*) are allowed. For example, "project*2015" will return projects with names like "project June 2015", "project April 2015", or simply "project 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "project" will match projects with name "my project", "project 2015", or simply "project".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only projects with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only projects with these advertiser IDs.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591645 = newJObject()
  var query_591646 = newJObject()
  add(path_591645, "profileId", newJString(profileId))
  add(query_591646, "fields", newJString(fields))
  add(query_591646, "pageToken", newJString(pageToken))
  add(query_591646, "quotaUser", newJString(quotaUser))
  add(query_591646, "sortField", newJString(sortField))
  add(query_591646, "alt", newJString(alt))
  add(query_591646, "searchString", newJString(searchString))
  add(query_591646, "oauth_token", newJString(oauthToken))
  add(query_591646, "userIp", newJString(userIp))
  add(query_591646, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_591646.add "ids", ids
  add(query_591646, "key", newJString(key))
  if advertiserIds != nil:
    query_591646.add "advertiserIds", advertiserIds
  add(query_591646, "sortOrder", newJString(sortOrder))
  add(query_591646, "prettyPrint", newJBool(prettyPrint))
  result = call_591644.call(path_591645, query_591646, nil, nil, nil)

var dfareportingProjectsList* = Call_DfareportingProjectsList_591625(
    name: "dfareportingProjectsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects",
    validator: validate_DfareportingProjectsList_591626,
    base: "/dfareporting/v2.7", url: url_DfareportingProjectsList_591627,
    schemes: {Scheme.Https})
type
  Call_DfareportingProjectsGet_591647 = ref object of OpenApiRestCall_588466
proc url_DfareportingProjectsGet_591649(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingProjectsGet_591648(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one project by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Project ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591650 = path.getOrDefault("profileId")
  valid_591650 = validateParameter(valid_591650, JString, required = true,
                                 default = nil)
  if valid_591650 != nil:
    section.add "profileId", valid_591650
  var valid_591651 = path.getOrDefault("id")
  valid_591651 = validateParameter(valid_591651, JString, required = true,
                                 default = nil)
  if valid_591651 != nil:
    section.add "id", valid_591651
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591652 = query.getOrDefault("fields")
  valid_591652 = validateParameter(valid_591652, JString, required = false,
                                 default = nil)
  if valid_591652 != nil:
    section.add "fields", valid_591652
  var valid_591653 = query.getOrDefault("quotaUser")
  valid_591653 = validateParameter(valid_591653, JString, required = false,
                                 default = nil)
  if valid_591653 != nil:
    section.add "quotaUser", valid_591653
  var valid_591654 = query.getOrDefault("alt")
  valid_591654 = validateParameter(valid_591654, JString, required = false,
                                 default = newJString("json"))
  if valid_591654 != nil:
    section.add "alt", valid_591654
  var valid_591655 = query.getOrDefault("oauth_token")
  valid_591655 = validateParameter(valid_591655, JString, required = false,
                                 default = nil)
  if valid_591655 != nil:
    section.add "oauth_token", valid_591655
  var valid_591656 = query.getOrDefault("userIp")
  valid_591656 = validateParameter(valid_591656, JString, required = false,
                                 default = nil)
  if valid_591656 != nil:
    section.add "userIp", valid_591656
  var valid_591657 = query.getOrDefault("key")
  valid_591657 = validateParameter(valid_591657, JString, required = false,
                                 default = nil)
  if valid_591657 != nil:
    section.add "key", valid_591657
  var valid_591658 = query.getOrDefault("prettyPrint")
  valid_591658 = validateParameter(valid_591658, JBool, required = false,
                                 default = newJBool(true))
  if valid_591658 != nil:
    section.add "prettyPrint", valid_591658
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591659: Call_DfareportingProjectsGet_591647; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one project by ID.
  ## 
  let valid = call_591659.validator(path, query, header, formData, body)
  let scheme = call_591659.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591659.url(scheme.get, call_591659.host, call_591659.base,
                         call_591659.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591659, url, valid)

proc call*(call_591660: Call_DfareportingProjectsGet_591647; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingProjectsGet
  ## Gets one project by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Project ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591661 = newJObject()
  var query_591662 = newJObject()
  add(path_591661, "profileId", newJString(profileId))
  add(query_591662, "fields", newJString(fields))
  add(query_591662, "quotaUser", newJString(quotaUser))
  add(query_591662, "alt", newJString(alt))
  add(query_591662, "oauth_token", newJString(oauthToken))
  add(query_591662, "userIp", newJString(userIp))
  add(path_591661, "id", newJString(id))
  add(query_591662, "key", newJString(key))
  add(query_591662, "prettyPrint", newJBool(prettyPrint))
  result = call_591660.call(path_591661, query_591662, nil, nil, nil)

var dfareportingProjectsGet* = Call_DfareportingProjectsGet_591647(
    name: "dfareportingProjectsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects/{id}",
    validator: validate_DfareportingProjectsGet_591648,
    base: "/dfareporting/v2.7", url: url_DfareportingProjectsGet_591649,
    schemes: {Scheme.Https})
type
  Call_DfareportingInventoryItemsList_591663 = ref object of OpenApiRestCall_588466
proc url_DfareportingInventoryItemsList_591665(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/inventoryItems")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingInventoryItemsList_591664(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of inventory items, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591666 = path.getOrDefault("profileId")
  valid_591666 = validateParameter(valid_591666, JString, required = true,
                                 default = nil)
  if valid_591666 != nil:
    section.add "profileId", valid_591666
  var valid_591667 = path.getOrDefault("projectId")
  valid_591667 = validateParameter(valid_591667, JString, required = true,
                                 default = nil)
  if valid_591667 != nil:
    section.add "projectId", valid_591667
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   inPlan: JBool
  ##         : Select only inventory items that are in plan.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   orderId: JArray
  ##          : Select only inventory items that belong to specified orders.
  ##   type: JString
  ##       : Select only inventory items with this type.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only inventory items that are associated with these sites.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only inventory items with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591668 = query.getOrDefault("fields")
  valid_591668 = validateParameter(valid_591668, JString, required = false,
                                 default = nil)
  if valid_591668 != nil:
    section.add "fields", valid_591668
  var valid_591669 = query.getOrDefault("inPlan")
  valid_591669 = validateParameter(valid_591669, JBool, required = false, default = nil)
  if valid_591669 != nil:
    section.add "inPlan", valid_591669
  var valid_591670 = query.getOrDefault("quotaUser")
  valid_591670 = validateParameter(valid_591670, JString, required = false,
                                 default = nil)
  if valid_591670 != nil:
    section.add "quotaUser", valid_591670
  var valid_591671 = query.getOrDefault("pageToken")
  valid_591671 = validateParameter(valid_591671, JString, required = false,
                                 default = nil)
  if valid_591671 != nil:
    section.add "pageToken", valid_591671
  var valid_591672 = query.getOrDefault("sortField")
  valid_591672 = validateParameter(valid_591672, JString, required = false,
                                 default = newJString("ID"))
  if valid_591672 != nil:
    section.add "sortField", valid_591672
  var valid_591673 = query.getOrDefault("alt")
  valid_591673 = validateParameter(valid_591673, JString, required = false,
                                 default = newJString("json"))
  if valid_591673 != nil:
    section.add "alt", valid_591673
  var valid_591674 = query.getOrDefault("orderId")
  valid_591674 = validateParameter(valid_591674, JArray, required = false,
                                 default = nil)
  if valid_591674 != nil:
    section.add "orderId", valid_591674
  var valid_591675 = query.getOrDefault("type")
  valid_591675 = validateParameter(valid_591675, JString, required = false, default = newJString(
      "PLANNING_PLACEMENT_TYPE_CREDIT"))
  if valid_591675 != nil:
    section.add "type", valid_591675
  var valid_591676 = query.getOrDefault("oauth_token")
  valid_591676 = validateParameter(valid_591676, JString, required = false,
                                 default = nil)
  if valid_591676 != nil:
    section.add "oauth_token", valid_591676
  var valid_591677 = query.getOrDefault("userIp")
  valid_591677 = validateParameter(valid_591677, JString, required = false,
                                 default = nil)
  if valid_591677 != nil:
    section.add "userIp", valid_591677
  var valid_591678 = query.getOrDefault("siteId")
  valid_591678 = validateParameter(valid_591678, JArray, required = false,
                                 default = nil)
  if valid_591678 != nil:
    section.add "siteId", valid_591678
  var valid_591679 = query.getOrDefault("maxResults")
  valid_591679 = validateParameter(valid_591679, JInt, required = false,
                                 default = newJInt(1000))
  if valid_591679 != nil:
    section.add "maxResults", valid_591679
  var valid_591680 = query.getOrDefault("ids")
  valid_591680 = validateParameter(valid_591680, JArray, required = false,
                                 default = nil)
  if valid_591680 != nil:
    section.add "ids", valid_591680
  var valid_591681 = query.getOrDefault("key")
  valid_591681 = validateParameter(valid_591681, JString, required = false,
                                 default = nil)
  if valid_591681 != nil:
    section.add "key", valid_591681
  var valid_591682 = query.getOrDefault("sortOrder")
  valid_591682 = validateParameter(valid_591682, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_591682 != nil:
    section.add "sortOrder", valid_591682
  var valid_591683 = query.getOrDefault("prettyPrint")
  valid_591683 = validateParameter(valid_591683, JBool, required = false,
                                 default = newJBool(true))
  if valid_591683 != nil:
    section.add "prettyPrint", valid_591683
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591684: Call_DfareportingInventoryItemsList_591663; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of inventory items, possibly filtered. This method supports paging.
  ## 
  let valid = call_591684.validator(path, query, header, formData, body)
  let scheme = call_591684.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591684.url(scheme.get, call_591684.host, call_591684.base,
                         call_591684.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591684, url, valid)

proc call*(call_591685: Call_DfareportingInventoryItemsList_591663;
          profileId: string; projectId: string; fields: string = "";
          inPlan: bool = false; quotaUser: string = ""; pageToken: string = "";
          sortField: string = "ID"; alt: string = "json"; orderId: JsonNode = nil;
          `type`: string = "PLANNING_PLACEMENT_TYPE_CREDIT";
          oauthToken: string = ""; userIp: string = ""; siteId: JsonNode = nil;
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingInventoryItemsList
  ## Retrieves a list of inventory items, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   inPlan: bool
  ##         : Select only inventory items that are in plan.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   orderId: JArray
  ##          : Select only inventory items that belong to specified orders.
  ##   type: string
  ##       : Select only inventory items with this type.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only inventory items that are associated with these sites.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only inventory items with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591686 = newJObject()
  var query_591687 = newJObject()
  add(path_591686, "profileId", newJString(profileId))
  add(query_591687, "fields", newJString(fields))
  add(query_591687, "inPlan", newJBool(inPlan))
  add(query_591687, "quotaUser", newJString(quotaUser))
  add(query_591687, "pageToken", newJString(pageToken))
  add(query_591687, "sortField", newJString(sortField))
  add(query_591687, "alt", newJString(alt))
  if orderId != nil:
    query_591687.add "orderId", orderId
  add(query_591687, "type", newJString(`type`))
  add(query_591687, "oauth_token", newJString(oauthToken))
  add(query_591687, "userIp", newJString(userIp))
  if siteId != nil:
    query_591687.add "siteId", siteId
  add(query_591687, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_591687.add "ids", ids
  add(query_591687, "key", newJString(key))
  add(path_591686, "projectId", newJString(projectId))
  add(query_591687, "sortOrder", newJString(sortOrder))
  add(query_591687, "prettyPrint", newJBool(prettyPrint))
  result = call_591685.call(path_591686, query_591687, nil, nil, nil)

var dfareportingInventoryItemsList* = Call_DfareportingInventoryItemsList_591663(
    name: "dfareportingInventoryItemsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/inventoryItems",
    validator: validate_DfareportingInventoryItemsList_591664,
    base: "/dfareporting/v2.7", url: url_DfareportingInventoryItemsList_591665,
    schemes: {Scheme.Https})
type
  Call_DfareportingInventoryItemsGet_591688 = ref object of OpenApiRestCall_588466
proc url_DfareportingInventoryItemsGet_591690(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/inventoryItems/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingInventoryItemsGet_591689(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one inventory item by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Inventory item ID.
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591691 = path.getOrDefault("profileId")
  valid_591691 = validateParameter(valid_591691, JString, required = true,
                                 default = nil)
  if valid_591691 != nil:
    section.add "profileId", valid_591691
  var valid_591692 = path.getOrDefault("id")
  valid_591692 = validateParameter(valid_591692, JString, required = true,
                                 default = nil)
  if valid_591692 != nil:
    section.add "id", valid_591692
  var valid_591693 = path.getOrDefault("projectId")
  valid_591693 = validateParameter(valid_591693, JString, required = true,
                                 default = nil)
  if valid_591693 != nil:
    section.add "projectId", valid_591693
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591694 = query.getOrDefault("fields")
  valid_591694 = validateParameter(valid_591694, JString, required = false,
                                 default = nil)
  if valid_591694 != nil:
    section.add "fields", valid_591694
  var valid_591695 = query.getOrDefault("quotaUser")
  valid_591695 = validateParameter(valid_591695, JString, required = false,
                                 default = nil)
  if valid_591695 != nil:
    section.add "quotaUser", valid_591695
  var valid_591696 = query.getOrDefault("alt")
  valid_591696 = validateParameter(valid_591696, JString, required = false,
                                 default = newJString("json"))
  if valid_591696 != nil:
    section.add "alt", valid_591696
  var valid_591697 = query.getOrDefault("oauth_token")
  valid_591697 = validateParameter(valid_591697, JString, required = false,
                                 default = nil)
  if valid_591697 != nil:
    section.add "oauth_token", valid_591697
  var valid_591698 = query.getOrDefault("userIp")
  valid_591698 = validateParameter(valid_591698, JString, required = false,
                                 default = nil)
  if valid_591698 != nil:
    section.add "userIp", valid_591698
  var valid_591699 = query.getOrDefault("key")
  valid_591699 = validateParameter(valid_591699, JString, required = false,
                                 default = nil)
  if valid_591699 != nil:
    section.add "key", valid_591699
  var valid_591700 = query.getOrDefault("prettyPrint")
  valid_591700 = validateParameter(valid_591700, JBool, required = false,
                                 default = newJBool(true))
  if valid_591700 != nil:
    section.add "prettyPrint", valid_591700
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591701: Call_DfareportingInventoryItemsGet_591688; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one inventory item by ID.
  ## 
  let valid = call_591701.validator(path, query, header, formData, body)
  let scheme = call_591701.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591701.url(scheme.get, call_591701.host, call_591701.base,
                         call_591701.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591701, url, valid)

proc call*(call_591702: Call_DfareportingInventoryItemsGet_591688;
          profileId: string; id: string; projectId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingInventoryItemsGet
  ## Gets one inventory item by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Inventory item ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591703 = newJObject()
  var query_591704 = newJObject()
  add(path_591703, "profileId", newJString(profileId))
  add(query_591704, "fields", newJString(fields))
  add(query_591704, "quotaUser", newJString(quotaUser))
  add(query_591704, "alt", newJString(alt))
  add(query_591704, "oauth_token", newJString(oauthToken))
  add(query_591704, "userIp", newJString(userIp))
  add(path_591703, "id", newJString(id))
  add(query_591704, "key", newJString(key))
  add(path_591703, "projectId", newJString(projectId))
  add(query_591704, "prettyPrint", newJBool(prettyPrint))
  result = call_591702.call(path_591703, query_591704, nil, nil, nil)

var dfareportingInventoryItemsGet* = Call_DfareportingInventoryItemsGet_591688(
    name: "dfareportingInventoryItemsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects/{projectId}/inventoryItems/{id}",
    validator: validate_DfareportingInventoryItemsGet_591689,
    base: "/dfareporting/v2.7", url: url_DfareportingInventoryItemsGet_591690,
    schemes: {Scheme.Https})
type
  Call_DfareportingOrderDocumentsList_591705 = ref object of OpenApiRestCall_588466
proc url_DfareportingOrderDocumentsList_591707(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orderDocuments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrderDocumentsList_591706(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of order documents, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591708 = path.getOrDefault("profileId")
  valid_591708 = validateParameter(valid_591708, JString, required = true,
                                 default = nil)
  if valid_591708 != nil:
    section.add "profileId", valid_591708
  var valid_591709 = path.getOrDefault("projectId")
  valid_591709 = validateParameter(valid_591709, JString, required = true,
                                 default = nil)
  if valid_591709 != nil:
    section.add "projectId", valid_591709
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for order documents by name or ID. Wildcards (*) are allowed. For example, "orderdocument*2015" will return order documents with names like "orderdocument June 2015", "orderdocument April 2015", or simply "orderdocument 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "orderdocument" will match order documents with name "my orderdocument", "orderdocument 2015", or simply "orderdocument".
  ##   orderId: JArray
  ##          : Select only order documents for specified orders.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only order documents that are associated with these sites.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only order documents with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   approved: JBool
  ##           : Select only order documents that have been approved by at least one user.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591710 = query.getOrDefault("fields")
  valid_591710 = validateParameter(valid_591710, JString, required = false,
                                 default = nil)
  if valid_591710 != nil:
    section.add "fields", valid_591710
  var valid_591711 = query.getOrDefault("pageToken")
  valid_591711 = validateParameter(valid_591711, JString, required = false,
                                 default = nil)
  if valid_591711 != nil:
    section.add "pageToken", valid_591711
  var valid_591712 = query.getOrDefault("quotaUser")
  valid_591712 = validateParameter(valid_591712, JString, required = false,
                                 default = nil)
  if valid_591712 != nil:
    section.add "quotaUser", valid_591712
  var valid_591713 = query.getOrDefault("sortField")
  valid_591713 = validateParameter(valid_591713, JString, required = false,
                                 default = newJString("ID"))
  if valid_591713 != nil:
    section.add "sortField", valid_591713
  var valid_591714 = query.getOrDefault("alt")
  valid_591714 = validateParameter(valid_591714, JString, required = false,
                                 default = newJString("json"))
  if valid_591714 != nil:
    section.add "alt", valid_591714
  var valid_591715 = query.getOrDefault("searchString")
  valid_591715 = validateParameter(valid_591715, JString, required = false,
                                 default = nil)
  if valid_591715 != nil:
    section.add "searchString", valid_591715
  var valid_591716 = query.getOrDefault("orderId")
  valid_591716 = validateParameter(valid_591716, JArray, required = false,
                                 default = nil)
  if valid_591716 != nil:
    section.add "orderId", valid_591716
  var valid_591717 = query.getOrDefault("oauth_token")
  valid_591717 = validateParameter(valid_591717, JString, required = false,
                                 default = nil)
  if valid_591717 != nil:
    section.add "oauth_token", valid_591717
  var valid_591718 = query.getOrDefault("userIp")
  valid_591718 = validateParameter(valid_591718, JString, required = false,
                                 default = nil)
  if valid_591718 != nil:
    section.add "userIp", valid_591718
  var valid_591719 = query.getOrDefault("siteId")
  valid_591719 = validateParameter(valid_591719, JArray, required = false,
                                 default = nil)
  if valid_591719 != nil:
    section.add "siteId", valid_591719
  var valid_591720 = query.getOrDefault("maxResults")
  valid_591720 = validateParameter(valid_591720, JInt, required = false,
                                 default = newJInt(1000))
  if valid_591720 != nil:
    section.add "maxResults", valid_591720
  var valid_591721 = query.getOrDefault("ids")
  valid_591721 = validateParameter(valid_591721, JArray, required = false,
                                 default = nil)
  if valid_591721 != nil:
    section.add "ids", valid_591721
  var valid_591722 = query.getOrDefault("key")
  valid_591722 = validateParameter(valid_591722, JString, required = false,
                                 default = nil)
  if valid_591722 != nil:
    section.add "key", valid_591722
  var valid_591723 = query.getOrDefault("sortOrder")
  valid_591723 = validateParameter(valid_591723, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_591723 != nil:
    section.add "sortOrder", valid_591723
  var valid_591724 = query.getOrDefault("approved")
  valid_591724 = validateParameter(valid_591724, JBool, required = false, default = nil)
  if valid_591724 != nil:
    section.add "approved", valid_591724
  var valid_591725 = query.getOrDefault("prettyPrint")
  valid_591725 = validateParameter(valid_591725, JBool, required = false,
                                 default = newJBool(true))
  if valid_591725 != nil:
    section.add "prettyPrint", valid_591725
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591726: Call_DfareportingOrderDocumentsList_591705; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of order documents, possibly filtered. This method supports paging.
  ## 
  let valid = call_591726.validator(path, query, header, formData, body)
  let scheme = call_591726.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591726.url(scheme.get, call_591726.host, call_591726.base,
                         call_591726.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591726, url, valid)

proc call*(call_591727: Call_DfareportingOrderDocumentsList_591705;
          profileId: string; projectId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; searchString: string = ""; orderId: JsonNode = nil;
          oauthToken: string = ""; userIp: string = ""; siteId: JsonNode = nil;
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; approved: bool = false;
          prettyPrint: bool = true): Recallable =
  ## dfareportingOrderDocumentsList
  ## Retrieves a list of order documents, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for order documents by name or ID. Wildcards (*) are allowed. For example, "orderdocument*2015" will return order documents with names like "orderdocument June 2015", "orderdocument April 2015", or simply "orderdocument 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "orderdocument" will match order documents with name "my orderdocument", "orderdocument 2015", or simply "orderdocument".
  ##   orderId: JArray
  ##          : Select only order documents for specified orders.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only order documents that are associated with these sites.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only order documents with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   approved: bool
  ##           : Select only order documents that have been approved by at least one user.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591728 = newJObject()
  var query_591729 = newJObject()
  add(path_591728, "profileId", newJString(profileId))
  add(query_591729, "fields", newJString(fields))
  add(query_591729, "pageToken", newJString(pageToken))
  add(query_591729, "quotaUser", newJString(quotaUser))
  add(query_591729, "sortField", newJString(sortField))
  add(query_591729, "alt", newJString(alt))
  add(query_591729, "searchString", newJString(searchString))
  if orderId != nil:
    query_591729.add "orderId", orderId
  add(query_591729, "oauth_token", newJString(oauthToken))
  add(query_591729, "userIp", newJString(userIp))
  if siteId != nil:
    query_591729.add "siteId", siteId
  add(query_591729, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_591729.add "ids", ids
  add(query_591729, "key", newJString(key))
  add(path_591728, "projectId", newJString(projectId))
  add(query_591729, "sortOrder", newJString(sortOrder))
  add(query_591729, "approved", newJBool(approved))
  add(query_591729, "prettyPrint", newJBool(prettyPrint))
  result = call_591727.call(path_591728, query_591729, nil, nil, nil)

var dfareportingOrderDocumentsList* = Call_DfareportingOrderDocumentsList_591705(
    name: "dfareportingOrderDocumentsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/orderDocuments",
    validator: validate_DfareportingOrderDocumentsList_591706,
    base: "/dfareporting/v2.7", url: url_DfareportingOrderDocumentsList_591707,
    schemes: {Scheme.Https})
type
  Call_DfareportingOrderDocumentsGet_591730 = ref object of OpenApiRestCall_588466
proc url_DfareportingOrderDocumentsGet_591732(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orderDocuments/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrderDocumentsGet_591731(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one order document by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Order document ID.
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591733 = path.getOrDefault("profileId")
  valid_591733 = validateParameter(valid_591733, JString, required = true,
                                 default = nil)
  if valid_591733 != nil:
    section.add "profileId", valid_591733
  var valid_591734 = path.getOrDefault("id")
  valid_591734 = validateParameter(valid_591734, JString, required = true,
                                 default = nil)
  if valid_591734 != nil:
    section.add "id", valid_591734
  var valid_591735 = path.getOrDefault("projectId")
  valid_591735 = validateParameter(valid_591735, JString, required = true,
                                 default = nil)
  if valid_591735 != nil:
    section.add "projectId", valid_591735
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591736 = query.getOrDefault("fields")
  valid_591736 = validateParameter(valid_591736, JString, required = false,
                                 default = nil)
  if valid_591736 != nil:
    section.add "fields", valid_591736
  var valid_591737 = query.getOrDefault("quotaUser")
  valid_591737 = validateParameter(valid_591737, JString, required = false,
                                 default = nil)
  if valid_591737 != nil:
    section.add "quotaUser", valid_591737
  var valid_591738 = query.getOrDefault("alt")
  valid_591738 = validateParameter(valid_591738, JString, required = false,
                                 default = newJString("json"))
  if valid_591738 != nil:
    section.add "alt", valid_591738
  var valid_591739 = query.getOrDefault("oauth_token")
  valid_591739 = validateParameter(valid_591739, JString, required = false,
                                 default = nil)
  if valid_591739 != nil:
    section.add "oauth_token", valid_591739
  var valid_591740 = query.getOrDefault("userIp")
  valid_591740 = validateParameter(valid_591740, JString, required = false,
                                 default = nil)
  if valid_591740 != nil:
    section.add "userIp", valid_591740
  var valid_591741 = query.getOrDefault("key")
  valid_591741 = validateParameter(valid_591741, JString, required = false,
                                 default = nil)
  if valid_591741 != nil:
    section.add "key", valid_591741
  var valid_591742 = query.getOrDefault("prettyPrint")
  valid_591742 = validateParameter(valid_591742, JBool, required = false,
                                 default = newJBool(true))
  if valid_591742 != nil:
    section.add "prettyPrint", valid_591742
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591743: Call_DfareportingOrderDocumentsGet_591730; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one order document by ID.
  ## 
  let valid = call_591743.validator(path, query, header, formData, body)
  let scheme = call_591743.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591743.url(scheme.get, call_591743.host, call_591743.base,
                         call_591743.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591743, url, valid)

proc call*(call_591744: Call_DfareportingOrderDocumentsGet_591730;
          profileId: string; id: string; projectId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOrderDocumentsGet
  ## Gets one order document by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Order document ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591745 = newJObject()
  var query_591746 = newJObject()
  add(path_591745, "profileId", newJString(profileId))
  add(query_591746, "fields", newJString(fields))
  add(query_591746, "quotaUser", newJString(quotaUser))
  add(query_591746, "alt", newJString(alt))
  add(query_591746, "oauth_token", newJString(oauthToken))
  add(query_591746, "userIp", newJString(userIp))
  add(path_591745, "id", newJString(id))
  add(query_591746, "key", newJString(key))
  add(path_591745, "projectId", newJString(projectId))
  add(query_591746, "prettyPrint", newJBool(prettyPrint))
  result = call_591744.call(path_591745, query_591746, nil, nil, nil)

var dfareportingOrderDocumentsGet* = Call_DfareportingOrderDocumentsGet_591730(
    name: "dfareportingOrderDocumentsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects/{projectId}/orderDocuments/{id}",
    validator: validate_DfareportingOrderDocumentsGet_591731,
    base: "/dfareporting/v2.7", url: url_DfareportingOrderDocumentsGet_591732,
    schemes: {Scheme.Https})
type
  Call_DfareportingOrdersList_591747 = ref object of OpenApiRestCall_588466
proc url_DfareportingOrdersList_591749(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orders")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrdersList_591748(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of orders, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   projectId: JString (required)
  ##            : Project ID for orders.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591750 = path.getOrDefault("profileId")
  valid_591750 = validateParameter(valid_591750, JString, required = true,
                                 default = nil)
  if valid_591750 != nil:
    section.add "profileId", valid_591750
  var valid_591751 = path.getOrDefault("projectId")
  valid_591751 = validateParameter(valid_591751, JString, required = true,
                                 default = nil)
  if valid_591751 != nil:
    section.add "projectId", valid_591751
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for orders by name or ID. Wildcards (*) are allowed. For example, "order*2015" will return orders with names like "order June 2015", "order April 2015", or simply "order 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "order" will match orders with name "my order", "order 2015", or simply "order".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only orders that are associated with these site IDs.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only orders with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591752 = query.getOrDefault("fields")
  valid_591752 = validateParameter(valid_591752, JString, required = false,
                                 default = nil)
  if valid_591752 != nil:
    section.add "fields", valid_591752
  var valid_591753 = query.getOrDefault("pageToken")
  valid_591753 = validateParameter(valid_591753, JString, required = false,
                                 default = nil)
  if valid_591753 != nil:
    section.add "pageToken", valid_591753
  var valid_591754 = query.getOrDefault("quotaUser")
  valid_591754 = validateParameter(valid_591754, JString, required = false,
                                 default = nil)
  if valid_591754 != nil:
    section.add "quotaUser", valid_591754
  var valid_591755 = query.getOrDefault("sortField")
  valid_591755 = validateParameter(valid_591755, JString, required = false,
                                 default = newJString("ID"))
  if valid_591755 != nil:
    section.add "sortField", valid_591755
  var valid_591756 = query.getOrDefault("alt")
  valid_591756 = validateParameter(valid_591756, JString, required = false,
                                 default = newJString("json"))
  if valid_591756 != nil:
    section.add "alt", valid_591756
  var valid_591757 = query.getOrDefault("searchString")
  valid_591757 = validateParameter(valid_591757, JString, required = false,
                                 default = nil)
  if valid_591757 != nil:
    section.add "searchString", valid_591757
  var valid_591758 = query.getOrDefault("oauth_token")
  valid_591758 = validateParameter(valid_591758, JString, required = false,
                                 default = nil)
  if valid_591758 != nil:
    section.add "oauth_token", valid_591758
  var valid_591759 = query.getOrDefault("userIp")
  valid_591759 = validateParameter(valid_591759, JString, required = false,
                                 default = nil)
  if valid_591759 != nil:
    section.add "userIp", valid_591759
  var valid_591760 = query.getOrDefault("siteId")
  valid_591760 = validateParameter(valid_591760, JArray, required = false,
                                 default = nil)
  if valid_591760 != nil:
    section.add "siteId", valid_591760
  var valid_591761 = query.getOrDefault("maxResults")
  valid_591761 = validateParameter(valid_591761, JInt, required = false,
                                 default = newJInt(1000))
  if valid_591761 != nil:
    section.add "maxResults", valid_591761
  var valid_591762 = query.getOrDefault("ids")
  valid_591762 = validateParameter(valid_591762, JArray, required = false,
                                 default = nil)
  if valid_591762 != nil:
    section.add "ids", valid_591762
  var valid_591763 = query.getOrDefault("key")
  valid_591763 = validateParameter(valid_591763, JString, required = false,
                                 default = nil)
  if valid_591763 != nil:
    section.add "key", valid_591763
  var valid_591764 = query.getOrDefault("sortOrder")
  valid_591764 = validateParameter(valid_591764, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_591764 != nil:
    section.add "sortOrder", valid_591764
  var valid_591765 = query.getOrDefault("prettyPrint")
  valid_591765 = validateParameter(valid_591765, JBool, required = false,
                                 default = newJBool(true))
  if valid_591765 != nil:
    section.add "prettyPrint", valid_591765
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591766: Call_DfareportingOrdersList_591747; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of orders, possibly filtered. This method supports paging.
  ## 
  let valid = call_591766.validator(path, query, header, formData, body)
  let scheme = call_591766.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591766.url(scheme.get, call_591766.host, call_591766.base,
                         call_591766.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591766, url, valid)

proc call*(call_591767: Call_DfareportingOrdersList_591747; profileId: string;
          projectId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          siteId: JsonNode = nil; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingOrdersList
  ## Retrieves a list of orders, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for orders by name or ID. Wildcards (*) are allowed. For example, "order*2015" will return orders with names like "order June 2015", "order April 2015", or simply "order 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "order" will match orders with name "my order", "order 2015", or simply "order".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only orders that are associated with these site IDs.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only orders with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for orders.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591768 = newJObject()
  var query_591769 = newJObject()
  add(path_591768, "profileId", newJString(profileId))
  add(query_591769, "fields", newJString(fields))
  add(query_591769, "pageToken", newJString(pageToken))
  add(query_591769, "quotaUser", newJString(quotaUser))
  add(query_591769, "sortField", newJString(sortField))
  add(query_591769, "alt", newJString(alt))
  add(query_591769, "searchString", newJString(searchString))
  add(query_591769, "oauth_token", newJString(oauthToken))
  add(query_591769, "userIp", newJString(userIp))
  if siteId != nil:
    query_591769.add "siteId", siteId
  add(query_591769, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_591769.add "ids", ids
  add(query_591769, "key", newJString(key))
  add(path_591768, "projectId", newJString(projectId))
  add(query_591769, "sortOrder", newJString(sortOrder))
  add(query_591769, "prettyPrint", newJBool(prettyPrint))
  result = call_591767.call(path_591768, query_591769, nil, nil, nil)

var dfareportingOrdersList* = Call_DfareportingOrdersList_591747(
    name: "dfareportingOrdersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/orders",
    validator: validate_DfareportingOrdersList_591748, base: "/dfareporting/v2.7",
    url: url_DfareportingOrdersList_591749, schemes: {Scheme.Https})
type
  Call_DfareportingOrdersGet_591770 = ref object of OpenApiRestCall_588466
proc url_DfareportingOrdersGet_591772(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orders/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrdersGet_591771(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one order by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Order ID.
  ##   projectId: JString (required)
  ##            : Project ID for orders.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591773 = path.getOrDefault("profileId")
  valid_591773 = validateParameter(valid_591773, JString, required = true,
                                 default = nil)
  if valid_591773 != nil:
    section.add "profileId", valid_591773
  var valid_591774 = path.getOrDefault("id")
  valid_591774 = validateParameter(valid_591774, JString, required = true,
                                 default = nil)
  if valid_591774 != nil:
    section.add "id", valid_591774
  var valid_591775 = path.getOrDefault("projectId")
  valid_591775 = validateParameter(valid_591775, JString, required = true,
                                 default = nil)
  if valid_591775 != nil:
    section.add "projectId", valid_591775
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591776 = query.getOrDefault("fields")
  valid_591776 = validateParameter(valid_591776, JString, required = false,
                                 default = nil)
  if valid_591776 != nil:
    section.add "fields", valid_591776
  var valid_591777 = query.getOrDefault("quotaUser")
  valid_591777 = validateParameter(valid_591777, JString, required = false,
                                 default = nil)
  if valid_591777 != nil:
    section.add "quotaUser", valid_591777
  var valid_591778 = query.getOrDefault("alt")
  valid_591778 = validateParameter(valid_591778, JString, required = false,
                                 default = newJString("json"))
  if valid_591778 != nil:
    section.add "alt", valid_591778
  var valid_591779 = query.getOrDefault("oauth_token")
  valid_591779 = validateParameter(valid_591779, JString, required = false,
                                 default = nil)
  if valid_591779 != nil:
    section.add "oauth_token", valid_591779
  var valid_591780 = query.getOrDefault("userIp")
  valid_591780 = validateParameter(valid_591780, JString, required = false,
                                 default = nil)
  if valid_591780 != nil:
    section.add "userIp", valid_591780
  var valid_591781 = query.getOrDefault("key")
  valid_591781 = validateParameter(valid_591781, JString, required = false,
                                 default = nil)
  if valid_591781 != nil:
    section.add "key", valid_591781
  var valid_591782 = query.getOrDefault("prettyPrint")
  valid_591782 = validateParameter(valid_591782, JBool, required = false,
                                 default = newJBool(true))
  if valid_591782 != nil:
    section.add "prettyPrint", valid_591782
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591783: Call_DfareportingOrdersGet_591770; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one order by ID.
  ## 
  let valid = call_591783.validator(path, query, header, formData, body)
  let scheme = call_591783.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591783.url(scheme.get, call_591783.host, call_591783.base,
                         call_591783.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591783, url, valid)

proc call*(call_591784: Call_DfareportingOrdersGet_591770; profileId: string;
          id: string; projectId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOrdersGet
  ## Gets one order by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Order ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for orders.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591785 = newJObject()
  var query_591786 = newJObject()
  add(path_591785, "profileId", newJString(profileId))
  add(query_591786, "fields", newJString(fields))
  add(query_591786, "quotaUser", newJString(quotaUser))
  add(query_591786, "alt", newJString(alt))
  add(query_591786, "oauth_token", newJString(oauthToken))
  add(query_591786, "userIp", newJString(userIp))
  add(path_591785, "id", newJString(id))
  add(query_591786, "key", newJString(key))
  add(path_591785, "projectId", newJString(projectId))
  add(query_591786, "prettyPrint", newJBool(prettyPrint))
  result = call_591784.call(path_591785, query_591786, nil, nil, nil)

var dfareportingOrdersGet* = Call_DfareportingOrdersGet_591770(
    name: "dfareportingOrdersGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/orders/{id}",
    validator: validate_DfareportingOrdersGet_591771, base: "/dfareporting/v2.7",
    url: url_DfareportingOrdersGet_591772, schemes: {Scheme.Https})
type
  Call_DfareportingRegionsList_591787 = ref object of OpenApiRestCall_588466
proc url_DfareportingRegionsList_591789(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/regions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRegionsList_591788(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of regions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591790 = path.getOrDefault("profileId")
  valid_591790 = validateParameter(valid_591790, JString, required = true,
                                 default = nil)
  if valid_591790 != nil:
    section.add "profileId", valid_591790
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591791 = query.getOrDefault("fields")
  valid_591791 = validateParameter(valid_591791, JString, required = false,
                                 default = nil)
  if valid_591791 != nil:
    section.add "fields", valid_591791
  var valid_591792 = query.getOrDefault("quotaUser")
  valid_591792 = validateParameter(valid_591792, JString, required = false,
                                 default = nil)
  if valid_591792 != nil:
    section.add "quotaUser", valid_591792
  var valid_591793 = query.getOrDefault("alt")
  valid_591793 = validateParameter(valid_591793, JString, required = false,
                                 default = newJString("json"))
  if valid_591793 != nil:
    section.add "alt", valid_591793
  var valid_591794 = query.getOrDefault("oauth_token")
  valid_591794 = validateParameter(valid_591794, JString, required = false,
                                 default = nil)
  if valid_591794 != nil:
    section.add "oauth_token", valid_591794
  var valid_591795 = query.getOrDefault("userIp")
  valid_591795 = validateParameter(valid_591795, JString, required = false,
                                 default = nil)
  if valid_591795 != nil:
    section.add "userIp", valid_591795
  var valid_591796 = query.getOrDefault("key")
  valid_591796 = validateParameter(valid_591796, JString, required = false,
                                 default = nil)
  if valid_591796 != nil:
    section.add "key", valid_591796
  var valid_591797 = query.getOrDefault("prettyPrint")
  valid_591797 = validateParameter(valid_591797, JBool, required = false,
                                 default = newJBool(true))
  if valid_591797 != nil:
    section.add "prettyPrint", valid_591797
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591798: Call_DfareportingRegionsList_591787; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of regions.
  ## 
  let valid = call_591798.validator(path, query, header, formData, body)
  let scheme = call_591798.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591798.url(scheme.get, call_591798.host, call_591798.base,
                         call_591798.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591798, url, valid)

proc call*(call_591799: Call_DfareportingRegionsList_591787; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingRegionsList
  ## Retrieves a list of regions.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591800 = newJObject()
  var query_591801 = newJObject()
  add(path_591800, "profileId", newJString(profileId))
  add(query_591801, "fields", newJString(fields))
  add(query_591801, "quotaUser", newJString(quotaUser))
  add(query_591801, "alt", newJString(alt))
  add(query_591801, "oauth_token", newJString(oauthToken))
  add(query_591801, "userIp", newJString(userIp))
  add(query_591801, "key", newJString(key))
  add(query_591801, "prettyPrint", newJBool(prettyPrint))
  result = call_591799.call(path_591800, query_591801, nil, nil, nil)

var dfareportingRegionsList* = Call_DfareportingRegionsList_591787(
    name: "dfareportingRegionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/regions",
    validator: validate_DfareportingRegionsList_591788,
    base: "/dfareporting/v2.7", url: url_DfareportingRegionsList_591789,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListSharesUpdate_591802 = ref object of OpenApiRestCall_588466
proc url_DfareportingRemarketingListSharesUpdate_591804(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingListShares")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListSharesUpdate_591803(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list share.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591805 = path.getOrDefault("profileId")
  valid_591805 = validateParameter(valid_591805, JString, required = true,
                                 default = nil)
  if valid_591805 != nil:
    section.add "profileId", valid_591805
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591806 = query.getOrDefault("fields")
  valid_591806 = validateParameter(valid_591806, JString, required = false,
                                 default = nil)
  if valid_591806 != nil:
    section.add "fields", valid_591806
  var valid_591807 = query.getOrDefault("quotaUser")
  valid_591807 = validateParameter(valid_591807, JString, required = false,
                                 default = nil)
  if valid_591807 != nil:
    section.add "quotaUser", valid_591807
  var valid_591808 = query.getOrDefault("alt")
  valid_591808 = validateParameter(valid_591808, JString, required = false,
                                 default = newJString("json"))
  if valid_591808 != nil:
    section.add "alt", valid_591808
  var valid_591809 = query.getOrDefault("oauth_token")
  valid_591809 = validateParameter(valid_591809, JString, required = false,
                                 default = nil)
  if valid_591809 != nil:
    section.add "oauth_token", valid_591809
  var valid_591810 = query.getOrDefault("userIp")
  valid_591810 = validateParameter(valid_591810, JString, required = false,
                                 default = nil)
  if valid_591810 != nil:
    section.add "userIp", valid_591810
  var valid_591811 = query.getOrDefault("key")
  valid_591811 = validateParameter(valid_591811, JString, required = false,
                                 default = nil)
  if valid_591811 != nil:
    section.add "key", valid_591811
  var valid_591812 = query.getOrDefault("prettyPrint")
  valid_591812 = validateParameter(valid_591812, JBool, required = false,
                                 default = newJBool(true))
  if valid_591812 != nil:
    section.add "prettyPrint", valid_591812
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591814: Call_DfareportingRemarketingListSharesUpdate_591802;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list share.
  ## 
  let valid = call_591814.validator(path, query, header, formData, body)
  let scheme = call_591814.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591814.url(scheme.get, call_591814.host, call_591814.base,
                         call_591814.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591814, url, valid)

proc call*(call_591815: Call_DfareportingRemarketingListSharesUpdate_591802;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListSharesUpdate
  ## Updates an existing remarketing list share.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591816 = newJObject()
  var query_591817 = newJObject()
  var body_591818 = newJObject()
  add(path_591816, "profileId", newJString(profileId))
  add(query_591817, "fields", newJString(fields))
  add(query_591817, "quotaUser", newJString(quotaUser))
  add(query_591817, "alt", newJString(alt))
  add(query_591817, "oauth_token", newJString(oauthToken))
  add(query_591817, "userIp", newJString(userIp))
  add(query_591817, "key", newJString(key))
  if body != nil:
    body_591818 = body
  add(query_591817, "prettyPrint", newJBool(prettyPrint))
  result = call_591815.call(path_591816, query_591817, nil, nil, body_591818)

var dfareportingRemarketingListSharesUpdate* = Call_DfareportingRemarketingListSharesUpdate_591802(
    name: "dfareportingRemarketingListSharesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingListShares",
    validator: validate_DfareportingRemarketingListSharesUpdate_591803,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListSharesUpdate_591804,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListSharesPatch_591819 = ref object of OpenApiRestCall_588466
proc url_DfareportingRemarketingListSharesPatch_591821(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingListShares")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListSharesPatch_591820(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list share. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591822 = path.getOrDefault("profileId")
  valid_591822 = validateParameter(valid_591822, JString, required = true,
                                 default = nil)
  if valid_591822 != nil:
    section.add "profileId", valid_591822
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   remarketingListId: JString (required)
  ##                    : Remarketing list ID.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591823 = query.getOrDefault("fields")
  valid_591823 = validateParameter(valid_591823, JString, required = false,
                                 default = nil)
  if valid_591823 != nil:
    section.add "fields", valid_591823
  var valid_591824 = query.getOrDefault("quotaUser")
  valid_591824 = validateParameter(valid_591824, JString, required = false,
                                 default = nil)
  if valid_591824 != nil:
    section.add "quotaUser", valid_591824
  var valid_591825 = query.getOrDefault("alt")
  valid_591825 = validateParameter(valid_591825, JString, required = false,
                                 default = newJString("json"))
  if valid_591825 != nil:
    section.add "alt", valid_591825
  var valid_591826 = query.getOrDefault("oauth_token")
  valid_591826 = validateParameter(valid_591826, JString, required = false,
                                 default = nil)
  if valid_591826 != nil:
    section.add "oauth_token", valid_591826
  var valid_591827 = query.getOrDefault("userIp")
  valid_591827 = validateParameter(valid_591827, JString, required = false,
                                 default = nil)
  if valid_591827 != nil:
    section.add "userIp", valid_591827
  var valid_591828 = query.getOrDefault("key")
  valid_591828 = validateParameter(valid_591828, JString, required = false,
                                 default = nil)
  if valid_591828 != nil:
    section.add "key", valid_591828
  assert query != nil,
        "query argument is necessary due to required `remarketingListId` field"
  var valid_591829 = query.getOrDefault("remarketingListId")
  valid_591829 = validateParameter(valid_591829, JString, required = true,
                                 default = nil)
  if valid_591829 != nil:
    section.add "remarketingListId", valid_591829
  var valid_591830 = query.getOrDefault("prettyPrint")
  valid_591830 = validateParameter(valid_591830, JBool, required = false,
                                 default = newJBool(true))
  if valid_591830 != nil:
    section.add "prettyPrint", valid_591830
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591832: Call_DfareportingRemarketingListSharesPatch_591819;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list share. This method supports patch semantics.
  ## 
  let valid = call_591832.validator(path, query, header, formData, body)
  let scheme = call_591832.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591832.url(scheme.get, call_591832.host, call_591832.base,
                         call_591832.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591832, url, valid)

proc call*(call_591833: Call_DfareportingRemarketingListSharesPatch_591819;
          profileId: string; remarketingListId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListSharesPatch
  ## Updates an existing remarketing list share. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   remarketingListId: string (required)
  ##                    : Remarketing list ID.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591834 = newJObject()
  var query_591835 = newJObject()
  var body_591836 = newJObject()
  add(path_591834, "profileId", newJString(profileId))
  add(query_591835, "fields", newJString(fields))
  add(query_591835, "quotaUser", newJString(quotaUser))
  add(query_591835, "alt", newJString(alt))
  add(query_591835, "oauth_token", newJString(oauthToken))
  add(query_591835, "userIp", newJString(userIp))
  add(query_591835, "key", newJString(key))
  add(query_591835, "remarketingListId", newJString(remarketingListId))
  if body != nil:
    body_591836 = body
  add(query_591835, "prettyPrint", newJBool(prettyPrint))
  result = call_591833.call(path_591834, query_591835, nil, nil, body_591836)

var dfareportingRemarketingListSharesPatch* = Call_DfareportingRemarketingListSharesPatch_591819(
    name: "dfareportingRemarketingListSharesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingListShares",
    validator: validate_DfareportingRemarketingListSharesPatch_591820,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListSharesPatch_591821,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListSharesGet_591837 = ref object of OpenApiRestCall_588466
proc url_DfareportingRemarketingListSharesGet_591839(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "remarketingListId" in path,
        "`remarketingListId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingListShares/"),
               (kind: VariableSegment, value: "remarketingListId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListSharesGet_591838(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one remarketing list share by remarketing list ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   remarketingListId: JString (required)
  ##                    : Remarketing list ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591840 = path.getOrDefault("profileId")
  valid_591840 = validateParameter(valid_591840, JString, required = true,
                                 default = nil)
  if valid_591840 != nil:
    section.add "profileId", valid_591840
  var valid_591841 = path.getOrDefault("remarketingListId")
  valid_591841 = validateParameter(valid_591841, JString, required = true,
                                 default = nil)
  if valid_591841 != nil:
    section.add "remarketingListId", valid_591841
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591842 = query.getOrDefault("fields")
  valid_591842 = validateParameter(valid_591842, JString, required = false,
                                 default = nil)
  if valid_591842 != nil:
    section.add "fields", valid_591842
  var valid_591843 = query.getOrDefault("quotaUser")
  valid_591843 = validateParameter(valid_591843, JString, required = false,
                                 default = nil)
  if valid_591843 != nil:
    section.add "quotaUser", valid_591843
  var valid_591844 = query.getOrDefault("alt")
  valid_591844 = validateParameter(valid_591844, JString, required = false,
                                 default = newJString("json"))
  if valid_591844 != nil:
    section.add "alt", valid_591844
  var valid_591845 = query.getOrDefault("oauth_token")
  valid_591845 = validateParameter(valid_591845, JString, required = false,
                                 default = nil)
  if valid_591845 != nil:
    section.add "oauth_token", valid_591845
  var valid_591846 = query.getOrDefault("userIp")
  valid_591846 = validateParameter(valid_591846, JString, required = false,
                                 default = nil)
  if valid_591846 != nil:
    section.add "userIp", valid_591846
  var valid_591847 = query.getOrDefault("key")
  valid_591847 = validateParameter(valid_591847, JString, required = false,
                                 default = nil)
  if valid_591847 != nil:
    section.add "key", valid_591847
  var valid_591848 = query.getOrDefault("prettyPrint")
  valid_591848 = validateParameter(valid_591848, JBool, required = false,
                                 default = newJBool(true))
  if valid_591848 != nil:
    section.add "prettyPrint", valid_591848
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591849: Call_DfareportingRemarketingListSharesGet_591837;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one remarketing list share by remarketing list ID.
  ## 
  let valid = call_591849.validator(path, query, header, formData, body)
  let scheme = call_591849.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591849.url(scheme.get, call_591849.host, call_591849.base,
                         call_591849.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591849, url, valid)

proc call*(call_591850: Call_DfareportingRemarketingListSharesGet_591837;
          profileId: string; remarketingListId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListSharesGet
  ## Gets one remarketing list share by remarketing list ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   remarketingListId: string (required)
  ##                    : Remarketing list ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591851 = newJObject()
  var query_591852 = newJObject()
  add(path_591851, "profileId", newJString(profileId))
  add(query_591852, "fields", newJString(fields))
  add(query_591852, "quotaUser", newJString(quotaUser))
  add(query_591852, "alt", newJString(alt))
  add(query_591852, "oauth_token", newJString(oauthToken))
  add(query_591852, "userIp", newJString(userIp))
  add(path_591851, "remarketingListId", newJString(remarketingListId))
  add(query_591852, "key", newJString(key))
  add(query_591852, "prettyPrint", newJBool(prettyPrint))
  result = call_591850.call(path_591851, query_591852, nil, nil, nil)

var dfareportingRemarketingListSharesGet* = Call_DfareportingRemarketingListSharesGet_591837(
    name: "dfareportingRemarketingListSharesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/remarketingListShares/{remarketingListId}",
    validator: validate_DfareportingRemarketingListSharesGet_591838,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListSharesGet_591839,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsUpdate_591876 = ref object of OpenApiRestCall_588466
proc url_DfareportingRemarketingListsUpdate_591878(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsUpdate_591877(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591879 = path.getOrDefault("profileId")
  valid_591879 = validateParameter(valid_591879, JString, required = true,
                                 default = nil)
  if valid_591879 != nil:
    section.add "profileId", valid_591879
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591880 = query.getOrDefault("fields")
  valid_591880 = validateParameter(valid_591880, JString, required = false,
                                 default = nil)
  if valid_591880 != nil:
    section.add "fields", valid_591880
  var valid_591881 = query.getOrDefault("quotaUser")
  valid_591881 = validateParameter(valid_591881, JString, required = false,
                                 default = nil)
  if valid_591881 != nil:
    section.add "quotaUser", valid_591881
  var valid_591882 = query.getOrDefault("alt")
  valid_591882 = validateParameter(valid_591882, JString, required = false,
                                 default = newJString("json"))
  if valid_591882 != nil:
    section.add "alt", valid_591882
  var valid_591883 = query.getOrDefault("oauth_token")
  valid_591883 = validateParameter(valid_591883, JString, required = false,
                                 default = nil)
  if valid_591883 != nil:
    section.add "oauth_token", valid_591883
  var valid_591884 = query.getOrDefault("userIp")
  valid_591884 = validateParameter(valid_591884, JString, required = false,
                                 default = nil)
  if valid_591884 != nil:
    section.add "userIp", valid_591884
  var valid_591885 = query.getOrDefault("key")
  valid_591885 = validateParameter(valid_591885, JString, required = false,
                                 default = nil)
  if valid_591885 != nil:
    section.add "key", valid_591885
  var valid_591886 = query.getOrDefault("prettyPrint")
  valid_591886 = validateParameter(valid_591886, JBool, required = false,
                                 default = newJBool(true))
  if valid_591886 != nil:
    section.add "prettyPrint", valid_591886
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591888: Call_DfareportingRemarketingListsUpdate_591876;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list.
  ## 
  let valid = call_591888.validator(path, query, header, formData, body)
  let scheme = call_591888.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591888.url(scheme.get, call_591888.host, call_591888.base,
                         call_591888.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591888, url, valid)

proc call*(call_591889: Call_DfareportingRemarketingListsUpdate_591876;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsUpdate
  ## Updates an existing remarketing list.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591890 = newJObject()
  var query_591891 = newJObject()
  var body_591892 = newJObject()
  add(path_591890, "profileId", newJString(profileId))
  add(query_591891, "fields", newJString(fields))
  add(query_591891, "quotaUser", newJString(quotaUser))
  add(query_591891, "alt", newJString(alt))
  add(query_591891, "oauth_token", newJString(oauthToken))
  add(query_591891, "userIp", newJString(userIp))
  add(query_591891, "key", newJString(key))
  if body != nil:
    body_591892 = body
  add(query_591891, "prettyPrint", newJBool(prettyPrint))
  result = call_591889.call(path_591890, query_591891, nil, nil, body_591892)

var dfareportingRemarketingListsUpdate* = Call_DfareportingRemarketingListsUpdate_591876(
    name: "dfareportingRemarketingListsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsUpdate_591877,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsUpdate_591878,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsInsert_591893 = ref object of OpenApiRestCall_588466
proc url_DfareportingRemarketingListsInsert_591895(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsInsert_591894(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new remarketing list.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591896 = path.getOrDefault("profileId")
  valid_591896 = validateParameter(valid_591896, JString, required = true,
                                 default = nil)
  if valid_591896 != nil:
    section.add "profileId", valid_591896
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591897 = query.getOrDefault("fields")
  valid_591897 = validateParameter(valid_591897, JString, required = false,
                                 default = nil)
  if valid_591897 != nil:
    section.add "fields", valid_591897
  var valid_591898 = query.getOrDefault("quotaUser")
  valid_591898 = validateParameter(valid_591898, JString, required = false,
                                 default = nil)
  if valid_591898 != nil:
    section.add "quotaUser", valid_591898
  var valid_591899 = query.getOrDefault("alt")
  valid_591899 = validateParameter(valid_591899, JString, required = false,
                                 default = newJString("json"))
  if valid_591899 != nil:
    section.add "alt", valid_591899
  var valid_591900 = query.getOrDefault("oauth_token")
  valid_591900 = validateParameter(valid_591900, JString, required = false,
                                 default = nil)
  if valid_591900 != nil:
    section.add "oauth_token", valid_591900
  var valid_591901 = query.getOrDefault("userIp")
  valid_591901 = validateParameter(valid_591901, JString, required = false,
                                 default = nil)
  if valid_591901 != nil:
    section.add "userIp", valid_591901
  var valid_591902 = query.getOrDefault("key")
  valid_591902 = validateParameter(valid_591902, JString, required = false,
                                 default = nil)
  if valid_591902 != nil:
    section.add "key", valid_591902
  var valid_591903 = query.getOrDefault("prettyPrint")
  valid_591903 = validateParameter(valid_591903, JBool, required = false,
                                 default = newJBool(true))
  if valid_591903 != nil:
    section.add "prettyPrint", valid_591903
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591905: Call_DfareportingRemarketingListsInsert_591893;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new remarketing list.
  ## 
  let valid = call_591905.validator(path, query, header, formData, body)
  let scheme = call_591905.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591905.url(scheme.get, call_591905.host, call_591905.base,
                         call_591905.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591905, url, valid)

proc call*(call_591906: Call_DfareportingRemarketingListsInsert_591893;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsInsert
  ## Inserts a new remarketing list.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591907 = newJObject()
  var query_591908 = newJObject()
  var body_591909 = newJObject()
  add(path_591907, "profileId", newJString(profileId))
  add(query_591908, "fields", newJString(fields))
  add(query_591908, "quotaUser", newJString(quotaUser))
  add(query_591908, "alt", newJString(alt))
  add(query_591908, "oauth_token", newJString(oauthToken))
  add(query_591908, "userIp", newJString(userIp))
  add(query_591908, "key", newJString(key))
  if body != nil:
    body_591909 = body
  add(query_591908, "prettyPrint", newJBool(prettyPrint))
  result = call_591906.call(path_591907, query_591908, nil, nil, body_591909)

var dfareportingRemarketingListsInsert* = Call_DfareportingRemarketingListsInsert_591893(
    name: "dfareportingRemarketingListsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsInsert_591894,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsInsert_591895,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsList_591853 = ref object of OpenApiRestCall_588466
proc url_DfareportingRemarketingListsList_591855(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsList_591854(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of remarketing lists, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591856 = path.getOrDefault("profileId")
  valid_591856 = validateParameter(valid_591856, JString, required = true,
                                 default = nil)
  if valid_591856 != nil:
    section.add "profileId", valid_591856
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   advertiserId: JString (required)
  ##               : Select only remarketing lists owned by this advertiser.
  ##   active: JBool
  ##         : Select only active or only inactive remarketing lists.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   floodlightActivityId: JString
  ##                       : Select only remarketing lists that have this floodlight activity ID.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: JString
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591857 = query.getOrDefault("fields")
  valid_591857 = validateParameter(valid_591857, JString, required = false,
                                 default = nil)
  if valid_591857 != nil:
    section.add "fields", valid_591857
  var valid_591858 = query.getOrDefault("pageToken")
  valid_591858 = validateParameter(valid_591858, JString, required = false,
                                 default = nil)
  if valid_591858 != nil:
    section.add "pageToken", valid_591858
  var valid_591859 = query.getOrDefault("quotaUser")
  valid_591859 = validateParameter(valid_591859, JString, required = false,
                                 default = nil)
  if valid_591859 != nil:
    section.add "quotaUser", valid_591859
  var valid_591860 = query.getOrDefault("sortField")
  valid_591860 = validateParameter(valid_591860, JString, required = false,
                                 default = newJString("ID"))
  if valid_591860 != nil:
    section.add "sortField", valid_591860
  var valid_591861 = query.getOrDefault("alt")
  valid_591861 = validateParameter(valid_591861, JString, required = false,
                                 default = newJString("json"))
  if valid_591861 != nil:
    section.add "alt", valid_591861
  assert query != nil,
        "query argument is necessary due to required `advertiserId` field"
  var valid_591862 = query.getOrDefault("advertiserId")
  valid_591862 = validateParameter(valid_591862, JString, required = true,
                                 default = nil)
  if valid_591862 != nil:
    section.add "advertiserId", valid_591862
  var valid_591863 = query.getOrDefault("active")
  valid_591863 = validateParameter(valid_591863, JBool, required = false, default = nil)
  if valid_591863 != nil:
    section.add "active", valid_591863
  var valid_591864 = query.getOrDefault("oauth_token")
  valid_591864 = validateParameter(valid_591864, JString, required = false,
                                 default = nil)
  if valid_591864 != nil:
    section.add "oauth_token", valid_591864
  var valid_591865 = query.getOrDefault("floodlightActivityId")
  valid_591865 = validateParameter(valid_591865, JString, required = false,
                                 default = nil)
  if valid_591865 != nil:
    section.add "floodlightActivityId", valid_591865
  var valid_591866 = query.getOrDefault("userIp")
  valid_591866 = validateParameter(valid_591866, JString, required = false,
                                 default = nil)
  if valid_591866 != nil:
    section.add "userIp", valid_591866
  var valid_591867 = query.getOrDefault("maxResults")
  valid_591867 = validateParameter(valid_591867, JInt, required = false,
                                 default = newJInt(1000))
  if valid_591867 != nil:
    section.add "maxResults", valid_591867
  var valid_591868 = query.getOrDefault("key")
  valid_591868 = validateParameter(valid_591868, JString, required = false,
                                 default = nil)
  if valid_591868 != nil:
    section.add "key", valid_591868
  var valid_591869 = query.getOrDefault("name")
  valid_591869 = validateParameter(valid_591869, JString, required = false,
                                 default = nil)
  if valid_591869 != nil:
    section.add "name", valid_591869
  var valid_591870 = query.getOrDefault("sortOrder")
  valid_591870 = validateParameter(valid_591870, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_591870 != nil:
    section.add "sortOrder", valid_591870
  var valid_591871 = query.getOrDefault("prettyPrint")
  valid_591871 = validateParameter(valid_591871, JBool, required = false,
                                 default = newJBool(true))
  if valid_591871 != nil:
    section.add "prettyPrint", valid_591871
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591872: Call_DfareportingRemarketingListsList_591853;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of remarketing lists, possibly filtered. This method supports paging.
  ## 
  let valid = call_591872.validator(path, query, header, formData, body)
  let scheme = call_591872.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591872.url(scheme.get, call_591872.host, call_591872.base,
                         call_591872.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591872, url, valid)

proc call*(call_591873: Call_DfareportingRemarketingListsList_591853;
          profileId: string; advertiserId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; active: bool = false; oauthToken: string = "";
          floodlightActivityId: string = ""; userIp: string = "";
          maxResults: int = 1000; key: string = ""; name: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsList
  ## Retrieves a list of remarketing lists, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   advertiserId: string (required)
  ##               : Select only remarketing lists owned by this advertiser.
  ##   active: bool
  ##         : Select only active or only inactive remarketing lists.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   floodlightActivityId: string
  ##                       : Select only remarketing lists that have this floodlight activity ID.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: string
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591874 = newJObject()
  var query_591875 = newJObject()
  add(path_591874, "profileId", newJString(profileId))
  add(query_591875, "fields", newJString(fields))
  add(query_591875, "pageToken", newJString(pageToken))
  add(query_591875, "quotaUser", newJString(quotaUser))
  add(query_591875, "sortField", newJString(sortField))
  add(query_591875, "alt", newJString(alt))
  add(query_591875, "advertiserId", newJString(advertiserId))
  add(query_591875, "active", newJBool(active))
  add(query_591875, "oauth_token", newJString(oauthToken))
  add(query_591875, "floodlightActivityId", newJString(floodlightActivityId))
  add(query_591875, "userIp", newJString(userIp))
  add(query_591875, "maxResults", newJInt(maxResults))
  add(query_591875, "key", newJString(key))
  add(query_591875, "name", newJString(name))
  add(query_591875, "sortOrder", newJString(sortOrder))
  add(query_591875, "prettyPrint", newJBool(prettyPrint))
  result = call_591873.call(path_591874, query_591875, nil, nil, nil)

var dfareportingRemarketingListsList* = Call_DfareportingRemarketingListsList_591853(
    name: "dfareportingRemarketingListsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsList_591854,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsList_591855,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsPatch_591910 = ref object of OpenApiRestCall_588466
proc url_DfareportingRemarketingListsPatch_591912(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsPatch_591911(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591913 = path.getOrDefault("profileId")
  valid_591913 = validateParameter(valid_591913, JString, required = true,
                                 default = nil)
  if valid_591913 != nil:
    section.add "profileId", valid_591913
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Remarketing list ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591914 = query.getOrDefault("fields")
  valid_591914 = validateParameter(valid_591914, JString, required = false,
                                 default = nil)
  if valid_591914 != nil:
    section.add "fields", valid_591914
  var valid_591915 = query.getOrDefault("quotaUser")
  valid_591915 = validateParameter(valid_591915, JString, required = false,
                                 default = nil)
  if valid_591915 != nil:
    section.add "quotaUser", valid_591915
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_591916 = query.getOrDefault("id")
  valid_591916 = validateParameter(valid_591916, JString, required = true,
                                 default = nil)
  if valid_591916 != nil:
    section.add "id", valid_591916
  var valid_591917 = query.getOrDefault("alt")
  valid_591917 = validateParameter(valid_591917, JString, required = false,
                                 default = newJString("json"))
  if valid_591917 != nil:
    section.add "alt", valid_591917
  var valid_591918 = query.getOrDefault("oauth_token")
  valid_591918 = validateParameter(valid_591918, JString, required = false,
                                 default = nil)
  if valid_591918 != nil:
    section.add "oauth_token", valid_591918
  var valid_591919 = query.getOrDefault("userIp")
  valid_591919 = validateParameter(valid_591919, JString, required = false,
                                 default = nil)
  if valid_591919 != nil:
    section.add "userIp", valid_591919
  var valid_591920 = query.getOrDefault("key")
  valid_591920 = validateParameter(valid_591920, JString, required = false,
                                 default = nil)
  if valid_591920 != nil:
    section.add "key", valid_591920
  var valid_591921 = query.getOrDefault("prettyPrint")
  valid_591921 = validateParameter(valid_591921, JBool, required = false,
                                 default = newJBool(true))
  if valid_591921 != nil:
    section.add "prettyPrint", valid_591921
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591923: Call_DfareportingRemarketingListsPatch_591910;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list. This method supports patch semantics.
  ## 
  let valid = call_591923.validator(path, query, header, formData, body)
  let scheme = call_591923.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591923.url(scheme.get, call_591923.host, call_591923.base,
                         call_591923.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591923, url, valid)

proc call*(call_591924: Call_DfareportingRemarketingListsPatch_591910;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsPatch
  ## Updates an existing remarketing list. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Remarketing list ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591925 = newJObject()
  var query_591926 = newJObject()
  var body_591927 = newJObject()
  add(path_591925, "profileId", newJString(profileId))
  add(query_591926, "fields", newJString(fields))
  add(query_591926, "quotaUser", newJString(quotaUser))
  add(query_591926, "id", newJString(id))
  add(query_591926, "alt", newJString(alt))
  add(query_591926, "oauth_token", newJString(oauthToken))
  add(query_591926, "userIp", newJString(userIp))
  add(query_591926, "key", newJString(key))
  if body != nil:
    body_591927 = body
  add(query_591926, "prettyPrint", newJBool(prettyPrint))
  result = call_591924.call(path_591925, query_591926, nil, nil, body_591927)

var dfareportingRemarketingListsPatch* = Call_DfareportingRemarketingListsPatch_591910(
    name: "dfareportingRemarketingListsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsPatch_591911,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsPatch_591912,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsGet_591928 = ref object of OpenApiRestCall_588466
proc url_DfareportingRemarketingListsGet_591930(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsGet_591929(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one remarketing list by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Remarketing list ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591931 = path.getOrDefault("profileId")
  valid_591931 = validateParameter(valid_591931, JString, required = true,
                                 default = nil)
  if valid_591931 != nil:
    section.add "profileId", valid_591931
  var valid_591932 = path.getOrDefault("id")
  valid_591932 = validateParameter(valid_591932, JString, required = true,
                                 default = nil)
  if valid_591932 != nil:
    section.add "id", valid_591932
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591933 = query.getOrDefault("fields")
  valid_591933 = validateParameter(valid_591933, JString, required = false,
                                 default = nil)
  if valid_591933 != nil:
    section.add "fields", valid_591933
  var valid_591934 = query.getOrDefault("quotaUser")
  valid_591934 = validateParameter(valid_591934, JString, required = false,
                                 default = nil)
  if valid_591934 != nil:
    section.add "quotaUser", valid_591934
  var valid_591935 = query.getOrDefault("alt")
  valid_591935 = validateParameter(valid_591935, JString, required = false,
                                 default = newJString("json"))
  if valid_591935 != nil:
    section.add "alt", valid_591935
  var valid_591936 = query.getOrDefault("oauth_token")
  valid_591936 = validateParameter(valid_591936, JString, required = false,
                                 default = nil)
  if valid_591936 != nil:
    section.add "oauth_token", valid_591936
  var valid_591937 = query.getOrDefault("userIp")
  valid_591937 = validateParameter(valid_591937, JString, required = false,
                                 default = nil)
  if valid_591937 != nil:
    section.add "userIp", valid_591937
  var valid_591938 = query.getOrDefault("key")
  valid_591938 = validateParameter(valid_591938, JString, required = false,
                                 default = nil)
  if valid_591938 != nil:
    section.add "key", valid_591938
  var valid_591939 = query.getOrDefault("prettyPrint")
  valid_591939 = validateParameter(valid_591939, JBool, required = false,
                                 default = newJBool(true))
  if valid_591939 != nil:
    section.add "prettyPrint", valid_591939
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591940: Call_DfareportingRemarketingListsGet_591928;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one remarketing list by ID.
  ## 
  let valid = call_591940.validator(path, query, header, formData, body)
  let scheme = call_591940.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591940.url(scheme.get, call_591940.host, call_591940.base,
                         call_591940.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591940, url, valid)

proc call*(call_591941: Call_DfareportingRemarketingListsGet_591928;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsGet
  ## Gets one remarketing list by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Remarketing list ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591942 = newJObject()
  var query_591943 = newJObject()
  add(path_591942, "profileId", newJString(profileId))
  add(query_591943, "fields", newJString(fields))
  add(query_591943, "quotaUser", newJString(quotaUser))
  add(query_591943, "alt", newJString(alt))
  add(query_591943, "oauth_token", newJString(oauthToken))
  add(query_591943, "userIp", newJString(userIp))
  add(path_591942, "id", newJString(id))
  add(query_591943, "key", newJString(key))
  add(query_591943, "prettyPrint", newJBool(prettyPrint))
  result = call_591941.call(path_591942, query_591943, nil, nil, nil)

var dfareportingRemarketingListsGet* = Call_DfareportingRemarketingListsGet_591928(
    name: "dfareportingRemarketingListsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists/{id}",
    validator: validate_DfareportingRemarketingListsGet_591929,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsGet_591930,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsInsert_591964 = ref object of OpenApiRestCall_588466
proc url_DfareportingReportsInsert_591966(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsInsert_591965(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591967 = path.getOrDefault("profileId")
  valid_591967 = validateParameter(valid_591967, JString, required = true,
                                 default = nil)
  if valid_591967 != nil:
    section.add "profileId", valid_591967
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591968 = query.getOrDefault("fields")
  valid_591968 = validateParameter(valid_591968, JString, required = false,
                                 default = nil)
  if valid_591968 != nil:
    section.add "fields", valid_591968
  var valid_591969 = query.getOrDefault("quotaUser")
  valid_591969 = validateParameter(valid_591969, JString, required = false,
                                 default = nil)
  if valid_591969 != nil:
    section.add "quotaUser", valid_591969
  var valid_591970 = query.getOrDefault("alt")
  valid_591970 = validateParameter(valid_591970, JString, required = false,
                                 default = newJString("json"))
  if valid_591970 != nil:
    section.add "alt", valid_591970
  var valid_591971 = query.getOrDefault("oauth_token")
  valid_591971 = validateParameter(valid_591971, JString, required = false,
                                 default = nil)
  if valid_591971 != nil:
    section.add "oauth_token", valid_591971
  var valid_591972 = query.getOrDefault("userIp")
  valid_591972 = validateParameter(valid_591972, JString, required = false,
                                 default = nil)
  if valid_591972 != nil:
    section.add "userIp", valid_591972
  var valid_591973 = query.getOrDefault("key")
  valid_591973 = validateParameter(valid_591973, JString, required = false,
                                 default = nil)
  if valid_591973 != nil:
    section.add "key", valid_591973
  var valid_591974 = query.getOrDefault("prettyPrint")
  valid_591974 = validateParameter(valid_591974, JBool, required = false,
                                 default = newJBool(true))
  if valid_591974 != nil:
    section.add "prettyPrint", valid_591974
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591976: Call_DfareportingReportsInsert_591964; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a report.
  ## 
  let valid = call_591976.validator(path, query, header, formData, body)
  let scheme = call_591976.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591976.url(scheme.get, call_591976.host, call_591976.base,
                         call_591976.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591976, url, valid)

proc call*(call_591977: Call_DfareportingReportsInsert_591964; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsInsert
  ## Creates a report.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591978 = newJObject()
  var query_591979 = newJObject()
  var body_591980 = newJObject()
  add(path_591978, "profileId", newJString(profileId))
  add(query_591979, "fields", newJString(fields))
  add(query_591979, "quotaUser", newJString(quotaUser))
  add(query_591979, "alt", newJString(alt))
  add(query_591979, "oauth_token", newJString(oauthToken))
  add(query_591979, "userIp", newJString(userIp))
  add(query_591979, "key", newJString(key))
  if body != nil:
    body_591980 = body
  add(query_591979, "prettyPrint", newJBool(prettyPrint))
  result = call_591977.call(path_591978, query_591979, nil, nil, body_591980)

var dfareportingReportsInsert* = Call_DfareportingReportsInsert_591964(
    name: "dfareportingReportsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/reports",
    validator: validate_DfareportingReportsInsert_591965,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsInsert_591966,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsList_591944 = ref object of OpenApiRestCall_588466
proc url_DfareportingReportsList_591946(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsList_591945(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves list of reports.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591947 = path.getOrDefault("profileId")
  valid_591947 = validateParameter(valid_591947, JString, required = true,
                                 default = nil)
  if valid_591947 != nil:
    section.add "profileId", valid_591947
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : The field by which to sort the list.
  ##   scope: JString
  ##        : The scope that defines which results are returned.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591948 = query.getOrDefault("fields")
  valid_591948 = validateParameter(valid_591948, JString, required = false,
                                 default = nil)
  if valid_591948 != nil:
    section.add "fields", valid_591948
  var valid_591949 = query.getOrDefault("pageToken")
  valid_591949 = validateParameter(valid_591949, JString, required = false,
                                 default = nil)
  if valid_591949 != nil:
    section.add "pageToken", valid_591949
  var valid_591950 = query.getOrDefault("quotaUser")
  valid_591950 = validateParameter(valid_591950, JString, required = false,
                                 default = nil)
  if valid_591950 != nil:
    section.add "quotaUser", valid_591950
  var valid_591951 = query.getOrDefault("sortField")
  valid_591951 = validateParameter(valid_591951, JString, required = false,
                                 default = newJString("LAST_MODIFIED_TIME"))
  if valid_591951 != nil:
    section.add "sortField", valid_591951
  var valid_591952 = query.getOrDefault("scope")
  valid_591952 = validateParameter(valid_591952, JString, required = false,
                                 default = newJString("MINE"))
  if valid_591952 != nil:
    section.add "scope", valid_591952
  var valid_591953 = query.getOrDefault("alt")
  valid_591953 = validateParameter(valid_591953, JString, required = false,
                                 default = newJString("json"))
  if valid_591953 != nil:
    section.add "alt", valid_591953
  var valid_591954 = query.getOrDefault("oauth_token")
  valid_591954 = validateParameter(valid_591954, JString, required = false,
                                 default = nil)
  if valid_591954 != nil:
    section.add "oauth_token", valid_591954
  var valid_591955 = query.getOrDefault("userIp")
  valid_591955 = validateParameter(valid_591955, JString, required = false,
                                 default = nil)
  if valid_591955 != nil:
    section.add "userIp", valid_591955
  var valid_591956 = query.getOrDefault("maxResults")
  valid_591956 = validateParameter(valid_591956, JInt, required = false,
                                 default = newJInt(10))
  if valid_591956 != nil:
    section.add "maxResults", valid_591956
  var valid_591957 = query.getOrDefault("key")
  valid_591957 = validateParameter(valid_591957, JString, required = false,
                                 default = nil)
  if valid_591957 != nil:
    section.add "key", valid_591957
  var valid_591958 = query.getOrDefault("sortOrder")
  valid_591958 = validateParameter(valid_591958, JString, required = false,
                                 default = newJString("DESCENDING"))
  if valid_591958 != nil:
    section.add "sortOrder", valid_591958
  var valid_591959 = query.getOrDefault("prettyPrint")
  valid_591959 = validateParameter(valid_591959, JBool, required = false,
                                 default = newJBool(true))
  if valid_591959 != nil:
    section.add "prettyPrint", valid_591959
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_591960: Call_DfareportingReportsList_591944; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves list of reports.
  ## 
  let valid = call_591960.validator(path, query, header, formData, body)
  let scheme = call_591960.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591960.url(scheme.get, call_591960.host, call_591960.base,
                         call_591960.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591960, url, valid)

proc call*(call_591961: Call_DfareportingReportsList_591944; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "LAST_MODIFIED_TIME"; scope: string = "MINE";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 10; key: string = ""; sortOrder: string = "DESCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingReportsList
  ## Retrieves list of reports.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : The field by which to sort the list.
  ##   scope: string
  ##        : The scope that defines which results are returned.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591962 = newJObject()
  var query_591963 = newJObject()
  add(path_591962, "profileId", newJString(profileId))
  add(query_591963, "fields", newJString(fields))
  add(query_591963, "pageToken", newJString(pageToken))
  add(query_591963, "quotaUser", newJString(quotaUser))
  add(query_591963, "sortField", newJString(sortField))
  add(query_591963, "scope", newJString(scope))
  add(query_591963, "alt", newJString(alt))
  add(query_591963, "oauth_token", newJString(oauthToken))
  add(query_591963, "userIp", newJString(userIp))
  add(query_591963, "maxResults", newJInt(maxResults))
  add(query_591963, "key", newJString(key))
  add(query_591963, "sortOrder", newJString(sortOrder))
  add(query_591963, "prettyPrint", newJBool(prettyPrint))
  result = call_591961.call(path_591962, query_591963, nil, nil, nil)

var dfareportingReportsList* = Call_DfareportingReportsList_591944(
    name: "dfareportingReportsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/reports",
    validator: validate_DfareportingReportsList_591945,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsList_591946,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsCompatibleFieldsQuery_591981 = ref object of OpenApiRestCall_588466
proc url_DfareportingReportsCompatibleFieldsQuery_591983(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"), (kind: ConstantSegment,
        value: "/reports/compatiblefields/query")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsCompatibleFieldsQuery_591982(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the fields that are compatible to be selected in the respective sections of a report criteria, given the fields already selected in the input report and user permissions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_591984 = path.getOrDefault("profileId")
  valid_591984 = validateParameter(valid_591984, JString, required = true,
                                 default = nil)
  if valid_591984 != nil:
    section.add "profileId", valid_591984
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_591985 = query.getOrDefault("fields")
  valid_591985 = validateParameter(valid_591985, JString, required = false,
                                 default = nil)
  if valid_591985 != nil:
    section.add "fields", valid_591985
  var valid_591986 = query.getOrDefault("quotaUser")
  valid_591986 = validateParameter(valid_591986, JString, required = false,
                                 default = nil)
  if valid_591986 != nil:
    section.add "quotaUser", valid_591986
  var valid_591987 = query.getOrDefault("alt")
  valid_591987 = validateParameter(valid_591987, JString, required = false,
                                 default = newJString("json"))
  if valid_591987 != nil:
    section.add "alt", valid_591987
  var valid_591988 = query.getOrDefault("oauth_token")
  valid_591988 = validateParameter(valid_591988, JString, required = false,
                                 default = nil)
  if valid_591988 != nil:
    section.add "oauth_token", valid_591988
  var valid_591989 = query.getOrDefault("userIp")
  valid_591989 = validateParameter(valid_591989, JString, required = false,
                                 default = nil)
  if valid_591989 != nil:
    section.add "userIp", valid_591989
  var valid_591990 = query.getOrDefault("key")
  valid_591990 = validateParameter(valid_591990, JString, required = false,
                                 default = nil)
  if valid_591990 != nil:
    section.add "key", valid_591990
  var valid_591991 = query.getOrDefault("prettyPrint")
  valid_591991 = validateParameter(valid_591991, JBool, required = false,
                                 default = newJBool(true))
  if valid_591991 != nil:
    section.add "prettyPrint", valid_591991
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_591993: Call_DfareportingReportsCompatibleFieldsQuery_591981;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the fields that are compatible to be selected in the respective sections of a report criteria, given the fields already selected in the input report and user permissions.
  ## 
  let valid = call_591993.validator(path, query, header, formData, body)
  let scheme = call_591993.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_591993.url(scheme.get, call_591993.host, call_591993.base,
                         call_591993.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_591993, url, valid)

proc call*(call_591994: Call_DfareportingReportsCompatibleFieldsQuery_591981;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsCompatibleFieldsQuery
  ## Returns the fields that are compatible to be selected in the respective sections of a report criteria, given the fields already selected in the input report and user permissions.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_591995 = newJObject()
  var query_591996 = newJObject()
  var body_591997 = newJObject()
  add(path_591995, "profileId", newJString(profileId))
  add(query_591996, "fields", newJString(fields))
  add(query_591996, "quotaUser", newJString(quotaUser))
  add(query_591996, "alt", newJString(alt))
  add(query_591996, "oauth_token", newJString(oauthToken))
  add(query_591996, "userIp", newJString(userIp))
  add(query_591996, "key", newJString(key))
  if body != nil:
    body_591997 = body
  add(query_591996, "prettyPrint", newJBool(prettyPrint))
  result = call_591994.call(path_591995, query_591996, nil, nil, body_591997)

var dfareportingReportsCompatibleFieldsQuery* = Call_DfareportingReportsCompatibleFieldsQuery_591981(
    name: "dfareportingReportsCompatibleFieldsQuery", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/compatiblefields/query",
    validator: validate_DfareportingReportsCompatibleFieldsQuery_591982,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsCompatibleFieldsQuery_591983,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsUpdate_592014 = ref object of OpenApiRestCall_588466
proc url_DfareportingReportsUpdate_592016(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsUpdate_592015(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592017 = path.getOrDefault("profileId")
  valid_592017 = validateParameter(valid_592017, JString, required = true,
                                 default = nil)
  if valid_592017 != nil:
    section.add "profileId", valid_592017
  var valid_592018 = path.getOrDefault("reportId")
  valid_592018 = validateParameter(valid_592018, JString, required = true,
                                 default = nil)
  if valid_592018 != nil:
    section.add "reportId", valid_592018
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592019 = query.getOrDefault("fields")
  valid_592019 = validateParameter(valid_592019, JString, required = false,
                                 default = nil)
  if valid_592019 != nil:
    section.add "fields", valid_592019
  var valid_592020 = query.getOrDefault("quotaUser")
  valid_592020 = validateParameter(valid_592020, JString, required = false,
                                 default = nil)
  if valid_592020 != nil:
    section.add "quotaUser", valid_592020
  var valid_592021 = query.getOrDefault("alt")
  valid_592021 = validateParameter(valid_592021, JString, required = false,
                                 default = newJString("json"))
  if valid_592021 != nil:
    section.add "alt", valid_592021
  var valid_592022 = query.getOrDefault("oauth_token")
  valid_592022 = validateParameter(valid_592022, JString, required = false,
                                 default = nil)
  if valid_592022 != nil:
    section.add "oauth_token", valid_592022
  var valid_592023 = query.getOrDefault("userIp")
  valid_592023 = validateParameter(valid_592023, JString, required = false,
                                 default = nil)
  if valid_592023 != nil:
    section.add "userIp", valid_592023
  var valid_592024 = query.getOrDefault("key")
  valid_592024 = validateParameter(valid_592024, JString, required = false,
                                 default = nil)
  if valid_592024 != nil:
    section.add "key", valid_592024
  var valid_592025 = query.getOrDefault("prettyPrint")
  valid_592025 = validateParameter(valid_592025, JBool, required = false,
                                 default = newJBool(true))
  if valid_592025 != nil:
    section.add "prettyPrint", valid_592025
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592027: Call_DfareportingReportsUpdate_592014; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a report.
  ## 
  let valid = call_592027.validator(path, query, header, formData, body)
  let scheme = call_592027.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592027.url(scheme.get, call_592027.host, call_592027.base,
                         call_592027.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592027, url, valid)

proc call*(call_592028: Call_DfareportingReportsUpdate_592014; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsUpdate
  ## Updates a report.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592029 = newJObject()
  var query_592030 = newJObject()
  var body_592031 = newJObject()
  add(path_592029, "profileId", newJString(profileId))
  add(query_592030, "fields", newJString(fields))
  add(query_592030, "quotaUser", newJString(quotaUser))
  add(query_592030, "alt", newJString(alt))
  add(query_592030, "oauth_token", newJString(oauthToken))
  add(query_592030, "userIp", newJString(userIp))
  add(query_592030, "key", newJString(key))
  add(path_592029, "reportId", newJString(reportId))
  if body != nil:
    body_592031 = body
  add(query_592030, "prettyPrint", newJBool(prettyPrint))
  result = call_592028.call(path_592029, query_592030, nil, nil, body_592031)

var dfareportingReportsUpdate* = Call_DfareportingReportsUpdate_592014(
    name: "dfareportingReportsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsUpdate_592015,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsUpdate_592016,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsGet_591998 = ref object of OpenApiRestCall_588466
proc url_DfareportingReportsGet_592000(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsGet_591999(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a report by its ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592001 = path.getOrDefault("profileId")
  valid_592001 = validateParameter(valid_592001, JString, required = true,
                                 default = nil)
  if valid_592001 != nil:
    section.add "profileId", valid_592001
  var valid_592002 = path.getOrDefault("reportId")
  valid_592002 = validateParameter(valid_592002, JString, required = true,
                                 default = nil)
  if valid_592002 != nil:
    section.add "reportId", valid_592002
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592003 = query.getOrDefault("fields")
  valid_592003 = validateParameter(valid_592003, JString, required = false,
                                 default = nil)
  if valid_592003 != nil:
    section.add "fields", valid_592003
  var valid_592004 = query.getOrDefault("quotaUser")
  valid_592004 = validateParameter(valid_592004, JString, required = false,
                                 default = nil)
  if valid_592004 != nil:
    section.add "quotaUser", valid_592004
  var valid_592005 = query.getOrDefault("alt")
  valid_592005 = validateParameter(valid_592005, JString, required = false,
                                 default = newJString("json"))
  if valid_592005 != nil:
    section.add "alt", valid_592005
  var valid_592006 = query.getOrDefault("oauth_token")
  valid_592006 = validateParameter(valid_592006, JString, required = false,
                                 default = nil)
  if valid_592006 != nil:
    section.add "oauth_token", valid_592006
  var valid_592007 = query.getOrDefault("userIp")
  valid_592007 = validateParameter(valid_592007, JString, required = false,
                                 default = nil)
  if valid_592007 != nil:
    section.add "userIp", valid_592007
  var valid_592008 = query.getOrDefault("key")
  valid_592008 = validateParameter(valid_592008, JString, required = false,
                                 default = nil)
  if valid_592008 != nil:
    section.add "key", valid_592008
  var valid_592009 = query.getOrDefault("prettyPrint")
  valid_592009 = validateParameter(valid_592009, JBool, required = false,
                                 default = newJBool(true))
  if valid_592009 != nil:
    section.add "prettyPrint", valid_592009
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592010: Call_DfareportingReportsGet_591998; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a report by its ID.
  ## 
  let valid = call_592010.validator(path, query, header, formData, body)
  let scheme = call_592010.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592010.url(scheme.get, call_592010.host, call_592010.base,
                         call_592010.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592010, url, valid)

proc call*(call_592011: Call_DfareportingReportsGet_591998; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsGet
  ## Retrieves a report by its ID.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592012 = newJObject()
  var query_592013 = newJObject()
  add(path_592012, "profileId", newJString(profileId))
  add(query_592013, "fields", newJString(fields))
  add(query_592013, "quotaUser", newJString(quotaUser))
  add(query_592013, "alt", newJString(alt))
  add(query_592013, "oauth_token", newJString(oauthToken))
  add(query_592013, "userIp", newJString(userIp))
  add(query_592013, "key", newJString(key))
  add(path_592012, "reportId", newJString(reportId))
  add(query_592013, "prettyPrint", newJBool(prettyPrint))
  result = call_592011.call(path_592012, query_592013, nil, nil, nil)

var dfareportingReportsGet* = Call_DfareportingReportsGet_591998(
    name: "dfareportingReportsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsGet_591999, base: "/dfareporting/v2.7",
    url: url_DfareportingReportsGet_592000, schemes: {Scheme.Https})
type
  Call_DfareportingReportsPatch_592048 = ref object of OpenApiRestCall_588466
proc url_DfareportingReportsPatch_592050(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsPatch_592049(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a report. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592051 = path.getOrDefault("profileId")
  valid_592051 = validateParameter(valid_592051, JString, required = true,
                                 default = nil)
  if valid_592051 != nil:
    section.add "profileId", valid_592051
  var valid_592052 = path.getOrDefault("reportId")
  valid_592052 = validateParameter(valid_592052, JString, required = true,
                                 default = nil)
  if valid_592052 != nil:
    section.add "reportId", valid_592052
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592053 = query.getOrDefault("fields")
  valid_592053 = validateParameter(valid_592053, JString, required = false,
                                 default = nil)
  if valid_592053 != nil:
    section.add "fields", valid_592053
  var valid_592054 = query.getOrDefault("quotaUser")
  valid_592054 = validateParameter(valid_592054, JString, required = false,
                                 default = nil)
  if valid_592054 != nil:
    section.add "quotaUser", valid_592054
  var valid_592055 = query.getOrDefault("alt")
  valid_592055 = validateParameter(valid_592055, JString, required = false,
                                 default = newJString("json"))
  if valid_592055 != nil:
    section.add "alt", valid_592055
  var valid_592056 = query.getOrDefault("oauth_token")
  valid_592056 = validateParameter(valid_592056, JString, required = false,
                                 default = nil)
  if valid_592056 != nil:
    section.add "oauth_token", valid_592056
  var valid_592057 = query.getOrDefault("userIp")
  valid_592057 = validateParameter(valid_592057, JString, required = false,
                                 default = nil)
  if valid_592057 != nil:
    section.add "userIp", valid_592057
  var valid_592058 = query.getOrDefault("key")
  valid_592058 = validateParameter(valid_592058, JString, required = false,
                                 default = nil)
  if valid_592058 != nil:
    section.add "key", valid_592058
  var valid_592059 = query.getOrDefault("prettyPrint")
  valid_592059 = validateParameter(valid_592059, JBool, required = false,
                                 default = newJBool(true))
  if valid_592059 != nil:
    section.add "prettyPrint", valid_592059
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592061: Call_DfareportingReportsPatch_592048; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a report. This method supports patch semantics.
  ## 
  let valid = call_592061.validator(path, query, header, formData, body)
  let scheme = call_592061.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592061.url(scheme.get, call_592061.host, call_592061.base,
                         call_592061.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592061, url, valid)

proc call*(call_592062: Call_DfareportingReportsPatch_592048; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsPatch
  ## Updates a report. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592063 = newJObject()
  var query_592064 = newJObject()
  var body_592065 = newJObject()
  add(path_592063, "profileId", newJString(profileId))
  add(query_592064, "fields", newJString(fields))
  add(query_592064, "quotaUser", newJString(quotaUser))
  add(query_592064, "alt", newJString(alt))
  add(query_592064, "oauth_token", newJString(oauthToken))
  add(query_592064, "userIp", newJString(userIp))
  add(query_592064, "key", newJString(key))
  add(path_592063, "reportId", newJString(reportId))
  if body != nil:
    body_592065 = body
  add(query_592064, "prettyPrint", newJBool(prettyPrint))
  result = call_592062.call(path_592063, query_592064, nil, nil, body_592065)

var dfareportingReportsPatch* = Call_DfareportingReportsPatch_592048(
    name: "dfareportingReportsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsPatch_592049,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsPatch_592050,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsDelete_592032 = ref object of OpenApiRestCall_588466
proc url_DfareportingReportsDelete_592034(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsDelete_592033(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a report by its ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592035 = path.getOrDefault("profileId")
  valid_592035 = validateParameter(valid_592035, JString, required = true,
                                 default = nil)
  if valid_592035 != nil:
    section.add "profileId", valid_592035
  var valid_592036 = path.getOrDefault("reportId")
  valid_592036 = validateParameter(valid_592036, JString, required = true,
                                 default = nil)
  if valid_592036 != nil:
    section.add "reportId", valid_592036
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592037 = query.getOrDefault("fields")
  valid_592037 = validateParameter(valid_592037, JString, required = false,
                                 default = nil)
  if valid_592037 != nil:
    section.add "fields", valid_592037
  var valid_592038 = query.getOrDefault("quotaUser")
  valid_592038 = validateParameter(valid_592038, JString, required = false,
                                 default = nil)
  if valid_592038 != nil:
    section.add "quotaUser", valid_592038
  var valid_592039 = query.getOrDefault("alt")
  valid_592039 = validateParameter(valid_592039, JString, required = false,
                                 default = newJString("json"))
  if valid_592039 != nil:
    section.add "alt", valid_592039
  var valid_592040 = query.getOrDefault("oauth_token")
  valid_592040 = validateParameter(valid_592040, JString, required = false,
                                 default = nil)
  if valid_592040 != nil:
    section.add "oauth_token", valid_592040
  var valid_592041 = query.getOrDefault("userIp")
  valid_592041 = validateParameter(valid_592041, JString, required = false,
                                 default = nil)
  if valid_592041 != nil:
    section.add "userIp", valid_592041
  var valid_592042 = query.getOrDefault("key")
  valid_592042 = validateParameter(valid_592042, JString, required = false,
                                 default = nil)
  if valid_592042 != nil:
    section.add "key", valid_592042
  var valid_592043 = query.getOrDefault("prettyPrint")
  valid_592043 = validateParameter(valid_592043, JBool, required = false,
                                 default = newJBool(true))
  if valid_592043 != nil:
    section.add "prettyPrint", valid_592043
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592044: Call_DfareportingReportsDelete_592032; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a report by its ID.
  ## 
  let valid = call_592044.validator(path, query, header, formData, body)
  let scheme = call_592044.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592044.url(scheme.get, call_592044.host, call_592044.base,
                         call_592044.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592044, url, valid)

proc call*(call_592045: Call_DfareportingReportsDelete_592032; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsDelete
  ## Deletes a report by its ID.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592046 = newJObject()
  var query_592047 = newJObject()
  add(path_592046, "profileId", newJString(profileId))
  add(query_592047, "fields", newJString(fields))
  add(query_592047, "quotaUser", newJString(quotaUser))
  add(query_592047, "alt", newJString(alt))
  add(query_592047, "oauth_token", newJString(oauthToken))
  add(query_592047, "userIp", newJString(userIp))
  add(query_592047, "key", newJString(key))
  add(path_592046, "reportId", newJString(reportId))
  add(query_592047, "prettyPrint", newJBool(prettyPrint))
  result = call_592045.call(path_592046, query_592047, nil, nil, nil)

var dfareportingReportsDelete* = Call_DfareportingReportsDelete_592032(
    name: "dfareportingReportsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsDelete_592033,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsDelete_592034,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsFilesList_592066 = ref object of OpenApiRestCall_588466
proc url_DfareportingReportsFilesList_592068(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsFilesList_592067(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists files for a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the parent report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592069 = path.getOrDefault("profileId")
  valid_592069 = validateParameter(valid_592069, JString, required = true,
                                 default = nil)
  if valid_592069 != nil:
    section.add "profileId", valid_592069
  var valid_592070 = path.getOrDefault("reportId")
  valid_592070 = validateParameter(valid_592070, JString, required = true,
                                 default = nil)
  if valid_592070 != nil:
    section.add "reportId", valid_592070
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : The field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592071 = query.getOrDefault("fields")
  valid_592071 = validateParameter(valid_592071, JString, required = false,
                                 default = nil)
  if valid_592071 != nil:
    section.add "fields", valid_592071
  var valid_592072 = query.getOrDefault("pageToken")
  valid_592072 = validateParameter(valid_592072, JString, required = false,
                                 default = nil)
  if valid_592072 != nil:
    section.add "pageToken", valid_592072
  var valid_592073 = query.getOrDefault("quotaUser")
  valid_592073 = validateParameter(valid_592073, JString, required = false,
                                 default = nil)
  if valid_592073 != nil:
    section.add "quotaUser", valid_592073
  var valid_592074 = query.getOrDefault("sortField")
  valid_592074 = validateParameter(valid_592074, JString, required = false,
                                 default = newJString("LAST_MODIFIED_TIME"))
  if valid_592074 != nil:
    section.add "sortField", valid_592074
  var valid_592075 = query.getOrDefault("alt")
  valid_592075 = validateParameter(valid_592075, JString, required = false,
                                 default = newJString("json"))
  if valid_592075 != nil:
    section.add "alt", valid_592075
  var valid_592076 = query.getOrDefault("oauth_token")
  valid_592076 = validateParameter(valid_592076, JString, required = false,
                                 default = nil)
  if valid_592076 != nil:
    section.add "oauth_token", valid_592076
  var valid_592077 = query.getOrDefault("userIp")
  valid_592077 = validateParameter(valid_592077, JString, required = false,
                                 default = nil)
  if valid_592077 != nil:
    section.add "userIp", valid_592077
  var valid_592078 = query.getOrDefault("maxResults")
  valid_592078 = validateParameter(valid_592078, JInt, required = false,
                                 default = newJInt(10))
  if valid_592078 != nil:
    section.add "maxResults", valid_592078
  var valid_592079 = query.getOrDefault("key")
  valid_592079 = validateParameter(valid_592079, JString, required = false,
                                 default = nil)
  if valid_592079 != nil:
    section.add "key", valid_592079
  var valid_592080 = query.getOrDefault("sortOrder")
  valid_592080 = validateParameter(valid_592080, JString, required = false,
                                 default = newJString("DESCENDING"))
  if valid_592080 != nil:
    section.add "sortOrder", valid_592080
  var valid_592081 = query.getOrDefault("prettyPrint")
  valid_592081 = validateParameter(valid_592081, JBool, required = false,
                                 default = newJBool(true))
  if valid_592081 != nil:
    section.add "prettyPrint", valid_592081
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592082: Call_DfareportingReportsFilesList_592066; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists files for a report.
  ## 
  let valid = call_592082.validator(path, query, header, formData, body)
  let scheme = call_592082.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592082.url(scheme.get, call_592082.host, call_592082.base,
                         call_592082.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592082, url, valid)

proc call*(call_592083: Call_DfareportingReportsFilesList_592066;
          profileId: string; reportId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = "";
          sortField: string = "LAST_MODIFIED_TIME"; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 10;
          key: string = ""; sortOrder: string = "DESCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsFilesList
  ## Lists files for a report.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : The field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   reportId: string (required)
  ##           : The ID of the parent report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592084 = newJObject()
  var query_592085 = newJObject()
  add(path_592084, "profileId", newJString(profileId))
  add(query_592085, "fields", newJString(fields))
  add(query_592085, "pageToken", newJString(pageToken))
  add(query_592085, "quotaUser", newJString(quotaUser))
  add(query_592085, "sortField", newJString(sortField))
  add(query_592085, "alt", newJString(alt))
  add(query_592085, "oauth_token", newJString(oauthToken))
  add(query_592085, "userIp", newJString(userIp))
  add(query_592085, "maxResults", newJInt(maxResults))
  add(query_592085, "key", newJString(key))
  add(query_592085, "sortOrder", newJString(sortOrder))
  add(path_592084, "reportId", newJString(reportId))
  add(query_592085, "prettyPrint", newJBool(prettyPrint))
  result = call_592083.call(path_592084, query_592085, nil, nil, nil)

var dfareportingReportsFilesList* = Call_DfareportingReportsFilesList_592066(
    name: "dfareportingReportsFilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}/files",
    validator: validate_DfareportingReportsFilesList_592067,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsFilesList_592068,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsFilesGet_592086 = ref object of OpenApiRestCall_588466
proc url_DfareportingReportsFilesGet_592088(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  assert "fileId" in path, "`fileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/files/"),
               (kind: VariableSegment, value: "fileId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsFilesGet_592087(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a report file. This method supports media download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  ##   fileId: JString (required)
  ##         : The ID of the report file.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592089 = path.getOrDefault("profileId")
  valid_592089 = validateParameter(valid_592089, JString, required = true,
                                 default = nil)
  if valid_592089 != nil:
    section.add "profileId", valid_592089
  var valid_592090 = path.getOrDefault("fileId")
  valid_592090 = validateParameter(valid_592090, JString, required = true,
                                 default = nil)
  if valid_592090 != nil:
    section.add "fileId", valid_592090
  var valid_592091 = path.getOrDefault("reportId")
  valid_592091 = validateParameter(valid_592091, JString, required = true,
                                 default = nil)
  if valid_592091 != nil:
    section.add "reportId", valid_592091
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592092 = query.getOrDefault("fields")
  valid_592092 = validateParameter(valid_592092, JString, required = false,
                                 default = nil)
  if valid_592092 != nil:
    section.add "fields", valid_592092
  var valid_592093 = query.getOrDefault("quotaUser")
  valid_592093 = validateParameter(valid_592093, JString, required = false,
                                 default = nil)
  if valid_592093 != nil:
    section.add "quotaUser", valid_592093
  var valid_592094 = query.getOrDefault("alt")
  valid_592094 = validateParameter(valid_592094, JString, required = false,
                                 default = newJString("json"))
  if valid_592094 != nil:
    section.add "alt", valid_592094
  var valid_592095 = query.getOrDefault("oauth_token")
  valid_592095 = validateParameter(valid_592095, JString, required = false,
                                 default = nil)
  if valid_592095 != nil:
    section.add "oauth_token", valid_592095
  var valid_592096 = query.getOrDefault("userIp")
  valid_592096 = validateParameter(valid_592096, JString, required = false,
                                 default = nil)
  if valid_592096 != nil:
    section.add "userIp", valid_592096
  var valid_592097 = query.getOrDefault("key")
  valid_592097 = validateParameter(valid_592097, JString, required = false,
                                 default = nil)
  if valid_592097 != nil:
    section.add "key", valid_592097
  var valid_592098 = query.getOrDefault("prettyPrint")
  valid_592098 = validateParameter(valid_592098, JBool, required = false,
                                 default = newJBool(true))
  if valid_592098 != nil:
    section.add "prettyPrint", valid_592098
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592099: Call_DfareportingReportsFilesGet_592086; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a report file. This method supports media download.
  ## 
  let valid = call_592099.validator(path, query, header, formData, body)
  let scheme = call_592099.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592099.url(scheme.get, call_592099.host, call_592099.base,
                         call_592099.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592099, url, valid)

proc call*(call_592100: Call_DfareportingReportsFilesGet_592086; profileId: string;
          fileId: string; reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsFilesGet
  ## Retrieves a report file. This method supports media download.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fileId: string (required)
  ##         : The ID of the report file.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592101 = newJObject()
  var query_592102 = newJObject()
  add(path_592101, "profileId", newJString(profileId))
  add(query_592102, "fields", newJString(fields))
  add(query_592102, "quotaUser", newJString(quotaUser))
  add(path_592101, "fileId", newJString(fileId))
  add(query_592102, "alt", newJString(alt))
  add(query_592102, "oauth_token", newJString(oauthToken))
  add(query_592102, "userIp", newJString(userIp))
  add(query_592102, "key", newJString(key))
  add(path_592101, "reportId", newJString(reportId))
  add(query_592102, "prettyPrint", newJBool(prettyPrint))
  result = call_592100.call(path_592101, query_592102, nil, nil, nil)

var dfareportingReportsFilesGet* = Call_DfareportingReportsFilesGet_592086(
    name: "dfareportingReportsFilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}/files/{fileId}",
    validator: validate_DfareportingReportsFilesGet_592087,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsFilesGet_592088,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsRun_592103 = ref object of OpenApiRestCall_588466
proc url_DfareportingReportsRun_592105(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/run")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsRun_592104(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Runs a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592106 = path.getOrDefault("profileId")
  valid_592106 = validateParameter(valid_592106, JString, required = true,
                                 default = nil)
  if valid_592106 != nil:
    section.add "profileId", valid_592106
  var valid_592107 = path.getOrDefault("reportId")
  valid_592107 = validateParameter(valid_592107, JString, required = true,
                                 default = nil)
  if valid_592107 != nil:
    section.add "reportId", valid_592107
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   synchronous: JBool
  ##              : If set and true, tries to run the report synchronously.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592108 = query.getOrDefault("fields")
  valid_592108 = validateParameter(valid_592108, JString, required = false,
                                 default = nil)
  if valid_592108 != nil:
    section.add "fields", valid_592108
  var valid_592109 = query.getOrDefault("quotaUser")
  valid_592109 = validateParameter(valid_592109, JString, required = false,
                                 default = nil)
  if valid_592109 != nil:
    section.add "quotaUser", valid_592109
  var valid_592110 = query.getOrDefault("alt")
  valid_592110 = validateParameter(valid_592110, JString, required = false,
                                 default = newJString("json"))
  if valid_592110 != nil:
    section.add "alt", valid_592110
  var valid_592111 = query.getOrDefault("oauth_token")
  valid_592111 = validateParameter(valid_592111, JString, required = false,
                                 default = nil)
  if valid_592111 != nil:
    section.add "oauth_token", valid_592111
  var valid_592112 = query.getOrDefault("userIp")
  valid_592112 = validateParameter(valid_592112, JString, required = false,
                                 default = nil)
  if valid_592112 != nil:
    section.add "userIp", valid_592112
  var valid_592113 = query.getOrDefault("synchronous")
  valid_592113 = validateParameter(valid_592113, JBool, required = false,
                                 default = newJBool(false))
  if valid_592113 != nil:
    section.add "synchronous", valid_592113
  var valid_592114 = query.getOrDefault("key")
  valid_592114 = validateParameter(valid_592114, JString, required = false,
                                 default = nil)
  if valid_592114 != nil:
    section.add "key", valid_592114
  var valid_592115 = query.getOrDefault("prettyPrint")
  valid_592115 = validateParameter(valid_592115, JBool, required = false,
                                 default = newJBool(true))
  if valid_592115 != nil:
    section.add "prettyPrint", valid_592115
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592116: Call_DfareportingReportsRun_592103; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Runs a report.
  ## 
  let valid = call_592116.validator(path, query, header, formData, body)
  let scheme = call_592116.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592116.url(scheme.get, call_592116.host, call_592116.base,
                         call_592116.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592116, url, valid)

proc call*(call_592117: Call_DfareportingReportsRun_592103; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          synchronous: bool = false; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsRun
  ## Runs a report.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   synchronous: bool
  ##              : If set and true, tries to run the report synchronously.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592118 = newJObject()
  var query_592119 = newJObject()
  add(path_592118, "profileId", newJString(profileId))
  add(query_592119, "fields", newJString(fields))
  add(query_592119, "quotaUser", newJString(quotaUser))
  add(query_592119, "alt", newJString(alt))
  add(query_592119, "oauth_token", newJString(oauthToken))
  add(query_592119, "userIp", newJString(userIp))
  add(query_592119, "synchronous", newJBool(synchronous))
  add(query_592119, "key", newJString(key))
  add(path_592118, "reportId", newJString(reportId))
  add(query_592119, "prettyPrint", newJBool(prettyPrint))
  result = call_592117.call(path_592118, query_592119, nil, nil, nil)

var dfareportingReportsRun* = Call_DfareportingReportsRun_592103(
    name: "dfareportingReportsRun", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}/run",
    validator: validate_DfareportingReportsRun_592104, base: "/dfareporting/v2.7",
    url: url_DfareportingReportsRun_592105, schemes: {Scheme.Https})
type
  Call_DfareportingSitesUpdate_592150 = ref object of OpenApiRestCall_588466
proc url_DfareportingSitesUpdate_592152(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesUpdate_592151(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing site.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592153 = path.getOrDefault("profileId")
  valid_592153 = validateParameter(valid_592153, JString, required = true,
                                 default = nil)
  if valid_592153 != nil:
    section.add "profileId", valid_592153
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592154 = query.getOrDefault("fields")
  valid_592154 = validateParameter(valid_592154, JString, required = false,
                                 default = nil)
  if valid_592154 != nil:
    section.add "fields", valid_592154
  var valid_592155 = query.getOrDefault("quotaUser")
  valid_592155 = validateParameter(valid_592155, JString, required = false,
                                 default = nil)
  if valid_592155 != nil:
    section.add "quotaUser", valid_592155
  var valid_592156 = query.getOrDefault("alt")
  valid_592156 = validateParameter(valid_592156, JString, required = false,
                                 default = newJString("json"))
  if valid_592156 != nil:
    section.add "alt", valid_592156
  var valid_592157 = query.getOrDefault("oauth_token")
  valid_592157 = validateParameter(valid_592157, JString, required = false,
                                 default = nil)
  if valid_592157 != nil:
    section.add "oauth_token", valid_592157
  var valid_592158 = query.getOrDefault("userIp")
  valid_592158 = validateParameter(valid_592158, JString, required = false,
                                 default = nil)
  if valid_592158 != nil:
    section.add "userIp", valid_592158
  var valid_592159 = query.getOrDefault("key")
  valid_592159 = validateParameter(valid_592159, JString, required = false,
                                 default = nil)
  if valid_592159 != nil:
    section.add "key", valid_592159
  var valid_592160 = query.getOrDefault("prettyPrint")
  valid_592160 = validateParameter(valid_592160, JBool, required = false,
                                 default = newJBool(true))
  if valid_592160 != nil:
    section.add "prettyPrint", valid_592160
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592162: Call_DfareportingSitesUpdate_592150; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing site.
  ## 
  let valid = call_592162.validator(path, query, header, formData, body)
  let scheme = call_592162.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592162.url(scheme.get, call_592162.host, call_592162.base,
                         call_592162.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592162, url, valid)

proc call*(call_592163: Call_DfareportingSitesUpdate_592150; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSitesUpdate
  ## Updates an existing site.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592164 = newJObject()
  var query_592165 = newJObject()
  var body_592166 = newJObject()
  add(path_592164, "profileId", newJString(profileId))
  add(query_592165, "fields", newJString(fields))
  add(query_592165, "quotaUser", newJString(quotaUser))
  add(query_592165, "alt", newJString(alt))
  add(query_592165, "oauth_token", newJString(oauthToken))
  add(query_592165, "userIp", newJString(userIp))
  add(query_592165, "key", newJString(key))
  if body != nil:
    body_592166 = body
  add(query_592165, "prettyPrint", newJBool(prettyPrint))
  result = call_592163.call(path_592164, query_592165, nil, nil, body_592166)

var dfareportingSitesUpdate* = Call_DfareportingSitesUpdate_592150(
    name: "dfareportingSitesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesUpdate_592151,
    base: "/dfareporting/v2.7", url: url_DfareportingSitesUpdate_592152,
    schemes: {Scheme.Https})
type
  Call_DfareportingSitesInsert_592167 = ref object of OpenApiRestCall_588466
proc url_DfareportingSitesInsert_592169(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesInsert_592168(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new site.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592170 = path.getOrDefault("profileId")
  valid_592170 = validateParameter(valid_592170, JString, required = true,
                                 default = nil)
  if valid_592170 != nil:
    section.add "profileId", valid_592170
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592171 = query.getOrDefault("fields")
  valid_592171 = validateParameter(valid_592171, JString, required = false,
                                 default = nil)
  if valid_592171 != nil:
    section.add "fields", valid_592171
  var valid_592172 = query.getOrDefault("quotaUser")
  valid_592172 = validateParameter(valid_592172, JString, required = false,
                                 default = nil)
  if valid_592172 != nil:
    section.add "quotaUser", valid_592172
  var valid_592173 = query.getOrDefault("alt")
  valid_592173 = validateParameter(valid_592173, JString, required = false,
                                 default = newJString("json"))
  if valid_592173 != nil:
    section.add "alt", valid_592173
  var valid_592174 = query.getOrDefault("oauth_token")
  valid_592174 = validateParameter(valid_592174, JString, required = false,
                                 default = nil)
  if valid_592174 != nil:
    section.add "oauth_token", valid_592174
  var valid_592175 = query.getOrDefault("userIp")
  valid_592175 = validateParameter(valid_592175, JString, required = false,
                                 default = nil)
  if valid_592175 != nil:
    section.add "userIp", valid_592175
  var valid_592176 = query.getOrDefault("key")
  valid_592176 = validateParameter(valid_592176, JString, required = false,
                                 default = nil)
  if valid_592176 != nil:
    section.add "key", valid_592176
  var valid_592177 = query.getOrDefault("prettyPrint")
  valid_592177 = validateParameter(valid_592177, JBool, required = false,
                                 default = newJBool(true))
  if valid_592177 != nil:
    section.add "prettyPrint", valid_592177
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592179: Call_DfareportingSitesInsert_592167; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new site.
  ## 
  let valid = call_592179.validator(path, query, header, formData, body)
  let scheme = call_592179.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592179.url(scheme.get, call_592179.host, call_592179.base,
                         call_592179.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592179, url, valid)

proc call*(call_592180: Call_DfareportingSitesInsert_592167; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSitesInsert
  ## Inserts a new site.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592181 = newJObject()
  var query_592182 = newJObject()
  var body_592183 = newJObject()
  add(path_592181, "profileId", newJString(profileId))
  add(query_592182, "fields", newJString(fields))
  add(query_592182, "quotaUser", newJString(quotaUser))
  add(query_592182, "alt", newJString(alt))
  add(query_592182, "oauth_token", newJString(oauthToken))
  add(query_592182, "userIp", newJString(userIp))
  add(query_592182, "key", newJString(key))
  if body != nil:
    body_592183 = body
  add(query_592182, "prettyPrint", newJBool(prettyPrint))
  result = call_592180.call(path_592181, query_592182, nil, nil, body_592183)

var dfareportingSitesInsert* = Call_DfareportingSitesInsert_592167(
    name: "dfareportingSitesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesInsert_592168,
    base: "/dfareporting/v2.7", url: url_DfareportingSitesInsert_592169,
    schemes: {Scheme.Https})
type
  Call_DfareportingSitesList_592120 = ref object of OpenApiRestCall_588466
proc url_DfareportingSitesList_592122(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesList_592121(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of sites, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592123 = path.getOrDefault("profileId")
  valid_592123 = validateParameter(valid_592123, JString, required = true,
                                 default = nil)
  if valid_592123 != nil:
    section.add "profileId", valid_592123
  result.add "path", section
  ## parameters in `query` object:
  ##   subaccountId: JString
  ##               : Select only sites with this subaccount ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or keyName. Wildcards (*) are allowed. For example, "site*2015" will return objects with names like "site June 2015", "site April 2015", or simply "site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "site" will match objects with name "my site", "site 2015", or simply "site".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   campaignIds: JArray
  ##              : Select only sites with these campaign IDs.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only sites with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsInterstitialPlacements: JBool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   acceptsInStreamVideoPlacements: JBool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   adWordsSite: JBool
  ##              : Select only AdWords sites.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   approved: JBool
  ##           : Select only approved sites.
  ##   unmappedSite: JBool
  ##               : Select only sites that have not been mapped to a directory site.
  ##   acceptsPublisherPaidPlacements: JBool
  ##                                 : Select only sites that accept publisher paid placements.
  ##   directorySiteIds: JArray
  ##                   : Select only sites with these directory site IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592124 = query.getOrDefault("subaccountId")
  valid_592124 = validateParameter(valid_592124, JString, required = false,
                                 default = nil)
  if valid_592124 != nil:
    section.add "subaccountId", valid_592124
  var valid_592125 = query.getOrDefault("fields")
  valid_592125 = validateParameter(valid_592125, JString, required = false,
                                 default = nil)
  if valid_592125 != nil:
    section.add "fields", valid_592125
  var valid_592126 = query.getOrDefault("pageToken")
  valid_592126 = validateParameter(valid_592126, JString, required = false,
                                 default = nil)
  if valid_592126 != nil:
    section.add "pageToken", valid_592126
  var valid_592127 = query.getOrDefault("quotaUser")
  valid_592127 = validateParameter(valid_592127, JString, required = false,
                                 default = nil)
  if valid_592127 != nil:
    section.add "quotaUser", valid_592127
  var valid_592128 = query.getOrDefault("sortField")
  valid_592128 = validateParameter(valid_592128, JString, required = false,
                                 default = newJString("ID"))
  if valid_592128 != nil:
    section.add "sortField", valid_592128
  var valid_592129 = query.getOrDefault("alt")
  valid_592129 = validateParameter(valid_592129, JString, required = false,
                                 default = newJString("json"))
  if valid_592129 != nil:
    section.add "alt", valid_592129
  var valid_592130 = query.getOrDefault("searchString")
  valid_592130 = validateParameter(valid_592130, JString, required = false,
                                 default = nil)
  if valid_592130 != nil:
    section.add "searchString", valid_592130
  var valid_592131 = query.getOrDefault("oauth_token")
  valid_592131 = validateParameter(valid_592131, JString, required = false,
                                 default = nil)
  if valid_592131 != nil:
    section.add "oauth_token", valid_592131
  var valid_592132 = query.getOrDefault("campaignIds")
  valid_592132 = validateParameter(valid_592132, JArray, required = false,
                                 default = nil)
  if valid_592132 != nil:
    section.add "campaignIds", valid_592132
  var valid_592133 = query.getOrDefault("userIp")
  valid_592133 = validateParameter(valid_592133, JString, required = false,
                                 default = nil)
  if valid_592133 != nil:
    section.add "userIp", valid_592133
  var valid_592134 = query.getOrDefault("maxResults")
  valid_592134 = validateParameter(valid_592134, JInt, required = false,
                                 default = newJInt(1000))
  if valid_592134 != nil:
    section.add "maxResults", valid_592134
  var valid_592135 = query.getOrDefault("ids")
  valid_592135 = validateParameter(valid_592135, JArray, required = false,
                                 default = nil)
  if valid_592135 != nil:
    section.add "ids", valid_592135
  var valid_592136 = query.getOrDefault("key")
  valid_592136 = validateParameter(valid_592136, JString, required = false,
                                 default = nil)
  if valid_592136 != nil:
    section.add "key", valid_592136
  var valid_592137 = query.getOrDefault("acceptsInterstitialPlacements")
  valid_592137 = validateParameter(valid_592137, JBool, required = false, default = nil)
  if valid_592137 != nil:
    section.add "acceptsInterstitialPlacements", valid_592137
  var valid_592138 = query.getOrDefault("acceptsInStreamVideoPlacements")
  valid_592138 = validateParameter(valid_592138, JBool, required = false, default = nil)
  if valid_592138 != nil:
    section.add "acceptsInStreamVideoPlacements", valid_592138
  var valid_592139 = query.getOrDefault("adWordsSite")
  valid_592139 = validateParameter(valid_592139, JBool, required = false, default = nil)
  if valid_592139 != nil:
    section.add "adWordsSite", valid_592139
  var valid_592140 = query.getOrDefault("sortOrder")
  valid_592140 = validateParameter(valid_592140, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_592140 != nil:
    section.add "sortOrder", valid_592140
  var valid_592141 = query.getOrDefault("approved")
  valid_592141 = validateParameter(valid_592141, JBool, required = false, default = nil)
  if valid_592141 != nil:
    section.add "approved", valid_592141
  var valid_592142 = query.getOrDefault("unmappedSite")
  valid_592142 = validateParameter(valid_592142, JBool, required = false, default = nil)
  if valid_592142 != nil:
    section.add "unmappedSite", valid_592142
  var valid_592143 = query.getOrDefault("acceptsPublisherPaidPlacements")
  valid_592143 = validateParameter(valid_592143, JBool, required = false, default = nil)
  if valid_592143 != nil:
    section.add "acceptsPublisherPaidPlacements", valid_592143
  var valid_592144 = query.getOrDefault("directorySiteIds")
  valid_592144 = validateParameter(valid_592144, JArray, required = false,
                                 default = nil)
  if valid_592144 != nil:
    section.add "directorySiteIds", valid_592144
  var valid_592145 = query.getOrDefault("prettyPrint")
  valid_592145 = validateParameter(valid_592145, JBool, required = false,
                                 default = newJBool(true))
  if valid_592145 != nil:
    section.add "prettyPrint", valid_592145
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592146: Call_DfareportingSitesList_592120; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of sites, possibly filtered. This method supports paging.
  ## 
  let valid = call_592146.validator(path, query, header, formData, body)
  let scheme = call_592146.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592146.url(scheme.get, call_592146.host, call_592146.base,
                         call_592146.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592146, url, valid)

proc call*(call_592147: Call_DfareportingSitesList_592120; profileId: string;
          subaccountId: string = ""; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = "";
          campaignIds: JsonNode = nil; userIp: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = "";
          acceptsInterstitialPlacements: bool = false;
          acceptsInStreamVideoPlacements: bool = false; adWordsSite: bool = false;
          sortOrder: string = "ASCENDING"; approved: bool = false;
          unmappedSite: bool = false; acceptsPublisherPaidPlacements: bool = false;
          directorySiteIds: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSitesList
  ## Retrieves a list of sites, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only sites with this subaccount ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or keyName. Wildcards (*) are allowed. For example, "site*2015" will return objects with names like "site June 2015", "site April 2015", or simply "site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "site" will match objects with name "my site", "site 2015", or simply "site".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   campaignIds: JArray
  ##              : Select only sites with these campaign IDs.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only sites with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsInterstitialPlacements: bool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   acceptsInStreamVideoPlacements: bool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   adWordsSite: bool
  ##              : Select only AdWords sites.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   approved: bool
  ##           : Select only approved sites.
  ##   unmappedSite: bool
  ##               : Select only sites that have not been mapped to a directory site.
  ##   acceptsPublisherPaidPlacements: bool
  ##                                 : Select only sites that accept publisher paid placements.
  ##   directorySiteIds: JArray
  ##                   : Select only sites with these directory site IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592148 = newJObject()
  var query_592149 = newJObject()
  add(path_592148, "profileId", newJString(profileId))
  add(query_592149, "subaccountId", newJString(subaccountId))
  add(query_592149, "fields", newJString(fields))
  add(query_592149, "pageToken", newJString(pageToken))
  add(query_592149, "quotaUser", newJString(quotaUser))
  add(query_592149, "sortField", newJString(sortField))
  add(query_592149, "alt", newJString(alt))
  add(query_592149, "searchString", newJString(searchString))
  add(query_592149, "oauth_token", newJString(oauthToken))
  if campaignIds != nil:
    query_592149.add "campaignIds", campaignIds
  add(query_592149, "userIp", newJString(userIp))
  add(query_592149, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_592149.add "ids", ids
  add(query_592149, "key", newJString(key))
  add(query_592149, "acceptsInterstitialPlacements",
      newJBool(acceptsInterstitialPlacements))
  add(query_592149, "acceptsInStreamVideoPlacements",
      newJBool(acceptsInStreamVideoPlacements))
  add(query_592149, "adWordsSite", newJBool(adWordsSite))
  add(query_592149, "sortOrder", newJString(sortOrder))
  add(query_592149, "approved", newJBool(approved))
  add(query_592149, "unmappedSite", newJBool(unmappedSite))
  add(query_592149, "acceptsPublisherPaidPlacements",
      newJBool(acceptsPublisherPaidPlacements))
  if directorySiteIds != nil:
    query_592149.add "directorySiteIds", directorySiteIds
  add(query_592149, "prettyPrint", newJBool(prettyPrint))
  result = call_592147.call(path_592148, query_592149, nil, nil, nil)

var dfareportingSitesList* = Call_DfareportingSitesList_592120(
    name: "dfareportingSitesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesList_592121, base: "/dfareporting/v2.7",
    url: url_DfareportingSitesList_592122, schemes: {Scheme.Https})
type
  Call_DfareportingSitesPatch_592184 = ref object of OpenApiRestCall_588466
proc url_DfareportingSitesPatch_592186(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesPatch_592185(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing site. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592187 = path.getOrDefault("profileId")
  valid_592187 = validateParameter(valid_592187, JString, required = true,
                                 default = nil)
  if valid_592187 != nil:
    section.add "profileId", valid_592187
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Site ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592188 = query.getOrDefault("fields")
  valid_592188 = validateParameter(valid_592188, JString, required = false,
                                 default = nil)
  if valid_592188 != nil:
    section.add "fields", valid_592188
  var valid_592189 = query.getOrDefault("quotaUser")
  valid_592189 = validateParameter(valid_592189, JString, required = false,
                                 default = nil)
  if valid_592189 != nil:
    section.add "quotaUser", valid_592189
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_592190 = query.getOrDefault("id")
  valid_592190 = validateParameter(valid_592190, JString, required = true,
                                 default = nil)
  if valid_592190 != nil:
    section.add "id", valid_592190
  var valid_592191 = query.getOrDefault("alt")
  valid_592191 = validateParameter(valid_592191, JString, required = false,
                                 default = newJString("json"))
  if valid_592191 != nil:
    section.add "alt", valid_592191
  var valid_592192 = query.getOrDefault("oauth_token")
  valid_592192 = validateParameter(valid_592192, JString, required = false,
                                 default = nil)
  if valid_592192 != nil:
    section.add "oauth_token", valid_592192
  var valid_592193 = query.getOrDefault("userIp")
  valid_592193 = validateParameter(valid_592193, JString, required = false,
                                 default = nil)
  if valid_592193 != nil:
    section.add "userIp", valid_592193
  var valid_592194 = query.getOrDefault("key")
  valid_592194 = validateParameter(valid_592194, JString, required = false,
                                 default = nil)
  if valid_592194 != nil:
    section.add "key", valid_592194
  var valid_592195 = query.getOrDefault("prettyPrint")
  valid_592195 = validateParameter(valid_592195, JBool, required = false,
                                 default = newJBool(true))
  if valid_592195 != nil:
    section.add "prettyPrint", valid_592195
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592197: Call_DfareportingSitesPatch_592184; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing site. This method supports patch semantics.
  ## 
  let valid = call_592197.validator(path, query, header, formData, body)
  let scheme = call_592197.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592197.url(scheme.get, call_592197.host, call_592197.base,
                         call_592197.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592197, url, valid)

proc call*(call_592198: Call_DfareportingSitesPatch_592184; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSitesPatch
  ## Updates an existing site. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Site ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592199 = newJObject()
  var query_592200 = newJObject()
  var body_592201 = newJObject()
  add(path_592199, "profileId", newJString(profileId))
  add(query_592200, "fields", newJString(fields))
  add(query_592200, "quotaUser", newJString(quotaUser))
  add(query_592200, "id", newJString(id))
  add(query_592200, "alt", newJString(alt))
  add(query_592200, "oauth_token", newJString(oauthToken))
  add(query_592200, "userIp", newJString(userIp))
  add(query_592200, "key", newJString(key))
  if body != nil:
    body_592201 = body
  add(query_592200, "prettyPrint", newJBool(prettyPrint))
  result = call_592198.call(path_592199, query_592200, nil, nil, body_592201)

var dfareportingSitesPatch* = Call_DfareportingSitesPatch_592184(
    name: "dfareportingSitesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesPatch_592185, base: "/dfareporting/v2.7",
    url: url_DfareportingSitesPatch_592186, schemes: {Scheme.Https})
type
  Call_DfareportingSitesGet_592202 = ref object of OpenApiRestCall_588466
proc url_DfareportingSitesGet_592204(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesGet_592203(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one site by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Site ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592205 = path.getOrDefault("profileId")
  valid_592205 = validateParameter(valid_592205, JString, required = true,
                                 default = nil)
  if valid_592205 != nil:
    section.add "profileId", valid_592205
  var valid_592206 = path.getOrDefault("id")
  valid_592206 = validateParameter(valid_592206, JString, required = true,
                                 default = nil)
  if valid_592206 != nil:
    section.add "id", valid_592206
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592207 = query.getOrDefault("fields")
  valid_592207 = validateParameter(valid_592207, JString, required = false,
                                 default = nil)
  if valid_592207 != nil:
    section.add "fields", valid_592207
  var valid_592208 = query.getOrDefault("quotaUser")
  valid_592208 = validateParameter(valid_592208, JString, required = false,
                                 default = nil)
  if valid_592208 != nil:
    section.add "quotaUser", valid_592208
  var valid_592209 = query.getOrDefault("alt")
  valid_592209 = validateParameter(valid_592209, JString, required = false,
                                 default = newJString("json"))
  if valid_592209 != nil:
    section.add "alt", valid_592209
  var valid_592210 = query.getOrDefault("oauth_token")
  valid_592210 = validateParameter(valid_592210, JString, required = false,
                                 default = nil)
  if valid_592210 != nil:
    section.add "oauth_token", valid_592210
  var valid_592211 = query.getOrDefault("userIp")
  valid_592211 = validateParameter(valid_592211, JString, required = false,
                                 default = nil)
  if valid_592211 != nil:
    section.add "userIp", valid_592211
  var valid_592212 = query.getOrDefault("key")
  valid_592212 = validateParameter(valid_592212, JString, required = false,
                                 default = nil)
  if valid_592212 != nil:
    section.add "key", valid_592212
  var valid_592213 = query.getOrDefault("prettyPrint")
  valid_592213 = validateParameter(valid_592213, JBool, required = false,
                                 default = newJBool(true))
  if valid_592213 != nil:
    section.add "prettyPrint", valid_592213
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592214: Call_DfareportingSitesGet_592202; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one site by ID.
  ## 
  let valid = call_592214.validator(path, query, header, formData, body)
  let scheme = call_592214.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592214.url(scheme.get, call_592214.host, call_592214.base,
                         call_592214.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592214, url, valid)

proc call*(call_592215: Call_DfareportingSitesGet_592202; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingSitesGet
  ## Gets one site by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Site ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592216 = newJObject()
  var query_592217 = newJObject()
  add(path_592216, "profileId", newJString(profileId))
  add(query_592217, "fields", newJString(fields))
  add(query_592217, "quotaUser", newJString(quotaUser))
  add(query_592217, "alt", newJString(alt))
  add(query_592217, "oauth_token", newJString(oauthToken))
  add(query_592217, "userIp", newJString(userIp))
  add(path_592216, "id", newJString(id))
  add(query_592217, "key", newJString(key))
  add(query_592217, "prettyPrint", newJBool(prettyPrint))
  result = call_592215.call(path_592216, query_592217, nil, nil, nil)

var dfareportingSitesGet* = Call_DfareportingSitesGet_592202(
    name: "dfareportingSitesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites/{id}",
    validator: validate_DfareportingSitesGet_592203, base: "/dfareporting/v2.7",
    url: url_DfareportingSitesGet_592204, schemes: {Scheme.Https})
type
  Call_DfareportingSizesInsert_592237 = ref object of OpenApiRestCall_588466
proc url_DfareportingSizesInsert_592239(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sizes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSizesInsert_592238(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new size.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592240 = path.getOrDefault("profileId")
  valid_592240 = validateParameter(valid_592240, JString, required = true,
                                 default = nil)
  if valid_592240 != nil:
    section.add "profileId", valid_592240
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592241 = query.getOrDefault("fields")
  valid_592241 = validateParameter(valid_592241, JString, required = false,
                                 default = nil)
  if valid_592241 != nil:
    section.add "fields", valid_592241
  var valid_592242 = query.getOrDefault("quotaUser")
  valid_592242 = validateParameter(valid_592242, JString, required = false,
                                 default = nil)
  if valid_592242 != nil:
    section.add "quotaUser", valid_592242
  var valid_592243 = query.getOrDefault("alt")
  valid_592243 = validateParameter(valid_592243, JString, required = false,
                                 default = newJString("json"))
  if valid_592243 != nil:
    section.add "alt", valid_592243
  var valid_592244 = query.getOrDefault("oauth_token")
  valid_592244 = validateParameter(valid_592244, JString, required = false,
                                 default = nil)
  if valid_592244 != nil:
    section.add "oauth_token", valid_592244
  var valid_592245 = query.getOrDefault("userIp")
  valid_592245 = validateParameter(valid_592245, JString, required = false,
                                 default = nil)
  if valid_592245 != nil:
    section.add "userIp", valid_592245
  var valid_592246 = query.getOrDefault("key")
  valid_592246 = validateParameter(valid_592246, JString, required = false,
                                 default = nil)
  if valid_592246 != nil:
    section.add "key", valid_592246
  var valid_592247 = query.getOrDefault("prettyPrint")
  valid_592247 = validateParameter(valid_592247, JBool, required = false,
                                 default = newJBool(true))
  if valid_592247 != nil:
    section.add "prettyPrint", valid_592247
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592249: Call_DfareportingSizesInsert_592237; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new size.
  ## 
  let valid = call_592249.validator(path, query, header, formData, body)
  let scheme = call_592249.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592249.url(scheme.get, call_592249.host, call_592249.base,
                         call_592249.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592249, url, valid)

proc call*(call_592250: Call_DfareportingSizesInsert_592237; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSizesInsert
  ## Inserts a new size.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592251 = newJObject()
  var query_592252 = newJObject()
  var body_592253 = newJObject()
  add(path_592251, "profileId", newJString(profileId))
  add(query_592252, "fields", newJString(fields))
  add(query_592252, "quotaUser", newJString(quotaUser))
  add(query_592252, "alt", newJString(alt))
  add(query_592252, "oauth_token", newJString(oauthToken))
  add(query_592252, "userIp", newJString(userIp))
  add(query_592252, "key", newJString(key))
  if body != nil:
    body_592253 = body
  add(query_592252, "prettyPrint", newJBool(prettyPrint))
  result = call_592250.call(path_592251, query_592252, nil, nil, body_592253)

var dfareportingSizesInsert* = Call_DfareportingSizesInsert_592237(
    name: "dfareportingSizesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sizes",
    validator: validate_DfareportingSizesInsert_592238,
    base: "/dfareporting/v2.7", url: url_DfareportingSizesInsert_592239,
    schemes: {Scheme.Https})
type
  Call_DfareportingSizesList_592218 = ref object of OpenApiRestCall_588466
proc url_DfareportingSizesList_592220(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sizes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSizesList_592219(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of sizes, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592221 = path.getOrDefault("profileId")
  valid_592221 = validateParameter(valid_592221, JString, required = true,
                                 default = nil)
  if valid_592221 != nil:
    section.add "profileId", valid_592221
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   height: JInt
  ##         : Select only sizes with this height.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Select only sizes with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   iabStandard: JBool
  ##              : Select only IAB standard sizes.
  ##   width: JInt
  ##        : Select only sizes with this width.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592222 = query.getOrDefault("fields")
  valid_592222 = validateParameter(valid_592222, JString, required = false,
                                 default = nil)
  if valid_592222 != nil:
    section.add "fields", valid_592222
  var valid_592223 = query.getOrDefault("quotaUser")
  valid_592223 = validateParameter(valid_592223, JString, required = false,
                                 default = nil)
  if valid_592223 != nil:
    section.add "quotaUser", valid_592223
  var valid_592224 = query.getOrDefault("alt")
  valid_592224 = validateParameter(valid_592224, JString, required = false,
                                 default = newJString("json"))
  if valid_592224 != nil:
    section.add "alt", valid_592224
  var valid_592225 = query.getOrDefault("oauth_token")
  valid_592225 = validateParameter(valid_592225, JString, required = false,
                                 default = nil)
  if valid_592225 != nil:
    section.add "oauth_token", valid_592225
  var valid_592226 = query.getOrDefault("height")
  valid_592226 = validateParameter(valid_592226, JInt, required = false, default = nil)
  if valid_592226 != nil:
    section.add "height", valid_592226
  var valid_592227 = query.getOrDefault("userIp")
  valid_592227 = validateParameter(valid_592227, JString, required = false,
                                 default = nil)
  if valid_592227 != nil:
    section.add "userIp", valid_592227
  var valid_592228 = query.getOrDefault("ids")
  valid_592228 = validateParameter(valid_592228, JArray, required = false,
                                 default = nil)
  if valid_592228 != nil:
    section.add "ids", valid_592228
  var valid_592229 = query.getOrDefault("key")
  valid_592229 = validateParameter(valid_592229, JString, required = false,
                                 default = nil)
  if valid_592229 != nil:
    section.add "key", valid_592229
  var valid_592230 = query.getOrDefault("iabStandard")
  valid_592230 = validateParameter(valid_592230, JBool, required = false, default = nil)
  if valid_592230 != nil:
    section.add "iabStandard", valid_592230
  var valid_592231 = query.getOrDefault("width")
  valid_592231 = validateParameter(valid_592231, JInt, required = false, default = nil)
  if valid_592231 != nil:
    section.add "width", valid_592231
  var valid_592232 = query.getOrDefault("prettyPrint")
  valid_592232 = validateParameter(valid_592232, JBool, required = false,
                                 default = newJBool(true))
  if valid_592232 != nil:
    section.add "prettyPrint", valid_592232
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592233: Call_DfareportingSizesList_592218; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of sizes, possibly filtered.
  ## 
  let valid = call_592233.validator(path, query, header, formData, body)
  let scheme = call_592233.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592233.url(scheme.get, call_592233.host, call_592233.base,
                         call_592233.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592233, url, valid)

proc call*(call_592234: Call_DfareportingSizesList_592218; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; height: int = 0; userIp: string = "";
          ids: JsonNode = nil; key: string = ""; iabStandard: bool = false; width: int = 0;
          prettyPrint: bool = true): Recallable =
  ## dfareportingSizesList
  ## Retrieves a list of sizes, possibly filtered.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   height: int
  ##         : Select only sizes with this height.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Select only sizes with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   iabStandard: bool
  ##              : Select only IAB standard sizes.
  ##   width: int
  ##        : Select only sizes with this width.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592235 = newJObject()
  var query_592236 = newJObject()
  add(path_592235, "profileId", newJString(profileId))
  add(query_592236, "fields", newJString(fields))
  add(query_592236, "quotaUser", newJString(quotaUser))
  add(query_592236, "alt", newJString(alt))
  add(query_592236, "oauth_token", newJString(oauthToken))
  add(query_592236, "height", newJInt(height))
  add(query_592236, "userIp", newJString(userIp))
  if ids != nil:
    query_592236.add "ids", ids
  add(query_592236, "key", newJString(key))
  add(query_592236, "iabStandard", newJBool(iabStandard))
  add(query_592236, "width", newJInt(width))
  add(query_592236, "prettyPrint", newJBool(prettyPrint))
  result = call_592234.call(path_592235, query_592236, nil, nil, nil)

var dfareportingSizesList* = Call_DfareportingSizesList_592218(
    name: "dfareportingSizesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sizes",
    validator: validate_DfareportingSizesList_592219, base: "/dfareporting/v2.7",
    url: url_DfareportingSizesList_592220, schemes: {Scheme.Https})
type
  Call_DfareportingSizesGet_592254 = ref object of OpenApiRestCall_588466
proc url_DfareportingSizesGet_592256(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sizes/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSizesGet_592255(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one size by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Size ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592257 = path.getOrDefault("profileId")
  valid_592257 = validateParameter(valid_592257, JString, required = true,
                                 default = nil)
  if valid_592257 != nil:
    section.add "profileId", valid_592257
  var valid_592258 = path.getOrDefault("id")
  valid_592258 = validateParameter(valid_592258, JString, required = true,
                                 default = nil)
  if valid_592258 != nil:
    section.add "id", valid_592258
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592259 = query.getOrDefault("fields")
  valid_592259 = validateParameter(valid_592259, JString, required = false,
                                 default = nil)
  if valid_592259 != nil:
    section.add "fields", valid_592259
  var valid_592260 = query.getOrDefault("quotaUser")
  valid_592260 = validateParameter(valid_592260, JString, required = false,
                                 default = nil)
  if valid_592260 != nil:
    section.add "quotaUser", valid_592260
  var valid_592261 = query.getOrDefault("alt")
  valid_592261 = validateParameter(valid_592261, JString, required = false,
                                 default = newJString("json"))
  if valid_592261 != nil:
    section.add "alt", valid_592261
  var valid_592262 = query.getOrDefault("oauth_token")
  valid_592262 = validateParameter(valid_592262, JString, required = false,
                                 default = nil)
  if valid_592262 != nil:
    section.add "oauth_token", valid_592262
  var valid_592263 = query.getOrDefault("userIp")
  valid_592263 = validateParameter(valid_592263, JString, required = false,
                                 default = nil)
  if valid_592263 != nil:
    section.add "userIp", valid_592263
  var valid_592264 = query.getOrDefault("key")
  valid_592264 = validateParameter(valid_592264, JString, required = false,
                                 default = nil)
  if valid_592264 != nil:
    section.add "key", valid_592264
  var valid_592265 = query.getOrDefault("prettyPrint")
  valid_592265 = validateParameter(valid_592265, JBool, required = false,
                                 default = newJBool(true))
  if valid_592265 != nil:
    section.add "prettyPrint", valid_592265
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592266: Call_DfareportingSizesGet_592254; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one size by ID.
  ## 
  let valid = call_592266.validator(path, query, header, formData, body)
  let scheme = call_592266.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592266.url(scheme.get, call_592266.host, call_592266.base,
                         call_592266.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592266, url, valid)

proc call*(call_592267: Call_DfareportingSizesGet_592254; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingSizesGet
  ## Gets one size by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Size ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592268 = newJObject()
  var query_592269 = newJObject()
  add(path_592268, "profileId", newJString(profileId))
  add(query_592269, "fields", newJString(fields))
  add(query_592269, "quotaUser", newJString(quotaUser))
  add(query_592269, "alt", newJString(alt))
  add(query_592269, "oauth_token", newJString(oauthToken))
  add(query_592269, "userIp", newJString(userIp))
  add(path_592268, "id", newJString(id))
  add(query_592269, "key", newJString(key))
  add(query_592269, "prettyPrint", newJBool(prettyPrint))
  result = call_592267.call(path_592268, query_592269, nil, nil, nil)

var dfareportingSizesGet* = Call_DfareportingSizesGet_592254(
    name: "dfareportingSizesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sizes/{id}",
    validator: validate_DfareportingSizesGet_592255, base: "/dfareporting/v2.7",
    url: url_DfareportingSizesGet_592256, schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsUpdate_592291 = ref object of OpenApiRestCall_588466
proc url_DfareportingSubaccountsUpdate_592293(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsUpdate_592292(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing subaccount.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592294 = path.getOrDefault("profileId")
  valid_592294 = validateParameter(valid_592294, JString, required = true,
                                 default = nil)
  if valid_592294 != nil:
    section.add "profileId", valid_592294
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592295 = query.getOrDefault("fields")
  valid_592295 = validateParameter(valid_592295, JString, required = false,
                                 default = nil)
  if valid_592295 != nil:
    section.add "fields", valid_592295
  var valid_592296 = query.getOrDefault("quotaUser")
  valid_592296 = validateParameter(valid_592296, JString, required = false,
                                 default = nil)
  if valid_592296 != nil:
    section.add "quotaUser", valid_592296
  var valid_592297 = query.getOrDefault("alt")
  valid_592297 = validateParameter(valid_592297, JString, required = false,
                                 default = newJString("json"))
  if valid_592297 != nil:
    section.add "alt", valid_592297
  var valid_592298 = query.getOrDefault("oauth_token")
  valid_592298 = validateParameter(valid_592298, JString, required = false,
                                 default = nil)
  if valid_592298 != nil:
    section.add "oauth_token", valid_592298
  var valid_592299 = query.getOrDefault("userIp")
  valid_592299 = validateParameter(valid_592299, JString, required = false,
                                 default = nil)
  if valid_592299 != nil:
    section.add "userIp", valid_592299
  var valid_592300 = query.getOrDefault("key")
  valid_592300 = validateParameter(valid_592300, JString, required = false,
                                 default = nil)
  if valid_592300 != nil:
    section.add "key", valid_592300
  var valid_592301 = query.getOrDefault("prettyPrint")
  valid_592301 = validateParameter(valid_592301, JBool, required = false,
                                 default = newJBool(true))
  if valid_592301 != nil:
    section.add "prettyPrint", valid_592301
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592303: Call_DfareportingSubaccountsUpdate_592291; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing subaccount.
  ## 
  let valid = call_592303.validator(path, query, header, formData, body)
  let scheme = call_592303.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592303.url(scheme.get, call_592303.host, call_592303.base,
                         call_592303.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592303, url, valid)

proc call*(call_592304: Call_DfareportingSubaccountsUpdate_592291;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsUpdate
  ## Updates an existing subaccount.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592305 = newJObject()
  var query_592306 = newJObject()
  var body_592307 = newJObject()
  add(path_592305, "profileId", newJString(profileId))
  add(query_592306, "fields", newJString(fields))
  add(query_592306, "quotaUser", newJString(quotaUser))
  add(query_592306, "alt", newJString(alt))
  add(query_592306, "oauth_token", newJString(oauthToken))
  add(query_592306, "userIp", newJString(userIp))
  add(query_592306, "key", newJString(key))
  if body != nil:
    body_592307 = body
  add(query_592306, "prettyPrint", newJBool(prettyPrint))
  result = call_592304.call(path_592305, query_592306, nil, nil, body_592307)

var dfareportingSubaccountsUpdate* = Call_DfareportingSubaccountsUpdate_592291(
    name: "dfareportingSubaccountsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsUpdate_592292,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsUpdate_592293,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsInsert_592308 = ref object of OpenApiRestCall_588466
proc url_DfareportingSubaccountsInsert_592310(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsInsert_592309(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new subaccount.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592311 = path.getOrDefault("profileId")
  valid_592311 = validateParameter(valid_592311, JString, required = true,
                                 default = nil)
  if valid_592311 != nil:
    section.add "profileId", valid_592311
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592312 = query.getOrDefault("fields")
  valid_592312 = validateParameter(valid_592312, JString, required = false,
                                 default = nil)
  if valid_592312 != nil:
    section.add "fields", valid_592312
  var valid_592313 = query.getOrDefault("quotaUser")
  valid_592313 = validateParameter(valid_592313, JString, required = false,
                                 default = nil)
  if valid_592313 != nil:
    section.add "quotaUser", valid_592313
  var valid_592314 = query.getOrDefault("alt")
  valid_592314 = validateParameter(valid_592314, JString, required = false,
                                 default = newJString("json"))
  if valid_592314 != nil:
    section.add "alt", valid_592314
  var valid_592315 = query.getOrDefault("oauth_token")
  valid_592315 = validateParameter(valid_592315, JString, required = false,
                                 default = nil)
  if valid_592315 != nil:
    section.add "oauth_token", valid_592315
  var valid_592316 = query.getOrDefault("userIp")
  valid_592316 = validateParameter(valid_592316, JString, required = false,
                                 default = nil)
  if valid_592316 != nil:
    section.add "userIp", valid_592316
  var valid_592317 = query.getOrDefault("key")
  valid_592317 = validateParameter(valid_592317, JString, required = false,
                                 default = nil)
  if valid_592317 != nil:
    section.add "key", valid_592317
  var valid_592318 = query.getOrDefault("prettyPrint")
  valid_592318 = validateParameter(valid_592318, JBool, required = false,
                                 default = newJBool(true))
  if valid_592318 != nil:
    section.add "prettyPrint", valid_592318
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592320: Call_DfareportingSubaccountsInsert_592308; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new subaccount.
  ## 
  let valid = call_592320.validator(path, query, header, formData, body)
  let scheme = call_592320.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592320.url(scheme.get, call_592320.host, call_592320.base,
                         call_592320.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592320, url, valid)

proc call*(call_592321: Call_DfareportingSubaccountsInsert_592308;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsInsert
  ## Inserts a new subaccount.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592322 = newJObject()
  var query_592323 = newJObject()
  var body_592324 = newJObject()
  add(path_592322, "profileId", newJString(profileId))
  add(query_592323, "fields", newJString(fields))
  add(query_592323, "quotaUser", newJString(quotaUser))
  add(query_592323, "alt", newJString(alt))
  add(query_592323, "oauth_token", newJString(oauthToken))
  add(query_592323, "userIp", newJString(userIp))
  add(query_592323, "key", newJString(key))
  if body != nil:
    body_592324 = body
  add(query_592323, "prettyPrint", newJBool(prettyPrint))
  result = call_592321.call(path_592322, query_592323, nil, nil, body_592324)

var dfareportingSubaccountsInsert* = Call_DfareportingSubaccountsInsert_592308(
    name: "dfareportingSubaccountsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsInsert_592309,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsInsert_592310,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsList_592270 = ref object of OpenApiRestCall_588466
proc url_DfareportingSubaccountsList_592272(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsList_592271(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of subaccounts, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592273 = path.getOrDefault("profileId")
  valid_592273 = validateParameter(valid_592273, JString, required = true,
                                 default = nil)
  if valid_592273 != nil:
    section.add "profileId", valid_592273
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "subaccount*2015" will return objects with names like "subaccount June 2015", "subaccount April 2015", or simply "subaccount 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "subaccount" will match objects with name "my subaccount", "subaccount 2015", or simply "subaccount".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only subaccounts with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592274 = query.getOrDefault("fields")
  valid_592274 = validateParameter(valid_592274, JString, required = false,
                                 default = nil)
  if valid_592274 != nil:
    section.add "fields", valid_592274
  var valid_592275 = query.getOrDefault("pageToken")
  valid_592275 = validateParameter(valid_592275, JString, required = false,
                                 default = nil)
  if valid_592275 != nil:
    section.add "pageToken", valid_592275
  var valid_592276 = query.getOrDefault("quotaUser")
  valid_592276 = validateParameter(valid_592276, JString, required = false,
                                 default = nil)
  if valid_592276 != nil:
    section.add "quotaUser", valid_592276
  var valid_592277 = query.getOrDefault("sortField")
  valid_592277 = validateParameter(valid_592277, JString, required = false,
                                 default = newJString("ID"))
  if valid_592277 != nil:
    section.add "sortField", valid_592277
  var valid_592278 = query.getOrDefault("alt")
  valid_592278 = validateParameter(valid_592278, JString, required = false,
                                 default = newJString("json"))
  if valid_592278 != nil:
    section.add "alt", valid_592278
  var valid_592279 = query.getOrDefault("searchString")
  valid_592279 = validateParameter(valid_592279, JString, required = false,
                                 default = nil)
  if valid_592279 != nil:
    section.add "searchString", valid_592279
  var valid_592280 = query.getOrDefault("oauth_token")
  valid_592280 = validateParameter(valid_592280, JString, required = false,
                                 default = nil)
  if valid_592280 != nil:
    section.add "oauth_token", valid_592280
  var valid_592281 = query.getOrDefault("userIp")
  valid_592281 = validateParameter(valid_592281, JString, required = false,
                                 default = nil)
  if valid_592281 != nil:
    section.add "userIp", valid_592281
  var valid_592282 = query.getOrDefault("maxResults")
  valid_592282 = validateParameter(valid_592282, JInt, required = false,
                                 default = newJInt(1000))
  if valid_592282 != nil:
    section.add "maxResults", valid_592282
  var valid_592283 = query.getOrDefault("ids")
  valid_592283 = validateParameter(valid_592283, JArray, required = false,
                                 default = nil)
  if valid_592283 != nil:
    section.add "ids", valid_592283
  var valid_592284 = query.getOrDefault("key")
  valid_592284 = validateParameter(valid_592284, JString, required = false,
                                 default = nil)
  if valid_592284 != nil:
    section.add "key", valid_592284
  var valid_592285 = query.getOrDefault("sortOrder")
  valid_592285 = validateParameter(valid_592285, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_592285 != nil:
    section.add "sortOrder", valid_592285
  var valid_592286 = query.getOrDefault("prettyPrint")
  valid_592286 = validateParameter(valid_592286, JBool, required = false,
                                 default = newJBool(true))
  if valid_592286 != nil:
    section.add "prettyPrint", valid_592286
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592287: Call_DfareportingSubaccountsList_592270; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of subaccounts, possibly filtered. This method supports paging.
  ## 
  let valid = call_592287.validator(path, query, header, formData, body)
  let scheme = call_592287.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592287.url(scheme.get, call_592287.host, call_592287.base,
                         call_592287.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592287, url, valid)

proc call*(call_592288: Call_DfareportingSubaccountsList_592270; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; searchString: string = "";
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsList
  ## Gets a list of subaccounts, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "subaccount*2015" will return objects with names like "subaccount June 2015", "subaccount April 2015", or simply "subaccount 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "subaccount" will match objects with name "my subaccount", "subaccount 2015", or simply "subaccount".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only subaccounts with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592289 = newJObject()
  var query_592290 = newJObject()
  add(path_592289, "profileId", newJString(profileId))
  add(query_592290, "fields", newJString(fields))
  add(query_592290, "pageToken", newJString(pageToken))
  add(query_592290, "quotaUser", newJString(quotaUser))
  add(query_592290, "sortField", newJString(sortField))
  add(query_592290, "alt", newJString(alt))
  add(query_592290, "searchString", newJString(searchString))
  add(query_592290, "oauth_token", newJString(oauthToken))
  add(query_592290, "userIp", newJString(userIp))
  add(query_592290, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_592290.add "ids", ids
  add(query_592290, "key", newJString(key))
  add(query_592290, "sortOrder", newJString(sortOrder))
  add(query_592290, "prettyPrint", newJBool(prettyPrint))
  result = call_592288.call(path_592289, query_592290, nil, nil, nil)

var dfareportingSubaccountsList* = Call_DfareportingSubaccountsList_592270(
    name: "dfareportingSubaccountsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsList_592271,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsList_592272,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsPatch_592325 = ref object of OpenApiRestCall_588466
proc url_DfareportingSubaccountsPatch_592327(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsPatch_592326(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing subaccount. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592328 = path.getOrDefault("profileId")
  valid_592328 = validateParameter(valid_592328, JString, required = true,
                                 default = nil)
  if valid_592328 != nil:
    section.add "profileId", valid_592328
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Subaccount ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592329 = query.getOrDefault("fields")
  valid_592329 = validateParameter(valid_592329, JString, required = false,
                                 default = nil)
  if valid_592329 != nil:
    section.add "fields", valid_592329
  var valid_592330 = query.getOrDefault("quotaUser")
  valid_592330 = validateParameter(valid_592330, JString, required = false,
                                 default = nil)
  if valid_592330 != nil:
    section.add "quotaUser", valid_592330
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_592331 = query.getOrDefault("id")
  valid_592331 = validateParameter(valid_592331, JString, required = true,
                                 default = nil)
  if valid_592331 != nil:
    section.add "id", valid_592331
  var valid_592332 = query.getOrDefault("alt")
  valid_592332 = validateParameter(valid_592332, JString, required = false,
                                 default = newJString("json"))
  if valid_592332 != nil:
    section.add "alt", valid_592332
  var valid_592333 = query.getOrDefault("oauth_token")
  valid_592333 = validateParameter(valid_592333, JString, required = false,
                                 default = nil)
  if valid_592333 != nil:
    section.add "oauth_token", valid_592333
  var valid_592334 = query.getOrDefault("userIp")
  valid_592334 = validateParameter(valid_592334, JString, required = false,
                                 default = nil)
  if valid_592334 != nil:
    section.add "userIp", valid_592334
  var valid_592335 = query.getOrDefault("key")
  valid_592335 = validateParameter(valid_592335, JString, required = false,
                                 default = nil)
  if valid_592335 != nil:
    section.add "key", valid_592335
  var valid_592336 = query.getOrDefault("prettyPrint")
  valid_592336 = validateParameter(valid_592336, JBool, required = false,
                                 default = newJBool(true))
  if valid_592336 != nil:
    section.add "prettyPrint", valid_592336
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592338: Call_DfareportingSubaccountsPatch_592325; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing subaccount. This method supports patch semantics.
  ## 
  let valid = call_592338.validator(path, query, header, formData, body)
  let scheme = call_592338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592338.url(scheme.get, call_592338.host, call_592338.base,
                         call_592338.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592338, url, valid)

proc call*(call_592339: Call_DfareportingSubaccountsPatch_592325;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsPatch
  ## Updates an existing subaccount. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Subaccount ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592340 = newJObject()
  var query_592341 = newJObject()
  var body_592342 = newJObject()
  add(path_592340, "profileId", newJString(profileId))
  add(query_592341, "fields", newJString(fields))
  add(query_592341, "quotaUser", newJString(quotaUser))
  add(query_592341, "id", newJString(id))
  add(query_592341, "alt", newJString(alt))
  add(query_592341, "oauth_token", newJString(oauthToken))
  add(query_592341, "userIp", newJString(userIp))
  add(query_592341, "key", newJString(key))
  if body != nil:
    body_592342 = body
  add(query_592341, "prettyPrint", newJBool(prettyPrint))
  result = call_592339.call(path_592340, query_592341, nil, nil, body_592342)

var dfareportingSubaccountsPatch* = Call_DfareportingSubaccountsPatch_592325(
    name: "dfareportingSubaccountsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsPatch_592326,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsPatch_592327,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsGet_592343 = ref object of OpenApiRestCall_588466
proc url_DfareportingSubaccountsGet_592345(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsGet_592344(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one subaccount by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Subaccount ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592346 = path.getOrDefault("profileId")
  valid_592346 = validateParameter(valid_592346, JString, required = true,
                                 default = nil)
  if valid_592346 != nil:
    section.add "profileId", valid_592346
  var valid_592347 = path.getOrDefault("id")
  valid_592347 = validateParameter(valid_592347, JString, required = true,
                                 default = nil)
  if valid_592347 != nil:
    section.add "id", valid_592347
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592348 = query.getOrDefault("fields")
  valid_592348 = validateParameter(valid_592348, JString, required = false,
                                 default = nil)
  if valid_592348 != nil:
    section.add "fields", valid_592348
  var valid_592349 = query.getOrDefault("quotaUser")
  valid_592349 = validateParameter(valid_592349, JString, required = false,
                                 default = nil)
  if valid_592349 != nil:
    section.add "quotaUser", valid_592349
  var valid_592350 = query.getOrDefault("alt")
  valid_592350 = validateParameter(valid_592350, JString, required = false,
                                 default = newJString("json"))
  if valid_592350 != nil:
    section.add "alt", valid_592350
  var valid_592351 = query.getOrDefault("oauth_token")
  valid_592351 = validateParameter(valid_592351, JString, required = false,
                                 default = nil)
  if valid_592351 != nil:
    section.add "oauth_token", valid_592351
  var valid_592352 = query.getOrDefault("userIp")
  valid_592352 = validateParameter(valid_592352, JString, required = false,
                                 default = nil)
  if valid_592352 != nil:
    section.add "userIp", valid_592352
  var valid_592353 = query.getOrDefault("key")
  valid_592353 = validateParameter(valid_592353, JString, required = false,
                                 default = nil)
  if valid_592353 != nil:
    section.add "key", valid_592353
  var valid_592354 = query.getOrDefault("prettyPrint")
  valid_592354 = validateParameter(valid_592354, JBool, required = false,
                                 default = newJBool(true))
  if valid_592354 != nil:
    section.add "prettyPrint", valid_592354
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592355: Call_DfareportingSubaccountsGet_592343; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one subaccount by ID.
  ## 
  let valid = call_592355.validator(path, query, header, formData, body)
  let scheme = call_592355.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592355.url(scheme.get, call_592355.host, call_592355.base,
                         call_592355.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592355, url, valid)

proc call*(call_592356: Call_DfareportingSubaccountsGet_592343; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsGet
  ## Gets one subaccount by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Subaccount ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592357 = newJObject()
  var query_592358 = newJObject()
  add(path_592357, "profileId", newJString(profileId))
  add(query_592358, "fields", newJString(fields))
  add(query_592358, "quotaUser", newJString(quotaUser))
  add(query_592358, "alt", newJString(alt))
  add(query_592358, "oauth_token", newJString(oauthToken))
  add(query_592358, "userIp", newJString(userIp))
  add(path_592357, "id", newJString(id))
  add(query_592358, "key", newJString(key))
  add(query_592358, "prettyPrint", newJBool(prettyPrint))
  result = call_592356.call(path_592357, query_592358, nil, nil, nil)

var dfareportingSubaccountsGet* = Call_DfareportingSubaccountsGet_592343(
    name: "dfareportingSubaccountsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/subaccounts/{id}",
    validator: validate_DfareportingSubaccountsGet_592344,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsGet_592345,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetableRemarketingListsList_592359 = ref object of OpenApiRestCall_588466
proc url_DfareportingTargetableRemarketingListsList_592361(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetableRemarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetableRemarketingListsList_592360(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of targetable remarketing lists, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592362 = path.getOrDefault("profileId")
  valid_592362 = validateParameter(valid_592362, JString, required = true,
                                 default = nil)
  if valid_592362 != nil:
    section.add "profileId", valid_592362
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   advertiserId: JString (required)
  ##               : Select only targetable remarketing lists targetable by these advertisers.
  ##   active: JBool
  ##         : Select only active or only inactive targetable remarketing lists.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: JString
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592363 = query.getOrDefault("fields")
  valid_592363 = validateParameter(valid_592363, JString, required = false,
                                 default = nil)
  if valid_592363 != nil:
    section.add "fields", valid_592363
  var valid_592364 = query.getOrDefault("pageToken")
  valid_592364 = validateParameter(valid_592364, JString, required = false,
                                 default = nil)
  if valid_592364 != nil:
    section.add "pageToken", valid_592364
  var valid_592365 = query.getOrDefault("quotaUser")
  valid_592365 = validateParameter(valid_592365, JString, required = false,
                                 default = nil)
  if valid_592365 != nil:
    section.add "quotaUser", valid_592365
  var valid_592366 = query.getOrDefault("sortField")
  valid_592366 = validateParameter(valid_592366, JString, required = false,
                                 default = newJString("ID"))
  if valid_592366 != nil:
    section.add "sortField", valid_592366
  var valid_592367 = query.getOrDefault("alt")
  valid_592367 = validateParameter(valid_592367, JString, required = false,
                                 default = newJString("json"))
  if valid_592367 != nil:
    section.add "alt", valid_592367
  assert query != nil,
        "query argument is necessary due to required `advertiserId` field"
  var valid_592368 = query.getOrDefault("advertiserId")
  valid_592368 = validateParameter(valid_592368, JString, required = true,
                                 default = nil)
  if valid_592368 != nil:
    section.add "advertiserId", valid_592368
  var valid_592369 = query.getOrDefault("active")
  valid_592369 = validateParameter(valid_592369, JBool, required = false, default = nil)
  if valid_592369 != nil:
    section.add "active", valid_592369
  var valid_592370 = query.getOrDefault("oauth_token")
  valid_592370 = validateParameter(valid_592370, JString, required = false,
                                 default = nil)
  if valid_592370 != nil:
    section.add "oauth_token", valid_592370
  var valid_592371 = query.getOrDefault("userIp")
  valid_592371 = validateParameter(valid_592371, JString, required = false,
                                 default = nil)
  if valid_592371 != nil:
    section.add "userIp", valid_592371
  var valid_592372 = query.getOrDefault("maxResults")
  valid_592372 = validateParameter(valid_592372, JInt, required = false,
                                 default = newJInt(1000))
  if valid_592372 != nil:
    section.add "maxResults", valid_592372
  var valid_592373 = query.getOrDefault("key")
  valid_592373 = validateParameter(valid_592373, JString, required = false,
                                 default = nil)
  if valid_592373 != nil:
    section.add "key", valid_592373
  var valid_592374 = query.getOrDefault("name")
  valid_592374 = validateParameter(valid_592374, JString, required = false,
                                 default = nil)
  if valid_592374 != nil:
    section.add "name", valid_592374
  var valid_592375 = query.getOrDefault("sortOrder")
  valid_592375 = validateParameter(valid_592375, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_592375 != nil:
    section.add "sortOrder", valid_592375
  var valid_592376 = query.getOrDefault("prettyPrint")
  valid_592376 = validateParameter(valid_592376, JBool, required = false,
                                 default = newJBool(true))
  if valid_592376 != nil:
    section.add "prettyPrint", valid_592376
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592377: Call_DfareportingTargetableRemarketingListsList_592359;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of targetable remarketing lists, possibly filtered. This method supports paging.
  ## 
  let valid = call_592377.validator(path, query, header, formData, body)
  let scheme = call_592377.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592377.url(scheme.get, call_592377.host, call_592377.base,
                         call_592377.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592377, url, valid)

proc call*(call_592378: Call_DfareportingTargetableRemarketingListsList_592359;
          profileId: string; advertiserId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; active: bool = false; oauthToken: string = "";
          userIp: string = ""; maxResults: int = 1000; key: string = ""; name: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetableRemarketingListsList
  ## Retrieves a list of targetable remarketing lists, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   advertiserId: string (required)
  ##               : Select only targetable remarketing lists targetable by these advertisers.
  ##   active: bool
  ##         : Select only active or only inactive targetable remarketing lists.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: string
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592379 = newJObject()
  var query_592380 = newJObject()
  add(path_592379, "profileId", newJString(profileId))
  add(query_592380, "fields", newJString(fields))
  add(query_592380, "pageToken", newJString(pageToken))
  add(query_592380, "quotaUser", newJString(quotaUser))
  add(query_592380, "sortField", newJString(sortField))
  add(query_592380, "alt", newJString(alt))
  add(query_592380, "advertiserId", newJString(advertiserId))
  add(query_592380, "active", newJBool(active))
  add(query_592380, "oauth_token", newJString(oauthToken))
  add(query_592380, "userIp", newJString(userIp))
  add(query_592380, "maxResults", newJInt(maxResults))
  add(query_592380, "key", newJString(key))
  add(query_592380, "name", newJString(name))
  add(query_592380, "sortOrder", newJString(sortOrder))
  add(query_592380, "prettyPrint", newJBool(prettyPrint))
  result = call_592378.call(path_592379, query_592380, nil, nil, nil)

var dfareportingTargetableRemarketingListsList* = Call_DfareportingTargetableRemarketingListsList_592359(
    name: "dfareportingTargetableRemarketingListsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetableRemarketingLists",
    validator: validate_DfareportingTargetableRemarketingListsList_592360,
    base: "/dfareporting/v2.7",
    url: url_DfareportingTargetableRemarketingListsList_592361,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetableRemarketingListsGet_592381 = ref object of OpenApiRestCall_588466
proc url_DfareportingTargetableRemarketingListsGet_592383(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetableRemarketingLists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetableRemarketingListsGet_592382(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one remarketing list by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Remarketing list ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592384 = path.getOrDefault("profileId")
  valid_592384 = validateParameter(valid_592384, JString, required = true,
                                 default = nil)
  if valid_592384 != nil:
    section.add "profileId", valid_592384
  var valid_592385 = path.getOrDefault("id")
  valid_592385 = validateParameter(valid_592385, JString, required = true,
                                 default = nil)
  if valid_592385 != nil:
    section.add "id", valid_592385
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592386 = query.getOrDefault("fields")
  valid_592386 = validateParameter(valid_592386, JString, required = false,
                                 default = nil)
  if valid_592386 != nil:
    section.add "fields", valid_592386
  var valid_592387 = query.getOrDefault("quotaUser")
  valid_592387 = validateParameter(valid_592387, JString, required = false,
                                 default = nil)
  if valid_592387 != nil:
    section.add "quotaUser", valid_592387
  var valid_592388 = query.getOrDefault("alt")
  valid_592388 = validateParameter(valid_592388, JString, required = false,
                                 default = newJString("json"))
  if valid_592388 != nil:
    section.add "alt", valid_592388
  var valid_592389 = query.getOrDefault("oauth_token")
  valid_592389 = validateParameter(valid_592389, JString, required = false,
                                 default = nil)
  if valid_592389 != nil:
    section.add "oauth_token", valid_592389
  var valid_592390 = query.getOrDefault("userIp")
  valid_592390 = validateParameter(valid_592390, JString, required = false,
                                 default = nil)
  if valid_592390 != nil:
    section.add "userIp", valid_592390
  var valid_592391 = query.getOrDefault("key")
  valid_592391 = validateParameter(valid_592391, JString, required = false,
                                 default = nil)
  if valid_592391 != nil:
    section.add "key", valid_592391
  var valid_592392 = query.getOrDefault("prettyPrint")
  valid_592392 = validateParameter(valid_592392, JBool, required = false,
                                 default = newJBool(true))
  if valid_592392 != nil:
    section.add "prettyPrint", valid_592392
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592393: Call_DfareportingTargetableRemarketingListsGet_592381;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one remarketing list by ID.
  ## 
  let valid = call_592393.validator(path, query, header, formData, body)
  let scheme = call_592393.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592393.url(scheme.get, call_592393.host, call_592393.base,
                         call_592393.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592393, url, valid)

proc call*(call_592394: Call_DfareportingTargetableRemarketingListsGet_592381;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetableRemarketingListsGet
  ## Gets one remarketing list by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Remarketing list ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592395 = newJObject()
  var query_592396 = newJObject()
  add(path_592395, "profileId", newJString(profileId))
  add(query_592396, "fields", newJString(fields))
  add(query_592396, "quotaUser", newJString(quotaUser))
  add(query_592396, "alt", newJString(alt))
  add(query_592396, "oauth_token", newJString(oauthToken))
  add(query_592396, "userIp", newJString(userIp))
  add(path_592395, "id", newJString(id))
  add(query_592396, "key", newJString(key))
  add(query_592396, "prettyPrint", newJBool(prettyPrint))
  result = call_592394.call(path_592395, query_592396, nil, nil, nil)

var dfareportingTargetableRemarketingListsGet* = Call_DfareportingTargetableRemarketingListsGet_592381(
    name: "dfareportingTargetableRemarketingListsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetableRemarketingLists/{id}",
    validator: validate_DfareportingTargetableRemarketingListsGet_592382,
    base: "/dfareporting/v2.7",
    url: url_DfareportingTargetableRemarketingListsGet_592383,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesUpdate_592419 = ref object of OpenApiRestCall_588466
proc url_DfareportingTargetingTemplatesUpdate_592421(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesUpdate_592420(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing targeting template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592422 = path.getOrDefault("profileId")
  valid_592422 = validateParameter(valid_592422, JString, required = true,
                                 default = nil)
  if valid_592422 != nil:
    section.add "profileId", valid_592422
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592423 = query.getOrDefault("fields")
  valid_592423 = validateParameter(valid_592423, JString, required = false,
                                 default = nil)
  if valid_592423 != nil:
    section.add "fields", valid_592423
  var valid_592424 = query.getOrDefault("quotaUser")
  valid_592424 = validateParameter(valid_592424, JString, required = false,
                                 default = nil)
  if valid_592424 != nil:
    section.add "quotaUser", valid_592424
  var valid_592425 = query.getOrDefault("alt")
  valid_592425 = validateParameter(valid_592425, JString, required = false,
                                 default = newJString("json"))
  if valid_592425 != nil:
    section.add "alt", valid_592425
  var valid_592426 = query.getOrDefault("oauth_token")
  valid_592426 = validateParameter(valid_592426, JString, required = false,
                                 default = nil)
  if valid_592426 != nil:
    section.add "oauth_token", valid_592426
  var valid_592427 = query.getOrDefault("userIp")
  valid_592427 = validateParameter(valid_592427, JString, required = false,
                                 default = nil)
  if valid_592427 != nil:
    section.add "userIp", valid_592427
  var valid_592428 = query.getOrDefault("key")
  valid_592428 = validateParameter(valid_592428, JString, required = false,
                                 default = nil)
  if valid_592428 != nil:
    section.add "key", valid_592428
  var valid_592429 = query.getOrDefault("prettyPrint")
  valid_592429 = validateParameter(valid_592429, JBool, required = false,
                                 default = newJBool(true))
  if valid_592429 != nil:
    section.add "prettyPrint", valid_592429
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592431: Call_DfareportingTargetingTemplatesUpdate_592419;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing targeting template.
  ## 
  let valid = call_592431.validator(path, query, header, formData, body)
  let scheme = call_592431.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592431.url(scheme.get, call_592431.host, call_592431.base,
                         call_592431.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592431, url, valid)

proc call*(call_592432: Call_DfareportingTargetingTemplatesUpdate_592419;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesUpdate
  ## Updates an existing targeting template.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592433 = newJObject()
  var query_592434 = newJObject()
  var body_592435 = newJObject()
  add(path_592433, "profileId", newJString(profileId))
  add(query_592434, "fields", newJString(fields))
  add(query_592434, "quotaUser", newJString(quotaUser))
  add(query_592434, "alt", newJString(alt))
  add(query_592434, "oauth_token", newJString(oauthToken))
  add(query_592434, "userIp", newJString(userIp))
  add(query_592434, "key", newJString(key))
  if body != nil:
    body_592435 = body
  add(query_592434, "prettyPrint", newJBool(prettyPrint))
  result = call_592432.call(path_592433, query_592434, nil, nil, body_592435)

var dfareportingTargetingTemplatesUpdate* = Call_DfareportingTargetingTemplatesUpdate_592419(
    name: "dfareportingTargetingTemplatesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesUpdate_592420,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesUpdate_592421,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesInsert_592436 = ref object of OpenApiRestCall_588466
proc url_DfareportingTargetingTemplatesInsert_592438(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesInsert_592437(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new targeting template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592439 = path.getOrDefault("profileId")
  valid_592439 = validateParameter(valid_592439, JString, required = true,
                                 default = nil)
  if valid_592439 != nil:
    section.add "profileId", valid_592439
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592440 = query.getOrDefault("fields")
  valid_592440 = validateParameter(valid_592440, JString, required = false,
                                 default = nil)
  if valid_592440 != nil:
    section.add "fields", valid_592440
  var valid_592441 = query.getOrDefault("quotaUser")
  valid_592441 = validateParameter(valid_592441, JString, required = false,
                                 default = nil)
  if valid_592441 != nil:
    section.add "quotaUser", valid_592441
  var valid_592442 = query.getOrDefault("alt")
  valid_592442 = validateParameter(valid_592442, JString, required = false,
                                 default = newJString("json"))
  if valid_592442 != nil:
    section.add "alt", valid_592442
  var valid_592443 = query.getOrDefault("oauth_token")
  valid_592443 = validateParameter(valid_592443, JString, required = false,
                                 default = nil)
  if valid_592443 != nil:
    section.add "oauth_token", valid_592443
  var valid_592444 = query.getOrDefault("userIp")
  valid_592444 = validateParameter(valid_592444, JString, required = false,
                                 default = nil)
  if valid_592444 != nil:
    section.add "userIp", valid_592444
  var valid_592445 = query.getOrDefault("key")
  valid_592445 = validateParameter(valid_592445, JString, required = false,
                                 default = nil)
  if valid_592445 != nil:
    section.add "key", valid_592445
  var valid_592446 = query.getOrDefault("prettyPrint")
  valid_592446 = validateParameter(valid_592446, JBool, required = false,
                                 default = newJBool(true))
  if valid_592446 != nil:
    section.add "prettyPrint", valid_592446
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592448: Call_DfareportingTargetingTemplatesInsert_592436;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new targeting template.
  ## 
  let valid = call_592448.validator(path, query, header, formData, body)
  let scheme = call_592448.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592448.url(scheme.get, call_592448.host, call_592448.base,
                         call_592448.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592448, url, valid)

proc call*(call_592449: Call_DfareportingTargetingTemplatesInsert_592436;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesInsert
  ## Inserts a new targeting template.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592450 = newJObject()
  var query_592451 = newJObject()
  var body_592452 = newJObject()
  add(path_592450, "profileId", newJString(profileId))
  add(query_592451, "fields", newJString(fields))
  add(query_592451, "quotaUser", newJString(quotaUser))
  add(query_592451, "alt", newJString(alt))
  add(query_592451, "oauth_token", newJString(oauthToken))
  add(query_592451, "userIp", newJString(userIp))
  add(query_592451, "key", newJString(key))
  if body != nil:
    body_592452 = body
  add(query_592451, "prettyPrint", newJBool(prettyPrint))
  result = call_592449.call(path_592450, query_592451, nil, nil, body_592452)

var dfareportingTargetingTemplatesInsert* = Call_DfareportingTargetingTemplatesInsert_592436(
    name: "dfareportingTargetingTemplatesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesInsert_592437,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesInsert_592438,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesList_592397 = ref object of OpenApiRestCall_588466
proc url_DfareportingTargetingTemplatesList_592399(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesList_592398(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of targeting templates, optionally filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592400 = path.getOrDefault("profileId")
  valid_592400 = validateParameter(valid_592400, JString, required = true,
                                 default = nil)
  if valid_592400 != nil:
    section.add "profileId", valid_592400
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "template*2015" will return objects with names like "template June 2015", "template April 2015", or simply "template 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "template" will match objects with name "my template", "template 2015", or simply "template".
  ##   advertiserId: JString
  ##               : Select only targeting templates with this advertiser ID.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only targeting templates with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592401 = query.getOrDefault("fields")
  valid_592401 = validateParameter(valid_592401, JString, required = false,
                                 default = nil)
  if valid_592401 != nil:
    section.add "fields", valid_592401
  var valid_592402 = query.getOrDefault("pageToken")
  valid_592402 = validateParameter(valid_592402, JString, required = false,
                                 default = nil)
  if valid_592402 != nil:
    section.add "pageToken", valid_592402
  var valid_592403 = query.getOrDefault("quotaUser")
  valid_592403 = validateParameter(valid_592403, JString, required = false,
                                 default = nil)
  if valid_592403 != nil:
    section.add "quotaUser", valid_592403
  var valid_592404 = query.getOrDefault("sortField")
  valid_592404 = validateParameter(valid_592404, JString, required = false,
                                 default = newJString("ID"))
  if valid_592404 != nil:
    section.add "sortField", valid_592404
  var valid_592405 = query.getOrDefault("alt")
  valid_592405 = validateParameter(valid_592405, JString, required = false,
                                 default = newJString("json"))
  if valid_592405 != nil:
    section.add "alt", valid_592405
  var valid_592406 = query.getOrDefault("searchString")
  valid_592406 = validateParameter(valid_592406, JString, required = false,
                                 default = nil)
  if valid_592406 != nil:
    section.add "searchString", valid_592406
  var valid_592407 = query.getOrDefault("advertiserId")
  valid_592407 = validateParameter(valid_592407, JString, required = false,
                                 default = nil)
  if valid_592407 != nil:
    section.add "advertiserId", valid_592407
  var valid_592408 = query.getOrDefault("oauth_token")
  valid_592408 = validateParameter(valid_592408, JString, required = false,
                                 default = nil)
  if valid_592408 != nil:
    section.add "oauth_token", valid_592408
  var valid_592409 = query.getOrDefault("userIp")
  valid_592409 = validateParameter(valid_592409, JString, required = false,
                                 default = nil)
  if valid_592409 != nil:
    section.add "userIp", valid_592409
  var valid_592410 = query.getOrDefault("maxResults")
  valid_592410 = validateParameter(valid_592410, JInt, required = false,
                                 default = newJInt(1000))
  if valid_592410 != nil:
    section.add "maxResults", valid_592410
  var valid_592411 = query.getOrDefault("ids")
  valid_592411 = validateParameter(valid_592411, JArray, required = false,
                                 default = nil)
  if valid_592411 != nil:
    section.add "ids", valid_592411
  var valid_592412 = query.getOrDefault("key")
  valid_592412 = validateParameter(valid_592412, JString, required = false,
                                 default = nil)
  if valid_592412 != nil:
    section.add "key", valid_592412
  var valid_592413 = query.getOrDefault("sortOrder")
  valid_592413 = validateParameter(valid_592413, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_592413 != nil:
    section.add "sortOrder", valid_592413
  var valid_592414 = query.getOrDefault("prettyPrint")
  valid_592414 = validateParameter(valid_592414, JBool, required = false,
                                 default = newJBool(true))
  if valid_592414 != nil:
    section.add "prettyPrint", valid_592414
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592415: Call_DfareportingTargetingTemplatesList_592397;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of targeting templates, optionally filtered. This method supports paging.
  ## 
  let valid = call_592415.validator(path, query, header, formData, body)
  let scheme = call_592415.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592415.url(scheme.get, call_592415.host, call_592415.base,
                         call_592415.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592415, url, valid)

proc call*(call_592416: Call_DfareportingTargetingTemplatesList_592397;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; advertiserId: string = ""; oauthToken: string = "";
          userIp: string = ""; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesList
  ## Retrieves a list of targeting templates, optionally filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "template*2015" will return objects with names like "template June 2015", "template April 2015", or simply "template 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "template" will match objects with name "my template", "template 2015", or simply "template".
  ##   advertiserId: string
  ##               : Select only targeting templates with this advertiser ID.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only targeting templates with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592417 = newJObject()
  var query_592418 = newJObject()
  add(path_592417, "profileId", newJString(profileId))
  add(query_592418, "fields", newJString(fields))
  add(query_592418, "pageToken", newJString(pageToken))
  add(query_592418, "quotaUser", newJString(quotaUser))
  add(query_592418, "sortField", newJString(sortField))
  add(query_592418, "alt", newJString(alt))
  add(query_592418, "searchString", newJString(searchString))
  add(query_592418, "advertiserId", newJString(advertiserId))
  add(query_592418, "oauth_token", newJString(oauthToken))
  add(query_592418, "userIp", newJString(userIp))
  add(query_592418, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_592418.add "ids", ids
  add(query_592418, "key", newJString(key))
  add(query_592418, "sortOrder", newJString(sortOrder))
  add(query_592418, "prettyPrint", newJBool(prettyPrint))
  result = call_592416.call(path_592417, query_592418, nil, nil, nil)

var dfareportingTargetingTemplatesList* = Call_DfareportingTargetingTemplatesList_592397(
    name: "dfareportingTargetingTemplatesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesList_592398,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesList_592399,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesPatch_592453 = ref object of OpenApiRestCall_588466
proc url_DfareportingTargetingTemplatesPatch_592455(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesPatch_592454(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing targeting template. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592456 = path.getOrDefault("profileId")
  valid_592456 = validateParameter(valid_592456, JString, required = true,
                                 default = nil)
  if valid_592456 != nil:
    section.add "profileId", valid_592456
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Targeting template ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592457 = query.getOrDefault("fields")
  valid_592457 = validateParameter(valid_592457, JString, required = false,
                                 default = nil)
  if valid_592457 != nil:
    section.add "fields", valid_592457
  var valid_592458 = query.getOrDefault("quotaUser")
  valid_592458 = validateParameter(valid_592458, JString, required = false,
                                 default = nil)
  if valid_592458 != nil:
    section.add "quotaUser", valid_592458
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_592459 = query.getOrDefault("id")
  valid_592459 = validateParameter(valid_592459, JString, required = true,
                                 default = nil)
  if valid_592459 != nil:
    section.add "id", valid_592459
  var valid_592460 = query.getOrDefault("alt")
  valid_592460 = validateParameter(valid_592460, JString, required = false,
                                 default = newJString("json"))
  if valid_592460 != nil:
    section.add "alt", valid_592460
  var valid_592461 = query.getOrDefault("oauth_token")
  valid_592461 = validateParameter(valid_592461, JString, required = false,
                                 default = nil)
  if valid_592461 != nil:
    section.add "oauth_token", valid_592461
  var valid_592462 = query.getOrDefault("userIp")
  valid_592462 = validateParameter(valid_592462, JString, required = false,
                                 default = nil)
  if valid_592462 != nil:
    section.add "userIp", valid_592462
  var valid_592463 = query.getOrDefault("key")
  valid_592463 = validateParameter(valid_592463, JString, required = false,
                                 default = nil)
  if valid_592463 != nil:
    section.add "key", valid_592463
  var valid_592464 = query.getOrDefault("prettyPrint")
  valid_592464 = validateParameter(valid_592464, JBool, required = false,
                                 default = newJBool(true))
  if valid_592464 != nil:
    section.add "prettyPrint", valid_592464
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592466: Call_DfareportingTargetingTemplatesPatch_592453;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing targeting template. This method supports patch semantics.
  ## 
  let valid = call_592466.validator(path, query, header, formData, body)
  let scheme = call_592466.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592466.url(scheme.get, call_592466.host, call_592466.base,
                         call_592466.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592466, url, valid)

proc call*(call_592467: Call_DfareportingTargetingTemplatesPatch_592453;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesPatch
  ## Updates an existing targeting template. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Targeting template ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592468 = newJObject()
  var query_592469 = newJObject()
  var body_592470 = newJObject()
  add(path_592468, "profileId", newJString(profileId))
  add(query_592469, "fields", newJString(fields))
  add(query_592469, "quotaUser", newJString(quotaUser))
  add(query_592469, "id", newJString(id))
  add(query_592469, "alt", newJString(alt))
  add(query_592469, "oauth_token", newJString(oauthToken))
  add(query_592469, "userIp", newJString(userIp))
  add(query_592469, "key", newJString(key))
  if body != nil:
    body_592470 = body
  add(query_592469, "prettyPrint", newJBool(prettyPrint))
  result = call_592467.call(path_592468, query_592469, nil, nil, body_592470)

var dfareportingTargetingTemplatesPatch* = Call_DfareportingTargetingTemplatesPatch_592453(
    name: "dfareportingTargetingTemplatesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesPatch_592454,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesPatch_592455,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesGet_592471 = ref object of OpenApiRestCall_588466
proc url_DfareportingTargetingTemplatesGet_592473(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesGet_592472(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one targeting template by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Targeting template ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592474 = path.getOrDefault("profileId")
  valid_592474 = validateParameter(valid_592474, JString, required = true,
                                 default = nil)
  if valid_592474 != nil:
    section.add "profileId", valid_592474
  var valid_592475 = path.getOrDefault("id")
  valid_592475 = validateParameter(valid_592475, JString, required = true,
                                 default = nil)
  if valid_592475 != nil:
    section.add "id", valid_592475
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592476 = query.getOrDefault("fields")
  valid_592476 = validateParameter(valid_592476, JString, required = false,
                                 default = nil)
  if valid_592476 != nil:
    section.add "fields", valid_592476
  var valid_592477 = query.getOrDefault("quotaUser")
  valid_592477 = validateParameter(valid_592477, JString, required = false,
                                 default = nil)
  if valid_592477 != nil:
    section.add "quotaUser", valid_592477
  var valid_592478 = query.getOrDefault("alt")
  valid_592478 = validateParameter(valid_592478, JString, required = false,
                                 default = newJString("json"))
  if valid_592478 != nil:
    section.add "alt", valid_592478
  var valid_592479 = query.getOrDefault("oauth_token")
  valid_592479 = validateParameter(valid_592479, JString, required = false,
                                 default = nil)
  if valid_592479 != nil:
    section.add "oauth_token", valid_592479
  var valid_592480 = query.getOrDefault("userIp")
  valid_592480 = validateParameter(valid_592480, JString, required = false,
                                 default = nil)
  if valid_592480 != nil:
    section.add "userIp", valid_592480
  var valid_592481 = query.getOrDefault("key")
  valid_592481 = validateParameter(valid_592481, JString, required = false,
                                 default = nil)
  if valid_592481 != nil:
    section.add "key", valid_592481
  var valid_592482 = query.getOrDefault("prettyPrint")
  valid_592482 = validateParameter(valid_592482, JBool, required = false,
                                 default = newJBool(true))
  if valid_592482 != nil:
    section.add "prettyPrint", valid_592482
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592483: Call_DfareportingTargetingTemplatesGet_592471;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one targeting template by ID.
  ## 
  let valid = call_592483.validator(path, query, header, formData, body)
  let scheme = call_592483.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592483.url(scheme.get, call_592483.host, call_592483.base,
                         call_592483.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592483, url, valid)

proc call*(call_592484: Call_DfareportingTargetingTemplatesGet_592471;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesGet
  ## Gets one targeting template by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Targeting template ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592485 = newJObject()
  var query_592486 = newJObject()
  add(path_592485, "profileId", newJString(profileId))
  add(query_592486, "fields", newJString(fields))
  add(query_592486, "quotaUser", newJString(quotaUser))
  add(query_592486, "alt", newJString(alt))
  add(query_592486, "oauth_token", newJString(oauthToken))
  add(query_592486, "userIp", newJString(userIp))
  add(path_592485, "id", newJString(id))
  add(query_592486, "key", newJString(key))
  add(query_592486, "prettyPrint", newJBool(prettyPrint))
  result = call_592484.call(path_592485, query_592486, nil, nil, nil)

var dfareportingTargetingTemplatesGet* = Call_DfareportingTargetingTemplatesGet_592471(
    name: "dfareportingTargetingTemplatesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates/{id}",
    validator: validate_DfareportingTargetingTemplatesGet_592472,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesGet_592473,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionGroupsList_592487 = ref object of OpenApiRestCall_588466
proc url_DfareportingUserRolePermissionGroupsList_592489(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissionGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionGroupsList_592488(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of all supported user role permission groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592490 = path.getOrDefault("profileId")
  valid_592490 = validateParameter(valid_592490, JString, required = true,
                                 default = nil)
  if valid_592490 != nil:
    section.add "profileId", valid_592490
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592491 = query.getOrDefault("fields")
  valid_592491 = validateParameter(valid_592491, JString, required = false,
                                 default = nil)
  if valid_592491 != nil:
    section.add "fields", valid_592491
  var valid_592492 = query.getOrDefault("quotaUser")
  valid_592492 = validateParameter(valid_592492, JString, required = false,
                                 default = nil)
  if valid_592492 != nil:
    section.add "quotaUser", valid_592492
  var valid_592493 = query.getOrDefault("alt")
  valid_592493 = validateParameter(valid_592493, JString, required = false,
                                 default = newJString("json"))
  if valid_592493 != nil:
    section.add "alt", valid_592493
  var valid_592494 = query.getOrDefault("oauth_token")
  valid_592494 = validateParameter(valid_592494, JString, required = false,
                                 default = nil)
  if valid_592494 != nil:
    section.add "oauth_token", valid_592494
  var valid_592495 = query.getOrDefault("userIp")
  valid_592495 = validateParameter(valid_592495, JString, required = false,
                                 default = nil)
  if valid_592495 != nil:
    section.add "userIp", valid_592495
  var valid_592496 = query.getOrDefault("key")
  valid_592496 = validateParameter(valid_592496, JString, required = false,
                                 default = nil)
  if valid_592496 != nil:
    section.add "key", valid_592496
  var valid_592497 = query.getOrDefault("prettyPrint")
  valid_592497 = validateParameter(valid_592497, JBool, required = false,
                                 default = newJBool(true))
  if valid_592497 != nil:
    section.add "prettyPrint", valid_592497
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592498: Call_DfareportingUserRolePermissionGroupsList_592487;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of all supported user role permission groups.
  ## 
  let valid = call_592498.validator(path, query, header, formData, body)
  let scheme = call_592498.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592498.url(scheme.get, call_592498.host, call_592498.base,
                         call_592498.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592498, url, valid)

proc call*(call_592499: Call_DfareportingUserRolePermissionGroupsList_592487;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolePermissionGroupsList
  ## Gets a list of all supported user role permission groups.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592500 = newJObject()
  var query_592501 = newJObject()
  add(path_592500, "profileId", newJString(profileId))
  add(query_592501, "fields", newJString(fields))
  add(query_592501, "quotaUser", newJString(quotaUser))
  add(query_592501, "alt", newJString(alt))
  add(query_592501, "oauth_token", newJString(oauthToken))
  add(query_592501, "userIp", newJString(userIp))
  add(query_592501, "key", newJString(key))
  add(query_592501, "prettyPrint", newJBool(prettyPrint))
  result = call_592499.call(path_592500, query_592501, nil, nil, nil)

var dfareportingUserRolePermissionGroupsList* = Call_DfareportingUserRolePermissionGroupsList_592487(
    name: "dfareportingUserRolePermissionGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissionGroups",
    validator: validate_DfareportingUserRolePermissionGroupsList_592488,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionGroupsList_592489,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionGroupsGet_592502 = ref object of OpenApiRestCall_588466
proc url_DfareportingUserRolePermissionGroupsGet_592504(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissionGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionGroupsGet_592503(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user role permission group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role permission group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592505 = path.getOrDefault("profileId")
  valid_592505 = validateParameter(valid_592505, JString, required = true,
                                 default = nil)
  if valid_592505 != nil:
    section.add "profileId", valid_592505
  var valid_592506 = path.getOrDefault("id")
  valid_592506 = validateParameter(valid_592506, JString, required = true,
                                 default = nil)
  if valid_592506 != nil:
    section.add "id", valid_592506
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592507 = query.getOrDefault("fields")
  valid_592507 = validateParameter(valid_592507, JString, required = false,
                                 default = nil)
  if valid_592507 != nil:
    section.add "fields", valid_592507
  var valid_592508 = query.getOrDefault("quotaUser")
  valid_592508 = validateParameter(valid_592508, JString, required = false,
                                 default = nil)
  if valid_592508 != nil:
    section.add "quotaUser", valid_592508
  var valid_592509 = query.getOrDefault("alt")
  valid_592509 = validateParameter(valid_592509, JString, required = false,
                                 default = newJString("json"))
  if valid_592509 != nil:
    section.add "alt", valid_592509
  var valid_592510 = query.getOrDefault("oauth_token")
  valid_592510 = validateParameter(valid_592510, JString, required = false,
                                 default = nil)
  if valid_592510 != nil:
    section.add "oauth_token", valid_592510
  var valid_592511 = query.getOrDefault("userIp")
  valid_592511 = validateParameter(valid_592511, JString, required = false,
                                 default = nil)
  if valid_592511 != nil:
    section.add "userIp", valid_592511
  var valid_592512 = query.getOrDefault("key")
  valid_592512 = validateParameter(valid_592512, JString, required = false,
                                 default = nil)
  if valid_592512 != nil:
    section.add "key", valid_592512
  var valid_592513 = query.getOrDefault("prettyPrint")
  valid_592513 = validateParameter(valid_592513, JBool, required = false,
                                 default = newJBool(true))
  if valid_592513 != nil:
    section.add "prettyPrint", valid_592513
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592514: Call_DfareportingUserRolePermissionGroupsGet_592502;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one user role permission group by ID.
  ## 
  let valid = call_592514.validator(path, query, header, formData, body)
  let scheme = call_592514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592514.url(scheme.get, call_592514.host, call_592514.base,
                         call_592514.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592514, url, valid)

proc call*(call_592515: Call_DfareportingUserRolePermissionGroupsGet_592502;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolePermissionGroupsGet
  ## Gets one user role permission group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User role permission group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592516 = newJObject()
  var query_592517 = newJObject()
  add(path_592516, "profileId", newJString(profileId))
  add(query_592517, "fields", newJString(fields))
  add(query_592517, "quotaUser", newJString(quotaUser))
  add(query_592517, "alt", newJString(alt))
  add(query_592517, "oauth_token", newJString(oauthToken))
  add(query_592517, "userIp", newJString(userIp))
  add(path_592516, "id", newJString(id))
  add(query_592517, "key", newJString(key))
  add(query_592517, "prettyPrint", newJBool(prettyPrint))
  result = call_592515.call(path_592516, query_592517, nil, nil, nil)

var dfareportingUserRolePermissionGroupsGet* = Call_DfareportingUserRolePermissionGroupsGet_592502(
    name: "dfareportingUserRolePermissionGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissionGroups/{id}",
    validator: validate_DfareportingUserRolePermissionGroupsGet_592503,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionGroupsGet_592504,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionsList_592518 = ref object of OpenApiRestCall_588466
proc url_DfareportingUserRolePermissionsList_592520(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionsList_592519(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of user role permissions, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592521 = path.getOrDefault("profileId")
  valid_592521 = validateParameter(valid_592521, JString, required = true,
                                 default = nil)
  if valid_592521 != nil:
    section.add "profileId", valid_592521
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Select only user role permissions with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592522 = query.getOrDefault("fields")
  valid_592522 = validateParameter(valid_592522, JString, required = false,
                                 default = nil)
  if valid_592522 != nil:
    section.add "fields", valid_592522
  var valid_592523 = query.getOrDefault("quotaUser")
  valid_592523 = validateParameter(valid_592523, JString, required = false,
                                 default = nil)
  if valid_592523 != nil:
    section.add "quotaUser", valid_592523
  var valid_592524 = query.getOrDefault("alt")
  valid_592524 = validateParameter(valid_592524, JString, required = false,
                                 default = newJString("json"))
  if valid_592524 != nil:
    section.add "alt", valid_592524
  var valid_592525 = query.getOrDefault("oauth_token")
  valid_592525 = validateParameter(valid_592525, JString, required = false,
                                 default = nil)
  if valid_592525 != nil:
    section.add "oauth_token", valid_592525
  var valid_592526 = query.getOrDefault("userIp")
  valid_592526 = validateParameter(valid_592526, JString, required = false,
                                 default = nil)
  if valid_592526 != nil:
    section.add "userIp", valid_592526
  var valid_592527 = query.getOrDefault("ids")
  valid_592527 = validateParameter(valid_592527, JArray, required = false,
                                 default = nil)
  if valid_592527 != nil:
    section.add "ids", valid_592527
  var valid_592528 = query.getOrDefault("key")
  valid_592528 = validateParameter(valid_592528, JString, required = false,
                                 default = nil)
  if valid_592528 != nil:
    section.add "key", valid_592528
  var valid_592529 = query.getOrDefault("prettyPrint")
  valid_592529 = validateParameter(valid_592529, JBool, required = false,
                                 default = newJBool(true))
  if valid_592529 != nil:
    section.add "prettyPrint", valid_592529
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592530: Call_DfareportingUserRolePermissionsList_592518;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of user role permissions, possibly filtered.
  ## 
  let valid = call_592530.validator(path, query, header, formData, body)
  let scheme = call_592530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592530.url(scheme.get, call_592530.host, call_592530.base,
                         call_592530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592530, url, valid)

proc call*(call_592531: Call_DfareportingUserRolePermissionsList_592518;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          ids: JsonNode = nil; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolePermissionsList
  ## Gets a list of user role permissions, possibly filtered.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Select only user role permissions with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592532 = newJObject()
  var query_592533 = newJObject()
  add(path_592532, "profileId", newJString(profileId))
  add(query_592533, "fields", newJString(fields))
  add(query_592533, "quotaUser", newJString(quotaUser))
  add(query_592533, "alt", newJString(alt))
  add(query_592533, "oauth_token", newJString(oauthToken))
  add(query_592533, "userIp", newJString(userIp))
  if ids != nil:
    query_592533.add "ids", ids
  add(query_592533, "key", newJString(key))
  add(query_592533, "prettyPrint", newJBool(prettyPrint))
  result = call_592531.call(path_592532, query_592533, nil, nil, nil)

var dfareportingUserRolePermissionsList* = Call_DfareportingUserRolePermissionsList_592518(
    name: "dfareportingUserRolePermissionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissions",
    validator: validate_DfareportingUserRolePermissionsList_592519,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionsList_592520,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionsGet_592534 = ref object of OpenApiRestCall_588466
proc url_DfareportingUserRolePermissionsGet_592536(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissions/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionsGet_592535(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user role permission by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role permission ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592537 = path.getOrDefault("profileId")
  valid_592537 = validateParameter(valid_592537, JString, required = true,
                                 default = nil)
  if valid_592537 != nil:
    section.add "profileId", valid_592537
  var valid_592538 = path.getOrDefault("id")
  valid_592538 = validateParameter(valid_592538, JString, required = true,
                                 default = nil)
  if valid_592538 != nil:
    section.add "id", valid_592538
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592539 = query.getOrDefault("fields")
  valid_592539 = validateParameter(valid_592539, JString, required = false,
                                 default = nil)
  if valid_592539 != nil:
    section.add "fields", valid_592539
  var valid_592540 = query.getOrDefault("quotaUser")
  valid_592540 = validateParameter(valid_592540, JString, required = false,
                                 default = nil)
  if valid_592540 != nil:
    section.add "quotaUser", valid_592540
  var valid_592541 = query.getOrDefault("alt")
  valid_592541 = validateParameter(valid_592541, JString, required = false,
                                 default = newJString("json"))
  if valid_592541 != nil:
    section.add "alt", valid_592541
  var valid_592542 = query.getOrDefault("oauth_token")
  valid_592542 = validateParameter(valid_592542, JString, required = false,
                                 default = nil)
  if valid_592542 != nil:
    section.add "oauth_token", valid_592542
  var valid_592543 = query.getOrDefault("userIp")
  valid_592543 = validateParameter(valid_592543, JString, required = false,
                                 default = nil)
  if valid_592543 != nil:
    section.add "userIp", valid_592543
  var valid_592544 = query.getOrDefault("key")
  valid_592544 = validateParameter(valid_592544, JString, required = false,
                                 default = nil)
  if valid_592544 != nil:
    section.add "key", valid_592544
  var valid_592545 = query.getOrDefault("prettyPrint")
  valid_592545 = validateParameter(valid_592545, JBool, required = false,
                                 default = newJBool(true))
  if valid_592545 != nil:
    section.add "prettyPrint", valid_592545
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592546: Call_DfareportingUserRolePermissionsGet_592534;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one user role permission by ID.
  ## 
  let valid = call_592546.validator(path, query, header, formData, body)
  let scheme = call_592546.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592546.url(scheme.get, call_592546.host, call_592546.base,
                         call_592546.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592546, url, valid)

proc call*(call_592547: Call_DfareportingUserRolePermissionsGet_592534;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolePermissionsGet
  ## Gets one user role permission by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User role permission ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592548 = newJObject()
  var query_592549 = newJObject()
  add(path_592548, "profileId", newJString(profileId))
  add(query_592549, "fields", newJString(fields))
  add(query_592549, "quotaUser", newJString(quotaUser))
  add(query_592549, "alt", newJString(alt))
  add(query_592549, "oauth_token", newJString(oauthToken))
  add(query_592549, "userIp", newJString(userIp))
  add(path_592548, "id", newJString(id))
  add(query_592549, "key", newJString(key))
  add(query_592549, "prettyPrint", newJBool(prettyPrint))
  result = call_592547.call(path_592548, query_592549, nil, nil, nil)

var dfareportingUserRolePermissionsGet* = Call_DfareportingUserRolePermissionsGet_592534(
    name: "dfareportingUserRolePermissionsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissions/{id}",
    validator: validate_DfareportingUserRolePermissionsGet_592535,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionsGet_592536,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesUpdate_592573 = ref object of OpenApiRestCall_588466
proc url_DfareportingUserRolesUpdate_592575(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesUpdate_592574(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing user role.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592576 = path.getOrDefault("profileId")
  valid_592576 = validateParameter(valid_592576, JString, required = true,
                                 default = nil)
  if valid_592576 != nil:
    section.add "profileId", valid_592576
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592577 = query.getOrDefault("fields")
  valid_592577 = validateParameter(valid_592577, JString, required = false,
                                 default = nil)
  if valid_592577 != nil:
    section.add "fields", valid_592577
  var valid_592578 = query.getOrDefault("quotaUser")
  valid_592578 = validateParameter(valid_592578, JString, required = false,
                                 default = nil)
  if valid_592578 != nil:
    section.add "quotaUser", valid_592578
  var valid_592579 = query.getOrDefault("alt")
  valid_592579 = validateParameter(valid_592579, JString, required = false,
                                 default = newJString("json"))
  if valid_592579 != nil:
    section.add "alt", valid_592579
  var valid_592580 = query.getOrDefault("oauth_token")
  valid_592580 = validateParameter(valid_592580, JString, required = false,
                                 default = nil)
  if valid_592580 != nil:
    section.add "oauth_token", valid_592580
  var valid_592581 = query.getOrDefault("userIp")
  valid_592581 = validateParameter(valid_592581, JString, required = false,
                                 default = nil)
  if valid_592581 != nil:
    section.add "userIp", valid_592581
  var valid_592582 = query.getOrDefault("key")
  valid_592582 = validateParameter(valid_592582, JString, required = false,
                                 default = nil)
  if valid_592582 != nil:
    section.add "key", valid_592582
  var valid_592583 = query.getOrDefault("prettyPrint")
  valid_592583 = validateParameter(valid_592583, JBool, required = false,
                                 default = newJBool(true))
  if valid_592583 != nil:
    section.add "prettyPrint", valid_592583
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592585: Call_DfareportingUserRolesUpdate_592573; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing user role.
  ## 
  let valid = call_592585.validator(path, query, header, formData, body)
  let scheme = call_592585.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592585.url(scheme.get, call_592585.host, call_592585.base,
                         call_592585.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592585, url, valid)

proc call*(call_592586: Call_DfareportingUserRolesUpdate_592573; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesUpdate
  ## Updates an existing user role.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592587 = newJObject()
  var query_592588 = newJObject()
  var body_592589 = newJObject()
  add(path_592587, "profileId", newJString(profileId))
  add(query_592588, "fields", newJString(fields))
  add(query_592588, "quotaUser", newJString(quotaUser))
  add(query_592588, "alt", newJString(alt))
  add(query_592588, "oauth_token", newJString(oauthToken))
  add(query_592588, "userIp", newJString(userIp))
  add(query_592588, "key", newJString(key))
  if body != nil:
    body_592589 = body
  add(query_592588, "prettyPrint", newJBool(prettyPrint))
  result = call_592586.call(path_592587, query_592588, nil, nil, body_592589)

var dfareportingUserRolesUpdate* = Call_DfareportingUserRolesUpdate_592573(
    name: "dfareportingUserRolesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesUpdate_592574,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesUpdate_592575,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesInsert_592590 = ref object of OpenApiRestCall_588466
proc url_DfareportingUserRolesInsert_592592(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesInsert_592591(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new user role.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592593 = path.getOrDefault("profileId")
  valid_592593 = validateParameter(valid_592593, JString, required = true,
                                 default = nil)
  if valid_592593 != nil:
    section.add "profileId", valid_592593
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592594 = query.getOrDefault("fields")
  valid_592594 = validateParameter(valid_592594, JString, required = false,
                                 default = nil)
  if valid_592594 != nil:
    section.add "fields", valid_592594
  var valid_592595 = query.getOrDefault("quotaUser")
  valid_592595 = validateParameter(valid_592595, JString, required = false,
                                 default = nil)
  if valid_592595 != nil:
    section.add "quotaUser", valid_592595
  var valid_592596 = query.getOrDefault("alt")
  valid_592596 = validateParameter(valid_592596, JString, required = false,
                                 default = newJString("json"))
  if valid_592596 != nil:
    section.add "alt", valid_592596
  var valid_592597 = query.getOrDefault("oauth_token")
  valid_592597 = validateParameter(valid_592597, JString, required = false,
                                 default = nil)
  if valid_592597 != nil:
    section.add "oauth_token", valid_592597
  var valid_592598 = query.getOrDefault("userIp")
  valid_592598 = validateParameter(valid_592598, JString, required = false,
                                 default = nil)
  if valid_592598 != nil:
    section.add "userIp", valid_592598
  var valid_592599 = query.getOrDefault("key")
  valid_592599 = validateParameter(valid_592599, JString, required = false,
                                 default = nil)
  if valid_592599 != nil:
    section.add "key", valid_592599
  var valid_592600 = query.getOrDefault("prettyPrint")
  valid_592600 = validateParameter(valid_592600, JBool, required = false,
                                 default = newJBool(true))
  if valid_592600 != nil:
    section.add "prettyPrint", valid_592600
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592602: Call_DfareportingUserRolesInsert_592590; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new user role.
  ## 
  let valid = call_592602.validator(path, query, header, formData, body)
  let scheme = call_592602.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592602.url(scheme.get, call_592602.host, call_592602.base,
                         call_592602.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592602, url, valid)

proc call*(call_592603: Call_DfareportingUserRolesInsert_592590; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesInsert
  ## Inserts a new user role.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592604 = newJObject()
  var query_592605 = newJObject()
  var body_592606 = newJObject()
  add(path_592604, "profileId", newJString(profileId))
  add(query_592605, "fields", newJString(fields))
  add(query_592605, "quotaUser", newJString(quotaUser))
  add(query_592605, "alt", newJString(alt))
  add(query_592605, "oauth_token", newJString(oauthToken))
  add(query_592605, "userIp", newJString(userIp))
  add(query_592605, "key", newJString(key))
  if body != nil:
    body_592606 = body
  add(query_592605, "prettyPrint", newJBool(prettyPrint))
  result = call_592603.call(path_592604, query_592605, nil, nil, body_592606)

var dfareportingUserRolesInsert* = Call_DfareportingUserRolesInsert_592590(
    name: "dfareportingUserRolesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesInsert_592591,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesInsert_592592,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesList_592550 = ref object of OpenApiRestCall_588466
proc url_DfareportingUserRolesList_592552(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesList_592551(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of user roles, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592553 = path.getOrDefault("profileId")
  valid_592553 = validateParameter(valid_592553, JString, required = true,
                                 default = nil)
  if valid_592553 != nil:
    section.add "profileId", valid_592553
  result.add "path", section
  ## parameters in `query` object:
  ##   subaccountId: JString
  ##               : Select only user roles that belong to this subaccount.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "userrole*2015" will return objects with names like "userrole June 2015", "userrole April 2015", or simply "userrole 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "userrole" will match objects with name "my userrole", "userrole 2015", or simply "userrole".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   accountUserRoleOnly: JBool
  ##                      : Select only account level user roles not associated with any specific subaccount.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only user roles with the specified IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592554 = query.getOrDefault("subaccountId")
  valid_592554 = validateParameter(valid_592554, JString, required = false,
                                 default = nil)
  if valid_592554 != nil:
    section.add "subaccountId", valid_592554
  var valid_592555 = query.getOrDefault("fields")
  valid_592555 = validateParameter(valid_592555, JString, required = false,
                                 default = nil)
  if valid_592555 != nil:
    section.add "fields", valid_592555
  var valid_592556 = query.getOrDefault("pageToken")
  valid_592556 = validateParameter(valid_592556, JString, required = false,
                                 default = nil)
  if valid_592556 != nil:
    section.add "pageToken", valid_592556
  var valid_592557 = query.getOrDefault("quotaUser")
  valid_592557 = validateParameter(valid_592557, JString, required = false,
                                 default = nil)
  if valid_592557 != nil:
    section.add "quotaUser", valid_592557
  var valid_592558 = query.getOrDefault("sortField")
  valid_592558 = validateParameter(valid_592558, JString, required = false,
                                 default = newJString("ID"))
  if valid_592558 != nil:
    section.add "sortField", valid_592558
  var valid_592559 = query.getOrDefault("alt")
  valid_592559 = validateParameter(valid_592559, JString, required = false,
                                 default = newJString("json"))
  if valid_592559 != nil:
    section.add "alt", valid_592559
  var valid_592560 = query.getOrDefault("searchString")
  valid_592560 = validateParameter(valid_592560, JString, required = false,
                                 default = nil)
  if valid_592560 != nil:
    section.add "searchString", valid_592560
  var valid_592561 = query.getOrDefault("oauth_token")
  valid_592561 = validateParameter(valid_592561, JString, required = false,
                                 default = nil)
  if valid_592561 != nil:
    section.add "oauth_token", valid_592561
  var valid_592562 = query.getOrDefault("accountUserRoleOnly")
  valid_592562 = validateParameter(valid_592562, JBool, required = false, default = nil)
  if valid_592562 != nil:
    section.add "accountUserRoleOnly", valid_592562
  var valid_592563 = query.getOrDefault("userIp")
  valid_592563 = validateParameter(valid_592563, JString, required = false,
                                 default = nil)
  if valid_592563 != nil:
    section.add "userIp", valid_592563
  var valid_592564 = query.getOrDefault("maxResults")
  valid_592564 = validateParameter(valid_592564, JInt, required = false,
                                 default = newJInt(1000))
  if valid_592564 != nil:
    section.add "maxResults", valid_592564
  var valid_592565 = query.getOrDefault("ids")
  valid_592565 = validateParameter(valid_592565, JArray, required = false,
                                 default = nil)
  if valid_592565 != nil:
    section.add "ids", valid_592565
  var valid_592566 = query.getOrDefault("key")
  valid_592566 = validateParameter(valid_592566, JString, required = false,
                                 default = nil)
  if valid_592566 != nil:
    section.add "key", valid_592566
  var valid_592567 = query.getOrDefault("sortOrder")
  valid_592567 = validateParameter(valid_592567, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_592567 != nil:
    section.add "sortOrder", valid_592567
  var valid_592568 = query.getOrDefault("prettyPrint")
  valid_592568 = validateParameter(valid_592568, JBool, required = false,
                                 default = newJBool(true))
  if valid_592568 != nil:
    section.add "prettyPrint", valid_592568
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592569: Call_DfareportingUserRolesList_592550; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of user roles, possibly filtered. This method supports paging.
  ## 
  let valid = call_592569.validator(path, query, header, formData, body)
  let scheme = call_592569.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592569.url(scheme.get, call_592569.host, call_592569.base,
                         call_592569.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592569, url, valid)

proc call*(call_592570: Call_DfareportingUserRolesList_592550; profileId: string;
          subaccountId: string = ""; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = "";
          accountUserRoleOnly: bool = false; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesList
  ## Retrieves a list of user roles, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only user roles that belong to this subaccount.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "userrole*2015" will return objects with names like "userrole June 2015", "userrole April 2015", or simply "userrole 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "userrole" will match objects with name "my userrole", "userrole 2015", or simply "userrole".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   accountUserRoleOnly: bool
  ##                      : Select only account level user roles not associated with any specific subaccount.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only user roles with the specified IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592571 = newJObject()
  var query_592572 = newJObject()
  add(path_592571, "profileId", newJString(profileId))
  add(query_592572, "subaccountId", newJString(subaccountId))
  add(query_592572, "fields", newJString(fields))
  add(query_592572, "pageToken", newJString(pageToken))
  add(query_592572, "quotaUser", newJString(quotaUser))
  add(query_592572, "sortField", newJString(sortField))
  add(query_592572, "alt", newJString(alt))
  add(query_592572, "searchString", newJString(searchString))
  add(query_592572, "oauth_token", newJString(oauthToken))
  add(query_592572, "accountUserRoleOnly", newJBool(accountUserRoleOnly))
  add(query_592572, "userIp", newJString(userIp))
  add(query_592572, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_592572.add "ids", ids
  add(query_592572, "key", newJString(key))
  add(query_592572, "sortOrder", newJString(sortOrder))
  add(query_592572, "prettyPrint", newJBool(prettyPrint))
  result = call_592570.call(path_592571, query_592572, nil, nil, nil)

var dfareportingUserRolesList* = Call_DfareportingUserRolesList_592550(
    name: "dfareportingUserRolesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesList_592551,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesList_592552,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesPatch_592607 = ref object of OpenApiRestCall_588466
proc url_DfareportingUserRolesPatch_592609(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesPatch_592608(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing user role. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592610 = path.getOrDefault("profileId")
  valid_592610 = validateParameter(valid_592610, JString, required = true,
                                 default = nil)
  if valid_592610 != nil:
    section.add "profileId", valid_592610
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : User role ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592611 = query.getOrDefault("fields")
  valid_592611 = validateParameter(valid_592611, JString, required = false,
                                 default = nil)
  if valid_592611 != nil:
    section.add "fields", valid_592611
  var valid_592612 = query.getOrDefault("quotaUser")
  valid_592612 = validateParameter(valid_592612, JString, required = false,
                                 default = nil)
  if valid_592612 != nil:
    section.add "quotaUser", valid_592612
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_592613 = query.getOrDefault("id")
  valid_592613 = validateParameter(valid_592613, JString, required = true,
                                 default = nil)
  if valid_592613 != nil:
    section.add "id", valid_592613
  var valid_592614 = query.getOrDefault("alt")
  valid_592614 = validateParameter(valid_592614, JString, required = false,
                                 default = newJString("json"))
  if valid_592614 != nil:
    section.add "alt", valid_592614
  var valid_592615 = query.getOrDefault("oauth_token")
  valid_592615 = validateParameter(valid_592615, JString, required = false,
                                 default = nil)
  if valid_592615 != nil:
    section.add "oauth_token", valid_592615
  var valid_592616 = query.getOrDefault("userIp")
  valid_592616 = validateParameter(valid_592616, JString, required = false,
                                 default = nil)
  if valid_592616 != nil:
    section.add "userIp", valid_592616
  var valid_592617 = query.getOrDefault("key")
  valid_592617 = validateParameter(valid_592617, JString, required = false,
                                 default = nil)
  if valid_592617 != nil:
    section.add "key", valid_592617
  var valid_592618 = query.getOrDefault("prettyPrint")
  valid_592618 = validateParameter(valid_592618, JBool, required = false,
                                 default = newJBool(true))
  if valid_592618 != nil:
    section.add "prettyPrint", valid_592618
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_592620: Call_DfareportingUserRolesPatch_592607; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing user role. This method supports patch semantics.
  ## 
  let valid = call_592620.validator(path, query, header, formData, body)
  let scheme = call_592620.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592620.url(scheme.get, call_592620.host, call_592620.base,
                         call_592620.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592620, url, valid)

proc call*(call_592621: Call_DfareportingUserRolesPatch_592607; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesPatch
  ## Updates an existing user role. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : User role ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592622 = newJObject()
  var query_592623 = newJObject()
  var body_592624 = newJObject()
  add(path_592622, "profileId", newJString(profileId))
  add(query_592623, "fields", newJString(fields))
  add(query_592623, "quotaUser", newJString(quotaUser))
  add(query_592623, "id", newJString(id))
  add(query_592623, "alt", newJString(alt))
  add(query_592623, "oauth_token", newJString(oauthToken))
  add(query_592623, "userIp", newJString(userIp))
  add(query_592623, "key", newJString(key))
  if body != nil:
    body_592624 = body
  add(query_592623, "prettyPrint", newJBool(prettyPrint))
  result = call_592621.call(path_592622, query_592623, nil, nil, body_592624)

var dfareportingUserRolesPatch* = Call_DfareportingUserRolesPatch_592607(
    name: "dfareportingUserRolesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesPatch_592608,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesPatch_592609,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesGet_592625 = ref object of OpenApiRestCall_588466
proc url_DfareportingUserRolesGet_592627(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesGet_592626(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user role by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592628 = path.getOrDefault("profileId")
  valid_592628 = validateParameter(valid_592628, JString, required = true,
                                 default = nil)
  if valid_592628 != nil:
    section.add "profileId", valid_592628
  var valid_592629 = path.getOrDefault("id")
  valid_592629 = validateParameter(valid_592629, JString, required = true,
                                 default = nil)
  if valid_592629 != nil:
    section.add "id", valid_592629
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592630 = query.getOrDefault("fields")
  valid_592630 = validateParameter(valid_592630, JString, required = false,
                                 default = nil)
  if valid_592630 != nil:
    section.add "fields", valid_592630
  var valid_592631 = query.getOrDefault("quotaUser")
  valid_592631 = validateParameter(valid_592631, JString, required = false,
                                 default = nil)
  if valid_592631 != nil:
    section.add "quotaUser", valid_592631
  var valid_592632 = query.getOrDefault("alt")
  valid_592632 = validateParameter(valid_592632, JString, required = false,
                                 default = newJString("json"))
  if valid_592632 != nil:
    section.add "alt", valid_592632
  var valid_592633 = query.getOrDefault("oauth_token")
  valid_592633 = validateParameter(valid_592633, JString, required = false,
                                 default = nil)
  if valid_592633 != nil:
    section.add "oauth_token", valid_592633
  var valid_592634 = query.getOrDefault("userIp")
  valid_592634 = validateParameter(valid_592634, JString, required = false,
                                 default = nil)
  if valid_592634 != nil:
    section.add "userIp", valid_592634
  var valid_592635 = query.getOrDefault("key")
  valid_592635 = validateParameter(valid_592635, JString, required = false,
                                 default = nil)
  if valid_592635 != nil:
    section.add "key", valid_592635
  var valid_592636 = query.getOrDefault("prettyPrint")
  valid_592636 = validateParameter(valid_592636, JBool, required = false,
                                 default = newJBool(true))
  if valid_592636 != nil:
    section.add "prettyPrint", valid_592636
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592637: Call_DfareportingUserRolesGet_592625; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one user role by ID.
  ## 
  let valid = call_592637.validator(path, query, header, formData, body)
  let scheme = call_592637.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592637.url(scheme.get, call_592637.host, call_592637.base,
                         call_592637.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592637, url, valid)

proc call*(call_592638: Call_DfareportingUserRolesGet_592625; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesGet
  ## Gets one user role by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User role ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592639 = newJObject()
  var query_592640 = newJObject()
  add(path_592639, "profileId", newJString(profileId))
  add(query_592640, "fields", newJString(fields))
  add(query_592640, "quotaUser", newJString(quotaUser))
  add(query_592640, "alt", newJString(alt))
  add(query_592640, "oauth_token", newJString(oauthToken))
  add(query_592640, "userIp", newJString(userIp))
  add(path_592639, "id", newJString(id))
  add(query_592640, "key", newJString(key))
  add(query_592640, "prettyPrint", newJBool(prettyPrint))
  result = call_592638.call(path_592639, query_592640, nil, nil, nil)

var dfareportingUserRolesGet* = Call_DfareportingUserRolesGet_592625(
    name: "dfareportingUserRolesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles/{id}",
    validator: validate_DfareportingUserRolesGet_592626,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesGet_592627,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesDelete_592641 = ref object of OpenApiRestCall_588466
proc url_DfareportingUserRolesDelete_592643(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesDelete_592642(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing user role.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592644 = path.getOrDefault("profileId")
  valid_592644 = validateParameter(valid_592644, JString, required = true,
                                 default = nil)
  if valid_592644 != nil:
    section.add "profileId", valid_592644
  var valid_592645 = path.getOrDefault("id")
  valid_592645 = validateParameter(valid_592645, JString, required = true,
                                 default = nil)
  if valid_592645 != nil:
    section.add "id", valid_592645
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592646 = query.getOrDefault("fields")
  valid_592646 = validateParameter(valid_592646, JString, required = false,
                                 default = nil)
  if valid_592646 != nil:
    section.add "fields", valid_592646
  var valid_592647 = query.getOrDefault("quotaUser")
  valid_592647 = validateParameter(valid_592647, JString, required = false,
                                 default = nil)
  if valid_592647 != nil:
    section.add "quotaUser", valid_592647
  var valid_592648 = query.getOrDefault("alt")
  valid_592648 = validateParameter(valid_592648, JString, required = false,
                                 default = newJString("json"))
  if valid_592648 != nil:
    section.add "alt", valid_592648
  var valid_592649 = query.getOrDefault("oauth_token")
  valid_592649 = validateParameter(valid_592649, JString, required = false,
                                 default = nil)
  if valid_592649 != nil:
    section.add "oauth_token", valid_592649
  var valid_592650 = query.getOrDefault("userIp")
  valid_592650 = validateParameter(valid_592650, JString, required = false,
                                 default = nil)
  if valid_592650 != nil:
    section.add "userIp", valid_592650
  var valid_592651 = query.getOrDefault("key")
  valid_592651 = validateParameter(valid_592651, JString, required = false,
                                 default = nil)
  if valid_592651 != nil:
    section.add "key", valid_592651
  var valid_592652 = query.getOrDefault("prettyPrint")
  valid_592652 = validateParameter(valid_592652, JBool, required = false,
                                 default = newJBool(true))
  if valid_592652 != nil:
    section.add "prettyPrint", valid_592652
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592653: Call_DfareportingUserRolesDelete_592641; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing user role.
  ## 
  let valid = call_592653.validator(path, query, header, formData, body)
  let scheme = call_592653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592653.url(scheme.get, call_592653.host, call_592653.base,
                         call_592653.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592653, url, valid)

proc call*(call_592654: Call_DfareportingUserRolesDelete_592641; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesDelete
  ## Deletes an existing user role.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User role ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592655 = newJObject()
  var query_592656 = newJObject()
  add(path_592655, "profileId", newJString(profileId))
  add(query_592656, "fields", newJString(fields))
  add(query_592656, "quotaUser", newJString(quotaUser))
  add(query_592656, "alt", newJString(alt))
  add(query_592656, "oauth_token", newJString(oauthToken))
  add(query_592656, "userIp", newJString(userIp))
  add(path_592655, "id", newJString(id))
  add(query_592656, "key", newJString(key))
  add(query_592656, "prettyPrint", newJBool(prettyPrint))
  result = call_592654.call(path_592655, query_592656, nil, nil, nil)

var dfareportingUserRolesDelete* = Call_DfareportingUserRolesDelete_592641(
    name: "dfareportingUserRolesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles/{id}",
    validator: validate_DfareportingUserRolesDelete_592642,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesDelete_592643,
    schemes: {Scheme.Https})
type
  Call_DfareportingVideoFormatsList_592657 = ref object of OpenApiRestCall_588466
proc url_DfareportingVideoFormatsList_592659(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/videoFormats")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingVideoFormatsList_592658(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists available video formats.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592660 = path.getOrDefault("profileId")
  valid_592660 = validateParameter(valid_592660, JString, required = true,
                                 default = nil)
  if valid_592660 != nil:
    section.add "profileId", valid_592660
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592661 = query.getOrDefault("fields")
  valid_592661 = validateParameter(valid_592661, JString, required = false,
                                 default = nil)
  if valid_592661 != nil:
    section.add "fields", valid_592661
  var valid_592662 = query.getOrDefault("quotaUser")
  valid_592662 = validateParameter(valid_592662, JString, required = false,
                                 default = nil)
  if valid_592662 != nil:
    section.add "quotaUser", valid_592662
  var valid_592663 = query.getOrDefault("alt")
  valid_592663 = validateParameter(valid_592663, JString, required = false,
                                 default = newJString("json"))
  if valid_592663 != nil:
    section.add "alt", valid_592663
  var valid_592664 = query.getOrDefault("oauth_token")
  valid_592664 = validateParameter(valid_592664, JString, required = false,
                                 default = nil)
  if valid_592664 != nil:
    section.add "oauth_token", valid_592664
  var valid_592665 = query.getOrDefault("userIp")
  valid_592665 = validateParameter(valid_592665, JString, required = false,
                                 default = nil)
  if valid_592665 != nil:
    section.add "userIp", valid_592665
  var valid_592666 = query.getOrDefault("key")
  valid_592666 = validateParameter(valid_592666, JString, required = false,
                                 default = nil)
  if valid_592666 != nil:
    section.add "key", valid_592666
  var valid_592667 = query.getOrDefault("prettyPrint")
  valid_592667 = validateParameter(valid_592667, JBool, required = false,
                                 default = newJBool(true))
  if valid_592667 != nil:
    section.add "prettyPrint", valid_592667
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592668: Call_DfareportingVideoFormatsList_592657; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists available video formats.
  ## 
  let valid = call_592668.validator(path, query, header, formData, body)
  let scheme = call_592668.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592668.url(scheme.get, call_592668.host, call_592668.base,
                         call_592668.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592668, url, valid)

proc call*(call_592669: Call_DfareportingVideoFormatsList_592657;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingVideoFormatsList
  ## Lists available video formats.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592670 = newJObject()
  var query_592671 = newJObject()
  add(path_592670, "profileId", newJString(profileId))
  add(query_592671, "fields", newJString(fields))
  add(query_592671, "quotaUser", newJString(quotaUser))
  add(query_592671, "alt", newJString(alt))
  add(query_592671, "oauth_token", newJString(oauthToken))
  add(query_592671, "userIp", newJString(userIp))
  add(query_592671, "key", newJString(key))
  add(query_592671, "prettyPrint", newJBool(prettyPrint))
  result = call_592669.call(path_592670, query_592671, nil, nil, nil)

var dfareportingVideoFormatsList* = Call_DfareportingVideoFormatsList_592657(
    name: "dfareportingVideoFormatsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/videoFormats",
    validator: validate_DfareportingVideoFormatsList_592658,
    base: "/dfareporting/v2.7", url: url_DfareportingVideoFormatsList_592659,
    schemes: {Scheme.Https})
type
  Call_DfareportingVideoFormatsGet_592672 = ref object of OpenApiRestCall_588466
proc url_DfareportingVideoFormatsGet_592674(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $composeQueryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/videoFormats/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingVideoFormatsGet_592673(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one video format by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JInt (required)
  ##     : Video format ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_592675 = path.getOrDefault("profileId")
  valid_592675 = validateParameter(valid_592675, JString, required = true,
                                 default = nil)
  if valid_592675 != nil:
    section.add "profileId", valid_592675
  var valid_592676 = path.getOrDefault("id")
  valid_592676 = validateParameter(valid_592676, JInt, required = true, default = nil)
  if valid_592676 != nil:
    section.add "id", valid_592676
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_592677 = query.getOrDefault("fields")
  valid_592677 = validateParameter(valid_592677, JString, required = false,
                                 default = nil)
  if valid_592677 != nil:
    section.add "fields", valid_592677
  var valid_592678 = query.getOrDefault("quotaUser")
  valid_592678 = validateParameter(valid_592678, JString, required = false,
                                 default = nil)
  if valid_592678 != nil:
    section.add "quotaUser", valid_592678
  var valid_592679 = query.getOrDefault("alt")
  valid_592679 = validateParameter(valid_592679, JString, required = false,
                                 default = newJString("json"))
  if valid_592679 != nil:
    section.add "alt", valid_592679
  var valid_592680 = query.getOrDefault("oauth_token")
  valid_592680 = validateParameter(valid_592680, JString, required = false,
                                 default = nil)
  if valid_592680 != nil:
    section.add "oauth_token", valid_592680
  var valid_592681 = query.getOrDefault("userIp")
  valid_592681 = validateParameter(valid_592681, JString, required = false,
                                 default = nil)
  if valid_592681 != nil:
    section.add "userIp", valid_592681
  var valid_592682 = query.getOrDefault("key")
  valid_592682 = validateParameter(valid_592682, JString, required = false,
                                 default = nil)
  if valid_592682 != nil:
    section.add "key", valid_592682
  var valid_592683 = query.getOrDefault("prettyPrint")
  valid_592683 = validateParameter(valid_592683, JBool, required = false,
                                 default = newJBool(true))
  if valid_592683 != nil:
    section.add "prettyPrint", valid_592683
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592684: Call_DfareportingVideoFormatsGet_592672; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one video format by ID.
  ## 
  let valid = call_592684.validator(path, query, header, formData, body)
  let scheme = call_592684.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592684.url(scheme.get, call_592684.host, call_592684.base,
                         call_592684.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592684, url, valid)

proc call*(call_592685: Call_DfareportingVideoFormatsGet_592672; profileId: string;
          id: int; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingVideoFormatsGet
  ## Gets one video format by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: int (required)
  ##     : Video format ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_592686 = newJObject()
  var query_592687 = newJObject()
  add(path_592686, "profileId", newJString(profileId))
  add(query_592687, "fields", newJString(fields))
  add(query_592687, "quotaUser", newJString(quotaUser))
  add(query_592687, "alt", newJString(alt))
  add(query_592687, "oauth_token", newJString(oauthToken))
  add(query_592687, "userIp", newJString(userIp))
  add(path_592686, "id", newJInt(id))
  add(query_592687, "key", newJString(key))
  add(query_592687, "prettyPrint", newJBool(prettyPrint))
  result = call_592685.call(path_592686, query_592687, nil, nil, nil)

var dfareportingVideoFormatsGet* = Call_DfareportingVideoFormatsGet_592672(
    name: "dfareportingVideoFormatsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/videoFormats/{id}",
    validator: validate_DfareportingVideoFormatsGet_592673,
    base: "/dfareporting/v2.7", url: url_DfareportingVideoFormatsGet_592674,
    schemes: {Scheme.Https})
export
  rest

type
  GoogleAuth = ref object
    endpoint*: Uri
    token: string
    expiry*: float64
    issued*: float64
    email: string
    key: string
    scope*: seq[string]
    form: string
    digest: Hash

const
  endpoint = "https://www.googleapis.com/oauth2/v4/token".parseUri
var auth = GoogleAuth(endpoint: endpoint)
proc hash(auth: GoogleAuth): Hash =
  ## yield differing values for effectively different auth payloads
  result = hash($auth.endpoint)
  result = result !& hash(auth.email)
  result = result !& hash(auth.key)
  result = result !& hash(auth.scope.join(" "))
  result = !$result

proc newAuthenticator*(path: string): GoogleAuth =
  let
    input = readFile(path)
    js = parseJson(input)
  auth.email = js["client_email"].getStr
  auth.key = js["private_key"].getStr
  result = auth

proc store(auth: var GoogleAuth; token: string; expiry: int; form: string) =
  auth.token = token
  auth.issued = epochTime()
  auth.expiry = auth.issued + expiry.float64
  auth.form = form
  auth.digest = auth.hash

proc authenticate*(fresh: float64 = 3600.0; lifetime: int = 3600): Future[bool] {.async.} =
  ## get or refresh an authentication token; provide `fresh`
  ## to ensure that the token won't expire in the next N seconds.
  ## provide `lifetime` to indicate how long the token should last.
  let clock = epochTime()
  if auth.expiry > clock + fresh:
    if auth.hash == auth.digest:
      return true
  let
    expiry = clock.int + lifetime
    header = JOSEHeader(alg: RS256, typ: "JWT")
    claims = %*{"iss": auth.email, "scope": auth.scope.join(" "),
              "aud": "https://www.googleapis.com/oauth2/v4/token", "exp": expiry,
              "iat": clock.int}
  var tok = JWT(header: header, claims: toClaims(claims))
  tok.sign(auth.key)
  let post = encodeQuery({"grant_type": "urn:ietf:params:oauth:grant-type:jwt-bearer",
                       "assertion": $tok}, usePlus = false, omitEq = false)
  var client = newAsyncHttpClient()
  client.headers = newHttpHeaders({"Content-Type": "application/x-www-form-urlencoded",
                                 "Content-Length": $post.len})
  let response = await client.request($auth.endpoint, HttpPost, body = post)
  if not response.code.is2xx:
    return false
  let body = await response.body
  client.close
  try:
    let js = parseJson(body)
    auth.store(js["access_token"].getStr, js["expires_in"].getInt,
               js["token_type"].getStr)
  except KeyError:
    return false
  except JsonParsingError:
    return false
  return true

proc composeQueryString(query: JsonNode): string =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs, usePlus = false, omitEq = false)

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  var headers = massageHeaders(input.getOrDefault("header"))
  let body = input.getOrDefault("body").getStr
  if auth.scope.len == 0:
    raise newException(ValueError, "specify authentication scopes")
  if not waitfor authenticate(fresh = 10.0):
    raise newException(IOError, "unable to refresh authentication token")
  headers.add ("Authorization", auth.form & " " & auth.token)
  headers.add ("Content-Type", "application/json")
  headers.add ("Content-Length", $body.len)
  result = newRecallable(call, url, headers, body = body)
