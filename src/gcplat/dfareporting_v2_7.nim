
import
  json, options, hashes, uri, openapi/rest, os, uri, strutils, httpcore

## auto-generated via openapi macro
## title: DCM/DFA Reporting And Trafficking
## version: v2.7
## termsOfService: (not provided)
## license: (not provided)
## 
## Manages your DoubleClick Campaign Manager ad campaigns and reports.
## 
## https://developers.google.com/doubleclick-advertisers/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_593437 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_593437](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_593437): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    if js.kind notin {JString, JInt, JFloat, JNull, JBool}:
      return
    head = $js
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  gcpServiceName = "dfareporting"
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_DfareportingFilesGet_593706 = ref object of OpenApiRestCall_593437
proc url_DfareportingFilesGet_593708(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "reportId" in path, "`reportId` is a required path parameter"
  assert "fileId" in path, "`fileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/files/"),
               (kind: VariableSegment, value: "fileId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFilesGet_593707(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a report file by its report ID and file ID. This method supports media download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   fileId: JString (required)
  ##         : The ID of the report file.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `fileId` field"
  var valid_593834 = path.getOrDefault("fileId")
  valid_593834 = validateParameter(valid_593834, JString, required = true,
                                 default = nil)
  if valid_593834 != nil:
    section.add "fileId", valid_593834
  var valid_593835 = path.getOrDefault("reportId")
  valid_593835 = validateParameter(valid_593835, JString, required = true,
                                 default = nil)
  if valid_593835 != nil:
    section.add "reportId", valid_593835
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_593836 = query.getOrDefault("fields")
  valid_593836 = validateParameter(valid_593836, JString, required = false,
                                 default = nil)
  if valid_593836 != nil:
    section.add "fields", valid_593836
  var valid_593837 = query.getOrDefault("quotaUser")
  valid_593837 = validateParameter(valid_593837, JString, required = false,
                                 default = nil)
  if valid_593837 != nil:
    section.add "quotaUser", valid_593837
  var valid_593851 = query.getOrDefault("alt")
  valid_593851 = validateParameter(valid_593851, JString, required = false,
                                 default = newJString("json"))
  if valid_593851 != nil:
    section.add "alt", valid_593851
  var valid_593852 = query.getOrDefault("oauth_token")
  valid_593852 = validateParameter(valid_593852, JString, required = false,
                                 default = nil)
  if valid_593852 != nil:
    section.add "oauth_token", valid_593852
  var valid_593853 = query.getOrDefault("userIp")
  valid_593853 = validateParameter(valid_593853, JString, required = false,
                                 default = nil)
  if valid_593853 != nil:
    section.add "userIp", valid_593853
  var valid_593854 = query.getOrDefault("key")
  valid_593854 = validateParameter(valid_593854, JString, required = false,
                                 default = nil)
  if valid_593854 != nil:
    section.add "key", valid_593854
  var valid_593855 = query.getOrDefault("prettyPrint")
  valid_593855 = validateParameter(valid_593855, JBool, required = false,
                                 default = newJBool(true))
  if valid_593855 != nil:
    section.add "prettyPrint", valid_593855
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593878: Call_DfareportingFilesGet_593706; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a report file by its report ID and file ID. This method supports media download.
  ## 
  let valid = call_593878.validator(path, query, header, formData, body)
  let scheme = call_593878.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593878.url(scheme.get, call_593878.host, call_593878.base,
                         call_593878.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593878, url, valid)

proc call*(call_593949: Call_DfareportingFilesGet_593706; fileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFilesGet
  ## Retrieves a report file by its report ID and file ID. This method supports media download.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fileId: string (required)
  ##         : The ID of the report file.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_593950 = newJObject()
  var query_593952 = newJObject()
  add(query_593952, "fields", newJString(fields))
  add(query_593952, "quotaUser", newJString(quotaUser))
  add(path_593950, "fileId", newJString(fileId))
  add(query_593952, "alt", newJString(alt))
  add(query_593952, "oauth_token", newJString(oauthToken))
  add(query_593952, "userIp", newJString(userIp))
  add(query_593952, "key", newJString(key))
  add(path_593950, "reportId", newJString(reportId))
  add(query_593952, "prettyPrint", newJBool(prettyPrint))
  result = call_593949.call(path_593950, query_593952, nil, nil, nil)

var dfareportingFilesGet* = Call_DfareportingFilesGet_593706(
    name: "dfareportingFilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/reports/{reportId}/files/{fileId}",
    validator: validate_DfareportingFilesGet_593707, base: "/dfareporting/v2.7",
    url: url_DfareportingFilesGet_593708, schemes: {Scheme.Https})
type
  Call_DfareportingUserProfilesList_593991 = ref object of OpenApiRestCall_593437
proc url_DfareportingUserProfilesList_593993(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DfareportingUserProfilesList_593992(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves list of user profiles for a user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_593994 = query.getOrDefault("fields")
  valid_593994 = validateParameter(valid_593994, JString, required = false,
                                 default = nil)
  if valid_593994 != nil:
    section.add "fields", valid_593994
  var valid_593995 = query.getOrDefault("quotaUser")
  valid_593995 = validateParameter(valid_593995, JString, required = false,
                                 default = nil)
  if valid_593995 != nil:
    section.add "quotaUser", valid_593995
  var valid_593996 = query.getOrDefault("alt")
  valid_593996 = validateParameter(valid_593996, JString, required = false,
                                 default = newJString("json"))
  if valid_593996 != nil:
    section.add "alt", valid_593996
  var valid_593997 = query.getOrDefault("oauth_token")
  valid_593997 = validateParameter(valid_593997, JString, required = false,
                                 default = nil)
  if valid_593997 != nil:
    section.add "oauth_token", valid_593997
  var valid_593998 = query.getOrDefault("userIp")
  valid_593998 = validateParameter(valid_593998, JString, required = false,
                                 default = nil)
  if valid_593998 != nil:
    section.add "userIp", valid_593998
  var valid_593999 = query.getOrDefault("key")
  valid_593999 = validateParameter(valid_593999, JString, required = false,
                                 default = nil)
  if valid_593999 != nil:
    section.add "key", valid_593999
  var valid_594000 = query.getOrDefault("prettyPrint")
  valid_594000 = validateParameter(valid_594000, JBool, required = false,
                                 default = newJBool(true))
  if valid_594000 != nil:
    section.add "prettyPrint", valid_594000
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594001: Call_DfareportingUserProfilesList_593991; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves list of user profiles for a user.
  ## 
  let valid = call_594001.validator(path, query, header, formData, body)
  let scheme = call_594001.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594001.url(scheme.get, call_594001.host, call_594001.base,
                         call_594001.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594001, url, valid)

proc call*(call_594002: Call_DfareportingUserProfilesList_593991;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingUserProfilesList
  ## Retrieves list of user profiles for a user.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var query_594003 = newJObject()
  add(query_594003, "fields", newJString(fields))
  add(query_594003, "quotaUser", newJString(quotaUser))
  add(query_594003, "alt", newJString(alt))
  add(query_594003, "oauth_token", newJString(oauthToken))
  add(query_594003, "userIp", newJString(userIp))
  add(query_594003, "key", newJString(key))
  add(query_594003, "prettyPrint", newJBool(prettyPrint))
  result = call_594002.call(nil, query_594003, nil, nil, nil)

var dfareportingUserProfilesList* = Call_DfareportingUserProfilesList_593991(
    name: "dfareportingUserProfilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles",
    validator: validate_DfareportingUserProfilesList_593992,
    base: "/dfareporting/v2.7", url: url_DfareportingUserProfilesList_593993,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserProfilesGet_594004 = ref object of OpenApiRestCall_593437
proc url_DfareportingUserProfilesGet_594006(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserProfilesGet_594005(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user profile by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594007 = path.getOrDefault("profileId")
  valid_594007 = validateParameter(valid_594007, JString, required = true,
                                 default = nil)
  if valid_594007 != nil:
    section.add "profileId", valid_594007
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594008 = query.getOrDefault("fields")
  valid_594008 = validateParameter(valid_594008, JString, required = false,
                                 default = nil)
  if valid_594008 != nil:
    section.add "fields", valid_594008
  var valid_594009 = query.getOrDefault("quotaUser")
  valid_594009 = validateParameter(valid_594009, JString, required = false,
                                 default = nil)
  if valid_594009 != nil:
    section.add "quotaUser", valid_594009
  var valid_594010 = query.getOrDefault("alt")
  valid_594010 = validateParameter(valid_594010, JString, required = false,
                                 default = newJString("json"))
  if valid_594010 != nil:
    section.add "alt", valid_594010
  var valid_594011 = query.getOrDefault("oauth_token")
  valid_594011 = validateParameter(valid_594011, JString, required = false,
                                 default = nil)
  if valid_594011 != nil:
    section.add "oauth_token", valid_594011
  var valid_594012 = query.getOrDefault("userIp")
  valid_594012 = validateParameter(valid_594012, JString, required = false,
                                 default = nil)
  if valid_594012 != nil:
    section.add "userIp", valid_594012
  var valid_594013 = query.getOrDefault("key")
  valid_594013 = validateParameter(valid_594013, JString, required = false,
                                 default = nil)
  if valid_594013 != nil:
    section.add "key", valid_594013
  var valid_594014 = query.getOrDefault("prettyPrint")
  valid_594014 = validateParameter(valid_594014, JBool, required = false,
                                 default = newJBool(true))
  if valid_594014 != nil:
    section.add "prettyPrint", valid_594014
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594015: Call_DfareportingUserProfilesGet_594004; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one user profile by ID.
  ## 
  let valid = call_594015.validator(path, query, header, formData, body)
  let scheme = call_594015.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594015.url(scheme.get, call_594015.host, call_594015.base,
                         call_594015.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594015, url, valid)

proc call*(call_594016: Call_DfareportingUserProfilesGet_594004; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingUserProfilesGet
  ## Gets one user profile by ID.
  ##   profileId: string (required)
  ##            : The user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594017 = newJObject()
  var query_594018 = newJObject()
  add(path_594017, "profileId", newJString(profileId))
  add(query_594018, "fields", newJString(fields))
  add(query_594018, "quotaUser", newJString(quotaUser))
  add(query_594018, "alt", newJString(alt))
  add(query_594018, "oauth_token", newJString(oauthToken))
  add(query_594018, "userIp", newJString(userIp))
  add(query_594018, "key", newJString(key))
  add(query_594018, "prettyPrint", newJBool(prettyPrint))
  result = call_594016.call(path_594017, query_594018, nil, nil, nil)

var dfareportingUserProfilesGet* = Call_DfareportingUserProfilesGet_594004(
    name: "dfareportingUserProfilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}",
    validator: validate_DfareportingUserProfilesGet_594005,
    base: "/dfareporting/v2.7", url: url_DfareportingUserProfilesGet_594006,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountActiveAdSummariesGet_594019 = ref object of OpenApiRestCall_593437
proc url_DfareportingAccountActiveAdSummariesGet_594021(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "summaryAccountId" in path,
        "`summaryAccountId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountActiveAdSummaries/"),
               (kind: VariableSegment, value: "summaryAccountId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountActiveAdSummariesGet_594020(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the account's active ad summary by account ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   summaryAccountId: JString (required)
  ##                   : Account ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594022 = path.getOrDefault("profileId")
  valid_594022 = validateParameter(valid_594022, JString, required = true,
                                 default = nil)
  if valid_594022 != nil:
    section.add "profileId", valid_594022
  var valid_594023 = path.getOrDefault("summaryAccountId")
  valid_594023 = validateParameter(valid_594023, JString, required = true,
                                 default = nil)
  if valid_594023 != nil:
    section.add "summaryAccountId", valid_594023
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594024 = query.getOrDefault("fields")
  valid_594024 = validateParameter(valid_594024, JString, required = false,
                                 default = nil)
  if valid_594024 != nil:
    section.add "fields", valid_594024
  var valid_594025 = query.getOrDefault("quotaUser")
  valid_594025 = validateParameter(valid_594025, JString, required = false,
                                 default = nil)
  if valid_594025 != nil:
    section.add "quotaUser", valid_594025
  var valid_594026 = query.getOrDefault("alt")
  valid_594026 = validateParameter(valid_594026, JString, required = false,
                                 default = newJString("json"))
  if valid_594026 != nil:
    section.add "alt", valid_594026
  var valid_594027 = query.getOrDefault("oauth_token")
  valid_594027 = validateParameter(valid_594027, JString, required = false,
                                 default = nil)
  if valid_594027 != nil:
    section.add "oauth_token", valid_594027
  var valid_594028 = query.getOrDefault("userIp")
  valid_594028 = validateParameter(valid_594028, JString, required = false,
                                 default = nil)
  if valid_594028 != nil:
    section.add "userIp", valid_594028
  var valid_594029 = query.getOrDefault("key")
  valid_594029 = validateParameter(valid_594029, JString, required = false,
                                 default = nil)
  if valid_594029 != nil:
    section.add "key", valid_594029
  var valid_594030 = query.getOrDefault("prettyPrint")
  valid_594030 = validateParameter(valid_594030, JBool, required = false,
                                 default = newJBool(true))
  if valid_594030 != nil:
    section.add "prettyPrint", valid_594030
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594031: Call_DfareportingAccountActiveAdSummariesGet_594019;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the account's active ad summary by account ID.
  ## 
  let valid = call_594031.validator(path, query, header, formData, body)
  let scheme = call_594031.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594031.url(scheme.get, call_594031.host, call_594031.base,
                         call_594031.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594031, url, valid)

proc call*(call_594032: Call_DfareportingAccountActiveAdSummariesGet_594019;
          profileId: string; summaryAccountId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountActiveAdSummariesGet
  ## Gets the account's active ad summary by account ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   summaryAccountId: string (required)
  ##                   : Account ID.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594033 = newJObject()
  var query_594034 = newJObject()
  add(path_594033, "profileId", newJString(profileId))
  add(query_594034, "fields", newJString(fields))
  add(query_594034, "quotaUser", newJString(quotaUser))
  add(query_594034, "alt", newJString(alt))
  add(query_594034, "oauth_token", newJString(oauthToken))
  add(query_594034, "userIp", newJString(userIp))
  add(query_594034, "key", newJString(key))
  add(path_594033, "summaryAccountId", newJString(summaryAccountId))
  add(query_594034, "prettyPrint", newJBool(prettyPrint))
  result = call_594032.call(path_594033, query_594034, nil, nil, nil)

var dfareportingAccountActiveAdSummariesGet* = Call_DfareportingAccountActiveAdSummariesGet_594019(
    name: "dfareportingAccountActiveAdSummariesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accountActiveAdSummaries/{summaryAccountId}",
    validator: validate_DfareportingAccountActiveAdSummariesGet_594020,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountActiveAdSummariesGet_594021,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionGroupsList_594035 = ref object of OpenApiRestCall_593437
proc url_DfareportingAccountPermissionGroupsList_594037(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissionGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionGroupsList_594036(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of account permission groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594038 = path.getOrDefault("profileId")
  valid_594038 = validateParameter(valid_594038, JString, required = true,
                                 default = nil)
  if valid_594038 != nil:
    section.add "profileId", valid_594038
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594039 = query.getOrDefault("fields")
  valid_594039 = validateParameter(valid_594039, JString, required = false,
                                 default = nil)
  if valid_594039 != nil:
    section.add "fields", valid_594039
  var valid_594040 = query.getOrDefault("quotaUser")
  valid_594040 = validateParameter(valid_594040, JString, required = false,
                                 default = nil)
  if valid_594040 != nil:
    section.add "quotaUser", valid_594040
  var valid_594041 = query.getOrDefault("alt")
  valid_594041 = validateParameter(valid_594041, JString, required = false,
                                 default = newJString("json"))
  if valid_594041 != nil:
    section.add "alt", valid_594041
  var valid_594042 = query.getOrDefault("oauth_token")
  valid_594042 = validateParameter(valid_594042, JString, required = false,
                                 default = nil)
  if valid_594042 != nil:
    section.add "oauth_token", valid_594042
  var valid_594043 = query.getOrDefault("userIp")
  valid_594043 = validateParameter(valid_594043, JString, required = false,
                                 default = nil)
  if valid_594043 != nil:
    section.add "userIp", valid_594043
  var valid_594044 = query.getOrDefault("key")
  valid_594044 = validateParameter(valid_594044, JString, required = false,
                                 default = nil)
  if valid_594044 != nil:
    section.add "key", valid_594044
  var valid_594045 = query.getOrDefault("prettyPrint")
  valid_594045 = validateParameter(valid_594045, JBool, required = false,
                                 default = newJBool(true))
  if valid_594045 != nil:
    section.add "prettyPrint", valid_594045
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594046: Call_DfareportingAccountPermissionGroupsList_594035;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves the list of account permission groups.
  ## 
  let valid = call_594046.validator(path, query, header, formData, body)
  let scheme = call_594046.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594046.url(scheme.get, call_594046.host, call_594046.base,
                         call_594046.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594046, url, valid)

proc call*(call_594047: Call_DfareportingAccountPermissionGroupsList_594035;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountPermissionGroupsList
  ## Retrieves the list of account permission groups.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594048 = newJObject()
  var query_594049 = newJObject()
  add(path_594048, "profileId", newJString(profileId))
  add(query_594049, "fields", newJString(fields))
  add(query_594049, "quotaUser", newJString(quotaUser))
  add(query_594049, "alt", newJString(alt))
  add(query_594049, "oauth_token", newJString(oauthToken))
  add(query_594049, "userIp", newJString(userIp))
  add(query_594049, "key", newJString(key))
  add(query_594049, "prettyPrint", newJBool(prettyPrint))
  result = call_594047.call(path_594048, query_594049, nil, nil, nil)

var dfareportingAccountPermissionGroupsList* = Call_DfareportingAccountPermissionGroupsList_594035(
    name: "dfareportingAccountPermissionGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissionGroups",
    validator: validate_DfareportingAccountPermissionGroupsList_594036,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionGroupsList_594037,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionGroupsGet_594050 = ref object of OpenApiRestCall_593437
proc url_DfareportingAccountPermissionGroupsGet_594052(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissionGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionGroupsGet_594051(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account permission group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Account permission group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594053 = path.getOrDefault("profileId")
  valid_594053 = validateParameter(valid_594053, JString, required = true,
                                 default = nil)
  if valid_594053 != nil:
    section.add "profileId", valid_594053
  var valid_594054 = path.getOrDefault("id")
  valid_594054 = validateParameter(valid_594054, JString, required = true,
                                 default = nil)
  if valid_594054 != nil:
    section.add "id", valid_594054
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594055 = query.getOrDefault("fields")
  valid_594055 = validateParameter(valid_594055, JString, required = false,
                                 default = nil)
  if valid_594055 != nil:
    section.add "fields", valid_594055
  var valid_594056 = query.getOrDefault("quotaUser")
  valid_594056 = validateParameter(valid_594056, JString, required = false,
                                 default = nil)
  if valid_594056 != nil:
    section.add "quotaUser", valid_594056
  var valid_594057 = query.getOrDefault("alt")
  valid_594057 = validateParameter(valid_594057, JString, required = false,
                                 default = newJString("json"))
  if valid_594057 != nil:
    section.add "alt", valid_594057
  var valid_594058 = query.getOrDefault("oauth_token")
  valid_594058 = validateParameter(valid_594058, JString, required = false,
                                 default = nil)
  if valid_594058 != nil:
    section.add "oauth_token", valid_594058
  var valid_594059 = query.getOrDefault("userIp")
  valid_594059 = validateParameter(valid_594059, JString, required = false,
                                 default = nil)
  if valid_594059 != nil:
    section.add "userIp", valid_594059
  var valid_594060 = query.getOrDefault("key")
  valid_594060 = validateParameter(valid_594060, JString, required = false,
                                 default = nil)
  if valid_594060 != nil:
    section.add "key", valid_594060
  var valid_594061 = query.getOrDefault("prettyPrint")
  valid_594061 = validateParameter(valid_594061, JBool, required = false,
                                 default = newJBool(true))
  if valid_594061 != nil:
    section.add "prettyPrint", valid_594061
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594062: Call_DfareportingAccountPermissionGroupsGet_594050;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one account permission group by ID.
  ## 
  let valid = call_594062.validator(path, query, header, formData, body)
  let scheme = call_594062.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594062.url(scheme.get, call_594062.host, call_594062.base,
                         call_594062.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594062, url, valid)

proc call*(call_594063: Call_DfareportingAccountPermissionGroupsGet_594050;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountPermissionGroupsGet
  ## Gets one account permission group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Account permission group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594064 = newJObject()
  var query_594065 = newJObject()
  add(path_594064, "profileId", newJString(profileId))
  add(query_594065, "fields", newJString(fields))
  add(query_594065, "quotaUser", newJString(quotaUser))
  add(query_594065, "alt", newJString(alt))
  add(query_594065, "oauth_token", newJString(oauthToken))
  add(query_594065, "userIp", newJString(userIp))
  add(path_594064, "id", newJString(id))
  add(query_594065, "key", newJString(key))
  add(query_594065, "prettyPrint", newJBool(prettyPrint))
  result = call_594063.call(path_594064, query_594065, nil, nil, nil)

var dfareportingAccountPermissionGroupsGet* = Call_DfareportingAccountPermissionGroupsGet_594050(
    name: "dfareportingAccountPermissionGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissionGroups/{id}",
    validator: validate_DfareportingAccountPermissionGroupsGet_594051,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionGroupsGet_594052,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionsList_594066 = ref object of OpenApiRestCall_593437
proc url_DfareportingAccountPermissionsList_594068(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionsList_594067(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of account permissions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594069 = path.getOrDefault("profileId")
  valid_594069 = validateParameter(valid_594069, JString, required = true,
                                 default = nil)
  if valid_594069 != nil:
    section.add "profileId", valid_594069
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594070 = query.getOrDefault("fields")
  valid_594070 = validateParameter(valid_594070, JString, required = false,
                                 default = nil)
  if valid_594070 != nil:
    section.add "fields", valid_594070
  var valid_594071 = query.getOrDefault("quotaUser")
  valid_594071 = validateParameter(valid_594071, JString, required = false,
                                 default = nil)
  if valid_594071 != nil:
    section.add "quotaUser", valid_594071
  var valid_594072 = query.getOrDefault("alt")
  valid_594072 = validateParameter(valid_594072, JString, required = false,
                                 default = newJString("json"))
  if valid_594072 != nil:
    section.add "alt", valid_594072
  var valid_594073 = query.getOrDefault("oauth_token")
  valid_594073 = validateParameter(valid_594073, JString, required = false,
                                 default = nil)
  if valid_594073 != nil:
    section.add "oauth_token", valid_594073
  var valid_594074 = query.getOrDefault("userIp")
  valid_594074 = validateParameter(valid_594074, JString, required = false,
                                 default = nil)
  if valid_594074 != nil:
    section.add "userIp", valid_594074
  var valid_594075 = query.getOrDefault("key")
  valid_594075 = validateParameter(valid_594075, JString, required = false,
                                 default = nil)
  if valid_594075 != nil:
    section.add "key", valid_594075
  var valid_594076 = query.getOrDefault("prettyPrint")
  valid_594076 = validateParameter(valid_594076, JBool, required = false,
                                 default = newJBool(true))
  if valid_594076 != nil:
    section.add "prettyPrint", valid_594076
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594077: Call_DfareportingAccountPermissionsList_594066;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves the list of account permissions.
  ## 
  let valid = call_594077.validator(path, query, header, formData, body)
  let scheme = call_594077.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594077.url(scheme.get, call_594077.host, call_594077.base,
                         call_594077.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594077, url, valid)

proc call*(call_594078: Call_DfareportingAccountPermissionsList_594066;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountPermissionsList
  ## Retrieves the list of account permissions.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594079 = newJObject()
  var query_594080 = newJObject()
  add(path_594079, "profileId", newJString(profileId))
  add(query_594080, "fields", newJString(fields))
  add(query_594080, "quotaUser", newJString(quotaUser))
  add(query_594080, "alt", newJString(alt))
  add(query_594080, "oauth_token", newJString(oauthToken))
  add(query_594080, "userIp", newJString(userIp))
  add(query_594080, "key", newJString(key))
  add(query_594080, "prettyPrint", newJBool(prettyPrint))
  result = call_594078.call(path_594079, query_594080, nil, nil, nil)

var dfareportingAccountPermissionsList* = Call_DfareportingAccountPermissionsList_594066(
    name: "dfareportingAccountPermissionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissions",
    validator: validate_DfareportingAccountPermissionsList_594067,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionsList_594068,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountPermissionsGet_594081 = ref object of OpenApiRestCall_593437
proc url_DfareportingAccountPermissionsGet_594083(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountPermissions/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountPermissionsGet_594082(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account permission by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Account permission ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594084 = path.getOrDefault("profileId")
  valid_594084 = validateParameter(valid_594084, JString, required = true,
                                 default = nil)
  if valid_594084 != nil:
    section.add "profileId", valid_594084
  var valid_594085 = path.getOrDefault("id")
  valid_594085 = validateParameter(valid_594085, JString, required = true,
                                 default = nil)
  if valid_594085 != nil:
    section.add "id", valid_594085
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594086 = query.getOrDefault("fields")
  valid_594086 = validateParameter(valid_594086, JString, required = false,
                                 default = nil)
  if valid_594086 != nil:
    section.add "fields", valid_594086
  var valid_594087 = query.getOrDefault("quotaUser")
  valid_594087 = validateParameter(valid_594087, JString, required = false,
                                 default = nil)
  if valid_594087 != nil:
    section.add "quotaUser", valid_594087
  var valid_594088 = query.getOrDefault("alt")
  valid_594088 = validateParameter(valid_594088, JString, required = false,
                                 default = newJString("json"))
  if valid_594088 != nil:
    section.add "alt", valid_594088
  var valid_594089 = query.getOrDefault("oauth_token")
  valid_594089 = validateParameter(valid_594089, JString, required = false,
                                 default = nil)
  if valid_594089 != nil:
    section.add "oauth_token", valid_594089
  var valid_594090 = query.getOrDefault("userIp")
  valid_594090 = validateParameter(valid_594090, JString, required = false,
                                 default = nil)
  if valid_594090 != nil:
    section.add "userIp", valid_594090
  var valid_594091 = query.getOrDefault("key")
  valid_594091 = validateParameter(valid_594091, JString, required = false,
                                 default = nil)
  if valid_594091 != nil:
    section.add "key", valid_594091
  var valid_594092 = query.getOrDefault("prettyPrint")
  valid_594092 = validateParameter(valid_594092, JBool, required = false,
                                 default = newJBool(true))
  if valid_594092 != nil:
    section.add "prettyPrint", valid_594092
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594093: Call_DfareportingAccountPermissionsGet_594081;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one account permission by ID.
  ## 
  let valid = call_594093.validator(path, query, header, formData, body)
  let scheme = call_594093.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594093.url(scheme.get, call_594093.host, call_594093.base,
                         call_594093.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594093, url, valid)

proc call*(call_594094: Call_DfareportingAccountPermissionsGet_594081;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountPermissionsGet
  ## Gets one account permission by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Account permission ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594095 = newJObject()
  var query_594096 = newJObject()
  add(path_594095, "profileId", newJString(profileId))
  add(query_594096, "fields", newJString(fields))
  add(query_594096, "quotaUser", newJString(quotaUser))
  add(query_594096, "alt", newJString(alt))
  add(query_594096, "oauth_token", newJString(oauthToken))
  add(query_594096, "userIp", newJString(userIp))
  add(path_594095, "id", newJString(id))
  add(query_594096, "key", newJString(key))
  add(query_594096, "prettyPrint", newJBool(prettyPrint))
  result = call_594094.call(path_594095, query_594096, nil, nil, nil)

var dfareportingAccountPermissionsGet* = Call_DfareportingAccountPermissionsGet_594081(
    name: "dfareportingAccountPermissionsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountPermissions/{id}",
    validator: validate_DfareportingAccountPermissionsGet_594082,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountPermissionsGet_594083,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesUpdate_594122 = ref object of OpenApiRestCall_593437
proc url_DfareportingAccountUserProfilesUpdate_594124(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesUpdate_594123(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account user profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594125 = path.getOrDefault("profileId")
  valid_594125 = validateParameter(valid_594125, JString, required = true,
                                 default = nil)
  if valid_594125 != nil:
    section.add "profileId", valid_594125
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594126 = query.getOrDefault("fields")
  valid_594126 = validateParameter(valid_594126, JString, required = false,
                                 default = nil)
  if valid_594126 != nil:
    section.add "fields", valid_594126
  var valid_594127 = query.getOrDefault("quotaUser")
  valid_594127 = validateParameter(valid_594127, JString, required = false,
                                 default = nil)
  if valid_594127 != nil:
    section.add "quotaUser", valid_594127
  var valid_594128 = query.getOrDefault("alt")
  valid_594128 = validateParameter(valid_594128, JString, required = false,
                                 default = newJString("json"))
  if valid_594128 != nil:
    section.add "alt", valid_594128
  var valid_594129 = query.getOrDefault("oauth_token")
  valid_594129 = validateParameter(valid_594129, JString, required = false,
                                 default = nil)
  if valid_594129 != nil:
    section.add "oauth_token", valid_594129
  var valid_594130 = query.getOrDefault("userIp")
  valid_594130 = validateParameter(valid_594130, JString, required = false,
                                 default = nil)
  if valid_594130 != nil:
    section.add "userIp", valid_594130
  var valid_594131 = query.getOrDefault("key")
  valid_594131 = validateParameter(valid_594131, JString, required = false,
                                 default = nil)
  if valid_594131 != nil:
    section.add "key", valid_594131
  var valid_594132 = query.getOrDefault("prettyPrint")
  valid_594132 = validateParameter(valid_594132, JBool, required = false,
                                 default = newJBool(true))
  if valid_594132 != nil:
    section.add "prettyPrint", valid_594132
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594134: Call_DfareportingAccountUserProfilesUpdate_594122;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing account user profile.
  ## 
  let valid = call_594134.validator(path, query, header, formData, body)
  let scheme = call_594134.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594134.url(scheme.get, call_594134.host, call_594134.base,
                         call_594134.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594134, url, valid)

proc call*(call_594135: Call_DfareportingAccountUserProfilesUpdate_594122;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountUserProfilesUpdate
  ## Updates an existing account user profile.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594136 = newJObject()
  var query_594137 = newJObject()
  var body_594138 = newJObject()
  add(path_594136, "profileId", newJString(profileId))
  add(query_594137, "fields", newJString(fields))
  add(query_594137, "quotaUser", newJString(quotaUser))
  add(query_594137, "alt", newJString(alt))
  add(query_594137, "oauth_token", newJString(oauthToken))
  add(query_594137, "userIp", newJString(userIp))
  add(query_594137, "key", newJString(key))
  if body != nil:
    body_594138 = body
  add(query_594137, "prettyPrint", newJBool(prettyPrint))
  result = call_594135.call(path_594136, query_594137, nil, nil, body_594138)

var dfareportingAccountUserProfilesUpdate* = Call_DfareportingAccountUserProfilesUpdate_594122(
    name: "dfareportingAccountUserProfilesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesUpdate_594123,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesUpdate_594124,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesInsert_594139 = ref object of OpenApiRestCall_593437
proc url_DfareportingAccountUserProfilesInsert_594141(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesInsert_594140(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new account user profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594142 = path.getOrDefault("profileId")
  valid_594142 = validateParameter(valid_594142, JString, required = true,
                                 default = nil)
  if valid_594142 != nil:
    section.add "profileId", valid_594142
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594143 = query.getOrDefault("fields")
  valid_594143 = validateParameter(valid_594143, JString, required = false,
                                 default = nil)
  if valid_594143 != nil:
    section.add "fields", valid_594143
  var valid_594144 = query.getOrDefault("quotaUser")
  valid_594144 = validateParameter(valid_594144, JString, required = false,
                                 default = nil)
  if valid_594144 != nil:
    section.add "quotaUser", valid_594144
  var valid_594145 = query.getOrDefault("alt")
  valid_594145 = validateParameter(valid_594145, JString, required = false,
                                 default = newJString("json"))
  if valid_594145 != nil:
    section.add "alt", valid_594145
  var valid_594146 = query.getOrDefault("oauth_token")
  valid_594146 = validateParameter(valid_594146, JString, required = false,
                                 default = nil)
  if valid_594146 != nil:
    section.add "oauth_token", valid_594146
  var valid_594147 = query.getOrDefault("userIp")
  valid_594147 = validateParameter(valid_594147, JString, required = false,
                                 default = nil)
  if valid_594147 != nil:
    section.add "userIp", valid_594147
  var valid_594148 = query.getOrDefault("key")
  valid_594148 = validateParameter(valid_594148, JString, required = false,
                                 default = nil)
  if valid_594148 != nil:
    section.add "key", valid_594148
  var valid_594149 = query.getOrDefault("prettyPrint")
  valid_594149 = validateParameter(valid_594149, JBool, required = false,
                                 default = newJBool(true))
  if valid_594149 != nil:
    section.add "prettyPrint", valid_594149
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594151: Call_DfareportingAccountUserProfilesInsert_594139;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new account user profile.
  ## 
  let valid = call_594151.validator(path, query, header, formData, body)
  let scheme = call_594151.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594151.url(scheme.get, call_594151.host, call_594151.base,
                         call_594151.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594151, url, valid)

proc call*(call_594152: Call_DfareportingAccountUserProfilesInsert_594139;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountUserProfilesInsert
  ## Inserts a new account user profile.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594153 = newJObject()
  var query_594154 = newJObject()
  var body_594155 = newJObject()
  add(path_594153, "profileId", newJString(profileId))
  add(query_594154, "fields", newJString(fields))
  add(query_594154, "quotaUser", newJString(quotaUser))
  add(query_594154, "alt", newJString(alt))
  add(query_594154, "oauth_token", newJString(oauthToken))
  add(query_594154, "userIp", newJString(userIp))
  add(query_594154, "key", newJString(key))
  if body != nil:
    body_594155 = body
  add(query_594154, "prettyPrint", newJBool(prettyPrint))
  result = call_594152.call(path_594153, query_594154, nil, nil, body_594155)

var dfareportingAccountUserProfilesInsert* = Call_DfareportingAccountUserProfilesInsert_594139(
    name: "dfareportingAccountUserProfilesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesInsert_594140,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesInsert_594141,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesList_594097 = ref object of OpenApiRestCall_593437
proc url_DfareportingAccountUserProfilesList_594099(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesList_594098(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of account user profiles, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594100 = path.getOrDefault("profileId")
  valid_594100 = validateParameter(valid_594100, JString, required = true,
                                 default = nil)
  if valid_594100 != nil:
    section.add "profileId", valid_594100
  result.add "path", section
  ## parameters in `query` object:
  ##   subaccountId: JString
  ##               : Select only user profiles with the specified subaccount ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "user profile*2015" will return objects with names like "user profile June 2015", "user profile April 2015", or simply "user profile 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "user profile" will match objects with name "my user profile", "user profile 2015", or simply "user profile".
  ##   active: JBool
  ##         : Select only active user profiles.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only user profiles with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   userRoleId: JString
  ##             : Select only user profiles with the specified user role ID.
  section = newJObject()
  var valid_594101 = query.getOrDefault("subaccountId")
  valid_594101 = validateParameter(valid_594101, JString, required = false,
                                 default = nil)
  if valid_594101 != nil:
    section.add "subaccountId", valid_594101
  var valid_594102 = query.getOrDefault("fields")
  valid_594102 = validateParameter(valid_594102, JString, required = false,
                                 default = nil)
  if valid_594102 != nil:
    section.add "fields", valid_594102
  var valid_594103 = query.getOrDefault("pageToken")
  valid_594103 = validateParameter(valid_594103, JString, required = false,
                                 default = nil)
  if valid_594103 != nil:
    section.add "pageToken", valid_594103
  var valid_594104 = query.getOrDefault("quotaUser")
  valid_594104 = validateParameter(valid_594104, JString, required = false,
                                 default = nil)
  if valid_594104 != nil:
    section.add "quotaUser", valid_594104
  var valid_594105 = query.getOrDefault("sortField")
  valid_594105 = validateParameter(valid_594105, JString, required = false,
                                 default = newJString("ID"))
  if valid_594105 != nil:
    section.add "sortField", valid_594105
  var valid_594106 = query.getOrDefault("alt")
  valid_594106 = validateParameter(valid_594106, JString, required = false,
                                 default = newJString("json"))
  if valid_594106 != nil:
    section.add "alt", valid_594106
  var valid_594107 = query.getOrDefault("searchString")
  valid_594107 = validateParameter(valid_594107, JString, required = false,
                                 default = nil)
  if valid_594107 != nil:
    section.add "searchString", valid_594107
  var valid_594108 = query.getOrDefault("active")
  valid_594108 = validateParameter(valid_594108, JBool, required = false, default = nil)
  if valid_594108 != nil:
    section.add "active", valid_594108
  var valid_594109 = query.getOrDefault("oauth_token")
  valid_594109 = validateParameter(valid_594109, JString, required = false,
                                 default = nil)
  if valid_594109 != nil:
    section.add "oauth_token", valid_594109
  var valid_594110 = query.getOrDefault("userIp")
  valid_594110 = validateParameter(valid_594110, JString, required = false,
                                 default = nil)
  if valid_594110 != nil:
    section.add "userIp", valid_594110
  var valid_594112 = query.getOrDefault("maxResults")
  valid_594112 = validateParameter(valid_594112, JInt, required = false,
                                 default = newJInt(1000))
  if valid_594112 != nil:
    section.add "maxResults", valid_594112
  var valid_594113 = query.getOrDefault("ids")
  valid_594113 = validateParameter(valid_594113, JArray, required = false,
                                 default = nil)
  if valid_594113 != nil:
    section.add "ids", valid_594113
  var valid_594114 = query.getOrDefault("key")
  valid_594114 = validateParameter(valid_594114, JString, required = false,
                                 default = nil)
  if valid_594114 != nil:
    section.add "key", valid_594114
  var valid_594115 = query.getOrDefault("sortOrder")
  valid_594115 = validateParameter(valid_594115, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_594115 != nil:
    section.add "sortOrder", valid_594115
  var valid_594116 = query.getOrDefault("prettyPrint")
  valid_594116 = validateParameter(valid_594116, JBool, required = false,
                                 default = newJBool(true))
  if valid_594116 != nil:
    section.add "prettyPrint", valid_594116
  var valid_594117 = query.getOrDefault("userRoleId")
  valid_594117 = validateParameter(valid_594117, JString, required = false,
                                 default = nil)
  if valid_594117 != nil:
    section.add "userRoleId", valid_594117
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594118: Call_DfareportingAccountUserProfilesList_594097;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of account user profiles, possibly filtered. This method supports paging.
  ## 
  let valid = call_594118.validator(path, query, header, formData, body)
  let scheme = call_594118.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594118.url(scheme.get, call_594118.host, call_594118.base,
                         call_594118.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594118, url, valid)

proc call*(call_594119: Call_DfareportingAccountUserProfilesList_594097;
          profileId: string; subaccountId: string = ""; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; searchString: string = ""; active: bool = false;
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true; userRoleId: string = ""): Recallable =
  ## dfareportingAccountUserProfilesList
  ## Retrieves a list of account user profiles, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only user profiles with the specified subaccount ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "user profile*2015" will return objects with names like "user profile June 2015", "user profile April 2015", or simply "user profile 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "user profile" will match objects with name "my user profile", "user profile 2015", or simply "user profile".
  ##   active: bool
  ##         : Select only active user profiles.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only user profiles with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userRoleId: string
  ##             : Select only user profiles with the specified user role ID.
  var path_594120 = newJObject()
  var query_594121 = newJObject()
  add(path_594120, "profileId", newJString(profileId))
  add(query_594121, "subaccountId", newJString(subaccountId))
  add(query_594121, "fields", newJString(fields))
  add(query_594121, "pageToken", newJString(pageToken))
  add(query_594121, "quotaUser", newJString(quotaUser))
  add(query_594121, "sortField", newJString(sortField))
  add(query_594121, "alt", newJString(alt))
  add(query_594121, "searchString", newJString(searchString))
  add(query_594121, "active", newJBool(active))
  add(query_594121, "oauth_token", newJString(oauthToken))
  add(query_594121, "userIp", newJString(userIp))
  add(query_594121, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_594121.add "ids", ids
  add(query_594121, "key", newJString(key))
  add(query_594121, "sortOrder", newJString(sortOrder))
  add(query_594121, "prettyPrint", newJBool(prettyPrint))
  add(query_594121, "userRoleId", newJString(userRoleId))
  result = call_594119.call(path_594120, query_594121, nil, nil, nil)

var dfareportingAccountUserProfilesList* = Call_DfareportingAccountUserProfilesList_594097(
    name: "dfareportingAccountUserProfilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesList_594098,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesList_594099,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesPatch_594156 = ref object of OpenApiRestCall_593437
proc url_DfareportingAccountUserProfilesPatch_594158(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesPatch_594157(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account user profile. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594159 = path.getOrDefault("profileId")
  valid_594159 = validateParameter(valid_594159, JString, required = true,
                                 default = nil)
  if valid_594159 != nil:
    section.add "profileId", valid_594159
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : User profile ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594160 = query.getOrDefault("fields")
  valid_594160 = validateParameter(valid_594160, JString, required = false,
                                 default = nil)
  if valid_594160 != nil:
    section.add "fields", valid_594160
  var valid_594161 = query.getOrDefault("quotaUser")
  valid_594161 = validateParameter(valid_594161, JString, required = false,
                                 default = nil)
  if valid_594161 != nil:
    section.add "quotaUser", valid_594161
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_594162 = query.getOrDefault("id")
  valid_594162 = validateParameter(valid_594162, JString, required = true,
                                 default = nil)
  if valid_594162 != nil:
    section.add "id", valid_594162
  var valid_594163 = query.getOrDefault("alt")
  valid_594163 = validateParameter(valid_594163, JString, required = false,
                                 default = newJString("json"))
  if valid_594163 != nil:
    section.add "alt", valid_594163
  var valid_594164 = query.getOrDefault("oauth_token")
  valid_594164 = validateParameter(valid_594164, JString, required = false,
                                 default = nil)
  if valid_594164 != nil:
    section.add "oauth_token", valid_594164
  var valid_594165 = query.getOrDefault("userIp")
  valid_594165 = validateParameter(valid_594165, JString, required = false,
                                 default = nil)
  if valid_594165 != nil:
    section.add "userIp", valid_594165
  var valid_594166 = query.getOrDefault("key")
  valid_594166 = validateParameter(valid_594166, JString, required = false,
                                 default = nil)
  if valid_594166 != nil:
    section.add "key", valid_594166
  var valid_594167 = query.getOrDefault("prettyPrint")
  valid_594167 = validateParameter(valid_594167, JBool, required = false,
                                 default = newJBool(true))
  if valid_594167 != nil:
    section.add "prettyPrint", valid_594167
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594169: Call_DfareportingAccountUserProfilesPatch_594156;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing account user profile. This method supports patch semantics.
  ## 
  let valid = call_594169.validator(path, query, header, formData, body)
  let scheme = call_594169.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594169.url(scheme.get, call_594169.host, call_594169.base,
                         call_594169.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594169, url, valid)

proc call*(call_594170: Call_DfareportingAccountUserProfilesPatch_594156;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountUserProfilesPatch
  ## Updates an existing account user profile. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : User profile ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594171 = newJObject()
  var query_594172 = newJObject()
  var body_594173 = newJObject()
  add(path_594171, "profileId", newJString(profileId))
  add(query_594172, "fields", newJString(fields))
  add(query_594172, "quotaUser", newJString(quotaUser))
  add(query_594172, "id", newJString(id))
  add(query_594172, "alt", newJString(alt))
  add(query_594172, "oauth_token", newJString(oauthToken))
  add(query_594172, "userIp", newJString(userIp))
  add(query_594172, "key", newJString(key))
  if body != nil:
    body_594173 = body
  add(query_594172, "prettyPrint", newJBool(prettyPrint))
  result = call_594170.call(path_594171, query_594172, nil, nil, body_594173)

var dfareportingAccountUserProfilesPatch* = Call_DfareportingAccountUserProfilesPatch_594156(
    name: "dfareportingAccountUserProfilesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles",
    validator: validate_DfareportingAccountUserProfilesPatch_594157,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesPatch_594158,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountUserProfilesGet_594174 = ref object of OpenApiRestCall_593437
proc url_DfareportingAccountUserProfilesGet_594176(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accountUserProfiles/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountUserProfilesGet_594175(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account user profile by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594177 = path.getOrDefault("profileId")
  valid_594177 = validateParameter(valid_594177, JString, required = true,
                                 default = nil)
  if valid_594177 != nil:
    section.add "profileId", valid_594177
  var valid_594178 = path.getOrDefault("id")
  valid_594178 = validateParameter(valid_594178, JString, required = true,
                                 default = nil)
  if valid_594178 != nil:
    section.add "id", valid_594178
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594179 = query.getOrDefault("fields")
  valid_594179 = validateParameter(valid_594179, JString, required = false,
                                 default = nil)
  if valid_594179 != nil:
    section.add "fields", valid_594179
  var valid_594180 = query.getOrDefault("quotaUser")
  valid_594180 = validateParameter(valid_594180, JString, required = false,
                                 default = nil)
  if valid_594180 != nil:
    section.add "quotaUser", valid_594180
  var valid_594181 = query.getOrDefault("alt")
  valid_594181 = validateParameter(valid_594181, JString, required = false,
                                 default = newJString("json"))
  if valid_594181 != nil:
    section.add "alt", valid_594181
  var valid_594182 = query.getOrDefault("oauth_token")
  valid_594182 = validateParameter(valid_594182, JString, required = false,
                                 default = nil)
  if valid_594182 != nil:
    section.add "oauth_token", valid_594182
  var valid_594183 = query.getOrDefault("userIp")
  valid_594183 = validateParameter(valid_594183, JString, required = false,
                                 default = nil)
  if valid_594183 != nil:
    section.add "userIp", valid_594183
  var valid_594184 = query.getOrDefault("key")
  valid_594184 = validateParameter(valid_594184, JString, required = false,
                                 default = nil)
  if valid_594184 != nil:
    section.add "key", valid_594184
  var valid_594185 = query.getOrDefault("prettyPrint")
  valid_594185 = validateParameter(valid_594185, JBool, required = false,
                                 default = newJBool(true))
  if valid_594185 != nil:
    section.add "prettyPrint", valid_594185
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594186: Call_DfareportingAccountUserProfilesGet_594174;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one account user profile by ID.
  ## 
  let valid = call_594186.validator(path, query, header, formData, body)
  let scheme = call_594186.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594186.url(scheme.get, call_594186.host, call_594186.base,
                         call_594186.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594186, url, valid)

proc call*(call_594187: Call_DfareportingAccountUserProfilesGet_594174;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountUserProfilesGet
  ## Gets one account user profile by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User profile ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594188 = newJObject()
  var query_594189 = newJObject()
  add(path_594188, "profileId", newJString(profileId))
  add(query_594189, "fields", newJString(fields))
  add(query_594189, "quotaUser", newJString(quotaUser))
  add(query_594189, "alt", newJString(alt))
  add(query_594189, "oauth_token", newJString(oauthToken))
  add(query_594189, "userIp", newJString(userIp))
  add(path_594188, "id", newJString(id))
  add(query_594189, "key", newJString(key))
  add(query_594189, "prettyPrint", newJBool(prettyPrint))
  result = call_594187.call(path_594188, query_594189, nil, nil, nil)

var dfareportingAccountUserProfilesGet* = Call_DfareportingAccountUserProfilesGet_594174(
    name: "dfareportingAccountUserProfilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/accountUserProfiles/{id}",
    validator: validate_DfareportingAccountUserProfilesGet_594175,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountUserProfilesGet_594176,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsUpdate_594212 = ref object of OpenApiRestCall_593437
proc url_DfareportingAccountsUpdate_594214(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsUpdate_594213(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594215 = path.getOrDefault("profileId")
  valid_594215 = validateParameter(valid_594215, JString, required = true,
                                 default = nil)
  if valid_594215 != nil:
    section.add "profileId", valid_594215
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594216 = query.getOrDefault("fields")
  valid_594216 = validateParameter(valid_594216, JString, required = false,
                                 default = nil)
  if valid_594216 != nil:
    section.add "fields", valid_594216
  var valid_594217 = query.getOrDefault("quotaUser")
  valid_594217 = validateParameter(valid_594217, JString, required = false,
                                 default = nil)
  if valid_594217 != nil:
    section.add "quotaUser", valid_594217
  var valid_594218 = query.getOrDefault("alt")
  valid_594218 = validateParameter(valid_594218, JString, required = false,
                                 default = newJString("json"))
  if valid_594218 != nil:
    section.add "alt", valid_594218
  var valid_594219 = query.getOrDefault("oauth_token")
  valid_594219 = validateParameter(valid_594219, JString, required = false,
                                 default = nil)
  if valid_594219 != nil:
    section.add "oauth_token", valid_594219
  var valid_594220 = query.getOrDefault("userIp")
  valid_594220 = validateParameter(valid_594220, JString, required = false,
                                 default = nil)
  if valid_594220 != nil:
    section.add "userIp", valid_594220
  var valid_594221 = query.getOrDefault("key")
  valid_594221 = validateParameter(valid_594221, JString, required = false,
                                 default = nil)
  if valid_594221 != nil:
    section.add "key", valid_594221
  var valid_594222 = query.getOrDefault("prettyPrint")
  valid_594222 = validateParameter(valid_594222, JBool, required = false,
                                 default = newJBool(true))
  if valid_594222 != nil:
    section.add "prettyPrint", valid_594222
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594224: Call_DfareportingAccountsUpdate_594212; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing account.
  ## 
  let valid = call_594224.validator(path, query, header, formData, body)
  let scheme = call_594224.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594224.url(scheme.get, call_594224.host, call_594224.base,
                         call_594224.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594224, url, valid)

proc call*(call_594225: Call_DfareportingAccountsUpdate_594212; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountsUpdate
  ## Updates an existing account.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594226 = newJObject()
  var query_594227 = newJObject()
  var body_594228 = newJObject()
  add(path_594226, "profileId", newJString(profileId))
  add(query_594227, "fields", newJString(fields))
  add(query_594227, "quotaUser", newJString(quotaUser))
  add(query_594227, "alt", newJString(alt))
  add(query_594227, "oauth_token", newJString(oauthToken))
  add(query_594227, "userIp", newJString(userIp))
  add(query_594227, "key", newJString(key))
  if body != nil:
    body_594228 = body
  add(query_594227, "prettyPrint", newJBool(prettyPrint))
  result = call_594225.call(path_594226, query_594227, nil, nil, body_594228)

var dfareportingAccountsUpdate* = Call_DfareportingAccountsUpdate_594212(
    name: "dfareportingAccountsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts",
    validator: validate_DfareportingAccountsUpdate_594213,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsUpdate_594214,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsList_594190 = ref object of OpenApiRestCall_593437
proc url_DfareportingAccountsList_594192(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsList_594191(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of accounts, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594193 = path.getOrDefault("profileId")
  valid_594193 = validateParameter(valid_594193, JString, required = true,
                                 default = nil)
  if valid_594193 != nil:
    section.add "profileId", valid_594193
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "account*2015" will return objects with names like "account June 2015", "account April 2015", or simply "account 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "account" will match objects with name "my account", "account 2015", or simply "account".
  ##   active: JBool
  ##         : Select only active accounts. Don't set this field to select both active and non-active accounts.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only accounts with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594194 = query.getOrDefault("fields")
  valid_594194 = validateParameter(valid_594194, JString, required = false,
                                 default = nil)
  if valid_594194 != nil:
    section.add "fields", valid_594194
  var valid_594195 = query.getOrDefault("pageToken")
  valid_594195 = validateParameter(valid_594195, JString, required = false,
                                 default = nil)
  if valid_594195 != nil:
    section.add "pageToken", valid_594195
  var valid_594196 = query.getOrDefault("quotaUser")
  valid_594196 = validateParameter(valid_594196, JString, required = false,
                                 default = nil)
  if valid_594196 != nil:
    section.add "quotaUser", valid_594196
  var valid_594197 = query.getOrDefault("sortField")
  valid_594197 = validateParameter(valid_594197, JString, required = false,
                                 default = newJString("ID"))
  if valid_594197 != nil:
    section.add "sortField", valid_594197
  var valid_594198 = query.getOrDefault("alt")
  valid_594198 = validateParameter(valid_594198, JString, required = false,
                                 default = newJString("json"))
  if valid_594198 != nil:
    section.add "alt", valid_594198
  var valid_594199 = query.getOrDefault("searchString")
  valid_594199 = validateParameter(valid_594199, JString, required = false,
                                 default = nil)
  if valid_594199 != nil:
    section.add "searchString", valid_594199
  var valid_594200 = query.getOrDefault("active")
  valid_594200 = validateParameter(valid_594200, JBool, required = false, default = nil)
  if valid_594200 != nil:
    section.add "active", valid_594200
  var valid_594201 = query.getOrDefault("oauth_token")
  valid_594201 = validateParameter(valid_594201, JString, required = false,
                                 default = nil)
  if valid_594201 != nil:
    section.add "oauth_token", valid_594201
  var valid_594202 = query.getOrDefault("userIp")
  valid_594202 = validateParameter(valid_594202, JString, required = false,
                                 default = nil)
  if valid_594202 != nil:
    section.add "userIp", valid_594202
  var valid_594203 = query.getOrDefault("maxResults")
  valid_594203 = validateParameter(valid_594203, JInt, required = false,
                                 default = newJInt(1000))
  if valid_594203 != nil:
    section.add "maxResults", valid_594203
  var valid_594204 = query.getOrDefault("ids")
  valid_594204 = validateParameter(valid_594204, JArray, required = false,
                                 default = nil)
  if valid_594204 != nil:
    section.add "ids", valid_594204
  var valid_594205 = query.getOrDefault("key")
  valid_594205 = validateParameter(valid_594205, JString, required = false,
                                 default = nil)
  if valid_594205 != nil:
    section.add "key", valid_594205
  var valid_594206 = query.getOrDefault("sortOrder")
  valid_594206 = validateParameter(valid_594206, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_594206 != nil:
    section.add "sortOrder", valid_594206
  var valid_594207 = query.getOrDefault("prettyPrint")
  valid_594207 = validateParameter(valid_594207, JBool, required = false,
                                 default = newJBool(true))
  if valid_594207 != nil:
    section.add "prettyPrint", valid_594207
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594208: Call_DfareportingAccountsList_594190; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves the list of accounts, possibly filtered. This method supports paging.
  ## 
  let valid = call_594208.validator(path, query, header, formData, body)
  let scheme = call_594208.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594208.url(scheme.get, call_594208.host, call_594208.base,
                         call_594208.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594208, url, valid)

proc call*(call_594209: Call_DfareportingAccountsList_594190; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; searchString: string = "";
          active: bool = false; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountsList
  ## Retrieves the list of accounts, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "account*2015" will return objects with names like "account June 2015", "account April 2015", or simply "account 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "account" will match objects with name "my account", "account 2015", or simply "account".
  ##   active: bool
  ##         : Select only active accounts. Don't set this field to select both active and non-active accounts.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only accounts with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594210 = newJObject()
  var query_594211 = newJObject()
  add(path_594210, "profileId", newJString(profileId))
  add(query_594211, "fields", newJString(fields))
  add(query_594211, "pageToken", newJString(pageToken))
  add(query_594211, "quotaUser", newJString(quotaUser))
  add(query_594211, "sortField", newJString(sortField))
  add(query_594211, "alt", newJString(alt))
  add(query_594211, "searchString", newJString(searchString))
  add(query_594211, "active", newJBool(active))
  add(query_594211, "oauth_token", newJString(oauthToken))
  add(query_594211, "userIp", newJString(userIp))
  add(query_594211, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_594211.add "ids", ids
  add(query_594211, "key", newJString(key))
  add(query_594211, "sortOrder", newJString(sortOrder))
  add(query_594211, "prettyPrint", newJBool(prettyPrint))
  result = call_594209.call(path_594210, query_594211, nil, nil, nil)

var dfareportingAccountsList* = Call_DfareportingAccountsList_594190(
    name: "dfareportingAccountsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts",
    validator: validate_DfareportingAccountsList_594191,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsList_594192,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsPatch_594229 = ref object of OpenApiRestCall_593437
proc url_DfareportingAccountsPatch_594231(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsPatch_594230(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing account. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594232 = path.getOrDefault("profileId")
  valid_594232 = validateParameter(valid_594232, JString, required = true,
                                 default = nil)
  if valid_594232 != nil:
    section.add "profileId", valid_594232
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Account ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594233 = query.getOrDefault("fields")
  valid_594233 = validateParameter(valid_594233, JString, required = false,
                                 default = nil)
  if valid_594233 != nil:
    section.add "fields", valid_594233
  var valid_594234 = query.getOrDefault("quotaUser")
  valid_594234 = validateParameter(valid_594234, JString, required = false,
                                 default = nil)
  if valid_594234 != nil:
    section.add "quotaUser", valid_594234
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_594235 = query.getOrDefault("id")
  valid_594235 = validateParameter(valid_594235, JString, required = true,
                                 default = nil)
  if valid_594235 != nil:
    section.add "id", valid_594235
  var valid_594236 = query.getOrDefault("alt")
  valid_594236 = validateParameter(valid_594236, JString, required = false,
                                 default = newJString("json"))
  if valid_594236 != nil:
    section.add "alt", valid_594236
  var valid_594237 = query.getOrDefault("oauth_token")
  valid_594237 = validateParameter(valid_594237, JString, required = false,
                                 default = nil)
  if valid_594237 != nil:
    section.add "oauth_token", valid_594237
  var valid_594238 = query.getOrDefault("userIp")
  valid_594238 = validateParameter(valid_594238, JString, required = false,
                                 default = nil)
  if valid_594238 != nil:
    section.add "userIp", valid_594238
  var valid_594239 = query.getOrDefault("key")
  valid_594239 = validateParameter(valid_594239, JString, required = false,
                                 default = nil)
  if valid_594239 != nil:
    section.add "key", valid_594239
  var valid_594240 = query.getOrDefault("prettyPrint")
  valid_594240 = validateParameter(valid_594240, JBool, required = false,
                                 default = newJBool(true))
  if valid_594240 != nil:
    section.add "prettyPrint", valid_594240
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594242: Call_DfareportingAccountsPatch_594229; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing account. This method supports patch semantics.
  ## 
  let valid = call_594242.validator(path, query, header, formData, body)
  let scheme = call_594242.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594242.url(scheme.get, call_594242.host, call_594242.base,
                         call_594242.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594242, url, valid)

proc call*(call_594243: Call_DfareportingAccountsPatch_594229; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAccountsPatch
  ## Updates an existing account. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Account ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594244 = newJObject()
  var query_594245 = newJObject()
  var body_594246 = newJObject()
  add(path_594244, "profileId", newJString(profileId))
  add(query_594245, "fields", newJString(fields))
  add(query_594245, "quotaUser", newJString(quotaUser))
  add(query_594245, "id", newJString(id))
  add(query_594245, "alt", newJString(alt))
  add(query_594245, "oauth_token", newJString(oauthToken))
  add(query_594245, "userIp", newJString(userIp))
  add(query_594245, "key", newJString(key))
  if body != nil:
    body_594246 = body
  add(query_594245, "prettyPrint", newJBool(prettyPrint))
  result = call_594243.call(path_594244, query_594245, nil, nil, body_594246)

var dfareportingAccountsPatch* = Call_DfareportingAccountsPatch_594229(
    name: "dfareportingAccountsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts",
    validator: validate_DfareportingAccountsPatch_594230,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsPatch_594231,
    schemes: {Scheme.Https})
type
  Call_DfareportingAccountsGet_594247 = ref object of OpenApiRestCall_593437
proc url_DfareportingAccountsGet_594249(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/accounts/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAccountsGet_594248(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one account by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Account ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594250 = path.getOrDefault("profileId")
  valid_594250 = validateParameter(valid_594250, JString, required = true,
                                 default = nil)
  if valid_594250 != nil:
    section.add "profileId", valid_594250
  var valid_594251 = path.getOrDefault("id")
  valid_594251 = validateParameter(valid_594251, JString, required = true,
                                 default = nil)
  if valid_594251 != nil:
    section.add "id", valid_594251
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594252 = query.getOrDefault("fields")
  valid_594252 = validateParameter(valid_594252, JString, required = false,
                                 default = nil)
  if valid_594252 != nil:
    section.add "fields", valid_594252
  var valid_594253 = query.getOrDefault("quotaUser")
  valid_594253 = validateParameter(valid_594253, JString, required = false,
                                 default = nil)
  if valid_594253 != nil:
    section.add "quotaUser", valid_594253
  var valid_594254 = query.getOrDefault("alt")
  valid_594254 = validateParameter(valid_594254, JString, required = false,
                                 default = newJString("json"))
  if valid_594254 != nil:
    section.add "alt", valid_594254
  var valid_594255 = query.getOrDefault("oauth_token")
  valid_594255 = validateParameter(valid_594255, JString, required = false,
                                 default = nil)
  if valid_594255 != nil:
    section.add "oauth_token", valid_594255
  var valid_594256 = query.getOrDefault("userIp")
  valid_594256 = validateParameter(valid_594256, JString, required = false,
                                 default = nil)
  if valid_594256 != nil:
    section.add "userIp", valid_594256
  var valid_594257 = query.getOrDefault("key")
  valid_594257 = validateParameter(valid_594257, JString, required = false,
                                 default = nil)
  if valid_594257 != nil:
    section.add "key", valid_594257
  var valid_594258 = query.getOrDefault("prettyPrint")
  valid_594258 = validateParameter(valid_594258, JBool, required = false,
                                 default = newJBool(true))
  if valid_594258 != nil:
    section.add "prettyPrint", valid_594258
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594259: Call_DfareportingAccountsGet_594247; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one account by ID.
  ## 
  let valid = call_594259.validator(path, query, header, formData, body)
  let scheme = call_594259.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594259.url(scheme.get, call_594259.host, call_594259.base,
                         call_594259.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594259, url, valid)

proc call*(call_594260: Call_DfareportingAccountsGet_594247; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingAccountsGet
  ## Gets one account by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Account ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594261 = newJObject()
  var query_594262 = newJObject()
  add(path_594261, "profileId", newJString(profileId))
  add(query_594262, "fields", newJString(fields))
  add(query_594262, "quotaUser", newJString(quotaUser))
  add(query_594262, "alt", newJString(alt))
  add(query_594262, "oauth_token", newJString(oauthToken))
  add(query_594262, "userIp", newJString(userIp))
  add(path_594261, "id", newJString(id))
  add(query_594262, "key", newJString(key))
  add(query_594262, "prettyPrint", newJBool(prettyPrint))
  result = call_594260.call(path_594261, query_594262, nil, nil, nil)

var dfareportingAccountsGet* = Call_DfareportingAccountsGet_594247(
    name: "dfareportingAccountsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/accounts/{id}",
    validator: validate_DfareportingAccountsGet_594248,
    base: "/dfareporting/v2.7", url: url_DfareportingAccountsGet_594249,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdsUpdate_594301 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdsUpdate_594303(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsUpdate_594302(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing ad.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594304 = path.getOrDefault("profileId")
  valid_594304 = validateParameter(valid_594304, JString, required = true,
                                 default = nil)
  if valid_594304 != nil:
    section.add "profileId", valid_594304
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594305 = query.getOrDefault("fields")
  valid_594305 = validateParameter(valid_594305, JString, required = false,
                                 default = nil)
  if valid_594305 != nil:
    section.add "fields", valid_594305
  var valid_594306 = query.getOrDefault("quotaUser")
  valid_594306 = validateParameter(valid_594306, JString, required = false,
                                 default = nil)
  if valid_594306 != nil:
    section.add "quotaUser", valid_594306
  var valid_594307 = query.getOrDefault("alt")
  valid_594307 = validateParameter(valid_594307, JString, required = false,
                                 default = newJString("json"))
  if valid_594307 != nil:
    section.add "alt", valid_594307
  var valid_594308 = query.getOrDefault("oauth_token")
  valid_594308 = validateParameter(valid_594308, JString, required = false,
                                 default = nil)
  if valid_594308 != nil:
    section.add "oauth_token", valid_594308
  var valid_594309 = query.getOrDefault("userIp")
  valid_594309 = validateParameter(valid_594309, JString, required = false,
                                 default = nil)
  if valid_594309 != nil:
    section.add "userIp", valid_594309
  var valid_594310 = query.getOrDefault("key")
  valid_594310 = validateParameter(valid_594310, JString, required = false,
                                 default = nil)
  if valid_594310 != nil:
    section.add "key", valid_594310
  var valid_594311 = query.getOrDefault("prettyPrint")
  valid_594311 = validateParameter(valid_594311, JBool, required = false,
                                 default = newJBool(true))
  if valid_594311 != nil:
    section.add "prettyPrint", valid_594311
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594313: Call_DfareportingAdsUpdate_594301; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing ad.
  ## 
  let valid = call_594313.validator(path, query, header, formData, body)
  let scheme = call_594313.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594313.url(scheme.get, call_594313.host, call_594313.base,
                         call_594313.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594313, url, valid)

proc call*(call_594314: Call_DfareportingAdsUpdate_594301; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdsUpdate
  ## Updates an existing ad.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594315 = newJObject()
  var query_594316 = newJObject()
  var body_594317 = newJObject()
  add(path_594315, "profileId", newJString(profileId))
  add(query_594316, "fields", newJString(fields))
  add(query_594316, "quotaUser", newJString(quotaUser))
  add(query_594316, "alt", newJString(alt))
  add(query_594316, "oauth_token", newJString(oauthToken))
  add(query_594316, "userIp", newJString(userIp))
  add(query_594316, "key", newJString(key))
  if body != nil:
    body_594317 = body
  add(query_594316, "prettyPrint", newJBool(prettyPrint))
  result = call_594314.call(path_594315, query_594316, nil, nil, body_594317)

var dfareportingAdsUpdate* = Call_DfareportingAdsUpdate_594301(
    name: "dfareportingAdsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsUpdate_594302, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsUpdate_594303, schemes: {Scheme.Https})
type
  Call_DfareportingAdsInsert_594318 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdsInsert_594320(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsInsert_594319(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new ad.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594321 = path.getOrDefault("profileId")
  valid_594321 = validateParameter(valid_594321, JString, required = true,
                                 default = nil)
  if valid_594321 != nil:
    section.add "profileId", valid_594321
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594322 = query.getOrDefault("fields")
  valid_594322 = validateParameter(valid_594322, JString, required = false,
                                 default = nil)
  if valid_594322 != nil:
    section.add "fields", valid_594322
  var valid_594323 = query.getOrDefault("quotaUser")
  valid_594323 = validateParameter(valid_594323, JString, required = false,
                                 default = nil)
  if valid_594323 != nil:
    section.add "quotaUser", valid_594323
  var valid_594324 = query.getOrDefault("alt")
  valid_594324 = validateParameter(valid_594324, JString, required = false,
                                 default = newJString("json"))
  if valid_594324 != nil:
    section.add "alt", valid_594324
  var valid_594325 = query.getOrDefault("oauth_token")
  valid_594325 = validateParameter(valid_594325, JString, required = false,
                                 default = nil)
  if valid_594325 != nil:
    section.add "oauth_token", valid_594325
  var valid_594326 = query.getOrDefault("userIp")
  valid_594326 = validateParameter(valid_594326, JString, required = false,
                                 default = nil)
  if valid_594326 != nil:
    section.add "userIp", valid_594326
  var valid_594327 = query.getOrDefault("key")
  valid_594327 = validateParameter(valid_594327, JString, required = false,
                                 default = nil)
  if valid_594327 != nil:
    section.add "key", valid_594327
  var valid_594328 = query.getOrDefault("prettyPrint")
  valid_594328 = validateParameter(valid_594328, JBool, required = false,
                                 default = newJBool(true))
  if valid_594328 != nil:
    section.add "prettyPrint", valid_594328
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594330: Call_DfareportingAdsInsert_594318; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new ad.
  ## 
  let valid = call_594330.validator(path, query, header, formData, body)
  let scheme = call_594330.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594330.url(scheme.get, call_594330.host, call_594330.base,
                         call_594330.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594330, url, valid)

proc call*(call_594331: Call_DfareportingAdsInsert_594318; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdsInsert
  ## Inserts a new ad.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594332 = newJObject()
  var query_594333 = newJObject()
  var body_594334 = newJObject()
  add(path_594332, "profileId", newJString(profileId))
  add(query_594333, "fields", newJString(fields))
  add(query_594333, "quotaUser", newJString(quotaUser))
  add(query_594333, "alt", newJString(alt))
  add(query_594333, "oauth_token", newJString(oauthToken))
  add(query_594333, "userIp", newJString(userIp))
  add(query_594333, "key", newJString(key))
  if body != nil:
    body_594334 = body
  add(query_594333, "prettyPrint", newJBool(prettyPrint))
  result = call_594331.call(path_594332, query_594333, nil, nil, body_594334)

var dfareportingAdsInsert* = Call_DfareportingAdsInsert_594318(
    name: "dfareportingAdsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsInsert_594319, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsInsert_594320, schemes: {Scheme.Https})
type
  Call_DfareportingAdsList_594263 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdsList_594265(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsList_594264(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Retrieves a list of ads, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594266 = path.getOrDefault("profileId")
  valid_594266 = validateParameter(valid_594266, JString, required = true,
                                 default = nil)
  if valid_594266 != nil:
    section.add "profileId", valid_594266
  result.add "path", section
  ## parameters in `query` object:
  ##   overriddenEventTagId: JString
  ##                       : Select only ads with this event tag override ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   creativeIds: JArray
  ##              : Select only ads with these creative IDs assigned.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   sslCompliant: JBool
  ##               : Select only ads that are SSL-compliant.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "ad*2015" will return objects with names like "ad June 2015", "ad April 2015", or simply "ad 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "ad" will match objects with name "my ad", "ad 2015", or simply "ad".
  ##   advertiserId: JString
  ##               : Select only ads with this advertiser ID.
  ##   dynamicClickTracker: JBool
  ##                      : Select only dynamic click trackers. Applicable when type is AD_SERVING_CLICK_TRACKER. If true, select dynamic click trackers. If false, select static click trackers. Leave unset to select both.
  ##   sizeIds: JArray
  ##          : Select only ads with these size IDs.
  ##   type: JArray
  ##       : Select only ads with these types.
  ##   active: JBool
  ##         : Select only active ads.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   campaignIds: JArray
  ##              : Select only ads with these campaign IDs.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   creativeOptimizationConfigurationIds: JArray
  ##                                       : Select only ads with these creative optimization configuration IDs.
  ##   archived: JBool
  ##           : Select only archived ads.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only ads with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   compatibility: JString
  ##                : Select default ads with the specified compatibility. Applicable when type is AD_SERVING_DEFAULT_AD. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads, respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering an in-stream video ads developed with the VAST standard.
  ##   landingPageIds: JArray
  ##                 : Select only ads with these landing page IDs.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   remarketingListIds: JArray
  ##                     : Select only ads whose list targeting expression use these remarketing list IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   sslRequired: JBool
  ##              : Select only ads that require SSL.
  ##   audienceSegmentIds: JArray
  ##                     : Select only ads with these audience segment IDs.
  ##   placementIds: JArray
  ##               : Select only ads with these placement IDs assigned.
  section = newJObject()
  var valid_594267 = query.getOrDefault("overriddenEventTagId")
  valid_594267 = validateParameter(valid_594267, JString, required = false,
                                 default = nil)
  if valid_594267 != nil:
    section.add "overriddenEventTagId", valid_594267
  var valid_594268 = query.getOrDefault("fields")
  valid_594268 = validateParameter(valid_594268, JString, required = false,
                                 default = nil)
  if valid_594268 != nil:
    section.add "fields", valid_594268
  var valid_594269 = query.getOrDefault("creativeIds")
  valid_594269 = validateParameter(valid_594269, JArray, required = false,
                                 default = nil)
  if valid_594269 != nil:
    section.add "creativeIds", valid_594269
  var valid_594270 = query.getOrDefault("quotaUser")
  valid_594270 = validateParameter(valid_594270, JString, required = false,
                                 default = nil)
  if valid_594270 != nil:
    section.add "quotaUser", valid_594270
  var valid_594271 = query.getOrDefault("pageToken")
  valid_594271 = validateParameter(valid_594271, JString, required = false,
                                 default = nil)
  if valid_594271 != nil:
    section.add "pageToken", valid_594271
  var valid_594272 = query.getOrDefault("sortField")
  valid_594272 = validateParameter(valid_594272, JString, required = false,
                                 default = newJString("ID"))
  if valid_594272 != nil:
    section.add "sortField", valid_594272
  var valid_594273 = query.getOrDefault("alt")
  valid_594273 = validateParameter(valid_594273, JString, required = false,
                                 default = newJString("json"))
  if valid_594273 != nil:
    section.add "alt", valid_594273
  var valid_594274 = query.getOrDefault("sslCompliant")
  valid_594274 = validateParameter(valid_594274, JBool, required = false, default = nil)
  if valid_594274 != nil:
    section.add "sslCompliant", valid_594274
  var valid_594275 = query.getOrDefault("searchString")
  valid_594275 = validateParameter(valid_594275, JString, required = false,
                                 default = nil)
  if valid_594275 != nil:
    section.add "searchString", valid_594275
  var valid_594276 = query.getOrDefault("advertiserId")
  valid_594276 = validateParameter(valid_594276, JString, required = false,
                                 default = nil)
  if valid_594276 != nil:
    section.add "advertiserId", valid_594276
  var valid_594277 = query.getOrDefault("dynamicClickTracker")
  valid_594277 = validateParameter(valid_594277, JBool, required = false, default = nil)
  if valid_594277 != nil:
    section.add "dynamicClickTracker", valid_594277
  var valid_594278 = query.getOrDefault("sizeIds")
  valid_594278 = validateParameter(valid_594278, JArray, required = false,
                                 default = nil)
  if valid_594278 != nil:
    section.add "sizeIds", valid_594278
  var valid_594279 = query.getOrDefault("type")
  valid_594279 = validateParameter(valid_594279, JArray, required = false,
                                 default = nil)
  if valid_594279 != nil:
    section.add "type", valid_594279
  var valid_594280 = query.getOrDefault("active")
  valid_594280 = validateParameter(valid_594280, JBool, required = false, default = nil)
  if valid_594280 != nil:
    section.add "active", valid_594280
  var valid_594281 = query.getOrDefault("oauth_token")
  valid_594281 = validateParameter(valid_594281, JString, required = false,
                                 default = nil)
  if valid_594281 != nil:
    section.add "oauth_token", valid_594281
  var valid_594282 = query.getOrDefault("campaignIds")
  valid_594282 = validateParameter(valid_594282, JArray, required = false,
                                 default = nil)
  if valid_594282 != nil:
    section.add "campaignIds", valid_594282
  var valid_594283 = query.getOrDefault("userIp")
  valid_594283 = validateParameter(valid_594283, JString, required = false,
                                 default = nil)
  if valid_594283 != nil:
    section.add "userIp", valid_594283
  var valid_594284 = query.getOrDefault("creativeOptimizationConfigurationIds")
  valid_594284 = validateParameter(valid_594284, JArray, required = false,
                                 default = nil)
  if valid_594284 != nil:
    section.add "creativeOptimizationConfigurationIds", valid_594284
  var valid_594285 = query.getOrDefault("archived")
  valid_594285 = validateParameter(valid_594285, JBool, required = false, default = nil)
  if valid_594285 != nil:
    section.add "archived", valid_594285
  var valid_594286 = query.getOrDefault("maxResults")
  valid_594286 = validateParameter(valid_594286, JInt, required = false,
                                 default = newJInt(1000))
  if valid_594286 != nil:
    section.add "maxResults", valid_594286
  var valid_594287 = query.getOrDefault("ids")
  valid_594287 = validateParameter(valid_594287, JArray, required = false,
                                 default = nil)
  if valid_594287 != nil:
    section.add "ids", valid_594287
  var valid_594288 = query.getOrDefault("key")
  valid_594288 = validateParameter(valid_594288, JString, required = false,
                                 default = nil)
  if valid_594288 != nil:
    section.add "key", valid_594288
  var valid_594289 = query.getOrDefault("compatibility")
  valid_594289 = validateParameter(valid_594289, JString, required = false,
                                 default = newJString("APP"))
  if valid_594289 != nil:
    section.add "compatibility", valid_594289
  var valid_594290 = query.getOrDefault("landingPageIds")
  valid_594290 = validateParameter(valid_594290, JArray, required = false,
                                 default = nil)
  if valid_594290 != nil:
    section.add "landingPageIds", valid_594290
  var valid_594291 = query.getOrDefault("sortOrder")
  valid_594291 = validateParameter(valid_594291, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_594291 != nil:
    section.add "sortOrder", valid_594291
  var valid_594292 = query.getOrDefault("remarketingListIds")
  valid_594292 = validateParameter(valid_594292, JArray, required = false,
                                 default = nil)
  if valid_594292 != nil:
    section.add "remarketingListIds", valid_594292
  var valid_594293 = query.getOrDefault("prettyPrint")
  valid_594293 = validateParameter(valid_594293, JBool, required = false,
                                 default = newJBool(true))
  if valid_594293 != nil:
    section.add "prettyPrint", valid_594293
  var valid_594294 = query.getOrDefault("sslRequired")
  valid_594294 = validateParameter(valid_594294, JBool, required = false, default = nil)
  if valid_594294 != nil:
    section.add "sslRequired", valid_594294
  var valid_594295 = query.getOrDefault("audienceSegmentIds")
  valid_594295 = validateParameter(valid_594295, JArray, required = false,
                                 default = nil)
  if valid_594295 != nil:
    section.add "audienceSegmentIds", valid_594295
  var valid_594296 = query.getOrDefault("placementIds")
  valid_594296 = validateParameter(valid_594296, JArray, required = false,
                                 default = nil)
  if valid_594296 != nil:
    section.add "placementIds", valid_594296
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594297: Call_DfareportingAdsList_594263; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of ads, possibly filtered. This method supports paging.
  ## 
  let valid = call_594297.validator(path, query, header, formData, body)
  let scheme = call_594297.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594297.url(scheme.get, call_594297.host, call_594297.base,
                         call_594297.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594297, url, valid)

proc call*(call_594298: Call_DfareportingAdsList_594263; profileId: string;
          overriddenEventTagId: string = ""; fields: string = "";
          creativeIds: JsonNode = nil; quotaUser: string = ""; pageToken: string = "";
          sortField: string = "ID"; alt: string = "json"; sslCompliant: bool = false;
          searchString: string = ""; advertiserId: string = "";
          dynamicClickTracker: bool = false; sizeIds: JsonNode = nil;
          `type`: JsonNode = nil; active: bool = false; oauthToken: string = "";
          campaignIds: JsonNode = nil; userIp: string = "";
          creativeOptimizationConfigurationIds: JsonNode = nil;
          archived: bool = false; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; compatibility: string = "APP";
          landingPageIds: JsonNode = nil; sortOrder: string = "ASCENDING";
          remarketingListIds: JsonNode = nil; prettyPrint: bool = true;
          sslRequired: bool = false; audienceSegmentIds: JsonNode = nil;
          placementIds: JsonNode = nil): Recallable =
  ## dfareportingAdsList
  ## Retrieves a list of ads, possibly filtered. This method supports paging.
  ##   overriddenEventTagId: string
  ##                       : Select only ads with this event tag override ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   creativeIds: JArray
  ##              : Select only ads with these creative IDs assigned.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   sslCompliant: bool
  ##               : Select only ads that are SSL-compliant.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "ad*2015" will return objects with names like "ad June 2015", "ad April 2015", or simply "ad 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "ad" will match objects with name "my ad", "ad 2015", or simply "ad".
  ##   advertiserId: string
  ##               : Select only ads with this advertiser ID.
  ##   dynamicClickTracker: bool
  ##                      : Select only dynamic click trackers. Applicable when type is AD_SERVING_CLICK_TRACKER. If true, select dynamic click trackers. If false, select static click trackers. Leave unset to select both.
  ##   sizeIds: JArray
  ##          : Select only ads with these size IDs.
  ##   type: JArray
  ##       : Select only ads with these types.
  ##   active: bool
  ##         : Select only active ads.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   campaignIds: JArray
  ##              : Select only ads with these campaign IDs.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   creativeOptimizationConfigurationIds: JArray
  ##                                       : Select only ads with these creative optimization configuration IDs.
  ##   archived: bool
  ##           : Select only archived ads.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only ads with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   compatibility: string
  ##                : Select default ads with the specified compatibility. Applicable when type is AD_SERVING_DEFAULT_AD. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads, respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering an in-stream video ads developed with the VAST standard.
  ##   landingPageIds: JArray
  ##                 : Select only ads with these landing page IDs.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   remarketingListIds: JArray
  ##                     : Select only ads whose list targeting expression use these remarketing list IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   sslRequired: bool
  ##              : Select only ads that require SSL.
  ##   audienceSegmentIds: JArray
  ##                     : Select only ads with these audience segment IDs.
  ##   placementIds: JArray
  ##               : Select only ads with these placement IDs assigned.
  var path_594299 = newJObject()
  var query_594300 = newJObject()
  add(query_594300, "overriddenEventTagId", newJString(overriddenEventTagId))
  add(path_594299, "profileId", newJString(profileId))
  add(query_594300, "fields", newJString(fields))
  if creativeIds != nil:
    query_594300.add "creativeIds", creativeIds
  add(query_594300, "quotaUser", newJString(quotaUser))
  add(query_594300, "pageToken", newJString(pageToken))
  add(query_594300, "sortField", newJString(sortField))
  add(query_594300, "alt", newJString(alt))
  add(query_594300, "sslCompliant", newJBool(sslCompliant))
  add(query_594300, "searchString", newJString(searchString))
  add(query_594300, "advertiserId", newJString(advertiserId))
  add(query_594300, "dynamicClickTracker", newJBool(dynamicClickTracker))
  if sizeIds != nil:
    query_594300.add "sizeIds", sizeIds
  if `type` != nil:
    query_594300.add "type", `type`
  add(query_594300, "active", newJBool(active))
  add(query_594300, "oauth_token", newJString(oauthToken))
  if campaignIds != nil:
    query_594300.add "campaignIds", campaignIds
  add(query_594300, "userIp", newJString(userIp))
  if creativeOptimizationConfigurationIds != nil:
    query_594300.add "creativeOptimizationConfigurationIds",
                    creativeOptimizationConfigurationIds
  add(query_594300, "archived", newJBool(archived))
  add(query_594300, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_594300.add "ids", ids
  add(query_594300, "key", newJString(key))
  add(query_594300, "compatibility", newJString(compatibility))
  if landingPageIds != nil:
    query_594300.add "landingPageIds", landingPageIds
  add(query_594300, "sortOrder", newJString(sortOrder))
  if remarketingListIds != nil:
    query_594300.add "remarketingListIds", remarketingListIds
  add(query_594300, "prettyPrint", newJBool(prettyPrint))
  add(query_594300, "sslRequired", newJBool(sslRequired))
  if audienceSegmentIds != nil:
    query_594300.add "audienceSegmentIds", audienceSegmentIds
  if placementIds != nil:
    query_594300.add "placementIds", placementIds
  result = call_594298.call(path_594299, query_594300, nil, nil, nil)

var dfareportingAdsList* = Call_DfareportingAdsList_594263(
    name: "dfareportingAdsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsList_594264, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsList_594265, schemes: {Scheme.Https})
type
  Call_DfareportingAdsPatch_594335 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdsPatch_594337(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsPatch_594336(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing ad. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594338 = path.getOrDefault("profileId")
  valid_594338 = validateParameter(valid_594338, JString, required = true,
                                 default = nil)
  if valid_594338 != nil:
    section.add "profileId", valid_594338
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Ad ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594339 = query.getOrDefault("fields")
  valid_594339 = validateParameter(valid_594339, JString, required = false,
                                 default = nil)
  if valid_594339 != nil:
    section.add "fields", valid_594339
  var valid_594340 = query.getOrDefault("quotaUser")
  valid_594340 = validateParameter(valid_594340, JString, required = false,
                                 default = nil)
  if valid_594340 != nil:
    section.add "quotaUser", valid_594340
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_594341 = query.getOrDefault("id")
  valid_594341 = validateParameter(valid_594341, JString, required = true,
                                 default = nil)
  if valid_594341 != nil:
    section.add "id", valid_594341
  var valid_594342 = query.getOrDefault("alt")
  valid_594342 = validateParameter(valid_594342, JString, required = false,
                                 default = newJString("json"))
  if valid_594342 != nil:
    section.add "alt", valid_594342
  var valid_594343 = query.getOrDefault("oauth_token")
  valid_594343 = validateParameter(valid_594343, JString, required = false,
                                 default = nil)
  if valid_594343 != nil:
    section.add "oauth_token", valid_594343
  var valid_594344 = query.getOrDefault("userIp")
  valid_594344 = validateParameter(valid_594344, JString, required = false,
                                 default = nil)
  if valid_594344 != nil:
    section.add "userIp", valid_594344
  var valid_594345 = query.getOrDefault("key")
  valid_594345 = validateParameter(valid_594345, JString, required = false,
                                 default = nil)
  if valid_594345 != nil:
    section.add "key", valid_594345
  var valid_594346 = query.getOrDefault("prettyPrint")
  valid_594346 = validateParameter(valid_594346, JBool, required = false,
                                 default = newJBool(true))
  if valid_594346 != nil:
    section.add "prettyPrint", valid_594346
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594348: Call_DfareportingAdsPatch_594335; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing ad. This method supports patch semantics.
  ## 
  let valid = call_594348.validator(path, query, header, formData, body)
  let scheme = call_594348.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594348.url(scheme.get, call_594348.host, call_594348.base,
                         call_594348.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594348, url, valid)

proc call*(call_594349: Call_DfareportingAdsPatch_594335; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdsPatch
  ## Updates an existing ad. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Ad ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594350 = newJObject()
  var query_594351 = newJObject()
  var body_594352 = newJObject()
  add(path_594350, "profileId", newJString(profileId))
  add(query_594351, "fields", newJString(fields))
  add(query_594351, "quotaUser", newJString(quotaUser))
  add(query_594351, "id", newJString(id))
  add(query_594351, "alt", newJString(alt))
  add(query_594351, "oauth_token", newJString(oauthToken))
  add(query_594351, "userIp", newJString(userIp))
  add(query_594351, "key", newJString(key))
  if body != nil:
    body_594352 = body
  add(query_594351, "prettyPrint", newJBool(prettyPrint))
  result = call_594349.call(path_594350, query_594351, nil, nil, body_594352)

var dfareportingAdsPatch* = Call_DfareportingAdsPatch_594335(
    name: "dfareportingAdsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads",
    validator: validate_DfareportingAdsPatch_594336, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsPatch_594337, schemes: {Scheme.Https})
type
  Call_DfareportingAdsGet_594353 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdsGet_594355(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/ads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdsGet_594354(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Gets one ad by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Ad ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594356 = path.getOrDefault("profileId")
  valid_594356 = validateParameter(valid_594356, JString, required = true,
                                 default = nil)
  if valid_594356 != nil:
    section.add "profileId", valid_594356
  var valid_594357 = path.getOrDefault("id")
  valid_594357 = validateParameter(valid_594357, JString, required = true,
                                 default = nil)
  if valid_594357 != nil:
    section.add "id", valid_594357
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594358 = query.getOrDefault("fields")
  valid_594358 = validateParameter(valid_594358, JString, required = false,
                                 default = nil)
  if valid_594358 != nil:
    section.add "fields", valid_594358
  var valid_594359 = query.getOrDefault("quotaUser")
  valid_594359 = validateParameter(valid_594359, JString, required = false,
                                 default = nil)
  if valid_594359 != nil:
    section.add "quotaUser", valid_594359
  var valid_594360 = query.getOrDefault("alt")
  valid_594360 = validateParameter(valid_594360, JString, required = false,
                                 default = newJString("json"))
  if valid_594360 != nil:
    section.add "alt", valid_594360
  var valid_594361 = query.getOrDefault("oauth_token")
  valid_594361 = validateParameter(valid_594361, JString, required = false,
                                 default = nil)
  if valid_594361 != nil:
    section.add "oauth_token", valid_594361
  var valid_594362 = query.getOrDefault("userIp")
  valid_594362 = validateParameter(valid_594362, JString, required = false,
                                 default = nil)
  if valid_594362 != nil:
    section.add "userIp", valid_594362
  var valid_594363 = query.getOrDefault("key")
  valid_594363 = validateParameter(valid_594363, JString, required = false,
                                 default = nil)
  if valid_594363 != nil:
    section.add "key", valid_594363
  var valid_594364 = query.getOrDefault("prettyPrint")
  valid_594364 = validateParameter(valid_594364, JBool, required = false,
                                 default = newJBool(true))
  if valid_594364 != nil:
    section.add "prettyPrint", valid_594364
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594365: Call_DfareportingAdsGet_594353; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one ad by ID.
  ## 
  let valid = call_594365.validator(path, query, header, formData, body)
  let scheme = call_594365.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594365.url(scheme.get, call_594365.host, call_594365.base,
                         call_594365.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594365, url, valid)

proc call*(call_594366: Call_DfareportingAdsGet_594353; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingAdsGet
  ## Gets one ad by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Ad ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594367 = newJObject()
  var query_594368 = newJObject()
  add(path_594367, "profileId", newJString(profileId))
  add(query_594368, "fields", newJString(fields))
  add(query_594368, "quotaUser", newJString(quotaUser))
  add(query_594368, "alt", newJString(alt))
  add(query_594368, "oauth_token", newJString(oauthToken))
  add(query_594368, "userIp", newJString(userIp))
  add(path_594367, "id", newJString(id))
  add(query_594368, "key", newJString(key))
  add(query_594368, "prettyPrint", newJBool(prettyPrint))
  result = call_594366.call(path_594367, query_594368, nil, nil, nil)

var dfareportingAdsGet* = Call_DfareportingAdsGet_594353(
    name: "dfareportingAdsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/ads/{id}",
    validator: validate_DfareportingAdsGet_594354, base: "/dfareporting/v2.7",
    url: url_DfareportingAdsGet_594355, schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsUpdate_594390 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdvertiserGroupsUpdate_594392(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsUpdate_594391(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594393 = path.getOrDefault("profileId")
  valid_594393 = validateParameter(valid_594393, JString, required = true,
                                 default = nil)
  if valid_594393 != nil:
    section.add "profileId", valid_594393
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594394 = query.getOrDefault("fields")
  valid_594394 = validateParameter(valid_594394, JString, required = false,
                                 default = nil)
  if valid_594394 != nil:
    section.add "fields", valid_594394
  var valid_594395 = query.getOrDefault("quotaUser")
  valid_594395 = validateParameter(valid_594395, JString, required = false,
                                 default = nil)
  if valid_594395 != nil:
    section.add "quotaUser", valid_594395
  var valid_594396 = query.getOrDefault("alt")
  valid_594396 = validateParameter(valid_594396, JString, required = false,
                                 default = newJString("json"))
  if valid_594396 != nil:
    section.add "alt", valid_594396
  var valid_594397 = query.getOrDefault("oauth_token")
  valid_594397 = validateParameter(valid_594397, JString, required = false,
                                 default = nil)
  if valid_594397 != nil:
    section.add "oauth_token", valid_594397
  var valid_594398 = query.getOrDefault("userIp")
  valid_594398 = validateParameter(valid_594398, JString, required = false,
                                 default = nil)
  if valid_594398 != nil:
    section.add "userIp", valid_594398
  var valid_594399 = query.getOrDefault("key")
  valid_594399 = validateParameter(valid_594399, JString, required = false,
                                 default = nil)
  if valid_594399 != nil:
    section.add "key", valid_594399
  var valid_594400 = query.getOrDefault("prettyPrint")
  valid_594400 = validateParameter(valid_594400, JBool, required = false,
                                 default = newJBool(true))
  if valid_594400 != nil:
    section.add "prettyPrint", valid_594400
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594402: Call_DfareportingAdvertiserGroupsUpdate_594390;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing advertiser group.
  ## 
  let valid = call_594402.validator(path, query, header, formData, body)
  let scheme = call_594402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594402.url(scheme.get, call_594402.host, call_594402.base,
                         call_594402.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594402, url, valid)

proc call*(call_594403: Call_DfareportingAdvertiserGroupsUpdate_594390;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsUpdate
  ## Updates an existing advertiser group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594404 = newJObject()
  var query_594405 = newJObject()
  var body_594406 = newJObject()
  add(path_594404, "profileId", newJString(profileId))
  add(query_594405, "fields", newJString(fields))
  add(query_594405, "quotaUser", newJString(quotaUser))
  add(query_594405, "alt", newJString(alt))
  add(query_594405, "oauth_token", newJString(oauthToken))
  add(query_594405, "userIp", newJString(userIp))
  add(query_594405, "key", newJString(key))
  if body != nil:
    body_594406 = body
  add(query_594405, "prettyPrint", newJBool(prettyPrint))
  result = call_594403.call(path_594404, query_594405, nil, nil, body_594406)

var dfareportingAdvertiserGroupsUpdate* = Call_DfareportingAdvertiserGroupsUpdate_594390(
    name: "dfareportingAdvertiserGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsUpdate_594391,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsUpdate_594392,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsInsert_594407 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdvertiserGroupsInsert_594409(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsInsert_594408(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new advertiser group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594410 = path.getOrDefault("profileId")
  valid_594410 = validateParameter(valid_594410, JString, required = true,
                                 default = nil)
  if valid_594410 != nil:
    section.add "profileId", valid_594410
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594411 = query.getOrDefault("fields")
  valid_594411 = validateParameter(valid_594411, JString, required = false,
                                 default = nil)
  if valid_594411 != nil:
    section.add "fields", valid_594411
  var valid_594412 = query.getOrDefault("quotaUser")
  valid_594412 = validateParameter(valid_594412, JString, required = false,
                                 default = nil)
  if valid_594412 != nil:
    section.add "quotaUser", valid_594412
  var valid_594413 = query.getOrDefault("alt")
  valid_594413 = validateParameter(valid_594413, JString, required = false,
                                 default = newJString("json"))
  if valid_594413 != nil:
    section.add "alt", valid_594413
  var valid_594414 = query.getOrDefault("oauth_token")
  valid_594414 = validateParameter(valid_594414, JString, required = false,
                                 default = nil)
  if valid_594414 != nil:
    section.add "oauth_token", valid_594414
  var valid_594415 = query.getOrDefault("userIp")
  valid_594415 = validateParameter(valid_594415, JString, required = false,
                                 default = nil)
  if valid_594415 != nil:
    section.add "userIp", valid_594415
  var valid_594416 = query.getOrDefault("key")
  valid_594416 = validateParameter(valid_594416, JString, required = false,
                                 default = nil)
  if valid_594416 != nil:
    section.add "key", valid_594416
  var valid_594417 = query.getOrDefault("prettyPrint")
  valid_594417 = validateParameter(valid_594417, JBool, required = false,
                                 default = newJBool(true))
  if valid_594417 != nil:
    section.add "prettyPrint", valid_594417
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594419: Call_DfareportingAdvertiserGroupsInsert_594407;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new advertiser group.
  ## 
  let valid = call_594419.validator(path, query, header, formData, body)
  let scheme = call_594419.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594419.url(scheme.get, call_594419.host, call_594419.base,
                         call_594419.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594419, url, valid)

proc call*(call_594420: Call_DfareportingAdvertiserGroupsInsert_594407;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsInsert
  ## Inserts a new advertiser group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594421 = newJObject()
  var query_594422 = newJObject()
  var body_594423 = newJObject()
  add(path_594421, "profileId", newJString(profileId))
  add(query_594422, "fields", newJString(fields))
  add(query_594422, "quotaUser", newJString(quotaUser))
  add(query_594422, "alt", newJString(alt))
  add(query_594422, "oauth_token", newJString(oauthToken))
  add(query_594422, "userIp", newJString(userIp))
  add(query_594422, "key", newJString(key))
  if body != nil:
    body_594423 = body
  add(query_594422, "prettyPrint", newJBool(prettyPrint))
  result = call_594420.call(path_594421, query_594422, nil, nil, body_594423)

var dfareportingAdvertiserGroupsInsert* = Call_DfareportingAdvertiserGroupsInsert_594407(
    name: "dfareportingAdvertiserGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsInsert_594408,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsInsert_594409,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsList_594369 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdvertiserGroupsList_594371(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsList_594370(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of advertiser groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594372 = path.getOrDefault("profileId")
  valid_594372 = validateParameter(valid_594372, JString, required = true,
                                 default = nil)
  if valid_594372 != nil:
    section.add "profileId", valid_594372
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser group June 2015", "advertiser group April 2015", or simply "advertiser group 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertisergroup" will match objects with name "my advertisergroup", "advertisergroup 2015", or simply "advertisergroup".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only advertiser groups with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594373 = query.getOrDefault("fields")
  valid_594373 = validateParameter(valid_594373, JString, required = false,
                                 default = nil)
  if valid_594373 != nil:
    section.add "fields", valid_594373
  var valid_594374 = query.getOrDefault("pageToken")
  valid_594374 = validateParameter(valid_594374, JString, required = false,
                                 default = nil)
  if valid_594374 != nil:
    section.add "pageToken", valid_594374
  var valid_594375 = query.getOrDefault("quotaUser")
  valid_594375 = validateParameter(valid_594375, JString, required = false,
                                 default = nil)
  if valid_594375 != nil:
    section.add "quotaUser", valid_594375
  var valid_594376 = query.getOrDefault("sortField")
  valid_594376 = validateParameter(valid_594376, JString, required = false,
                                 default = newJString("ID"))
  if valid_594376 != nil:
    section.add "sortField", valid_594376
  var valid_594377 = query.getOrDefault("alt")
  valid_594377 = validateParameter(valid_594377, JString, required = false,
                                 default = newJString("json"))
  if valid_594377 != nil:
    section.add "alt", valid_594377
  var valid_594378 = query.getOrDefault("searchString")
  valid_594378 = validateParameter(valid_594378, JString, required = false,
                                 default = nil)
  if valid_594378 != nil:
    section.add "searchString", valid_594378
  var valid_594379 = query.getOrDefault("oauth_token")
  valid_594379 = validateParameter(valid_594379, JString, required = false,
                                 default = nil)
  if valid_594379 != nil:
    section.add "oauth_token", valid_594379
  var valid_594380 = query.getOrDefault("userIp")
  valid_594380 = validateParameter(valid_594380, JString, required = false,
                                 default = nil)
  if valid_594380 != nil:
    section.add "userIp", valid_594380
  var valid_594381 = query.getOrDefault("maxResults")
  valid_594381 = validateParameter(valid_594381, JInt, required = false,
                                 default = newJInt(1000))
  if valid_594381 != nil:
    section.add "maxResults", valid_594381
  var valid_594382 = query.getOrDefault("ids")
  valid_594382 = validateParameter(valid_594382, JArray, required = false,
                                 default = nil)
  if valid_594382 != nil:
    section.add "ids", valid_594382
  var valid_594383 = query.getOrDefault("key")
  valid_594383 = validateParameter(valid_594383, JString, required = false,
                                 default = nil)
  if valid_594383 != nil:
    section.add "key", valid_594383
  var valid_594384 = query.getOrDefault("sortOrder")
  valid_594384 = validateParameter(valid_594384, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_594384 != nil:
    section.add "sortOrder", valid_594384
  var valid_594385 = query.getOrDefault("prettyPrint")
  valid_594385 = validateParameter(valid_594385, JBool, required = false,
                                 default = newJBool(true))
  if valid_594385 != nil:
    section.add "prettyPrint", valid_594385
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594386: Call_DfareportingAdvertiserGroupsList_594369;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of advertiser groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_594386.validator(path, query, header, formData, body)
  let scheme = call_594386.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594386.url(scheme.get, call_594386.host, call_594386.base,
                         call_594386.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594386, url, valid)

proc call*(call_594387: Call_DfareportingAdvertiserGroupsList_594369;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsList
  ## Retrieves a list of advertiser groups, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser group June 2015", "advertiser group April 2015", or simply "advertiser group 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertisergroup" will match objects with name "my advertisergroup", "advertisergroup 2015", or simply "advertisergroup".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only advertiser groups with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594388 = newJObject()
  var query_594389 = newJObject()
  add(path_594388, "profileId", newJString(profileId))
  add(query_594389, "fields", newJString(fields))
  add(query_594389, "pageToken", newJString(pageToken))
  add(query_594389, "quotaUser", newJString(quotaUser))
  add(query_594389, "sortField", newJString(sortField))
  add(query_594389, "alt", newJString(alt))
  add(query_594389, "searchString", newJString(searchString))
  add(query_594389, "oauth_token", newJString(oauthToken))
  add(query_594389, "userIp", newJString(userIp))
  add(query_594389, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_594389.add "ids", ids
  add(query_594389, "key", newJString(key))
  add(query_594389, "sortOrder", newJString(sortOrder))
  add(query_594389, "prettyPrint", newJBool(prettyPrint))
  result = call_594387.call(path_594388, query_594389, nil, nil, nil)

var dfareportingAdvertiserGroupsList* = Call_DfareportingAdvertiserGroupsList_594369(
    name: "dfareportingAdvertiserGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsList_594370,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsList_594371,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsPatch_594424 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdvertiserGroupsPatch_594426(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsPatch_594425(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594427 = path.getOrDefault("profileId")
  valid_594427 = validateParameter(valid_594427, JString, required = true,
                                 default = nil)
  if valid_594427 != nil:
    section.add "profileId", valid_594427
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Advertiser group ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594428 = query.getOrDefault("fields")
  valid_594428 = validateParameter(valid_594428, JString, required = false,
                                 default = nil)
  if valid_594428 != nil:
    section.add "fields", valid_594428
  var valid_594429 = query.getOrDefault("quotaUser")
  valid_594429 = validateParameter(valid_594429, JString, required = false,
                                 default = nil)
  if valid_594429 != nil:
    section.add "quotaUser", valid_594429
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_594430 = query.getOrDefault("id")
  valid_594430 = validateParameter(valid_594430, JString, required = true,
                                 default = nil)
  if valid_594430 != nil:
    section.add "id", valid_594430
  var valid_594431 = query.getOrDefault("alt")
  valid_594431 = validateParameter(valid_594431, JString, required = false,
                                 default = newJString("json"))
  if valid_594431 != nil:
    section.add "alt", valid_594431
  var valid_594432 = query.getOrDefault("oauth_token")
  valid_594432 = validateParameter(valid_594432, JString, required = false,
                                 default = nil)
  if valid_594432 != nil:
    section.add "oauth_token", valid_594432
  var valid_594433 = query.getOrDefault("userIp")
  valid_594433 = validateParameter(valid_594433, JString, required = false,
                                 default = nil)
  if valid_594433 != nil:
    section.add "userIp", valid_594433
  var valid_594434 = query.getOrDefault("key")
  valid_594434 = validateParameter(valid_594434, JString, required = false,
                                 default = nil)
  if valid_594434 != nil:
    section.add "key", valid_594434
  var valid_594435 = query.getOrDefault("prettyPrint")
  valid_594435 = validateParameter(valid_594435, JBool, required = false,
                                 default = newJBool(true))
  if valid_594435 != nil:
    section.add "prettyPrint", valid_594435
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594437: Call_DfareportingAdvertiserGroupsPatch_594424;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing advertiser group. This method supports patch semantics.
  ## 
  let valid = call_594437.validator(path, query, header, formData, body)
  let scheme = call_594437.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594437.url(scheme.get, call_594437.host, call_594437.base,
                         call_594437.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594437, url, valid)

proc call*(call_594438: Call_DfareportingAdvertiserGroupsPatch_594424;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsPatch
  ## Updates an existing advertiser group. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Advertiser group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594439 = newJObject()
  var query_594440 = newJObject()
  var body_594441 = newJObject()
  add(path_594439, "profileId", newJString(profileId))
  add(query_594440, "fields", newJString(fields))
  add(query_594440, "quotaUser", newJString(quotaUser))
  add(query_594440, "id", newJString(id))
  add(query_594440, "alt", newJString(alt))
  add(query_594440, "oauth_token", newJString(oauthToken))
  add(query_594440, "userIp", newJString(userIp))
  add(query_594440, "key", newJString(key))
  if body != nil:
    body_594441 = body
  add(query_594440, "prettyPrint", newJBool(prettyPrint))
  result = call_594438.call(path_594439, query_594440, nil, nil, body_594441)

var dfareportingAdvertiserGroupsPatch* = Call_DfareportingAdvertiserGroupsPatch_594424(
    name: "dfareportingAdvertiserGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups",
    validator: validate_DfareportingAdvertiserGroupsPatch_594425,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsPatch_594426,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsGet_594442 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdvertiserGroupsGet_594444(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsGet_594443(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one advertiser group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Advertiser group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594445 = path.getOrDefault("profileId")
  valid_594445 = validateParameter(valid_594445, JString, required = true,
                                 default = nil)
  if valid_594445 != nil:
    section.add "profileId", valid_594445
  var valid_594446 = path.getOrDefault("id")
  valid_594446 = validateParameter(valid_594446, JString, required = true,
                                 default = nil)
  if valid_594446 != nil:
    section.add "id", valid_594446
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594447 = query.getOrDefault("fields")
  valid_594447 = validateParameter(valid_594447, JString, required = false,
                                 default = nil)
  if valid_594447 != nil:
    section.add "fields", valid_594447
  var valid_594448 = query.getOrDefault("quotaUser")
  valid_594448 = validateParameter(valid_594448, JString, required = false,
                                 default = nil)
  if valid_594448 != nil:
    section.add "quotaUser", valid_594448
  var valid_594449 = query.getOrDefault("alt")
  valid_594449 = validateParameter(valid_594449, JString, required = false,
                                 default = newJString("json"))
  if valid_594449 != nil:
    section.add "alt", valid_594449
  var valid_594450 = query.getOrDefault("oauth_token")
  valid_594450 = validateParameter(valid_594450, JString, required = false,
                                 default = nil)
  if valid_594450 != nil:
    section.add "oauth_token", valid_594450
  var valid_594451 = query.getOrDefault("userIp")
  valid_594451 = validateParameter(valid_594451, JString, required = false,
                                 default = nil)
  if valid_594451 != nil:
    section.add "userIp", valid_594451
  var valid_594452 = query.getOrDefault("key")
  valid_594452 = validateParameter(valid_594452, JString, required = false,
                                 default = nil)
  if valid_594452 != nil:
    section.add "key", valid_594452
  var valid_594453 = query.getOrDefault("prettyPrint")
  valid_594453 = validateParameter(valid_594453, JBool, required = false,
                                 default = newJBool(true))
  if valid_594453 != nil:
    section.add "prettyPrint", valid_594453
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594454: Call_DfareportingAdvertiserGroupsGet_594442;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one advertiser group by ID.
  ## 
  let valid = call_594454.validator(path, query, header, formData, body)
  let scheme = call_594454.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594454.url(scheme.get, call_594454.host, call_594454.base,
                         call_594454.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594454, url, valid)

proc call*(call_594455: Call_DfareportingAdvertiserGroupsGet_594442;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsGet
  ## Gets one advertiser group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Advertiser group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594456 = newJObject()
  var query_594457 = newJObject()
  add(path_594456, "profileId", newJString(profileId))
  add(query_594457, "fields", newJString(fields))
  add(query_594457, "quotaUser", newJString(quotaUser))
  add(query_594457, "alt", newJString(alt))
  add(query_594457, "oauth_token", newJString(oauthToken))
  add(query_594457, "userIp", newJString(userIp))
  add(path_594456, "id", newJString(id))
  add(query_594457, "key", newJString(key))
  add(query_594457, "prettyPrint", newJBool(prettyPrint))
  result = call_594455.call(path_594456, query_594457, nil, nil, nil)

var dfareportingAdvertiserGroupsGet* = Call_DfareportingAdvertiserGroupsGet_594442(
    name: "dfareportingAdvertiserGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups/{id}",
    validator: validate_DfareportingAdvertiserGroupsGet_594443,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsGet_594444,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertiserGroupsDelete_594458 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdvertiserGroupsDelete_594460(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertiserGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertiserGroupsDelete_594459(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing advertiser group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Advertiser group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594461 = path.getOrDefault("profileId")
  valid_594461 = validateParameter(valid_594461, JString, required = true,
                                 default = nil)
  if valid_594461 != nil:
    section.add "profileId", valid_594461
  var valid_594462 = path.getOrDefault("id")
  valid_594462 = validateParameter(valid_594462, JString, required = true,
                                 default = nil)
  if valid_594462 != nil:
    section.add "id", valid_594462
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594463 = query.getOrDefault("fields")
  valid_594463 = validateParameter(valid_594463, JString, required = false,
                                 default = nil)
  if valid_594463 != nil:
    section.add "fields", valid_594463
  var valid_594464 = query.getOrDefault("quotaUser")
  valid_594464 = validateParameter(valid_594464, JString, required = false,
                                 default = nil)
  if valid_594464 != nil:
    section.add "quotaUser", valid_594464
  var valid_594465 = query.getOrDefault("alt")
  valid_594465 = validateParameter(valid_594465, JString, required = false,
                                 default = newJString("json"))
  if valid_594465 != nil:
    section.add "alt", valid_594465
  var valid_594466 = query.getOrDefault("oauth_token")
  valid_594466 = validateParameter(valid_594466, JString, required = false,
                                 default = nil)
  if valid_594466 != nil:
    section.add "oauth_token", valid_594466
  var valid_594467 = query.getOrDefault("userIp")
  valid_594467 = validateParameter(valid_594467, JString, required = false,
                                 default = nil)
  if valid_594467 != nil:
    section.add "userIp", valid_594467
  var valid_594468 = query.getOrDefault("key")
  valid_594468 = validateParameter(valid_594468, JString, required = false,
                                 default = nil)
  if valid_594468 != nil:
    section.add "key", valid_594468
  var valid_594469 = query.getOrDefault("prettyPrint")
  valid_594469 = validateParameter(valid_594469, JBool, required = false,
                                 default = newJBool(true))
  if valid_594469 != nil:
    section.add "prettyPrint", valid_594469
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594470: Call_DfareportingAdvertiserGroupsDelete_594458;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing advertiser group.
  ## 
  let valid = call_594470.validator(path, query, header, formData, body)
  let scheme = call_594470.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594470.url(scheme.get, call_594470.host, call_594470.base,
                         call_594470.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594470, url, valid)

proc call*(call_594471: Call_DfareportingAdvertiserGroupsDelete_594458;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertiserGroupsDelete
  ## Deletes an existing advertiser group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Advertiser group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594472 = newJObject()
  var query_594473 = newJObject()
  add(path_594472, "profileId", newJString(profileId))
  add(query_594473, "fields", newJString(fields))
  add(query_594473, "quotaUser", newJString(quotaUser))
  add(query_594473, "alt", newJString(alt))
  add(query_594473, "oauth_token", newJString(oauthToken))
  add(query_594473, "userIp", newJString(userIp))
  add(path_594472, "id", newJString(id))
  add(query_594473, "key", newJString(key))
  add(query_594473, "prettyPrint", newJBool(prettyPrint))
  result = call_594471.call(path_594472, query_594473, nil, nil, nil)

var dfareportingAdvertiserGroupsDelete* = Call_DfareportingAdvertiserGroupsDelete_594458(
    name: "dfareportingAdvertiserGroupsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertiserGroups/{id}",
    validator: validate_DfareportingAdvertiserGroupsDelete_594459,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertiserGroupsDelete_594460,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersUpdate_594501 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdvertisersUpdate_594503(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersUpdate_594502(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594504 = path.getOrDefault("profileId")
  valid_594504 = validateParameter(valid_594504, JString, required = true,
                                 default = nil)
  if valid_594504 != nil:
    section.add "profileId", valid_594504
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594505 = query.getOrDefault("fields")
  valid_594505 = validateParameter(valid_594505, JString, required = false,
                                 default = nil)
  if valid_594505 != nil:
    section.add "fields", valid_594505
  var valid_594506 = query.getOrDefault("quotaUser")
  valid_594506 = validateParameter(valid_594506, JString, required = false,
                                 default = nil)
  if valid_594506 != nil:
    section.add "quotaUser", valid_594506
  var valid_594507 = query.getOrDefault("alt")
  valid_594507 = validateParameter(valid_594507, JString, required = false,
                                 default = newJString("json"))
  if valid_594507 != nil:
    section.add "alt", valid_594507
  var valid_594508 = query.getOrDefault("oauth_token")
  valid_594508 = validateParameter(valid_594508, JString, required = false,
                                 default = nil)
  if valid_594508 != nil:
    section.add "oauth_token", valid_594508
  var valid_594509 = query.getOrDefault("userIp")
  valid_594509 = validateParameter(valid_594509, JString, required = false,
                                 default = nil)
  if valid_594509 != nil:
    section.add "userIp", valid_594509
  var valid_594510 = query.getOrDefault("key")
  valid_594510 = validateParameter(valid_594510, JString, required = false,
                                 default = nil)
  if valid_594510 != nil:
    section.add "key", valid_594510
  var valid_594511 = query.getOrDefault("prettyPrint")
  valid_594511 = validateParameter(valid_594511, JBool, required = false,
                                 default = newJBool(true))
  if valid_594511 != nil:
    section.add "prettyPrint", valid_594511
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594513: Call_DfareportingAdvertisersUpdate_594501; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing advertiser.
  ## 
  let valid = call_594513.validator(path, query, header, formData, body)
  let scheme = call_594513.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594513.url(scheme.get, call_594513.host, call_594513.base,
                         call_594513.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594513, url, valid)

proc call*(call_594514: Call_DfareportingAdvertisersUpdate_594501;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertisersUpdate
  ## Updates an existing advertiser.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594515 = newJObject()
  var query_594516 = newJObject()
  var body_594517 = newJObject()
  add(path_594515, "profileId", newJString(profileId))
  add(query_594516, "fields", newJString(fields))
  add(query_594516, "quotaUser", newJString(quotaUser))
  add(query_594516, "alt", newJString(alt))
  add(query_594516, "oauth_token", newJString(oauthToken))
  add(query_594516, "userIp", newJString(userIp))
  add(query_594516, "key", newJString(key))
  if body != nil:
    body_594517 = body
  add(query_594516, "prettyPrint", newJBool(prettyPrint))
  result = call_594514.call(path_594515, query_594516, nil, nil, body_594517)

var dfareportingAdvertisersUpdate* = Call_DfareportingAdvertisersUpdate_594501(
    name: "dfareportingAdvertisersUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersUpdate_594502,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersUpdate_594503,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersInsert_594518 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdvertisersInsert_594520(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersInsert_594519(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new advertiser.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594521 = path.getOrDefault("profileId")
  valid_594521 = validateParameter(valid_594521, JString, required = true,
                                 default = nil)
  if valid_594521 != nil:
    section.add "profileId", valid_594521
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594522 = query.getOrDefault("fields")
  valid_594522 = validateParameter(valid_594522, JString, required = false,
                                 default = nil)
  if valid_594522 != nil:
    section.add "fields", valid_594522
  var valid_594523 = query.getOrDefault("quotaUser")
  valid_594523 = validateParameter(valid_594523, JString, required = false,
                                 default = nil)
  if valid_594523 != nil:
    section.add "quotaUser", valid_594523
  var valid_594524 = query.getOrDefault("alt")
  valid_594524 = validateParameter(valid_594524, JString, required = false,
                                 default = newJString("json"))
  if valid_594524 != nil:
    section.add "alt", valid_594524
  var valid_594525 = query.getOrDefault("oauth_token")
  valid_594525 = validateParameter(valid_594525, JString, required = false,
                                 default = nil)
  if valid_594525 != nil:
    section.add "oauth_token", valid_594525
  var valid_594526 = query.getOrDefault("userIp")
  valid_594526 = validateParameter(valid_594526, JString, required = false,
                                 default = nil)
  if valid_594526 != nil:
    section.add "userIp", valid_594526
  var valid_594527 = query.getOrDefault("key")
  valid_594527 = validateParameter(valid_594527, JString, required = false,
                                 default = nil)
  if valid_594527 != nil:
    section.add "key", valid_594527
  var valid_594528 = query.getOrDefault("prettyPrint")
  valid_594528 = validateParameter(valid_594528, JBool, required = false,
                                 default = newJBool(true))
  if valid_594528 != nil:
    section.add "prettyPrint", valid_594528
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594530: Call_DfareportingAdvertisersInsert_594518; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new advertiser.
  ## 
  let valid = call_594530.validator(path, query, header, formData, body)
  let scheme = call_594530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594530.url(scheme.get, call_594530.host, call_594530.base,
                         call_594530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594530, url, valid)

proc call*(call_594531: Call_DfareportingAdvertisersInsert_594518;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertisersInsert
  ## Inserts a new advertiser.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594532 = newJObject()
  var query_594533 = newJObject()
  var body_594534 = newJObject()
  add(path_594532, "profileId", newJString(profileId))
  add(query_594533, "fields", newJString(fields))
  add(query_594533, "quotaUser", newJString(quotaUser))
  add(query_594533, "alt", newJString(alt))
  add(query_594533, "oauth_token", newJString(oauthToken))
  add(query_594533, "userIp", newJString(userIp))
  add(query_594533, "key", newJString(key))
  if body != nil:
    body_594534 = body
  add(query_594533, "prettyPrint", newJBool(prettyPrint))
  result = call_594531.call(path_594532, query_594533, nil, nil, body_594534)

var dfareportingAdvertisersInsert* = Call_DfareportingAdvertisersInsert_594518(
    name: "dfareportingAdvertisersInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersInsert_594519,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersInsert_594520,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersList_594474 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdvertisersList_594476(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersList_594475(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of advertisers, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594477 = path.getOrDefault("profileId")
  valid_594477 = validateParameter(valid_594477, JString, required = true,
                                 default = nil)
  if valid_594477 != nil:
    section.add "profileId", valid_594477
  result.add "path", section
  ## parameters in `query` object:
  ##   subaccountId: JString
  ##               : Select only advertisers with these subaccount IDs.
  ##   advertiserGroupIds: JArray
  ##                     : Select only advertisers with these advertiser group IDs.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   onlyParent: JBool
  ##             : Select only advertisers which use another advertiser's floodlight configuration.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser June 2015", "advertiser April 2015", or simply "advertiser 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertiser" will match objects with name "my advertiser", "advertiser 2015", or simply "advertiser".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   floodlightConfigurationIds: JArray
  ##                             : Select only advertisers with these floodlight configuration IDs.
  ##   ids: JArray
  ##      : Select only advertisers with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   status: JString
  ##         : Select only advertisers with the specified status.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   includeAdvertisersWithoutGroupsOnly: JBool
  ##                                      : Select only advertisers which do not belong to any advertiser group.
  section = newJObject()
  var valid_594478 = query.getOrDefault("subaccountId")
  valid_594478 = validateParameter(valid_594478, JString, required = false,
                                 default = nil)
  if valid_594478 != nil:
    section.add "subaccountId", valid_594478
  var valid_594479 = query.getOrDefault("advertiserGroupIds")
  valid_594479 = validateParameter(valid_594479, JArray, required = false,
                                 default = nil)
  if valid_594479 != nil:
    section.add "advertiserGroupIds", valid_594479
  var valid_594480 = query.getOrDefault("fields")
  valid_594480 = validateParameter(valid_594480, JString, required = false,
                                 default = nil)
  if valid_594480 != nil:
    section.add "fields", valid_594480
  var valid_594481 = query.getOrDefault("pageToken")
  valid_594481 = validateParameter(valid_594481, JString, required = false,
                                 default = nil)
  if valid_594481 != nil:
    section.add "pageToken", valid_594481
  var valid_594482 = query.getOrDefault("quotaUser")
  valid_594482 = validateParameter(valid_594482, JString, required = false,
                                 default = nil)
  if valid_594482 != nil:
    section.add "quotaUser", valid_594482
  var valid_594483 = query.getOrDefault("sortField")
  valid_594483 = validateParameter(valid_594483, JString, required = false,
                                 default = newJString("ID"))
  if valid_594483 != nil:
    section.add "sortField", valid_594483
  var valid_594484 = query.getOrDefault("alt")
  valid_594484 = validateParameter(valid_594484, JString, required = false,
                                 default = newJString("json"))
  if valid_594484 != nil:
    section.add "alt", valid_594484
  var valid_594485 = query.getOrDefault("onlyParent")
  valid_594485 = validateParameter(valid_594485, JBool, required = false, default = nil)
  if valid_594485 != nil:
    section.add "onlyParent", valid_594485
  var valid_594486 = query.getOrDefault("searchString")
  valid_594486 = validateParameter(valid_594486, JString, required = false,
                                 default = nil)
  if valid_594486 != nil:
    section.add "searchString", valid_594486
  var valid_594487 = query.getOrDefault("oauth_token")
  valid_594487 = validateParameter(valid_594487, JString, required = false,
                                 default = nil)
  if valid_594487 != nil:
    section.add "oauth_token", valid_594487
  var valid_594488 = query.getOrDefault("userIp")
  valid_594488 = validateParameter(valid_594488, JString, required = false,
                                 default = nil)
  if valid_594488 != nil:
    section.add "userIp", valid_594488
  var valid_594489 = query.getOrDefault("maxResults")
  valid_594489 = validateParameter(valid_594489, JInt, required = false,
                                 default = newJInt(1000))
  if valid_594489 != nil:
    section.add "maxResults", valid_594489
  var valid_594490 = query.getOrDefault("floodlightConfigurationIds")
  valid_594490 = validateParameter(valid_594490, JArray, required = false,
                                 default = nil)
  if valid_594490 != nil:
    section.add "floodlightConfigurationIds", valid_594490
  var valid_594491 = query.getOrDefault("ids")
  valid_594491 = validateParameter(valid_594491, JArray, required = false,
                                 default = nil)
  if valid_594491 != nil:
    section.add "ids", valid_594491
  var valid_594492 = query.getOrDefault("key")
  valid_594492 = validateParameter(valid_594492, JString, required = false,
                                 default = nil)
  if valid_594492 != nil:
    section.add "key", valid_594492
  var valid_594493 = query.getOrDefault("status")
  valid_594493 = validateParameter(valid_594493, JString, required = false,
                                 default = newJString("APPROVED"))
  if valid_594493 != nil:
    section.add "status", valid_594493
  var valid_594494 = query.getOrDefault("sortOrder")
  valid_594494 = validateParameter(valid_594494, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_594494 != nil:
    section.add "sortOrder", valid_594494
  var valid_594495 = query.getOrDefault("prettyPrint")
  valid_594495 = validateParameter(valid_594495, JBool, required = false,
                                 default = newJBool(true))
  if valid_594495 != nil:
    section.add "prettyPrint", valid_594495
  var valid_594496 = query.getOrDefault("includeAdvertisersWithoutGroupsOnly")
  valid_594496 = validateParameter(valid_594496, JBool, required = false, default = nil)
  if valid_594496 != nil:
    section.add "includeAdvertisersWithoutGroupsOnly", valid_594496
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594497: Call_DfareportingAdvertisersList_594474; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of advertisers, possibly filtered. This method supports paging.
  ## 
  let valid = call_594497.validator(path, query, header, formData, body)
  let scheme = call_594497.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594497.url(scheme.get, call_594497.host, call_594497.base,
                         call_594497.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594497, url, valid)

proc call*(call_594498: Call_DfareportingAdvertisersList_594474; profileId: string;
          subaccountId: string = ""; advertiserGroupIds: JsonNode = nil;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; onlyParent: bool = false;
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; floodlightConfigurationIds: JsonNode = nil;
          ids: JsonNode = nil; key: string = ""; status: string = "APPROVED";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true;
          includeAdvertisersWithoutGroupsOnly: bool = false): Recallable =
  ## dfareportingAdvertisersList
  ## Retrieves a list of advertisers, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only advertisers with these subaccount IDs.
  ##   advertiserGroupIds: JArray
  ##                     : Select only advertisers with these advertiser group IDs.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   onlyParent: bool
  ##             : Select only advertisers which use another advertiser's floodlight configuration.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "advertiser*2015" will return objects with names like "advertiser June 2015", "advertiser April 2015", or simply "advertiser 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "advertiser" will match objects with name "my advertiser", "advertiser 2015", or simply "advertiser".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   floodlightConfigurationIds: JArray
  ##                             : Select only advertisers with these floodlight configuration IDs.
  ##   ids: JArray
  ##      : Select only advertisers with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   status: string
  ##         : Select only advertisers with the specified status.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   includeAdvertisersWithoutGroupsOnly: bool
  ##                                      : Select only advertisers which do not belong to any advertiser group.
  var path_594499 = newJObject()
  var query_594500 = newJObject()
  add(path_594499, "profileId", newJString(profileId))
  add(query_594500, "subaccountId", newJString(subaccountId))
  if advertiserGroupIds != nil:
    query_594500.add "advertiserGroupIds", advertiserGroupIds
  add(query_594500, "fields", newJString(fields))
  add(query_594500, "pageToken", newJString(pageToken))
  add(query_594500, "quotaUser", newJString(quotaUser))
  add(query_594500, "sortField", newJString(sortField))
  add(query_594500, "alt", newJString(alt))
  add(query_594500, "onlyParent", newJBool(onlyParent))
  add(query_594500, "searchString", newJString(searchString))
  add(query_594500, "oauth_token", newJString(oauthToken))
  add(query_594500, "userIp", newJString(userIp))
  add(query_594500, "maxResults", newJInt(maxResults))
  if floodlightConfigurationIds != nil:
    query_594500.add "floodlightConfigurationIds", floodlightConfigurationIds
  if ids != nil:
    query_594500.add "ids", ids
  add(query_594500, "key", newJString(key))
  add(query_594500, "status", newJString(status))
  add(query_594500, "sortOrder", newJString(sortOrder))
  add(query_594500, "prettyPrint", newJBool(prettyPrint))
  add(query_594500, "includeAdvertisersWithoutGroupsOnly",
      newJBool(includeAdvertisersWithoutGroupsOnly))
  result = call_594498.call(path_594499, query_594500, nil, nil, nil)

var dfareportingAdvertisersList* = Call_DfareportingAdvertisersList_594474(
    name: "dfareportingAdvertisersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersList_594475,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersList_594476,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersPatch_594535 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdvertisersPatch_594537(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersPatch_594536(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing advertiser. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594538 = path.getOrDefault("profileId")
  valid_594538 = validateParameter(valid_594538, JString, required = true,
                                 default = nil)
  if valid_594538 != nil:
    section.add "profileId", valid_594538
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Advertiser ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594539 = query.getOrDefault("fields")
  valid_594539 = validateParameter(valid_594539, JString, required = false,
                                 default = nil)
  if valid_594539 != nil:
    section.add "fields", valid_594539
  var valid_594540 = query.getOrDefault("quotaUser")
  valid_594540 = validateParameter(valid_594540, JString, required = false,
                                 default = nil)
  if valid_594540 != nil:
    section.add "quotaUser", valid_594540
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_594541 = query.getOrDefault("id")
  valid_594541 = validateParameter(valid_594541, JString, required = true,
                                 default = nil)
  if valid_594541 != nil:
    section.add "id", valid_594541
  var valid_594542 = query.getOrDefault("alt")
  valid_594542 = validateParameter(valid_594542, JString, required = false,
                                 default = newJString("json"))
  if valid_594542 != nil:
    section.add "alt", valid_594542
  var valid_594543 = query.getOrDefault("oauth_token")
  valid_594543 = validateParameter(valid_594543, JString, required = false,
                                 default = nil)
  if valid_594543 != nil:
    section.add "oauth_token", valid_594543
  var valid_594544 = query.getOrDefault("userIp")
  valid_594544 = validateParameter(valid_594544, JString, required = false,
                                 default = nil)
  if valid_594544 != nil:
    section.add "userIp", valid_594544
  var valid_594545 = query.getOrDefault("key")
  valid_594545 = validateParameter(valid_594545, JString, required = false,
                                 default = nil)
  if valid_594545 != nil:
    section.add "key", valid_594545
  var valid_594546 = query.getOrDefault("prettyPrint")
  valid_594546 = validateParameter(valid_594546, JBool, required = false,
                                 default = newJBool(true))
  if valid_594546 != nil:
    section.add "prettyPrint", valid_594546
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594548: Call_DfareportingAdvertisersPatch_594535; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing advertiser. This method supports patch semantics.
  ## 
  let valid = call_594548.validator(path, query, header, formData, body)
  let scheme = call_594548.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594548.url(scheme.get, call_594548.host, call_594548.base,
                         call_594548.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594548, url, valid)

proc call*(call_594549: Call_DfareportingAdvertisersPatch_594535;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertisersPatch
  ## Updates an existing advertiser. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Advertiser ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594550 = newJObject()
  var query_594551 = newJObject()
  var body_594552 = newJObject()
  add(path_594550, "profileId", newJString(profileId))
  add(query_594551, "fields", newJString(fields))
  add(query_594551, "quotaUser", newJString(quotaUser))
  add(query_594551, "id", newJString(id))
  add(query_594551, "alt", newJString(alt))
  add(query_594551, "oauth_token", newJString(oauthToken))
  add(query_594551, "userIp", newJString(userIp))
  add(query_594551, "key", newJString(key))
  if body != nil:
    body_594552 = body
  add(query_594551, "prettyPrint", newJBool(prettyPrint))
  result = call_594549.call(path_594550, query_594551, nil, nil, body_594552)

var dfareportingAdvertisersPatch* = Call_DfareportingAdvertisersPatch_594535(
    name: "dfareportingAdvertisersPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/advertisers",
    validator: validate_DfareportingAdvertisersPatch_594536,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersPatch_594537,
    schemes: {Scheme.Https})
type
  Call_DfareportingAdvertisersGet_594553 = ref object of OpenApiRestCall_593437
proc url_DfareportingAdvertisersGet_594555(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/advertisers/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingAdvertisersGet_594554(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one advertiser by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Advertiser ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594556 = path.getOrDefault("profileId")
  valid_594556 = validateParameter(valid_594556, JString, required = true,
                                 default = nil)
  if valid_594556 != nil:
    section.add "profileId", valid_594556
  var valid_594557 = path.getOrDefault("id")
  valid_594557 = validateParameter(valid_594557, JString, required = true,
                                 default = nil)
  if valid_594557 != nil:
    section.add "id", valid_594557
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594558 = query.getOrDefault("fields")
  valid_594558 = validateParameter(valid_594558, JString, required = false,
                                 default = nil)
  if valid_594558 != nil:
    section.add "fields", valid_594558
  var valid_594559 = query.getOrDefault("quotaUser")
  valid_594559 = validateParameter(valid_594559, JString, required = false,
                                 default = nil)
  if valid_594559 != nil:
    section.add "quotaUser", valid_594559
  var valid_594560 = query.getOrDefault("alt")
  valid_594560 = validateParameter(valid_594560, JString, required = false,
                                 default = newJString("json"))
  if valid_594560 != nil:
    section.add "alt", valid_594560
  var valid_594561 = query.getOrDefault("oauth_token")
  valid_594561 = validateParameter(valid_594561, JString, required = false,
                                 default = nil)
  if valid_594561 != nil:
    section.add "oauth_token", valid_594561
  var valid_594562 = query.getOrDefault("userIp")
  valid_594562 = validateParameter(valid_594562, JString, required = false,
                                 default = nil)
  if valid_594562 != nil:
    section.add "userIp", valid_594562
  var valid_594563 = query.getOrDefault("key")
  valid_594563 = validateParameter(valid_594563, JString, required = false,
                                 default = nil)
  if valid_594563 != nil:
    section.add "key", valid_594563
  var valid_594564 = query.getOrDefault("prettyPrint")
  valid_594564 = validateParameter(valid_594564, JBool, required = false,
                                 default = newJBool(true))
  if valid_594564 != nil:
    section.add "prettyPrint", valid_594564
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594565: Call_DfareportingAdvertisersGet_594553; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one advertiser by ID.
  ## 
  let valid = call_594565.validator(path, query, header, formData, body)
  let scheme = call_594565.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594565.url(scheme.get, call_594565.host, call_594565.base,
                         call_594565.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594565, url, valid)

proc call*(call_594566: Call_DfareportingAdvertisersGet_594553; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingAdvertisersGet
  ## Gets one advertiser by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Advertiser ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594567 = newJObject()
  var query_594568 = newJObject()
  add(path_594567, "profileId", newJString(profileId))
  add(query_594568, "fields", newJString(fields))
  add(query_594568, "quotaUser", newJString(quotaUser))
  add(query_594568, "alt", newJString(alt))
  add(query_594568, "oauth_token", newJString(oauthToken))
  add(query_594568, "userIp", newJString(userIp))
  add(path_594567, "id", newJString(id))
  add(query_594568, "key", newJString(key))
  add(query_594568, "prettyPrint", newJBool(prettyPrint))
  result = call_594566.call(path_594567, query_594568, nil, nil, nil)

var dfareportingAdvertisersGet* = Call_DfareportingAdvertisersGet_594553(
    name: "dfareportingAdvertisersGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/advertisers/{id}",
    validator: validate_DfareportingAdvertisersGet_594554,
    base: "/dfareporting/v2.7", url: url_DfareportingAdvertisersGet_594555,
    schemes: {Scheme.Https})
type
  Call_DfareportingBrowsersList_594569 = ref object of OpenApiRestCall_593437
proc url_DfareportingBrowsersList_594571(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/browsers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingBrowsersList_594570(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of browsers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594572 = path.getOrDefault("profileId")
  valid_594572 = validateParameter(valid_594572, JString, required = true,
                                 default = nil)
  if valid_594572 != nil:
    section.add "profileId", valid_594572
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594573 = query.getOrDefault("fields")
  valid_594573 = validateParameter(valid_594573, JString, required = false,
                                 default = nil)
  if valid_594573 != nil:
    section.add "fields", valid_594573
  var valid_594574 = query.getOrDefault("quotaUser")
  valid_594574 = validateParameter(valid_594574, JString, required = false,
                                 default = nil)
  if valid_594574 != nil:
    section.add "quotaUser", valid_594574
  var valid_594575 = query.getOrDefault("alt")
  valid_594575 = validateParameter(valid_594575, JString, required = false,
                                 default = newJString("json"))
  if valid_594575 != nil:
    section.add "alt", valid_594575
  var valid_594576 = query.getOrDefault("oauth_token")
  valid_594576 = validateParameter(valid_594576, JString, required = false,
                                 default = nil)
  if valid_594576 != nil:
    section.add "oauth_token", valid_594576
  var valid_594577 = query.getOrDefault("userIp")
  valid_594577 = validateParameter(valid_594577, JString, required = false,
                                 default = nil)
  if valid_594577 != nil:
    section.add "userIp", valid_594577
  var valid_594578 = query.getOrDefault("key")
  valid_594578 = validateParameter(valid_594578, JString, required = false,
                                 default = nil)
  if valid_594578 != nil:
    section.add "key", valid_594578
  var valid_594579 = query.getOrDefault("prettyPrint")
  valid_594579 = validateParameter(valid_594579, JBool, required = false,
                                 default = newJBool(true))
  if valid_594579 != nil:
    section.add "prettyPrint", valid_594579
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594580: Call_DfareportingBrowsersList_594569; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of browsers.
  ## 
  let valid = call_594580.validator(path, query, header, formData, body)
  let scheme = call_594580.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594580.url(scheme.get, call_594580.host, call_594580.base,
                         call_594580.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594580, url, valid)

proc call*(call_594581: Call_DfareportingBrowsersList_594569; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingBrowsersList
  ## Retrieves a list of browsers.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594582 = newJObject()
  var query_594583 = newJObject()
  add(path_594582, "profileId", newJString(profileId))
  add(query_594583, "fields", newJString(fields))
  add(query_594583, "quotaUser", newJString(quotaUser))
  add(query_594583, "alt", newJString(alt))
  add(query_594583, "oauth_token", newJString(oauthToken))
  add(query_594583, "userIp", newJString(userIp))
  add(query_594583, "key", newJString(key))
  add(query_594583, "prettyPrint", newJBool(prettyPrint))
  result = call_594581.call(path_594582, query_594583, nil, nil, nil)

var dfareportingBrowsersList* = Call_DfareportingBrowsersList_594569(
    name: "dfareportingBrowsersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/browsers",
    validator: validate_DfareportingBrowsersList_594570,
    base: "/dfareporting/v2.7", url: url_DfareportingBrowsersList_594571,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsUpdate_594612 = ref object of OpenApiRestCall_593437
proc url_DfareportingCampaignsUpdate_594614(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsUpdate_594613(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594615 = path.getOrDefault("profileId")
  valid_594615 = validateParameter(valid_594615, JString, required = true,
                                 default = nil)
  if valid_594615 != nil:
    section.add "profileId", valid_594615
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594616 = query.getOrDefault("fields")
  valid_594616 = validateParameter(valid_594616, JString, required = false,
                                 default = nil)
  if valid_594616 != nil:
    section.add "fields", valid_594616
  var valid_594617 = query.getOrDefault("quotaUser")
  valid_594617 = validateParameter(valid_594617, JString, required = false,
                                 default = nil)
  if valid_594617 != nil:
    section.add "quotaUser", valid_594617
  var valid_594618 = query.getOrDefault("alt")
  valid_594618 = validateParameter(valid_594618, JString, required = false,
                                 default = newJString("json"))
  if valid_594618 != nil:
    section.add "alt", valid_594618
  var valid_594619 = query.getOrDefault("oauth_token")
  valid_594619 = validateParameter(valid_594619, JString, required = false,
                                 default = nil)
  if valid_594619 != nil:
    section.add "oauth_token", valid_594619
  var valid_594620 = query.getOrDefault("userIp")
  valid_594620 = validateParameter(valid_594620, JString, required = false,
                                 default = nil)
  if valid_594620 != nil:
    section.add "userIp", valid_594620
  var valid_594621 = query.getOrDefault("key")
  valid_594621 = validateParameter(valid_594621, JString, required = false,
                                 default = nil)
  if valid_594621 != nil:
    section.add "key", valid_594621
  var valid_594622 = query.getOrDefault("prettyPrint")
  valid_594622 = validateParameter(valid_594622, JBool, required = false,
                                 default = newJBool(true))
  if valid_594622 != nil:
    section.add "prettyPrint", valid_594622
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594624: Call_DfareportingCampaignsUpdate_594612; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign.
  ## 
  let valid = call_594624.validator(path, query, header, formData, body)
  let scheme = call_594624.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594624.url(scheme.get, call_594624.host, call_594624.base,
                         call_594624.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594624, url, valid)

proc call*(call_594625: Call_DfareportingCampaignsUpdate_594612; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsUpdate
  ## Updates an existing campaign.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594626 = newJObject()
  var query_594627 = newJObject()
  var body_594628 = newJObject()
  add(path_594626, "profileId", newJString(profileId))
  add(query_594627, "fields", newJString(fields))
  add(query_594627, "quotaUser", newJString(quotaUser))
  add(query_594627, "alt", newJString(alt))
  add(query_594627, "oauth_token", newJString(oauthToken))
  add(query_594627, "userIp", newJString(userIp))
  add(query_594627, "key", newJString(key))
  if body != nil:
    body_594628 = body
  add(query_594627, "prettyPrint", newJBool(prettyPrint))
  result = call_594625.call(path_594626, query_594627, nil, nil, body_594628)

var dfareportingCampaignsUpdate* = Call_DfareportingCampaignsUpdate_594612(
    name: "dfareportingCampaignsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsUpdate_594613,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsUpdate_594614,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsInsert_594629 = ref object of OpenApiRestCall_593437
proc url_DfareportingCampaignsInsert_594631(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsInsert_594630(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594632 = path.getOrDefault("profileId")
  valid_594632 = validateParameter(valid_594632, JString, required = true,
                                 default = nil)
  if valid_594632 != nil:
    section.add "profileId", valid_594632
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   defaultLandingPageName: JString (required)
  ##                         : Default landing page name for this new campaign. Must be less than 256 characters long.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   defaultLandingPageUrl: JString (required)
  ##                        : Default landing page URL for this new campaign.
  section = newJObject()
  var valid_594633 = query.getOrDefault("fields")
  valid_594633 = validateParameter(valid_594633, JString, required = false,
                                 default = nil)
  if valid_594633 != nil:
    section.add "fields", valid_594633
  var valid_594634 = query.getOrDefault("quotaUser")
  valid_594634 = validateParameter(valid_594634, JString, required = false,
                                 default = nil)
  if valid_594634 != nil:
    section.add "quotaUser", valid_594634
  var valid_594635 = query.getOrDefault("alt")
  valid_594635 = validateParameter(valid_594635, JString, required = false,
                                 default = newJString("json"))
  if valid_594635 != nil:
    section.add "alt", valid_594635
  var valid_594636 = query.getOrDefault("oauth_token")
  valid_594636 = validateParameter(valid_594636, JString, required = false,
                                 default = nil)
  if valid_594636 != nil:
    section.add "oauth_token", valid_594636
  var valid_594637 = query.getOrDefault("userIp")
  valid_594637 = validateParameter(valid_594637, JString, required = false,
                                 default = nil)
  if valid_594637 != nil:
    section.add "userIp", valid_594637
  assert query != nil, "query argument is necessary due to required `defaultLandingPageName` field"
  var valid_594638 = query.getOrDefault("defaultLandingPageName")
  valid_594638 = validateParameter(valid_594638, JString, required = true,
                                 default = nil)
  if valid_594638 != nil:
    section.add "defaultLandingPageName", valid_594638
  var valid_594639 = query.getOrDefault("key")
  valid_594639 = validateParameter(valid_594639, JString, required = false,
                                 default = nil)
  if valid_594639 != nil:
    section.add "key", valid_594639
  var valid_594640 = query.getOrDefault("prettyPrint")
  valid_594640 = validateParameter(valid_594640, JBool, required = false,
                                 default = newJBool(true))
  if valid_594640 != nil:
    section.add "prettyPrint", valid_594640
  var valid_594641 = query.getOrDefault("defaultLandingPageUrl")
  valid_594641 = validateParameter(valid_594641, JString, required = true,
                                 default = nil)
  if valid_594641 != nil:
    section.add "defaultLandingPageUrl", valid_594641
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594643: Call_DfareportingCampaignsInsert_594629; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new campaign.
  ## 
  let valid = call_594643.validator(path, query, header, formData, body)
  let scheme = call_594643.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594643.url(scheme.get, call_594643.host, call_594643.base,
                         call_594643.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594643, url, valid)

proc call*(call_594644: Call_DfareportingCampaignsInsert_594629; profileId: string;
          defaultLandingPageName: string; defaultLandingPageUrl: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsInsert
  ## Inserts a new campaign.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   defaultLandingPageName: string (required)
  ##                         : Default landing page name for this new campaign. Must be less than 256 characters long.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   defaultLandingPageUrl: string (required)
  ##                        : Default landing page URL for this new campaign.
  var path_594645 = newJObject()
  var query_594646 = newJObject()
  var body_594647 = newJObject()
  add(path_594645, "profileId", newJString(profileId))
  add(query_594646, "fields", newJString(fields))
  add(query_594646, "quotaUser", newJString(quotaUser))
  add(query_594646, "alt", newJString(alt))
  add(query_594646, "oauth_token", newJString(oauthToken))
  add(query_594646, "userIp", newJString(userIp))
  add(query_594646, "defaultLandingPageName", newJString(defaultLandingPageName))
  add(query_594646, "key", newJString(key))
  if body != nil:
    body_594647 = body
  add(query_594646, "prettyPrint", newJBool(prettyPrint))
  add(query_594646, "defaultLandingPageUrl", newJString(defaultLandingPageUrl))
  result = call_594644.call(path_594645, query_594646, nil, nil, body_594647)

var dfareportingCampaignsInsert* = Call_DfareportingCampaignsInsert_594629(
    name: "dfareportingCampaignsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsInsert_594630,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsInsert_594631,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsList_594584 = ref object of OpenApiRestCall_593437
proc url_DfareportingCampaignsList_594586(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsList_594585(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of campaigns, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594587 = path.getOrDefault("profileId")
  valid_594587 = validateParameter(valid_594587, JString, required = true,
                                 default = nil)
  if valid_594587 != nil:
    section.add "profileId", valid_594587
  result.add "path", section
  ## parameters in `query` object:
  ##   overriddenEventTagId: JString
  ##                       : Select only campaigns that have overridden this event tag ID.
  ##   subaccountId: JString
  ##               : Select only campaigns that belong to this subaccount.
  ##   advertiserGroupIds: JArray
  ##                     : Select only campaigns whose advertisers belong to these advertiser groups.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   atLeastOneOptimizationActivity: JBool
  ##                                 : Select only campaigns that have at least one optimization activity.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for campaigns by name or ID. Wildcards (*) are allowed. For example, "campaign*2015" will return campaigns with names like "campaign June 2015", "campaign April 2015", or simply "campaign 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "campaign" will match campaigns with name "my campaign", "campaign 2015", or simply "campaign".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: JBool
  ##           : Select only archived campaigns. Don't set this field to select both archived and non-archived campaigns.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only campaigns with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only campaigns that belong to these advertisers.
  ##   excludedIds: JArray
  ##              : Exclude campaigns with these IDs.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594588 = query.getOrDefault("overriddenEventTagId")
  valid_594588 = validateParameter(valid_594588, JString, required = false,
                                 default = nil)
  if valid_594588 != nil:
    section.add "overriddenEventTagId", valid_594588
  var valid_594589 = query.getOrDefault("subaccountId")
  valid_594589 = validateParameter(valid_594589, JString, required = false,
                                 default = nil)
  if valid_594589 != nil:
    section.add "subaccountId", valid_594589
  var valid_594590 = query.getOrDefault("advertiserGroupIds")
  valid_594590 = validateParameter(valid_594590, JArray, required = false,
                                 default = nil)
  if valid_594590 != nil:
    section.add "advertiserGroupIds", valid_594590
  var valid_594591 = query.getOrDefault("fields")
  valid_594591 = validateParameter(valid_594591, JString, required = false,
                                 default = nil)
  if valid_594591 != nil:
    section.add "fields", valid_594591
  var valid_594592 = query.getOrDefault("atLeastOneOptimizationActivity")
  valid_594592 = validateParameter(valid_594592, JBool, required = false, default = nil)
  if valid_594592 != nil:
    section.add "atLeastOneOptimizationActivity", valid_594592
  var valid_594593 = query.getOrDefault("quotaUser")
  valid_594593 = validateParameter(valid_594593, JString, required = false,
                                 default = nil)
  if valid_594593 != nil:
    section.add "quotaUser", valid_594593
  var valid_594594 = query.getOrDefault("pageToken")
  valid_594594 = validateParameter(valid_594594, JString, required = false,
                                 default = nil)
  if valid_594594 != nil:
    section.add "pageToken", valid_594594
  var valid_594595 = query.getOrDefault("sortField")
  valid_594595 = validateParameter(valid_594595, JString, required = false,
                                 default = newJString("ID"))
  if valid_594595 != nil:
    section.add "sortField", valid_594595
  var valid_594596 = query.getOrDefault("alt")
  valid_594596 = validateParameter(valid_594596, JString, required = false,
                                 default = newJString("json"))
  if valid_594596 != nil:
    section.add "alt", valid_594596
  var valid_594597 = query.getOrDefault("searchString")
  valid_594597 = validateParameter(valid_594597, JString, required = false,
                                 default = nil)
  if valid_594597 != nil:
    section.add "searchString", valid_594597
  var valid_594598 = query.getOrDefault("oauth_token")
  valid_594598 = validateParameter(valid_594598, JString, required = false,
                                 default = nil)
  if valid_594598 != nil:
    section.add "oauth_token", valid_594598
  var valid_594599 = query.getOrDefault("userIp")
  valid_594599 = validateParameter(valid_594599, JString, required = false,
                                 default = nil)
  if valid_594599 != nil:
    section.add "userIp", valid_594599
  var valid_594600 = query.getOrDefault("archived")
  valid_594600 = validateParameter(valid_594600, JBool, required = false, default = nil)
  if valid_594600 != nil:
    section.add "archived", valid_594600
  var valid_594601 = query.getOrDefault("maxResults")
  valid_594601 = validateParameter(valid_594601, JInt, required = false,
                                 default = newJInt(1000))
  if valid_594601 != nil:
    section.add "maxResults", valid_594601
  var valid_594602 = query.getOrDefault("ids")
  valid_594602 = validateParameter(valid_594602, JArray, required = false,
                                 default = nil)
  if valid_594602 != nil:
    section.add "ids", valid_594602
  var valid_594603 = query.getOrDefault("key")
  valid_594603 = validateParameter(valid_594603, JString, required = false,
                                 default = nil)
  if valid_594603 != nil:
    section.add "key", valid_594603
  var valid_594604 = query.getOrDefault("advertiserIds")
  valid_594604 = validateParameter(valid_594604, JArray, required = false,
                                 default = nil)
  if valid_594604 != nil:
    section.add "advertiserIds", valid_594604
  var valid_594605 = query.getOrDefault("excludedIds")
  valid_594605 = validateParameter(valid_594605, JArray, required = false,
                                 default = nil)
  if valid_594605 != nil:
    section.add "excludedIds", valid_594605
  var valid_594606 = query.getOrDefault("sortOrder")
  valid_594606 = validateParameter(valid_594606, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_594606 != nil:
    section.add "sortOrder", valid_594606
  var valid_594607 = query.getOrDefault("prettyPrint")
  valid_594607 = validateParameter(valid_594607, JBool, required = false,
                                 default = newJBool(true))
  if valid_594607 != nil:
    section.add "prettyPrint", valid_594607
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594608: Call_DfareportingCampaignsList_594584; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of campaigns, possibly filtered. This method supports paging.
  ## 
  let valid = call_594608.validator(path, query, header, formData, body)
  let scheme = call_594608.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594608.url(scheme.get, call_594608.host, call_594608.base,
                         call_594608.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594608, url, valid)

proc call*(call_594609: Call_DfareportingCampaignsList_594584; profileId: string;
          overriddenEventTagId: string = ""; subaccountId: string = "";
          advertiserGroupIds: JsonNode = nil; fields: string = "";
          atLeastOneOptimizationActivity: bool = false; quotaUser: string = "";
          pageToken: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          archived: bool = false; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; advertiserIds: JsonNode = nil; excludedIds: JsonNode = nil;
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsList
  ## Retrieves a list of campaigns, possibly filtered. This method supports paging.
  ##   overriddenEventTagId: string
  ##                       : Select only campaigns that have overridden this event tag ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only campaigns that belong to this subaccount.
  ##   advertiserGroupIds: JArray
  ##                     : Select only campaigns whose advertisers belong to these advertiser groups.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   atLeastOneOptimizationActivity: bool
  ##                                 : Select only campaigns that have at least one optimization activity.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for campaigns by name or ID. Wildcards (*) are allowed. For example, "campaign*2015" will return campaigns with names like "campaign June 2015", "campaign April 2015", or simply "campaign 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "campaign" will match campaigns with name "my campaign", "campaign 2015", or simply "campaign".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: bool
  ##           : Select only archived campaigns. Don't set this field to select both archived and non-archived campaigns.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only campaigns with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only campaigns that belong to these advertisers.
  ##   excludedIds: JArray
  ##              : Exclude campaigns with these IDs.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594610 = newJObject()
  var query_594611 = newJObject()
  add(query_594611, "overriddenEventTagId", newJString(overriddenEventTagId))
  add(path_594610, "profileId", newJString(profileId))
  add(query_594611, "subaccountId", newJString(subaccountId))
  if advertiserGroupIds != nil:
    query_594611.add "advertiserGroupIds", advertiserGroupIds
  add(query_594611, "fields", newJString(fields))
  add(query_594611, "atLeastOneOptimizationActivity",
      newJBool(atLeastOneOptimizationActivity))
  add(query_594611, "quotaUser", newJString(quotaUser))
  add(query_594611, "pageToken", newJString(pageToken))
  add(query_594611, "sortField", newJString(sortField))
  add(query_594611, "alt", newJString(alt))
  add(query_594611, "searchString", newJString(searchString))
  add(query_594611, "oauth_token", newJString(oauthToken))
  add(query_594611, "userIp", newJString(userIp))
  add(query_594611, "archived", newJBool(archived))
  add(query_594611, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_594611.add "ids", ids
  add(query_594611, "key", newJString(key))
  if advertiserIds != nil:
    query_594611.add "advertiserIds", advertiserIds
  if excludedIds != nil:
    query_594611.add "excludedIds", excludedIds
  add(query_594611, "sortOrder", newJString(sortOrder))
  add(query_594611, "prettyPrint", newJBool(prettyPrint))
  result = call_594609.call(path_594610, query_594611, nil, nil, nil)

var dfareportingCampaignsList* = Call_DfareportingCampaignsList_594584(
    name: "dfareportingCampaignsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsList_594585,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsList_594586,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsPatch_594648 = ref object of OpenApiRestCall_593437
proc url_DfareportingCampaignsPatch_594650(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsPatch_594649(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594651 = path.getOrDefault("profileId")
  valid_594651 = validateParameter(valid_594651, JString, required = true,
                                 default = nil)
  if valid_594651 != nil:
    section.add "profileId", valid_594651
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Campaign ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594652 = query.getOrDefault("fields")
  valid_594652 = validateParameter(valid_594652, JString, required = false,
                                 default = nil)
  if valid_594652 != nil:
    section.add "fields", valid_594652
  var valid_594653 = query.getOrDefault("quotaUser")
  valid_594653 = validateParameter(valid_594653, JString, required = false,
                                 default = nil)
  if valid_594653 != nil:
    section.add "quotaUser", valid_594653
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_594654 = query.getOrDefault("id")
  valid_594654 = validateParameter(valid_594654, JString, required = true,
                                 default = nil)
  if valid_594654 != nil:
    section.add "id", valid_594654
  var valid_594655 = query.getOrDefault("alt")
  valid_594655 = validateParameter(valid_594655, JString, required = false,
                                 default = newJString("json"))
  if valid_594655 != nil:
    section.add "alt", valid_594655
  var valid_594656 = query.getOrDefault("oauth_token")
  valid_594656 = validateParameter(valid_594656, JString, required = false,
                                 default = nil)
  if valid_594656 != nil:
    section.add "oauth_token", valid_594656
  var valid_594657 = query.getOrDefault("userIp")
  valid_594657 = validateParameter(valid_594657, JString, required = false,
                                 default = nil)
  if valid_594657 != nil:
    section.add "userIp", valid_594657
  var valid_594658 = query.getOrDefault("key")
  valid_594658 = validateParameter(valid_594658, JString, required = false,
                                 default = nil)
  if valid_594658 != nil:
    section.add "key", valid_594658
  var valid_594659 = query.getOrDefault("prettyPrint")
  valid_594659 = validateParameter(valid_594659, JBool, required = false,
                                 default = newJBool(true))
  if valid_594659 != nil:
    section.add "prettyPrint", valid_594659
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594661: Call_DfareportingCampaignsPatch_594648; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign. This method supports patch semantics.
  ## 
  let valid = call_594661.validator(path, query, header, formData, body)
  let scheme = call_594661.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594661.url(scheme.get, call_594661.host, call_594661.base,
                         call_594661.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594661, url, valid)

proc call*(call_594662: Call_DfareportingCampaignsPatch_594648; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsPatch
  ## Updates an existing campaign. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Campaign ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594663 = newJObject()
  var query_594664 = newJObject()
  var body_594665 = newJObject()
  add(path_594663, "profileId", newJString(profileId))
  add(query_594664, "fields", newJString(fields))
  add(query_594664, "quotaUser", newJString(quotaUser))
  add(query_594664, "id", newJString(id))
  add(query_594664, "alt", newJString(alt))
  add(query_594664, "oauth_token", newJString(oauthToken))
  add(query_594664, "userIp", newJString(userIp))
  add(query_594664, "key", newJString(key))
  if body != nil:
    body_594665 = body
  add(query_594664, "prettyPrint", newJBool(prettyPrint))
  result = call_594662.call(path_594663, query_594664, nil, nil, body_594665)

var dfareportingCampaignsPatch* = Call_DfareportingCampaignsPatch_594648(
    name: "dfareportingCampaignsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns",
    validator: validate_DfareportingCampaignsPatch_594649,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsPatch_594650,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignCreativeAssociationsInsert_594685 = ref object of OpenApiRestCall_593437
proc url_DfareportingCampaignCreativeAssociationsInsert_594687(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/campaignCreativeAssociations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignCreativeAssociationsInsert_594686(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Associates a creative with the specified campaign. This method creates a default ad with dimensions matching the creative in the campaign if such a default ad does not exist already.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Campaign ID in this association.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594688 = path.getOrDefault("profileId")
  valid_594688 = validateParameter(valid_594688, JString, required = true,
                                 default = nil)
  if valid_594688 != nil:
    section.add "profileId", valid_594688
  var valid_594689 = path.getOrDefault("campaignId")
  valid_594689 = validateParameter(valid_594689, JString, required = true,
                                 default = nil)
  if valid_594689 != nil:
    section.add "campaignId", valid_594689
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594690 = query.getOrDefault("fields")
  valid_594690 = validateParameter(valid_594690, JString, required = false,
                                 default = nil)
  if valid_594690 != nil:
    section.add "fields", valid_594690
  var valid_594691 = query.getOrDefault("quotaUser")
  valid_594691 = validateParameter(valid_594691, JString, required = false,
                                 default = nil)
  if valid_594691 != nil:
    section.add "quotaUser", valid_594691
  var valid_594692 = query.getOrDefault("alt")
  valid_594692 = validateParameter(valid_594692, JString, required = false,
                                 default = newJString("json"))
  if valid_594692 != nil:
    section.add "alt", valid_594692
  var valid_594693 = query.getOrDefault("oauth_token")
  valid_594693 = validateParameter(valid_594693, JString, required = false,
                                 default = nil)
  if valid_594693 != nil:
    section.add "oauth_token", valid_594693
  var valid_594694 = query.getOrDefault("userIp")
  valid_594694 = validateParameter(valid_594694, JString, required = false,
                                 default = nil)
  if valid_594694 != nil:
    section.add "userIp", valid_594694
  var valid_594695 = query.getOrDefault("key")
  valid_594695 = validateParameter(valid_594695, JString, required = false,
                                 default = nil)
  if valid_594695 != nil:
    section.add "key", valid_594695
  var valid_594696 = query.getOrDefault("prettyPrint")
  valid_594696 = validateParameter(valid_594696, JBool, required = false,
                                 default = newJBool(true))
  if valid_594696 != nil:
    section.add "prettyPrint", valid_594696
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594698: Call_DfareportingCampaignCreativeAssociationsInsert_594685;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Associates a creative with the specified campaign. This method creates a default ad with dimensions matching the creative in the campaign if such a default ad does not exist already.
  ## 
  let valid = call_594698.validator(path, query, header, formData, body)
  let scheme = call_594698.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594698.url(scheme.get, call_594698.host, call_594698.base,
                         call_594698.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594698, url, valid)

proc call*(call_594699: Call_DfareportingCampaignCreativeAssociationsInsert_594685;
          profileId: string; campaignId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignCreativeAssociationsInsert
  ## Associates a creative with the specified campaign. This method creates a default ad with dimensions matching the creative in the campaign if such a default ad does not exist already.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Campaign ID in this association.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594700 = newJObject()
  var query_594701 = newJObject()
  var body_594702 = newJObject()
  add(path_594700, "profileId", newJString(profileId))
  add(path_594700, "campaignId", newJString(campaignId))
  add(query_594701, "fields", newJString(fields))
  add(query_594701, "quotaUser", newJString(quotaUser))
  add(query_594701, "alt", newJString(alt))
  add(query_594701, "oauth_token", newJString(oauthToken))
  add(query_594701, "userIp", newJString(userIp))
  add(query_594701, "key", newJString(key))
  if body != nil:
    body_594702 = body
  add(query_594701, "prettyPrint", newJBool(prettyPrint))
  result = call_594699.call(path_594700, query_594701, nil, nil, body_594702)

var dfareportingCampaignCreativeAssociationsInsert* = Call_DfareportingCampaignCreativeAssociationsInsert_594685(
    name: "dfareportingCampaignCreativeAssociationsInsert",
    meth: HttpMethod.HttpPost, host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/campaignCreativeAssociations",
    validator: validate_DfareportingCampaignCreativeAssociationsInsert_594686,
    base: "/dfareporting/v2.7",
    url: url_DfareportingCampaignCreativeAssociationsInsert_594687,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignCreativeAssociationsList_594666 = ref object of OpenApiRestCall_593437
proc url_DfareportingCampaignCreativeAssociationsList_594668(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/campaignCreativeAssociations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignCreativeAssociationsList_594667(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of creative IDs associated with the specified campaign. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Campaign ID in this association.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594669 = path.getOrDefault("profileId")
  valid_594669 = validateParameter(valid_594669, JString, required = true,
                                 default = nil)
  if valid_594669 != nil:
    section.add "profileId", valid_594669
  var valid_594670 = path.getOrDefault("campaignId")
  valid_594670 = validateParameter(valid_594670, JString, required = true,
                                 default = nil)
  if valid_594670 != nil:
    section.add "campaignId", valid_594670
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594671 = query.getOrDefault("fields")
  valid_594671 = validateParameter(valid_594671, JString, required = false,
                                 default = nil)
  if valid_594671 != nil:
    section.add "fields", valid_594671
  var valid_594672 = query.getOrDefault("pageToken")
  valid_594672 = validateParameter(valid_594672, JString, required = false,
                                 default = nil)
  if valid_594672 != nil:
    section.add "pageToken", valid_594672
  var valid_594673 = query.getOrDefault("quotaUser")
  valid_594673 = validateParameter(valid_594673, JString, required = false,
                                 default = nil)
  if valid_594673 != nil:
    section.add "quotaUser", valid_594673
  var valid_594674 = query.getOrDefault("alt")
  valid_594674 = validateParameter(valid_594674, JString, required = false,
                                 default = newJString("json"))
  if valid_594674 != nil:
    section.add "alt", valid_594674
  var valid_594675 = query.getOrDefault("oauth_token")
  valid_594675 = validateParameter(valid_594675, JString, required = false,
                                 default = nil)
  if valid_594675 != nil:
    section.add "oauth_token", valid_594675
  var valid_594676 = query.getOrDefault("userIp")
  valid_594676 = validateParameter(valid_594676, JString, required = false,
                                 default = nil)
  if valid_594676 != nil:
    section.add "userIp", valid_594676
  var valid_594677 = query.getOrDefault("maxResults")
  valid_594677 = validateParameter(valid_594677, JInt, required = false,
                                 default = newJInt(1000))
  if valid_594677 != nil:
    section.add "maxResults", valid_594677
  var valid_594678 = query.getOrDefault("key")
  valid_594678 = validateParameter(valid_594678, JString, required = false,
                                 default = nil)
  if valid_594678 != nil:
    section.add "key", valid_594678
  var valid_594679 = query.getOrDefault("sortOrder")
  valid_594679 = validateParameter(valid_594679, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_594679 != nil:
    section.add "sortOrder", valid_594679
  var valid_594680 = query.getOrDefault("prettyPrint")
  valid_594680 = validateParameter(valid_594680, JBool, required = false,
                                 default = newJBool(true))
  if valid_594680 != nil:
    section.add "prettyPrint", valid_594680
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594681: Call_DfareportingCampaignCreativeAssociationsList_594666;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves the list of creative IDs associated with the specified campaign. This method supports paging.
  ## 
  let valid = call_594681.validator(path, query, header, formData, body)
  let scheme = call_594681.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594681.url(scheme.get, call_594681.host, call_594681.base,
                         call_594681.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594681, url, valid)

proc call*(call_594682: Call_DfareportingCampaignCreativeAssociationsList_594666;
          profileId: string; campaignId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 1000;
          key: string = ""; sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignCreativeAssociationsList
  ## Retrieves the list of creative IDs associated with the specified campaign. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Campaign ID in this association.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594683 = newJObject()
  var query_594684 = newJObject()
  add(path_594683, "profileId", newJString(profileId))
  add(path_594683, "campaignId", newJString(campaignId))
  add(query_594684, "fields", newJString(fields))
  add(query_594684, "pageToken", newJString(pageToken))
  add(query_594684, "quotaUser", newJString(quotaUser))
  add(query_594684, "alt", newJString(alt))
  add(query_594684, "oauth_token", newJString(oauthToken))
  add(query_594684, "userIp", newJString(userIp))
  add(query_594684, "maxResults", newJInt(maxResults))
  add(query_594684, "key", newJString(key))
  add(query_594684, "sortOrder", newJString(sortOrder))
  add(query_594684, "prettyPrint", newJBool(prettyPrint))
  result = call_594682.call(path_594683, query_594684, nil, nil, nil)

var dfareportingCampaignCreativeAssociationsList* = Call_DfareportingCampaignCreativeAssociationsList_594666(
    name: "dfareportingCampaignCreativeAssociationsList",
    meth: HttpMethod.HttpGet, host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/campaignCreativeAssociations",
    validator: validate_DfareportingCampaignCreativeAssociationsList_594667,
    base: "/dfareporting/v2.7",
    url: url_DfareportingCampaignCreativeAssociationsList_594668,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesUpdate_594719 = ref object of OpenApiRestCall_593437
proc url_DfareportingLandingPagesUpdate_594721(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesUpdate_594720(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign landing page.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594722 = path.getOrDefault("profileId")
  valid_594722 = validateParameter(valid_594722, JString, required = true,
                                 default = nil)
  if valid_594722 != nil:
    section.add "profileId", valid_594722
  var valid_594723 = path.getOrDefault("campaignId")
  valid_594723 = validateParameter(valid_594723, JString, required = true,
                                 default = nil)
  if valid_594723 != nil:
    section.add "campaignId", valid_594723
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594724 = query.getOrDefault("fields")
  valid_594724 = validateParameter(valid_594724, JString, required = false,
                                 default = nil)
  if valid_594724 != nil:
    section.add "fields", valid_594724
  var valid_594725 = query.getOrDefault("quotaUser")
  valid_594725 = validateParameter(valid_594725, JString, required = false,
                                 default = nil)
  if valid_594725 != nil:
    section.add "quotaUser", valid_594725
  var valid_594726 = query.getOrDefault("alt")
  valid_594726 = validateParameter(valid_594726, JString, required = false,
                                 default = newJString("json"))
  if valid_594726 != nil:
    section.add "alt", valid_594726
  var valid_594727 = query.getOrDefault("oauth_token")
  valid_594727 = validateParameter(valid_594727, JString, required = false,
                                 default = nil)
  if valid_594727 != nil:
    section.add "oauth_token", valid_594727
  var valid_594728 = query.getOrDefault("userIp")
  valid_594728 = validateParameter(valid_594728, JString, required = false,
                                 default = nil)
  if valid_594728 != nil:
    section.add "userIp", valid_594728
  var valid_594729 = query.getOrDefault("key")
  valid_594729 = validateParameter(valid_594729, JString, required = false,
                                 default = nil)
  if valid_594729 != nil:
    section.add "key", valid_594729
  var valid_594730 = query.getOrDefault("prettyPrint")
  valid_594730 = validateParameter(valid_594730, JBool, required = false,
                                 default = newJBool(true))
  if valid_594730 != nil:
    section.add "prettyPrint", valid_594730
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594732: Call_DfareportingLandingPagesUpdate_594719; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign landing page.
  ## 
  let valid = call_594732.validator(path, query, header, formData, body)
  let scheme = call_594732.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594732.url(scheme.get, call_594732.host, call_594732.base,
                         call_594732.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594732, url, valid)

proc call*(call_594733: Call_DfareportingLandingPagesUpdate_594719;
          profileId: string; campaignId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesUpdate
  ## Updates an existing campaign landing page.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594734 = newJObject()
  var query_594735 = newJObject()
  var body_594736 = newJObject()
  add(path_594734, "profileId", newJString(profileId))
  add(path_594734, "campaignId", newJString(campaignId))
  add(query_594735, "fields", newJString(fields))
  add(query_594735, "quotaUser", newJString(quotaUser))
  add(query_594735, "alt", newJString(alt))
  add(query_594735, "oauth_token", newJString(oauthToken))
  add(query_594735, "userIp", newJString(userIp))
  add(query_594735, "key", newJString(key))
  if body != nil:
    body_594736 = body
  add(query_594735, "prettyPrint", newJBool(prettyPrint))
  result = call_594733.call(path_594734, query_594735, nil, nil, body_594736)

var dfareportingLandingPagesUpdate* = Call_DfareportingLandingPagesUpdate_594719(
    name: "dfareportingLandingPagesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesUpdate_594720,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesUpdate_594721,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesInsert_594737 = ref object of OpenApiRestCall_593437
proc url_DfareportingLandingPagesInsert_594739(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesInsert_594738(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new landing page for the specified campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594740 = path.getOrDefault("profileId")
  valid_594740 = validateParameter(valid_594740, JString, required = true,
                                 default = nil)
  if valid_594740 != nil:
    section.add "profileId", valid_594740
  var valid_594741 = path.getOrDefault("campaignId")
  valid_594741 = validateParameter(valid_594741, JString, required = true,
                                 default = nil)
  if valid_594741 != nil:
    section.add "campaignId", valid_594741
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594742 = query.getOrDefault("fields")
  valid_594742 = validateParameter(valid_594742, JString, required = false,
                                 default = nil)
  if valid_594742 != nil:
    section.add "fields", valid_594742
  var valid_594743 = query.getOrDefault("quotaUser")
  valid_594743 = validateParameter(valid_594743, JString, required = false,
                                 default = nil)
  if valid_594743 != nil:
    section.add "quotaUser", valid_594743
  var valid_594744 = query.getOrDefault("alt")
  valid_594744 = validateParameter(valid_594744, JString, required = false,
                                 default = newJString("json"))
  if valid_594744 != nil:
    section.add "alt", valid_594744
  var valid_594745 = query.getOrDefault("oauth_token")
  valid_594745 = validateParameter(valid_594745, JString, required = false,
                                 default = nil)
  if valid_594745 != nil:
    section.add "oauth_token", valid_594745
  var valid_594746 = query.getOrDefault("userIp")
  valid_594746 = validateParameter(valid_594746, JString, required = false,
                                 default = nil)
  if valid_594746 != nil:
    section.add "userIp", valid_594746
  var valid_594747 = query.getOrDefault("key")
  valid_594747 = validateParameter(valid_594747, JString, required = false,
                                 default = nil)
  if valid_594747 != nil:
    section.add "key", valid_594747
  var valid_594748 = query.getOrDefault("prettyPrint")
  valid_594748 = validateParameter(valid_594748, JBool, required = false,
                                 default = newJBool(true))
  if valid_594748 != nil:
    section.add "prettyPrint", valid_594748
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594750: Call_DfareportingLandingPagesInsert_594737; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new landing page for the specified campaign.
  ## 
  let valid = call_594750.validator(path, query, header, formData, body)
  let scheme = call_594750.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594750.url(scheme.get, call_594750.host, call_594750.base,
                         call_594750.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594750, url, valid)

proc call*(call_594751: Call_DfareportingLandingPagesInsert_594737;
          profileId: string; campaignId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesInsert
  ## Inserts a new landing page for the specified campaign.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594752 = newJObject()
  var query_594753 = newJObject()
  var body_594754 = newJObject()
  add(path_594752, "profileId", newJString(profileId))
  add(path_594752, "campaignId", newJString(campaignId))
  add(query_594753, "fields", newJString(fields))
  add(query_594753, "quotaUser", newJString(quotaUser))
  add(query_594753, "alt", newJString(alt))
  add(query_594753, "oauth_token", newJString(oauthToken))
  add(query_594753, "userIp", newJString(userIp))
  add(query_594753, "key", newJString(key))
  if body != nil:
    body_594754 = body
  add(query_594753, "prettyPrint", newJBool(prettyPrint))
  result = call_594751.call(path_594752, query_594753, nil, nil, body_594754)

var dfareportingLandingPagesInsert* = Call_DfareportingLandingPagesInsert_594737(
    name: "dfareportingLandingPagesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesInsert_594738,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesInsert_594739,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesList_594703 = ref object of OpenApiRestCall_593437
proc url_DfareportingLandingPagesList_594705(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesList_594704(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves the list of landing pages for the specified campaign.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594706 = path.getOrDefault("profileId")
  valid_594706 = validateParameter(valid_594706, JString, required = true,
                                 default = nil)
  if valid_594706 != nil:
    section.add "profileId", valid_594706
  var valid_594707 = path.getOrDefault("campaignId")
  valid_594707 = validateParameter(valid_594707, JString, required = true,
                                 default = nil)
  if valid_594707 != nil:
    section.add "campaignId", valid_594707
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594708 = query.getOrDefault("fields")
  valid_594708 = validateParameter(valid_594708, JString, required = false,
                                 default = nil)
  if valid_594708 != nil:
    section.add "fields", valid_594708
  var valid_594709 = query.getOrDefault("quotaUser")
  valid_594709 = validateParameter(valid_594709, JString, required = false,
                                 default = nil)
  if valid_594709 != nil:
    section.add "quotaUser", valid_594709
  var valid_594710 = query.getOrDefault("alt")
  valid_594710 = validateParameter(valid_594710, JString, required = false,
                                 default = newJString("json"))
  if valid_594710 != nil:
    section.add "alt", valid_594710
  var valid_594711 = query.getOrDefault("oauth_token")
  valid_594711 = validateParameter(valid_594711, JString, required = false,
                                 default = nil)
  if valid_594711 != nil:
    section.add "oauth_token", valid_594711
  var valid_594712 = query.getOrDefault("userIp")
  valid_594712 = validateParameter(valid_594712, JString, required = false,
                                 default = nil)
  if valid_594712 != nil:
    section.add "userIp", valid_594712
  var valid_594713 = query.getOrDefault("key")
  valid_594713 = validateParameter(valid_594713, JString, required = false,
                                 default = nil)
  if valid_594713 != nil:
    section.add "key", valid_594713
  var valid_594714 = query.getOrDefault("prettyPrint")
  valid_594714 = validateParameter(valid_594714, JBool, required = false,
                                 default = newJBool(true))
  if valid_594714 != nil:
    section.add "prettyPrint", valid_594714
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594715: Call_DfareportingLandingPagesList_594703; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves the list of landing pages for the specified campaign.
  ## 
  let valid = call_594715.validator(path, query, header, formData, body)
  let scheme = call_594715.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594715.url(scheme.get, call_594715.host, call_594715.base,
                         call_594715.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594715, url, valid)

proc call*(call_594716: Call_DfareportingLandingPagesList_594703;
          profileId: string; campaignId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesList
  ## Retrieves the list of landing pages for the specified campaign.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594717 = newJObject()
  var query_594718 = newJObject()
  add(path_594717, "profileId", newJString(profileId))
  add(path_594717, "campaignId", newJString(campaignId))
  add(query_594718, "fields", newJString(fields))
  add(query_594718, "quotaUser", newJString(quotaUser))
  add(query_594718, "alt", newJString(alt))
  add(query_594718, "oauth_token", newJString(oauthToken))
  add(query_594718, "userIp", newJString(userIp))
  add(query_594718, "key", newJString(key))
  add(query_594718, "prettyPrint", newJBool(prettyPrint))
  result = call_594716.call(path_594717, query_594718, nil, nil, nil)

var dfareportingLandingPagesList* = Call_DfareportingLandingPagesList_594703(
    name: "dfareportingLandingPagesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesList_594704,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesList_594705,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesPatch_594755 = ref object of OpenApiRestCall_593437
proc url_DfareportingLandingPagesPatch_594757(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesPatch_594756(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing campaign landing page. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594758 = path.getOrDefault("profileId")
  valid_594758 = validateParameter(valid_594758, JString, required = true,
                                 default = nil)
  if valid_594758 != nil:
    section.add "profileId", valid_594758
  var valid_594759 = path.getOrDefault("campaignId")
  valid_594759 = validateParameter(valid_594759, JString, required = true,
                                 default = nil)
  if valid_594759 != nil:
    section.add "campaignId", valid_594759
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Landing page ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594760 = query.getOrDefault("fields")
  valid_594760 = validateParameter(valid_594760, JString, required = false,
                                 default = nil)
  if valid_594760 != nil:
    section.add "fields", valid_594760
  var valid_594761 = query.getOrDefault("quotaUser")
  valid_594761 = validateParameter(valid_594761, JString, required = false,
                                 default = nil)
  if valid_594761 != nil:
    section.add "quotaUser", valid_594761
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_594762 = query.getOrDefault("id")
  valid_594762 = validateParameter(valid_594762, JString, required = true,
                                 default = nil)
  if valid_594762 != nil:
    section.add "id", valid_594762
  var valid_594763 = query.getOrDefault("alt")
  valid_594763 = validateParameter(valid_594763, JString, required = false,
                                 default = newJString("json"))
  if valid_594763 != nil:
    section.add "alt", valid_594763
  var valid_594764 = query.getOrDefault("oauth_token")
  valid_594764 = validateParameter(valid_594764, JString, required = false,
                                 default = nil)
  if valid_594764 != nil:
    section.add "oauth_token", valid_594764
  var valid_594765 = query.getOrDefault("userIp")
  valid_594765 = validateParameter(valid_594765, JString, required = false,
                                 default = nil)
  if valid_594765 != nil:
    section.add "userIp", valid_594765
  var valid_594766 = query.getOrDefault("key")
  valid_594766 = validateParameter(valid_594766, JString, required = false,
                                 default = nil)
  if valid_594766 != nil:
    section.add "key", valid_594766
  var valid_594767 = query.getOrDefault("prettyPrint")
  valid_594767 = validateParameter(valid_594767, JBool, required = false,
                                 default = newJBool(true))
  if valid_594767 != nil:
    section.add "prettyPrint", valid_594767
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594769: Call_DfareportingLandingPagesPatch_594755; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing campaign landing page. This method supports patch semantics.
  ## 
  let valid = call_594769.validator(path, query, header, formData, body)
  let scheme = call_594769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594769.url(scheme.get, call_594769.host, call_594769.base,
                         call_594769.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594769, url, valid)

proc call*(call_594770: Call_DfareportingLandingPagesPatch_594755;
          profileId: string; campaignId: string; id: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesPatch
  ## Updates an existing campaign landing page. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Landing page ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594771 = newJObject()
  var query_594772 = newJObject()
  var body_594773 = newJObject()
  add(path_594771, "profileId", newJString(profileId))
  add(path_594771, "campaignId", newJString(campaignId))
  add(query_594772, "fields", newJString(fields))
  add(query_594772, "quotaUser", newJString(quotaUser))
  add(query_594772, "id", newJString(id))
  add(query_594772, "alt", newJString(alt))
  add(query_594772, "oauth_token", newJString(oauthToken))
  add(query_594772, "userIp", newJString(userIp))
  add(query_594772, "key", newJString(key))
  if body != nil:
    body_594773 = body
  add(query_594772, "prettyPrint", newJBool(prettyPrint))
  result = call_594770.call(path_594771, query_594772, nil, nil, body_594773)

var dfareportingLandingPagesPatch* = Call_DfareportingLandingPagesPatch_594755(
    name: "dfareportingLandingPagesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages",
    validator: validate_DfareportingLandingPagesPatch_594756,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesPatch_594757,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesGet_594774 = ref object of OpenApiRestCall_593437
proc url_DfareportingLandingPagesGet_594776(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesGet_594775(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one campaign landing page by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  ##   id: JString (required)
  ##     : Landing page ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594777 = path.getOrDefault("profileId")
  valid_594777 = validateParameter(valid_594777, JString, required = true,
                                 default = nil)
  if valid_594777 != nil:
    section.add "profileId", valid_594777
  var valid_594778 = path.getOrDefault("campaignId")
  valid_594778 = validateParameter(valid_594778, JString, required = true,
                                 default = nil)
  if valid_594778 != nil:
    section.add "campaignId", valid_594778
  var valid_594779 = path.getOrDefault("id")
  valid_594779 = validateParameter(valid_594779, JString, required = true,
                                 default = nil)
  if valid_594779 != nil:
    section.add "id", valid_594779
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594780 = query.getOrDefault("fields")
  valid_594780 = validateParameter(valid_594780, JString, required = false,
                                 default = nil)
  if valid_594780 != nil:
    section.add "fields", valid_594780
  var valid_594781 = query.getOrDefault("quotaUser")
  valid_594781 = validateParameter(valid_594781, JString, required = false,
                                 default = nil)
  if valid_594781 != nil:
    section.add "quotaUser", valid_594781
  var valid_594782 = query.getOrDefault("alt")
  valid_594782 = validateParameter(valid_594782, JString, required = false,
                                 default = newJString("json"))
  if valid_594782 != nil:
    section.add "alt", valid_594782
  var valid_594783 = query.getOrDefault("oauth_token")
  valid_594783 = validateParameter(valid_594783, JString, required = false,
                                 default = nil)
  if valid_594783 != nil:
    section.add "oauth_token", valid_594783
  var valid_594784 = query.getOrDefault("userIp")
  valid_594784 = validateParameter(valid_594784, JString, required = false,
                                 default = nil)
  if valid_594784 != nil:
    section.add "userIp", valid_594784
  var valid_594785 = query.getOrDefault("key")
  valid_594785 = validateParameter(valid_594785, JString, required = false,
                                 default = nil)
  if valid_594785 != nil:
    section.add "key", valid_594785
  var valid_594786 = query.getOrDefault("prettyPrint")
  valid_594786 = validateParameter(valid_594786, JBool, required = false,
                                 default = newJBool(true))
  if valid_594786 != nil:
    section.add "prettyPrint", valid_594786
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594787: Call_DfareportingLandingPagesGet_594774; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one campaign landing page by ID.
  ## 
  let valid = call_594787.validator(path, query, header, formData, body)
  let scheme = call_594787.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594787.url(scheme.get, call_594787.host, call_594787.base,
                         call_594787.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594787, url, valid)

proc call*(call_594788: Call_DfareportingLandingPagesGet_594774; profileId: string;
          campaignId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesGet
  ## Gets one campaign landing page by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Landing page ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594789 = newJObject()
  var query_594790 = newJObject()
  add(path_594789, "profileId", newJString(profileId))
  add(path_594789, "campaignId", newJString(campaignId))
  add(query_594790, "fields", newJString(fields))
  add(query_594790, "quotaUser", newJString(quotaUser))
  add(query_594790, "alt", newJString(alt))
  add(query_594790, "oauth_token", newJString(oauthToken))
  add(query_594790, "userIp", newJString(userIp))
  add(path_594789, "id", newJString(id))
  add(query_594790, "key", newJString(key))
  add(query_594790, "prettyPrint", newJBool(prettyPrint))
  result = call_594788.call(path_594789, query_594790, nil, nil, nil)

var dfareportingLandingPagesGet* = Call_DfareportingLandingPagesGet_594774(
    name: "dfareportingLandingPagesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages/{id}",
    validator: validate_DfareportingLandingPagesGet_594775,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesGet_594776,
    schemes: {Scheme.Https})
type
  Call_DfareportingLandingPagesDelete_594791 = ref object of OpenApiRestCall_593437
proc url_DfareportingLandingPagesDelete_594793(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "campaignId" in path, "`campaignId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "campaignId"),
               (kind: ConstantSegment, value: "/landingPages/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLandingPagesDelete_594792(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing campaign landing page.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: JString (required)
  ##             : Landing page campaign ID.
  ##   id: JString (required)
  ##     : Landing page ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594794 = path.getOrDefault("profileId")
  valid_594794 = validateParameter(valid_594794, JString, required = true,
                                 default = nil)
  if valid_594794 != nil:
    section.add "profileId", valid_594794
  var valid_594795 = path.getOrDefault("campaignId")
  valid_594795 = validateParameter(valid_594795, JString, required = true,
                                 default = nil)
  if valid_594795 != nil:
    section.add "campaignId", valid_594795
  var valid_594796 = path.getOrDefault("id")
  valid_594796 = validateParameter(valid_594796, JString, required = true,
                                 default = nil)
  if valid_594796 != nil:
    section.add "id", valid_594796
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594797 = query.getOrDefault("fields")
  valid_594797 = validateParameter(valid_594797, JString, required = false,
                                 default = nil)
  if valid_594797 != nil:
    section.add "fields", valid_594797
  var valid_594798 = query.getOrDefault("quotaUser")
  valid_594798 = validateParameter(valid_594798, JString, required = false,
                                 default = nil)
  if valid_594798 != nil:
    section.add "quotaUser", valid_594798
  var valid_594799 = query.getOrDefault("alt")
  valid_594799 = validateParameter(valid_594799, JString, required = false,
                                 default = newJString("json"))
  if valid_594799 != nil:
    section.add "alt", valid_594799
  var valid_594800 = query.getOrDefault("oauth_token")
  valid_594800 = validateParameter(valid_594800, JString, required = false,
                                 default = nil)
  if valid_594800 != nil:
    section.add "oauth_token", valid_594800
  var valid_594801 = query.getOrDefault("userIp")
  valid_594801 = validateParameter(valid_594801, JString, required = false,
                                 default = nil)
  if valid_594801 != nil:
    section.add "userIp", valid_594801
  var valid_594802 = query.getOrDefault("key")
  valid_594802 = validateParameter(valid_594802, JString, required = false,
                                 default = nil)
  if valid_594802 != nil:
    section.add "key", valid_594802
  var valid_594803 = query.getOrDefault("prettyPrint")
  valid_594803 = validateParameter(valid_594803, JBool, required = false,
                                 default = newJBool(true))
  if valid_594803 != nil:
    section.add "prettyPrint", valid_594803
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594804: Call_DfareportingLandingPagesDelete_594791; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing campaign landing page.
  ## 
  let valid = call_594804.validator(path, query, header, formData, body)
  let scheme = call_594804.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594804.url(scheme.get, call_594804.host, call_594804.base,
                         call_594804.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594804, url, valid)

proc call*(call_594805: Call_DfareportingLandingPagesDelete_594791;
          profileId: string; campaignId: string; id: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingLandingPagesDelete
  ## Deletes an existing campaign landing page.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   campaignId: string (required)
  ##             : Landing page campaign ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Landing page ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594806 = newJObject()
  var query_594807 = newJObject()
  add(path_594806, "profileId", newJString(profileId))
  add(path_594806, "campaignId", newJString(campaignId))
  add(query_594807, "fields", newJString(fields))
  add(query_594807, "quotaUser", newJString(quotaUser))
  add(query_594807, "alt", newJString(alt))
  add(query_594807, "oauth_token", newJString(oauthToken))
  add(query_594807, "userIp", newJString(userIp))
  add(path_594806, "id", newJString(id))
  add(query_594807, "key", newJString(key))
  add(query_594807, "prettyPrint", newJBool(prettyPrint))
  result = call_594805.call(path_594806, query_594807, nil, nil, nil)

var dfareportingLandingPagesDelete* = Call_DfareportingLandingPagesDelete_594791(
    name: "dfareportingLandingPagesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{campaignId}/landingPages/{id}",
    validator: validate_DfareportingLandingPagesDelete_594792,
    base: "/dfareporting/v2.7", url: url_DfareportingLandingPagesDelete_594793,
    schemes: {Scheme.Https})
type
  Call_DfareportingCampaignsGet_594808 = ref object of OpenApiRestCall_593437
proc url_DfareportingCampaignsGet_594810(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/campaigns/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCampaignsGet_594809(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one campaign by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Campaign ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594811 = path.getOrDefault("profileId")
  valid_594811 = validateParameter(valid_594811, JString, required = true,
                                 default = nil)
  if valid_594811 != nil:
    section.add "profileId", valid_594811
  var valid_594812 = path.getOrDefault("id")
  valid_594812 = validateParameter(valid_594812, JString, required = true,
                                 default = nil)
  if valid_594812 != nil:
    section.add "id", valid_594812
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594813 = query.getOrDefault("fields")
  valid_594813 = validateParameter(valid_594813, JString, required = false,
                                 default = nil)
  if valid_594813 != nil:
    section.add "fields", valid_594813
  var valid_594814 = query.getOrDefault("quotaUser")
  valid_594814 = validateParameter(valid_594814, JString, required = false,
                                 default = nil)
  if valid_594814 != nil:
    section.add "quotaUser", valid_594814
  var valid_594815 = query.getOrDefault("alt")
  valid_594815 = validateParameter(valid_594815, JString, required = false,
                                 default = newJString("json"))
  if valid_594815 != nil:
    section.add "alt", valid_594815
  var valid_594816 = query.getOrDefault("oauth_token")
  valid_594816 = validateParameter(valid_594816, JString, required = false,
                                 default = nil)
  if valid_594816 != nil:
    section.add "oauth_token", valid_594816
  var valid_594817 = query.getOrDefault("userIp")
  valid_594817 = validateParameter(valid_594817, JString, required = false,
                                 default = nil)
  if valid_594817 != nil:
    section.add "userIp", valid_594817
  var valid_594818 = query.getOrDefault("key")
  valid_594818 = validateParameter(valid_594818, JString, required = false,
                                 default = nil)
  if valid_594818 != nil:
    section.add "key", valid_594818
  var valid_594819 = query.getOrDefault("prettyPrint")
  valid_594819 = validateParameter(valid_594819, JBool, required = false,
                                 default = newJBool(true))
  if valid_594819 != nil:
    section.add "prettyPrint", valid_594819
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594820: Call_DfareportingCampaignsGet_594808; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one campaign by ID.
  ## 
  let valid = call_594820.validator(path, query, header, formData, body)
  let scheme = call_594820.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594820.url(scheme.get, call_594820.host, call_594820.base,
                         call_594820.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594820, url, valid)

proc call*(call_594821: Call_DfareportingCampaignsGet_594808; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingCampaignsGet
  ## Gets one campaign by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Campaign ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594822 = newJObject()
  var query_594823 = newJObject()
  add(path_594822, "profileId", newJString(profileId))
  add(query_594823, "fields", newJString(fields))
  add(query_594823, "quotaUser", newJString(quotaUser))
  add(query_594823, "alt", newJString(alt))
  add(query_594823, "oauth_token", newJString(oauthToken))
  add(query_594823, "userIp", newJString(userIp))
  add(path_594822, "id", newJString(id))
  add(query_594823, "key", newJString(key))
  add(query_594823, "prettyPrint", newJBool(prettyPrint))
  result = call_594821.call(path_594822, query_594823, nil, nil, nil)

var dfareportingCampaignsGet* = Call_DfareportingCampaignsGet_594808(
    name: "dfareportingCampaignsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/campaigns/{id}",
    validator: validate_DfareportingCampaignsGet_594809,
    base: "/dfareporting/v2.7", url: url_DfareportingCampaignsGet_594810,
    schemes: {Scheme.Https})
type
  Call_DfareportingChangeLogsList_594824 = ref object of OpenApiRestCall_593437
proc url_DfareportingChangeLogsList_594826(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/changeLogs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingChangeLogsList_594825(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of change logs. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594827 = path.getOrDefault("profileId")
  valid_594827 = validateParameter(valid_594827, JString, required = true,
                                 default = nil)
  if valid_594827 != nil:
    section.add "profileId", valid_594827
  result.add "path", section
  ## parameters in `query` object:
  ##   action: JString
  ##         : Select only change logs with the specified action.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   minChangeTime: JString
  ##                : Select only change logs whose change time is before the specified minChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Select only change logs whose object ID, user name, old or new values match the search string.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   maxChangeTime: JString
  ##                : Select only change logs whose change time is before the specified maxChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   ids: JArray
  ##      : Select only change logs with these IDs.
  ##   objectType: JString
  ##             : Select only change logs with the specified object type.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   objectIds: JArray
  ##            : Select only change logs with these object IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   userProfileIds: JArray
  ##                 : Select only change logs with these user profile IDs.
  section = newJObject()
  var valid_594828 = query.getOrDefault("action")
  valid_594828 = validateParameter(valid_594828, JString, required = false,
                                 default = newJString("ACTION_ADD"))
  if valid_594828 != nil:
    section.add "action", valid_594828
  var valid_594829 = query.getOrDefault("fields")
  valid_594829 = validateParameter(valid_594829, JString, required = false,
                                 default = nil)
  if valid_594829 != nil:
    section.add "fields", valid_594829
  var valid_594830 = query.getOrDefault("pageToken")
  valid_594830 = validateParameter(valid_594830, JString, required = false,
                                 default = nil)
  if valid_594830 != nil:
    section.add "pageToken", valid_594830
  var valid_594831 = query.getOrDefault("quotaUser")
  valid_594831 = validateParameter(valid_594831, JString, required = false,
                                 default = nil)
  if valid_594831 != nil:
    section.add "quotaUser", valid_594831
  var valid_594832 = query.getOrDefault("minChangeTime")
  valid_594832 = validateParameter(valid_594832, JString, required = false,
                                 default = nil)
  if valid_594832 != nil:
    section.add "minChangeTime", valid_594832
  var valid_594833 = query.getOrDefault("alt")
  valid_594833 = validateParameter(valid_594833, JString, required = false,
                                 default = newJString("json"))
  if valid_594833 != nil:
    section.add "alt", valid_594833
  var valid_594834 = query.getOrDefault("searchString")
  valid_594834 = validateParameter(valid_594834, JString, required = false,
                                 default = nil)
  if valid_594834 != nil:
    section.add "searchString", valid_594834
  var valid_594835 = query.getOrDefault("oauth_token")
  valid_594835 = validateParameter(valid_594835, JString, required = false,
                                 default = nil)
  if valid_594835 != nil:
    section.add "oauth_token", valid_594835
  var valid_594836 = query.getOrDefault("userIp")
  valid_594836 = validateParameter(valid_594836, JString, required = false,
                                 default = nil)
  if valid_594836 != nil:
    section.add "userIp", valid_594836
  var valid_594837 = query.getOrDefault("maxResults")
  valid_594837 = validateParameter(valid_594837, JInt, required = false,
                                 default = newJInt(1000))
  if valid_594837 != nil:
    section.add "maxResults", valid_594837
  var valid_594838 = query.getOrDefault("maxChangeTime")
  valid_594838 = validateParameter(valid_594838, JString, required = false,
                                 default = nil)
  if valid_594838 != nil:
    section.add "maxChangeTime", valid_594838
  var valid_594839 = query.getOrDefault("ids")
  valid_594839 = validateParameter(valid_594839, JArray, required = false,
                                 default = nil)
  if valid_594839 != nil:
    section.add "ids", valid_594839
  var valid_594840 = query.getOrDefault("objectType")
  valid_594840 = validateParameter(valid_594840, JString, required = false,
                                 default = newJString("OBJECT_ACCOUNT"))
  if valid_594840 != nil:
    section.add "objectType", valid_594840
  var valid_594841 = query.getOrDefault("key")
  valid_594841 = validateParameter(valid_594841, JString, required = false,
                                 default = nil)
  if valid_594841 != nil:
    section.add "key", valid_594841
  var valid_594842 = query.getOrDefault("objectIds")
  valid_594842 = validateParameter(valid_594842, JArray, required = false,
                                 default = nil)
  if valid_594842 != nil:
    section.add "objectIds", valid_594842
  var valid_594843 = query.getOrDefault("prettyPrint")
  valid_594843 = validateParameter(valid_594843, JBool, required = false,
                                 default = newJBool(true))
  if valid_594843 != nil:
    section.add "prettyPrint", valid_594843
  var valid_594844 = query.getOrDefault("userProfileIds")
  valid_594844 = validateParameter(valid_594844, JArray, required = false,
                                 default = nil)
  if valid_594844 != nil:
    section.add "userProfileIds", valid_594844
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594845: Call_DfareportingChangeLogsList_594824; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of change logs. This method supports paging.
  ## 
  let valid = call_594845.validator(path, query, header, formData, body)
  let scheme = call_594845.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594845.url(scheme.get, call_594845.host, call_594845.base,
                         call_594845.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594845, url, valid)

proc call*(call_594846: Call_DfareportingChangeLogsList_594824; profileId: string;
          action: string = "ACTION_ADD"; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; minChangeTime: string = ""; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; maxChangeTime: string = ""; ids: JsonNode = nil;
          objectType: string = "OBJECT_ACCOUNT"; key: string = "";
          objectIds: JsonNode = nil; prettyPrint: bool = true;
          userProfileIds: JsonNode = nil): Recallable =
  ## dfareportingChangeLogsList
  ## Retrieves a list of change logs. This method supports paging.
  ##   action: string
  ##         : Select only change logs with the specified action.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   minChangeTime: string
  ##                : Select only change logs whose change time is before the specified minChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Select only change logs whose object ID, user name, old or new values match the search string.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   maxChangeTime: string
  ##                : Select only change logs whose change time is before the specified maxChangeTime.The time should be formatted as an RFC3339 date/time string. For example, for 10:54 PM on July 18th, 2015, in the America/New York time zone, the format is "2015-07-18T22:54:00-04:00". In other words, the year, month, day, the letter T, the hour (24-hour clock system), minute, second, and then the time zone offset.
  ##   ids: JArray
  ##      : Select only change logs with these IDs.
  ##   objectType: string
  ##             : Select only change logs with the specified object type.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   objectIds: JArray
  ##            : Select only change logs with these object IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   userProfileIds: JArray
  ##                 : Select only change logs with these user profile IDs.
  var path_594847 = newJObject()
  var query_594848 = newJObject()
  add(query_594848, "action", newJString(action))
  add(path_594847, "profileId", newJString(profileId))
  add(query_594848, "fields", newJString(fields))
  add(query_594848, "pageToken", newJString(pageToken))
  add(query_594848, "quotaUser", newJString(quotaUser))
  add(query_594848, "minChangeTime", newJString(minChangeTime))
  add(query_594848, "alt", newJString(alt))
  add(query_594848, "searchString", newJString(searchString))
  add(query_594848, "oauth_token", newJString(oauthToken))
  add(query_594848, "userIp", newJString(userIp))
  add(query_594848, "maxResults", newJInt(maxResults))
  add(query_594848, "maxChangeTime", newJString(maxChangeTime))
  if ids != nil:
    query_594848.add "ids", ids
  add(query_594848, "objectType", newJString(objectType))
  add(query_594848, "key", newJString(key))
  if objectIds != nil:
    query_594848.add "objectIds", objectIds
  add(query_594848, "prettyPrint", newJBool(prettyPrint))
  if userProfileIds != nil:
    query_594848.add "userProfileIds", userProfileIds
  result = call_594846.call(path_594847, query_594848, nil, nil, nil)

var dfareportingChangeLogsList* = Call_DfareportingChangeLogsList_594824(
    name: "dfareportingChangeLogsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/changeLogs",
    validator: validate_DfareportingChangeLogsList_594825,
    base: "/dfareporting/v2.7", url: url_DfareportingChangeLogsList_594826,
    schemes: {Scheme.Https})
type
  Call_DfareportingChangeLogsGet_594849 = ref object of OpenApiRestCall_593437
proc url_DfareportingChangeLogsGet_594851(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/changeLogs/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingChangeLogsGet_594850(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one change log by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Change log ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594852 = path.getOrDefault("profileId")
  valid_594852 = validateParameter(valid_594852, JString, required = true,
                                 default = nil)
  if valid_594852 != nil:
    section.add "profileId", valid_594852
  var valid_594853 = path.getOrDefault("id")
  valid_594853 = validateParameter(valid_594853, JString, required = true,
                                 default = nil)
  if valid_594853 != nil:
    section.add "id", valid_594853
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594854 = query.getOrDefault("fields")
  valid_594854 = validateParameter(valid_594854, JString, required = false,
                                 default = nil)
  if valid_594854 != nil:
    section.add "fields", valid_594854
  var valid_594855 = query.getOrDefault("quotaUser")
  valid_594855 = validateParameter(valid_594855, JString, required = false,
                                 default = nil)
  if valid_594855 != nil:
    section.add "quotaUser", valid_594855
  var valid_594856 = query.getOrDefault("alt")
  valid_594856 = validateParameter(valid_594856, JString, required = false,
                                 default = newJString("json"))
  if valid_594856 != nil:
    section.add "alt", valid_594856
  var valid_594857 = query.getOrDefault("oauth_token")
  valid_594857 = validateParameter(valid_594857, JString, required = false,
                                 default = nil)
  if valid_594857 != nil:
    section.add "oauth_token", valid_594857
  var valid_594858 = query.getOrDefault("userIp")
  valid_594858 = validateParameter(valid_594858, JString, required = false,
                                 default = nil)
  if valid_594858 != nil:
    section.add "userIp", valid_594858
  var valid_594859 = query.getOrDefault("key")
  valid_594859 = validateParameter(valid_594859, JString, required = false,
                                 default = nil)
  if valid_594859 != nil:
    section.add "key", valid_594859
  var valid_594860 = query.getOrDefault("prettyPrint")
  valid_594860 = validateParameter(valid_594860, JBool, required = false,
                                 default = newJBool(true))
  if valid_594860 != nil:
    section.add "prettyPrint", valid_594860
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594861: Call_DfareportingChangeLogsGet_594849; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one change log by ID.
  ## 
  let valid = call_594861.validator(path, query, header, formData, body)
  let scheme = call_594861.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594861.url(scheme.get, call_594861.host, call_594861.base,
                         call_594861.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594861, url, valid)

proc call*(call_594862: Call_DfareportingChangeLogsGet_594849; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingChangeLogsGet
  ## Gets one change log by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Change log ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594863 = newJObject()
  var query_594864 = newJObject()
  add(path_594863, "profileId", newJString(profileId))
  add(query_594864, "fields", newJString(fields))
  add(query_594864, "quotaUser", newJString(quotaUser))
  add(query_594864, "alt", newJString(alt))
  add(query_594864, "oauth_token", newJString(oauthToken))
  add(query_594864, "userIp", newJString(userIp))
  add(path_594863, "id", newJString(id))
  add(query_594864, "key", newJString(key))
  add(query_594864, "prettyPrint", newJBool(prettyPrint))
  result = call_594862.call(path_594863, query_594864, nil, nil, nil)

var dfareportingChangeLogsGet* = Call_DfareportingChangeLogsGet_594849(
    name: "dfareportingChangeLogsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/changeLogs/{id}",
    validator: validate_DfareportingChangeLogsGet_594850,
    base: "/dfareporting/v2.7", url: url_DfareportingChangeLogsGet_594851,
    schemes: {Scheme.Https})
type
  Call_DfareportingCitiesList_594865 = ref object of OpenApiRestCall_593437
proc url_DfareportingCitiesList_594867(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/cities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCitiesList_594866(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of cities, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594868 = path.getOrDefault("profileId")
  valid_594868 = validateParameter(valid_594868, JString, required = true,
                                 default = nil)
  if valid_594868 != nil:
    section.add "profileId", valid_594868
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   namePrefix: JString
  ##             : Select only cities with names starting with this prefix.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   countryDartIds: JArray
  ##                 : Select only cities from these countries.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   regionDartIds: JArray
  ##                : Select only cities from these regions.
  ##   dartIds: JArray
  ##          : Select only cities with these DART IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594869 = query.getOrDefault("fields")
  valid_594869 = validateParameter(valid_594869, JString, required = false,
                                 default = nil)
  if valid_594869 != nil:
    section.add "fields", valid_594869
  var valid_594870 = query.getOrDefault("quotaUser")
  valid_594870 = validateParameter(valid_594870, JString, required = false,
                                 default = nil)
  if valid_594870 != nil:
    section.add "quotaUser", valid_594870
  var valid_594871 = query.getOrDefault("alt")
  valid_594871 = validateParameter(valid_594871, JString, required = false,
                                 default = newJString("json"))
  if valid_594871 != nil:
    section.add "alt", valid_594871
  var valid_594872 = query.getOrDefault("namePrefix")
  valid_594872 = validateParameter(valid_594872, JString, required = false,
                                 default = nil)
  if valid_594872 != nil:
    section.add "namePrefix", valid_594872
  var valid_594873 = query.getOrDefault("oauth_token")
  valid_594873 = validateParameter(valid_594873, JString, required = false,
                                 default = nil)
  if valid_594873 != nil:
    section.add "oauth_token", valid_594873
  var valid_594874 = query.getOrDefault("userIp")
  valid_594874 = validateParameter(valid_594874, JString, required = false,
                                 default = nil)
  if valid_594874 != nil:
    section.add "userIp", valid_594874
  var valid_594875 = query.getOrDefault("countryDartIds")
  valid_594875 = validateParameter(valid_594875, JArray, required = false,
                                 default = nil)
  if valid_594875 != nil:
    section.add "countryDartIds", valid_594875
  var valid_594876 = query.getOrDefault("key")
  valid_594876 = validateParameter(valid_594876, JString, required = false,
                                 default = nil)
  if valid_594876 != nil:
    section.add "key", valid_594876
  var valid_594877 = query.getOrDefault("regionDartIds")
  valid_594877 = validateParameter(valid_594877, JArray, required = false,
                                 default = nil)
  if valid_594877 != nil:
    section.add "regionDartIds", valid_594877
  var valid_594878 = query.getOrDefault("dartIds")
  valid_594878 = validateParameter(valid_594878, JArray, required = false,
                                 default = nil)
  if valid_594878 != nil:
    section.add "dartIds", valid_594878
  var valid_594879 = query.getOrDefault("prettyPrint")
  valid_594879 = validateParameter(valid_594879, JBool, required = false,
                                 default = newJBool(true))
  if valid_594879 != nil:
    section.add "prettyPrint", valid_594879
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594880: Call_DfareportingCitiesList_594865; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of cities, possibly filtered.
  ## 
  let valid = call_594880.validator(path, query, header, formData, body)
  let scheme = call_594880.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594880.url(scheme.get, call_594880.host, call_594880.base,
                         call_594880.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594880, url, valid)

proc call*(call_594881: Call_DfareportingCitiesList_594865; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          namePrefix: string = ""; oauthToken: string = ""; userIp: string = "";
          countryDartIds: JsonNode = nil; key: string = "";
          regionDartIds: JsonNode = nil; dartIds: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCitiesList
  ## Retrieves a list of cities, possibly filtered.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   namePrefix: string
  ##             : Select only cities with names starting with this prefix.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   countryDartIds: JArray
  ##                 : Select only cities from these countries.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   regionDartIds: JArray
  ##                : Select only cities from these regions.
  ##   dartIds: JArray
  ##          : Select only cities with these DART IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594882 = newJObject()
  var query_594883 = newJObject()
  add(path_594882, "profileId", newJString(profileId))
  add(query_594883, "fields", newJString(fields))
  add(query_594883, "quotaUser", newJString(quotaUser))
  add(query_594883, "alt", newJString(alt))
  add(query_594883, "namePrefix", newJString(namePrefix))
  add(query_594883, "oauth_token", newJString(oauthToken))
  add(query_594883, "userIp", newJString(userIp))
  if countryDartIds != nil:
    query_594883.add "countryDartIds", countryDartIds
  add(query_594883, "key", newJString(key))
  if regionDartIds != nil:
    query_594883.add "regionDartIds", regionDartIds
  if dartIds != nil:
    query_594883.add "dartIds", dartIds
  add(query_594883, "prettyPrint", newJBool(prettyPrint))
  result = call_594881.call(path_594882, query_594883, nil, nil, nil)

var dfareportingCitiesList* = Call_DfareportingCitiesList_594865(
    name: "dfareportingCitiesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/cities",
    validator: validate_DfareportingCitiesList_594866, base: "/dfareporting/v2.7",
    url: url_DfareportingCitiesList_594867, schemes: {Scheme.Https})
type
  Call_DfareportingConnectionTypesList_594884 = ref object of OpenApiRestCall_593437
proc url_DfareportingConnectionTypesList_594886(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/connectionTypes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingConnectionTypesList_594885(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of connection types.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594887 = path.getOrDefault("profileId")
  valid_594887 = validateParameter(valid_594887, JString, required = true,
                                 default = nil)
  if valid_594887 != nil:
    section.add "profileId", valid_594887
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594888 = query.getOrDefault("fields")
  valid_594888 = validateParameter(valid_594888, JString, required = false,
                                 default = nil)
  if valid_594888 != nil:
    section.add "fields", valid_594888
  var valid_594889 = query.getOrDefault("quotaUser")
  valid_594889 = validateParameter(valid_594889, JString, required = false,
                                 default = nil)
  if valid_594889 != nil:
    section.add "quotaUser", valid_594889
  var valid_594890 = query.getOrDefault("alt")
  valid_594890 = validateParameter(valid_594890, JString, required = false,
                                 default = newJString("json"))
  if valid_594890 != nil:
    section.add "alt", valid_594890
  var valid_594891 = query.getOrDefault("oauth_token")
  valid_594891 = validateParameter(valid_594891, JString, required = false,
                                 default = nil)
  if valid_594891 != nil:
    section.add "oauth_token", valid_594891
  var valid_594892 = query.getOrDefault("userIp")
  valid_594892 = validateParameter(valid_594892, JString, required = false,
                                 default = nil)
  if valid_594892 != nil:
    section.add "userIp", valid_594892
  var valid_594893 = query.getOrDefault("key")
  valid_594893 = validateParameter(valid_594893, JString, required = false,
                                 default = nil)
  if valid_594893 != nil:
    section.add "key", valid_594893
  var valid_594894 = query.getOrDefault("prettyPrint")
  valid_594894 = validateParameter(valid_594894, JBool, required = false,
                                 default = newJBool(true))
  if valid_594894 != nil:
    section.add "prettyPrint", valid_594894
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594895: Call_DfareportingConnectionTypesList_594884;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of connection types.
  ## 
  let valid = call_594895.validator(path, query, header, formData, body)
  let scheme = call_594895.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594895.url(scheme.get, call_594895.host, call_594895.base,
                         call_594895.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594895, url, valid)

proc call*(call_594896: Call_DfareportingConnectionTypesList_594884;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingConnectionTypesList
  ## Retrieves a list of connection types.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594897 = newJObject()
  var query_594898 = newJObject()
  add(path_594897, "profileId", newJString(profileId))
  add(query_594898, "fields", newJString(fields))
  add(query_594898, "quotaUser", newJString(quotaUser))
  add(query_594898, "alt", newJString(alt))
  add(query_594898, "oauth_token", newJString(oauthToken))
  add(query_594898, "userIp", newJString(userIp))
  add(query_594898, "key", newJString(key))
  add(query_594898, "prettyPrint", newJBool(prettyPrint))
  result = call_594896.call(path_594897, query_594898, nil, nil, nil)

var dfareportingConnectionTypesList* = Call_DfareportingConnectionTypesList_594884(
    name: "dfareportingConnectionTypesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/connectionTypes",
    validator: validate_DfareportingConnectionTypesList_594885,
    base: "/dfareporting/v2.7", url: url_DfareportingConnectionTypesList_594886,
    schemes: {Scheme.Https})
type
  Call_DfareportingConnectionTypesGet_594899 = ref object of OpenApiRestCall_593437
proc url_DfareportingConnectionTypesGet_594901(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/connectionTypes/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingConnectionTypesGet_594900(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one connection type by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Connection type ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594902 = path.getOrDefault("profileId")
  valid_594902 = validateParameter(valid_594902, JString, required = true,
                                 default = nil)
  if valid_594902 != nil:
    section.add "profileId", valid_594902
  var valid_594903 = path.getOrDefault("id")
  valid_594903 = validateParameter(valid_594903, JString, required = true,
                                 default = nil)
  if valid_594903 != nil:
    section.add "id", valid_594903
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594904 = query.getOrDefault("fields")
  valid_594904 = validateParameter(valid_594904, JString, required = false,
                                 default = nil)
  if valid_594904 != nil:
    section.add "fields", valid_594904
  var valid_594905 = query.getOrDefault("quotaUser")
  valid_594905 = validateParameter(valid_594905, JString, required = false,
                                 default = nil)
  if valid_594905 != nil:
    section.add "quotaUser", valid_594905
  var valid_594906 = query.getOrDefault("alt")
  valid_594906 = validateParameter(valid_594906, JString, required = false,
                                 default = newJString("json"))
  if valid_594906 != nil:
    section.add "alt", valid_594906
  var valid_594907 = query.getOrDefault("oauth_token")
  valid_594907 = validateParameter(valid_594907, JString, required = false,
                                 default = nil)
  if valid_594907 != nil:
    section.add "oauth_token", valid_594907
  var valid_594908 = query.getOrDefault("userIp")
  valid_594908 = validateParameter(valid_594908, JString, required = false,
                                 default = nil)
  if valid_594908 != nil:
    section.add "userIp", valid_594908
  var valid_594909 = query.getOrDefault("key")
  valid_594909 = validateParameter(valid_594909, JString, required = false,
                                 default = nil)
  if valid_594909 != nil:
    section.add "key", valid_594909
  var valid_594910 = query.getOrDefault("prettyPrint")
  valid_594910 = validateParameter(valid_594910, JBool, required = false,
                                 default = newJBool(true))
  if valid_594910 != nil:
    section.add "prettyPrint", valid_594910
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594911: Call_DfareportingConnectionTypesGet_594899; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one connection type by ID.
  ## 
  let valid = call_594911.validator(path, query, header, formData, body)
  let scheme = call_594911.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594911.url(scheme.get, call_594911.host, call_594911.base,
                         call_594911.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594911, url, valid)

proc call*(call_594912: Call_DfareportingConnectionTypesGet_594899;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingConnectionTypesGet
  ## Gets one connection type by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Connection type ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594913 = newJObject()
  var query_594914 = newJObject()
  add(path_594913, "profileId", newJString(profileId))
  add(query_594914, "fields", newJString(fields))
  add(query_594914, "quotaUser", newJString(quotaUser))
  add(query_594914, "alt", newJString(alt))
  add(query_594914, "oauth_token", newJString(oauthToken))
  add(query_594914, "userIp", newJString(userIp))
  add(path_594913, "id", newJString(id))
  add(query_594914, "key", newJString(key))
  add(query_594914, "prettyPrint", newJBool(prettyPrint))
  result = call_594912.call(path_594913, query_594914, nil, nil, nil)

var dfareportingConnectionTypesGet* = Call_DfareportingConnectionTypesGet_594899(
    name: "dfareportingConnectionTypesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/connectionTypes/{id}",
    validator: validate_DfareportingConnectionTypesGet_594900,
    base: "/dfareporting/v2.7", url: url_DfareportingConnectionTypesGet_594901,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesUpdate_594936 = ref object of OpenApiRestCall_593437
proc url_DfareportingContentCategoriesUpdate_594938(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesUpdate_594937(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing content category.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594939 = path.getOrDefault("profileId")
  valid_594939 = validateParameter(valid_594939, JString, required = true,
                                 default = nil)
  if valid_594939 != nil:
    section.add "profileId", valid_594939
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594940 = query.getOrDefault("fields")
  valid_594940 = validateParameter(valid_594940, JString, required = false,
                                 default = nil)
  if valid_594940 != nil:
    section.add "fields", valid_594940
  var valid_594941 = query.getOrDefault("quotaUser")
  valid_594941 = validateParameter(valid_594941, JString, required = false,
                                 default = nil)
  if valid_594941 != nil:
    section.add "quotaUser", valid_594941
  var valid_594942 = query.getOrDefault("alt")
  valid_594942 = validateParameter(valid_594942, JString, required = false,
                                 default = newJString("json"))
  if valid_594942 != nil:
    section.add "alt", valid_594942
  var valid_594943 = query.getOrDefault("oauth_token")
  valid_594943 = validateParameter(valid_594943, JString, required = false,
                                 default = nil)
  if valid_594943 != nil:
    section.add "oauth_token", valid_594943
  var valid_594944 = query.getOrDefault("userIp")
  valid_594944 = validateParameter(valid_594944, JString, required = false,
                                 default = nil)
  if valid_594944 != nil:
    section.add "userIp", valid_594944
  var valid_594945 = query.getOrDefault("key")
  valid_594945 = validateParameter(valid_594945, JString, required = false,
                                 default = nil)
  if valid_594945 != nil:
    section.add "key", valid_594945
  var valid_594946 = query.getOrDefault("prettyPrint")
  valid_594946 = validateParameter(valid_594946, JBool, required = false,
                                 default = newJBool(true))
  if valid_594946 != nil:
    section.add "prettyPrint", valid_594946
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594948: Call_DfareportingContentCategoriesUpdate_594936;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing content category.
  ## 
  let valid = call_594948.validator(path, query, header, formData, body)
  let scheme = call_594948.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594948.url(scheme.get, call_594948.host, call_594948.base,
                         call_594948.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594948, url, valid)

proc call*(call_594949: Call_DfareportingContentCategoriesUpdate_594936;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesUpdate
  ## Updates an existing content category.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594950 = newJObject()
  var query_594951 = newJObject()
  var body_594952 = newJObject()
  add(path_594950, "profileId", newJString(profileId))
  add(query_594951, "fields", newJString(fields))
  add(query_594951, "quotaUser", newJString(quotaUser))
  add(query_594951, "alt", newJString(alt))
  add(query_594951, "oauth_token", newJString(oauthToken))
  add(query_594951, "userIp", newJString(userIp))
  add(query_594951, "key", newJString(key))
  if body != nil:
    body_594952 = body
  add(query_594951, "prettyPrint", newJBool(prettyPrint))
  result = call_594949.call(path_594950, query_594951, nil, nil, body_594952)

var dfareportingContentCategoriesUpdate* = Call_DfareportingContentCategoriesUpdate_594936(
    name: "dfareportingContentCategoriesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesUpdate_594937,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesUpdate_594938,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesInsert_594953 = ref object of OpenApiRestCall_593437
proc url_DfareportingContentCategoriesInsert_594955(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesInsert_594954(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new content category.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594956 = path.getOrDefault("profileId")
  valid_594956 = validateParameter(valid_594956, JString, required = true,
                                 default = nil)
  if valid_594956 != nil:
    section.add "profileId", valid_594956
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594957 = query.getOrDefault("fields")
  valid_594957 = validateParameter(valid_594957, JString, required = false,
                                 default = nil)
  if valid_594957 != nil:
    section.add "fields", valid_594957
  var valid_594958 = query.getOrDefault("quotaUser")
  valid_594958 = validateParameter(valid_594958, JString, required = false,
                                 default = nil)
  if valid_594958 != nil:
    section.add "quotaUser", valid_594958
  var valid_594959 = query.getOrDefault("alt")
  valid_594959 = validateParameter(valid_594959, JString, required = false,
                                 default = newJString("json"))
  if valid_594959 != nil:
    section.add "alt", valid_594959
  var valid_594960 = query.getOrDefault("oauth_token")
  valid_594960 = validateParameter(valid_594960, JString, required = false,
                                 default = nil)
  if valid_594960 != nil:
    section.add "oauth_token", valid_594960
  var valid_594961 = query.getOrDefault("userIp")
  valid_594961 = validateParameter(valid_594961, JString, required = false,
                                 default = nil)
  if valid_594961 != nil:
    section.add "userIp", valid_594961
  var valid_594962 = query.getOrDefault("key")
  valid_594962 = validateParameter(valid_594962, JString, required = false,
                                 default = nil)
  if valid_594962 != nil:
    section.add "key", valid_594962
  var valid_594963 = query.getOrDefault("prettyPrint")
  valid_594963 = validateParameter(valid_594963, JBool, required = false,
                                 default = newJBool(true))
  if valid_594963 != nil:
    section.add "prettyPrint", valid_594963
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594965: Call_DfareportingContentCategoriesInsert_594953;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new content category.
  ## 
  let valid = call_594965.validator(path, query, header, formData, body)
  let scheme = call_594965.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594965.url(scheme.get, call_594965.host, call_594965.base,
                         call_594965.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594965, url, valid)

proc call*(call_594966: Call_DfareportingContentCategoriesInsert_594953;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesInsert
  ## Inserts a new content category.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594967 = newJObject()
  var query_594968 = newJObject()
  var body_594969 = newJObject()
  add(path_594967, "profileId", newJString(profileId))
  add(query_594968, "fields", newJString(fields))
  add(query_594968, "quotaUser", newJString(quotaUser))
  add(query_594968, "alt", newJString(alt))
  add(query_594968, "oauth_token", newJString(oauthToken))
  add(query_594968, "userIp", newJString(userIp))
  add(query_594968, "key", newJString(key))
  if body != nil:
    body_594969 = body
  add(query_594968, "prettyPrint", newJBool(prettyPrint))
  result = call_594966.call(path_594967, query_594968, nil, nil, body_594969)

var dfareportingContentCategoriesInsert* = Call_DfareportingContentCategoriesInsert_594953(
    name: "dfareportingContentCategoriesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesInsert_594954,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesInsert_594955,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesList_594915 = ref object of OpenApiRestCall_593437
proc url_DfareportingContentCategoriesList_594917(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesList_594916(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of content categories, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594918 = path.getOrDefault("profileId")
  valid_594918 = validateParameter(valid_594918, JString, required = true,
                                 default = nil)
  if valid_594918 != nil:
    section.add "profileId", valid_594918
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "contentcategory*2015" will return objects with names like "contentcategory June 2015", "contentcategory April 2015", or simply "contentcategory 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "contentcategory" will match objects with name "my contentcategory", "contentcategory 2015", or simply "contentcategory".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only content categories with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594919 = query.getOrDefault("fields")
  valid_594919 = validateParameter(valid_594919, JString, required = false,
                                 default = nil)
  if valid_594919 != nil:
    section.add "fields", valid_594919
  var valid_594920 = query.getOrDefault("pageToken")
  valid_594920 = validateParameter(valid_594920, JString, required = false,
                                 default = nil)
  if valid_594920 != nil:
    section.add "pageToken", valid_594920
  var valid_594921 = query.getOrDefault("quotaUser")
  valid_594921 = validateParameter(valid_594921, JString, required = false,
                                 default = nil)
  if valid_594921 != nil:
    section.add "quotaUser", valid_594921
  var valid_594922 = query.getOrDefault("sortField")
  valid_594922 = validateParameter(valid_594922, JString, required = false,
                                 default = newJString("ID"))
  if valid_594922 != nil:
    section.add "sortField", valid_594922
  var valid_594923 = query.getOrDefault("alt")
  valid_594923 = validateParameter(valid_594923, JString, required = false,
                                 default = newJString("json"))
  if valid_594923 != nil:
    section.add "alt", valid_594923
  var valid_594924 = query.getOrDefault("searchString")
  valid_594924 = validateParameter(valid_594924, JString, required = false,
                                 default = nil)
  if valid_594924 != nil:
    section.add "searchString", valid_594924
  var valid_594925 = query.getOrDefault("oauth_token")
  valid_594925 = validateParameter(valid_594925, JString, required = false,
                                 default = nil)
  if valid_594925 != nil:
    section.add "oauth_token", valid_594925
  var valid_594926 = query.getOrDefault("userIp")
  valid_594926 = validateParameter(valid_594926, JString, required = false,
                                 default = nil)
  if valid_594926 != nil:
    section.add "userIp", valid_594926
  var valid_594927 = query.getOrDefault("maxResults")
  valid_594927 = validateParameter(valid_594927, JInt, required = false,
                                 default = newJInt(1000))
  if valid_594927 != nil:
    section.add "maxResults", valid_594927
  var valid_594928 = query.getOrDefault("ids")
  valid_594928 = validateParameter(valid_594928, JArray, required = false,
                                 default = nil)
  if valid_594928 != nil:
    section.add "ids", valid_594928
  var valid_594929 = query.getOrDefault("key")
  valid_594929 = validateParameter(valid_594929, JString, required = false,
                                 default = nil)
  if valid_594929 != nil:
    section.add "key", valid_594929
  var valid_594930 = query.getOrDefault("sortOrder")
  valid_594930 = validateParameter(valid_594930, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_594930 != nil:
    section.add "sortOrder", valid_594930
  var valid_594931 = query.getOrDefault("prettyPrint")
  valid_594931 = validateParameter(valid_594931, JBool, required = false,
                                 default = newJBool(true))
  if valid_594931 != nil:
    section.add "prettyPrint", valid_594931
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594932: Call_DfareportingContentCategoriesList_594915;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of content categories, possibly filtered. This method supports paging.
  ## 
  let valid = call_594932.validator(path, query, header, formData, body)
  let scheme = call_594932.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594932.url(scheme.get, call_594932.host, call_594932.base,
                         call_594932.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594932, url, valid)

proc call*(call_594933: Call_DfareportingContentCategoriesList_594915;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesList
  ## Retrieves a list of content categories, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "contentcategory*2015" will return objects with names like "contentcategory June 2015", "contentcategory April 2015", or simply "contentcategory 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "contentcategory" will match objects with name "my contentcategory", "contentcategory 2015", or simply "contentcategory".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only content categories with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594934 = newJObject()
  var query_594935 = newJObject()
  add(path_594934, "profileId", newJString(profileId))
  add(query_594935, "fields", newJString(fields))
  add(query_594935, "pageToken", newJString(pageToken))
  add(query_594935, "quotaUser", newJString(quotaUser))
  add(query_594935, "sortField", newJString(sortField))
  add(query_594935, "alt", newJString(alt))
  add(query_594935, "searchString", newJString(searchString))
  add(query_594935, "oauth_token", newJString(oauthToken))
  add(query_594935, "userIp", newJString(userIp))
  add(query_594935, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_594935.add "ids", ids
  add(query_594935, "key", newJString(key))
  add(query_594935, "sortOrder", newJString(sortOrder))
  add(query_594935, "prettyPrint", newJBool(prettyPrint))
  result = call_594933.call(path_594934, query_594935, nil, nil, nil)

var dfareportingContentCategoriesList* = Call_DfareportingContentCategoriesList_594915(
    name: "dfareportingContentCategoriesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesList_594916,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesList_594917,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesPatch_594970 = ref object of OpenApiRestCall_593437
proc url_DfareportingContentCategoriesPatch_594972(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesPatch_594971(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing content category. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594973 = path.getOrDefault("profileId")
  valid_594973 = validateParameter(valid_594973, JString, required = true,
                                 default = nil)
  if valid_594973 != nil:
    section.add "profileId", valid_594973
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Content category ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594974 = query.getOrDefault("fields")
  valid_594974 = validateParameter(valid_594974, JString, required = false,
                                 default = nil)
  if valid_594974 != nil:
    section.add "fields", valid_594974
  var valid_594975 = query.getOrDefault("quotaUser")
  valid_594975 = validateParameter(valid_594975, JString, required = false,
                                 default = nil)
  if valid_594975 != nil:
    section.add "quotaUser", valid_594975
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_594976 = query.getOrDefault("id")
  valid_594976 = validateParameter(valid_594976, JString, required = true,
                                 default = nil)
  if valid_594976 != nil:
    section.add "id", valid_594976
  var valid_594977 = query.getOrDefault("alt")
  valid_594977 = validateParameter(valid_594977, JString, required = false,
                                 default = newJString("json"))
  if valid_594977 != nil:
    section.add "alt", valid_594977
  var valid_594978 = query.getOrDefault("oauth_token")
  valid_594978 = validateParameter(valid_594978, JString, required = false,
                                 default = nil)
  if valid_594978 != nil:
    section.add "oauth_token", valid_594978
  var valid_594979 = query.getOrDefault("userIp")
  valid_594979 = validateParameter(valid_594979, JString, required = false,
                                 default = nil)
  if valid_594979 != nil:
    section.add "userIp", valid_594979
  var valid_594980 = query.getOrDefault("key")
  valid_594980 = validateParameter(valid_594980, JString, required = false,
                                 default = nil)
  if valid_594980 != nil:
    section.add "key", valid_594980
  var valid_594981 = query.getOrDefault("prettyPrint")
  valid_594981 = validateParameter(valid_594981, JBool, required = false,
                                 default = newJBool(true))
  if valid_594981 != nil:
    section.add "prettyPrint", valid_594981
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594983: Call_DfareportingContentCategoriesPatch_594970;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing content category. This method supports patch semantics.
  ## 
  let valid = call_594983.validator(path, query, header, formData, body)
  let scheme = call_594983.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594983.url(scheme.get, call_594983.host, call_594983.base,
                         call_594983.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594983, url, valid)

proc call*(call_594984: Call_DfareportingContentCategoriesPatch_594970;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesPatch
  ## Updates an existing content category. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Content category ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_594985 = newJObject()
  var query_594986 = newJObject()
  var body_594987 = newJObject()
  add(path_594985, "profileId", newJString(profileId))
  add(query_594986, "fields", newJString(fields))
  add(query_594986, "quotaUser", newJString(quotaUser))
  add(query_594986, "id", newJString(id))
  add(query_594986, "alt", newJString(alt))
  add(query_594986, "oauth_token", newJString(oauthToken))
  add(query_594986, "userIp", newJString(userIp))
  add(query_594986, "key", newJString(key))
  if body != nil:
    body_594987 = body
  add(query_594986, "prettyPrint", newJBool(prettyPrint))
  result = call_594984.call(path_594985, query_594986, nil, nil, body_594987)

var dfareportingContentCategoriesPatch* = Call_DfareportingContentCategoriesPatch_594970(
    name: "dfareportingContentCategoriesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories",
    validator: validate_DfareportingContentCategoriesPatch_594971,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesPatch_594972,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesGet_594988 = ref object of OpenApiRestCall_593437
proc url_DfareportingContentCategoriesGet_594990(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesGet_594989(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one content category by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Content category ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_594991 = path.getOrDefault("profileId")
  valid_594991 = validateParameter(valid_594991, JString, required = true,
                                 default = nil)
  if valid_594991 != nil:
    section.add "profileId", valid_594991
  var valid_594992 = path.getOrDefault("id")
  valid_594992 = validateParameter(valid_594992, JString, required = true,
                                 default = nil)
  if valid_594992 != nil:
    section.add "id", valid_594992
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_594993 = query.getOrDefault("fields")
  valid_594993 = validateParameter(valid_594993, JString, required = false,
                                 default = nil)
  if valid_594993 != nil:
    section.add "fields", valid_594993
  var valid_594994 = query.getOrDefault("quotaUser")
  valid_594994 = validateParameter(valid_594994, JString, required = false,
                                 default = nil)
  if valid_594994 != nil:
    section.add "quotaUser", valid_594994
  var valid_594995 = query.getOrDefault("alt")
  valid_594995 = validateParameter(valid_594995, JString, required = false,
                                 default = newJString("json"))
  if valid_594995 != nil:
    section.add "alt", valid_594995
  var valid_594996 = query.getOrDefault("oauth_token")
  valid_594996 = validateParameter(valid_594996, JString, required = false,
                                 default = nil)
  if valid_594996 != nil:
    section.add "oauth_token", valid_594996
  var valid_594997 = query.getOrDefault("userIp")
  valid_594997 = validateParameter(valid_594997, JString, required = false,
                                 default = nil)
  if valid_594997 != nil:
    section.add "userIp", valid_594997
  var valid_594998 = query.getOrDefault("key")
  valid_594998 = validateParameter(valid_594998, JString, required = false,
                                 default = nil)
  if valid_594998 != nil:
    section.add "key", valid_594998
  var valid_594999 = query.getOrDefault("prettyPrint")
  valid_594999 = validateParameter(valid_594999, JBool, required = false,
                                 default = newJBool(true))
  if valid_594999 != nil:
    section.add "prettyPrint", valid_594999
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595000: Call_DfareportingContentCategoriesGet_594988;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one content category by ID.
  ## 
  let valid = call_595000.validator(path, query, header, formData, body)
  let scheme = call_595000.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595000.url(scheme.get, call_595000.host, call_595000.base,
                         call_595000.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595000, url, valid)

proc call*(call_595001: Call_DfareportingContentCategoriesGet_594988;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesGet
  ## Gets one content category by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Content category ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595002 = newJObject()
  var query_595003 = newJObject()
  add(path_595002, "profileId", newJString(profileId))
  add(query_595003, "fields", newJString(fields))
  add(query_595003, "quotaUser", newJString(quotaUser))
  add(query_595003, "alt", newJString(alt))
  add(query_595003, "oauth_token", newJString(oauthToken))
  add(query_595003, "userIp", newJString(userIp))
  add(path_595002, "id", newJString(id))
  add(query_595003, "key", newJString(key))
  add(query_595003, "prettyPrint", newJBool(prettyPrint))
  result = call_595001.call(path_595002, query_595003, nil, nil, nil)

var dfareportingContentCategoriesGet* = Call_DfareportingContentCategoriesGet_594988(
    name: "dfareportingContentCategoriesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories/{id}",
    validator: validate_DfareportingContentCategoriesGet_594989,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesGet_594990,
    schemes: {Scheme.Https})
type
  Call_DfareportingContentCategoriesDelete_595004 = ref object of OpenApiRestCall_593437
proc url_DfareportingContentCategoriesDelete_595006(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/contentCategories/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingContentCategoriesDelete_595005(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing content category.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Content category ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595007 = path.getOrDefault("profileId")
  valid_595007 = validateParameter(valid_595007, JString, required = true,
                                 default = nil)
  if valid_595007 != nil:
    section.add "profileId", valid_595007
  var valid_595008 = path.getOrDefault("id")
  valid_595008 = validateParameter(valid_595008, JString, required = true,
                                 default = nil)
  if valid_595008 != nil:
    section.add "id", valid_595008
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595009 = query.getOrDefault("fields")
  valid_595009 = validateParameter(valid_595009, JString, required = false,
                                 default = nil)
  if valid_595009 != nil:
    section.add "fields", valid_595009
  var valid_595010 = query.getOrDefault("quotaUser")
  valid_595010 = validateParameter(valid_595010, JString, required = false,
                                 default = nil)
  if valid_595010 != nil:
    section.add "quotaUser", valid_595010
  var valid_595011 = query.getOrDefault("alt")
  valid_595011 = validateParameter(valid_595011, JString, required = false,
                                 default = newJString("json"))
  if valid_595011 != nil:
    section.add "alt", valid_595011
  var valid_595012 = query.getOrDefault("oauth_token")
  valid_595012 = validateParameter(valid_595012, JString, required = false,
                                 default = nil)
  if valid_595012 != nil:
    section.add "oauth_token", valid_595012
  var valid_595013 = query.getOrDefault("userIp")
  valid_595013 = validateParameter(valid_595013, JString, required = false,
                                 default = nil)
  if valid_595013 != nil:
    section.add "userIp", valid_595013
  var valid_595014 = query.getOrDefault("key")
  valid_595014 = validateParameter(valid_595014, JString, required = false,
                                 default = nil)
  if valid_595014 != nil:
    section.add "key", valid_595014
  var valid_595015 = query.getOrDefault("prettyPrint")
  valid_595015 = validateParameter(valid_595015, JBool, required = false,
                                 default = newJBool(true))
  if valid_595015 != nil:
    section.add "prettyPrint", valid_595015
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595016: Call_DfareportingContentCategoriesDelete_595004;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing content category.
  ## 
  let valid = call_595016.validator(path, query, header, formData, body)
  let scheme = call_595016.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595016.url(scheme.get, call_595016.host, call_595016.base,
                         call_595016.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595016, url, valid)

proc call*(call_595017: Call_DfareportingContentCategoriesDelete_595004;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingContentCategoriesDelete
  ## Deletes an existing content category.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Content category ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595018 = newJObject()
  var query_595019 = newJObject()
  add(path_595018, "profileId", newJString(profileId))
  add(query_595019, "fields", newJString(fields))
  add(query_595019, "quotaUser", newJString(quotaUser))
  add(query_595019, "alt", newJString(alt))
  add(query_595019, "oauth_token", newJString(oauthToken))
  add(query_595019, "userIp", newJString(userIp))
  add(path_595018, "id", newJString(id))
  add(query_595019, "key", newJString(key))
  add(query_595019, "prettyPrint", newJBool(prettyPrint))
  result = call_595017.call(path_595018, query_595019, nil, nil, nil)

var dfareportingContentCategoriesDelete* = Call_DfareportingContentCategoriesDelete_595004(
    name: "dfareportingContentCategoriesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/contentCategories/{id}",
    validator: validate_DfareportingContentCategoriesDelete_595005,
    base: "/dfareporting/v2.7", url: url_DfareportingContentCategoriesDelete_595006,
    schemes: {Scheme.Https})
type
  Call_DfareportingConversionsBatchinsert_595020 = ref object of OpenApiRestCall_593437
proc url_DfareportingConversionsBatchinsert_595022(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/conversions/batchinsert")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingConversionsBatchinsert_595021(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts conversions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595023 = path.getOrDefault("profileId")
  valid_595023 = validateParameter(valid_595023, JString, required = true,
                                 default = nil)
  if valid_595023 != nil:
    section.add "profileId", valid_595023
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595024 = query.getOrDefault("fields")
  valid_595024 = validateParameter(valid_595024, JString, required = false,
                                 default = nil)
  if valid_595024 != nil:
    section.add "fields", valid_595024
  var valid_595025 = query.getOrDefault("quotaUser")
  valid_595025 = validateParameter(valid_595025, JString, required = false,
                                 default = nil)
  if valid_595025 != nil:
    section.add "quotaUser", valid_595025
  var valid_595026 = query.getOrDefault("alt")
  valid_595026 = validateParameter(valid_595026, JString, required = false,
                                 default = newJString("json"))
  if valid_595026 != nil:
    section.add "alt", valid_595026
  var valid_595027 = query.getOrDefault("oauth_token")
  valid_595027 = validateParameter(valid_595027, JString, required = false,
                                 default = nil)
  if valid_595027 != nil:
    section.add "oauth_token", valid_595027
  var valid_595028 = query.getOrDefault("userIp")
  valid_595028 = validateParameter(valid_595028, JString, required = false,
                                 default = nil)
  if valid_595028 != nil:
    section.add "userIp", valid_595028
  var valid_595029 = query.getOrDefault("key")
  valid_595029 = validateParameter(valid_595029, JString, required = false,
                                 default = nil)
  if valid_595029 != nil:
    section.add "key", valid_595029
  var valid_595030 = query.getOrDefault("prettyPrint")
  valid_595030 = validateParameter(valid_595030, JBool, required = false,
                                 default = newJBool(true))
  if valid_595030 != nil:
    section.add "prettyPrint", valid_595030
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595032: Call_DfareportingConversionsBatchinsert_595020;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts conversions.
  ## 
  let valid = call_595032.validator(path, query, header, formData, body)
  let scheme = call_595032.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595032.url(scheme.get, call_595032.host, call_595032.base,
                         call_595032.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595032, url, valid)

proc call*(call_595033: Call_DfareportingConversionsBatchinsert_595020;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingConversionsBatchinsert
  ## Inserts conversions.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595034 = newJObject()
  var query_595035 = newJObject()
  var body_595036 = newJObject()
  add(path_595034, "profileId", newJString(profileId))
  add(query_595035, "fields", newJString(fields))
  add(query_595035, "quotaUser", newJString(quotaUser))
  add(query_595035, "alt", newJString(alt))
  add(query_595035, "oauth_token", newJString(oauthToken))
  add(query_595035, "userIp", newJString(userIp))
  add(query_595035, "key", newJString(key))
  if body != nil:
    body_595036 = body
  add(query_595035, "prettyPrint", newJBool(prettyPrint))
  result = call_595033.call(path_595034, query_595035, nil, nil, body_595036)

var dfareportingConversionsBatchinsert* = Call_DfareportingConversionsBatchinsert_595020(
    name: "dfareportingConversionsBatchinsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/conversions/batchinsert",
    validator: validate_DfareportingConversionsBatchinsert_595021,
    base: "/dfareporting/v2.7", url: url_DfareportingConversionsBatchinsert_595022,
    schemes: {Scheme.Https})
type
  Call_DfareportingCountriesList_595037 = ref object of OpenApiRestCall_593437
proc url_DfareportingCountriesList_595039(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/countries")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCountriesList_595038(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of countries.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595040 = path.getOrDefault("profileId")
  valid_595040 = validateParameter(valid_595040, JString, required = true,
                                 default = nil)
  if valid_595040 != nil:
    section.add "profileId", valid_595040
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595041 = query.getOrDefault("fields")
  valid_595041 = validateParameter(valid_595041, JString, required = false,
                                 default = nil)
  if valid_595041 != nil:
    section.add "fields", valid_595041
  var valid_595042 = query.getOrDefault("quotaUser")
  valid_595042 = validateParameter(valid_595042, JString, required = false,
                                 default = nil)
  if valid_595042 != nil:
    section.add "quotaUser", valid_595042
  var valid_595043 = query.getOrDefault("alt")
  valid_595043 = validateParameter(valid_595043, JString, required = false,
                                 default = newJString("json"))
  if valid_595043 != nil:
    section.add "alt", valid_595043
  var valid_595044 = query.getOrDefault("oauth_token")
  valid_595044 = validateParameter(valid_595044, JString, required = false,
                                 default = nil)
  if valid_595044 != nil:
    section.add "oauth_token", valid_595044
  var valid_595045 = query.getOrDefault("userIp")
  valid_595045 = validateParameter(valid_595045, JString, required = false,
                                 default = nil)
  if valid_595045 != nil:
    section.add "userIp", valid_595045
  var valid_595046 = query.getOrDefault("key")
  valid_595046 = validateParameter(valid_595046, JString, required = false,
                                 default = nil)
  if valid_595046 != nil:
    section.add "key", valid_595046
  var valid_595047 = query.getOrDefault("prettyPrint")
  valid_595047 = validateParameter(valid_595047, JBool, required = false,
                                 default = newJBool(true))
  if valid_595047 != nil:
    section.add "prettyPrint", valid_595047
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595048: Call_DfareportingCountriesList_595037; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of countries.
  ## 
  let valid = call_595048.validator(path, query, header, formData, body)
  let scheme = call_595048.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595048.url(scheme.get, call_595048.host, call_595048.base,
                         call_595048.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595048, url, valid)

proc call*(call_595049: Call_DfareportingCountriesList_595037; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingCountriesList
  ## Retrieves a list of countries.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595050 = newJObject()
  var query_595051 = newJObject()
  add(path_595050, "profileId", newJString(profileId))
  add(query_595051, "fields", newJString(fields))
  add(query_595051, "quotaUser", newJString(quotaUser))
  add(query_595051, "alt", newJString(alt))
  add(query_595051, "oauth_token", newJString(oauthToken))
  add(query_595051, "userIp", newJString(userIp))
  add(query_595051, "key", newJString(key))
  add(query_595051, "prettyPrint", newJBool(prettyPrint))
  result = call_595049.call(path_595050, query_595051, nil, nil, nil)

var dfareportingCountriesList* = Call_DfareportingCountriesList_595037(
    name: "dfareportingCountriesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/countries",
    validator: validate_DfareportingCountriesList_595038,
    base: "/dfareporting/v2.7", url: url_DfareportingCountriesList_595039,
    schemes: {Scheme.Https})
type
  Call_DfareportingCountriesGet_595052 = ref object of OpenApiRestCall_593437
proc url_DfareportingCountriesGet_595054(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "dartId" in path, "`dartId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/countries/"),
               (kind: VariableSegment, value: "dartId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCountriesGet_595053(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one country by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   dartId: JString (required)
  ##         : Country DART ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595055 = path.getOrDefault("profileId")
  valid_595055 = validateParameter(valid_595055, JString, required = true,
                                 default = nil)
  if valid_595055 != nil:
    section.add "profileId", valid_595055
  var valid_595056 = path.getOrDefault("dartId")
  valid_595056 = validateParameter(valid_595056, JString, required = true,
                                 default = nil)
  if valid_595056 != nil:
    section.add "dartId", valid_595056
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595057 = query.getOrDefault("fields")
  valid_595057 = validateParameter(valid_595057, JString, required = false,
                                 default = nil)
  if valid_595057 != nil:
    section.add "fields", valid_595057
  var valid_595058 = query.getOrDefault("quotaUser")
  valid_595058 = validateParameter(valid_595058, JString, required = false,
                                 default = nil)
  if valid_595058 != nil:
    section.add "quotaUser", valid_595058
  var valid_595059 = query.getOrDefault("alt")
  valid_595059 = validateParameter(valid_595059, JString, required = false,
                                 default = newJString("json"))
  if valid_595059 != nil:
    section.add "alt", valid_595059
  var valid_595060 = query.getOrDefault("oauth_token")
  valid_595060 = validateParameter(valid_595060, JString, required = false,
                                 default = nil)
  if valid_595060 != nil:
    section.add "oauth_token", valid_595060
  var valid_595061 = query.getOrDefault("userIp")
  valid_595061 = validateParameter(valid_595061, JString, required = false,
                                 default = nil)
  if valid_595061 != nil:
    section.add "userIp", valid_595061
  var valid_595062 = query.getOrDefault("key")
  valid_595062 = validateParameter(valid_595062, JString, required = false,
                                 default = nil)
  if valid_595062 != nil:
    section.add "key", valid_595062
  var valid_595063 = query.getOrDefault("prettyPrint")
  valid_595063 = validateParameter(valid_595063, JBool, required = false,
                                 default = newJBool(true))
  if valid_595063 != nil:
    section.add "prettyPrint", valid_595063
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595064: Call_DfareportingCountriesGet_595052; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one country by ID.
  ## 
  let valid = call_595064.validator(path, query, header, formData, body)
  let scheme = call_595064.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595064.url(scheme.get, call_595064.host, call_595064.base,
                         call_595064.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595064, url, valid)

proc call*(call_595065: Call_DfareportingCountriesGet_595052; profileId: string;
          dartId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCountriesGet
  ## Gets one country by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   dartId: string (required)
  ##         : Country DART ID.
  var path_595066 = newJObject()
  var query_595067 = newJObject()
  add(path_595066, "profileId", newJString(profileId))
  add(query_595067, "fields", newJString(fields))
  add(query_595067, "quotaUser", newJString(quotaUser))
  add(query_595067, "alt", newJString(alt))
  add(query_595067, "oauth_token", newJString(oauthToken))
  add(query_595067, "userIp", newJString(userIp))
  add(query_595067, "key", newJString(key))
  add(query_595067, "prettyPrint", newJBool(prettyPrint))
  add(path_595066, "dartId", newJString(dartId))
  result = call_595065.call(path_595066, query_595067, nil, nil, nil)

var dfareportingCountriesGet* = Call_DfareportingCountriesGet_595052(
    name: "dfareportingCountriesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/countries/{dartId}",
    validator: validate_DfareportingCountriesGet_595053,
    base: "/dfareporting/v2.7", url: url_DfareportingCountriesGet_595054,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeAssetsInsert_595068 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeAssetsInsert_595070(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "advertiserId" in path, "`advertiserId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeAssets/"),
               (kind: VariableSegment, value: "advertiserId"),
               (kind: ConstantSegment, value: "/creativeAssets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeAssetsInsert_595069(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative asset.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   advertiserId: JString (required)
  ##               : Advertiser ID of this creative. This is a required field.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595071 = path.getOrDefault("profileId")
  valid_595071 = validateParameter(valid_595071, JString, required = true,
                                 default = nil)
  if valid_595071 != nil:
    section.add "profileId", valid_595071
  var valid_595072 = path.getOrDefault("advertiserId")
  valid_595072 = validateParameter(valid_595072, JString, required = true,
                                 default = nil)
  if valid_595072 != nil:
    section.add "advertiserId", valid_595072
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595073 = query.getOrDefault("fields")
  valid_595073 = validateParameter(valid_595073, JString, required = false,
                                 default = nil)
  if valid_595073 != nil:
    section.add "fields", valid_595073
  var valid_595074 = query.getOrDefault("quotaUser")
  valid_595074 = validateParameter(valid_595074, JString, required = false,
                                 default = nil)
  if valid_595074 != nil:
    section.add "quotaUser", valid_595074
  var valid_595075 = query.getOrDefault("alt")
  valid_595075 = validateParameter(valid_595075, JString, required = false,
                                 default = newJString("json"))
  if valid_595075 != nil:
    section.add "alt", valid_595075
  var valid_595076 = query.getOrDefault("oauth_token")
  valid_595076 = validateParameter(valid_595076, JString, required = false,
                                 default = nil)
  if valid_595076 != nil:
    section.add "oauth_token", valid_595076
  var valid_595077 = query.getOrDefault("userIp")
  valid_595077 = validateParameter(valid_595077, JString, required = false,
                                 default = nil)
  if valid_595077 != nil:
    section.add "userIp", valid_595077
  var valid_595078 = query.getOrDefault("key")
  valid_595078 = validateParameter(valid_595078, JString, required = false,
                                 default = nil)
  if valid_595078 != nil:
    section.add "key", valid_595078
  var valid_595079 = query.getOrDefault("prettyPrint")
  valid_595079 = validateParameter(valid_595079, JBool, required = false,
                                 default = newJBool(true))
  if valid_595079 != nil:
    section.add "prettyPrint", valid_595079
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595081: Call_DfareportingCreativeAssetsInsert_595068;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative asset.
  ## 
  let valid = call_595081.validator(path, query, header, formData, body)
  let scheme = call_595081.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595081.url(scheme.get, call_595081.host, call_595081.base,
                         call_595081.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595081, url, valid)

proc call*(call_595082: Call_DfareportingCreativeAssetsInsert_595068;
          profileId: string; advertiserId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeAssetsInsert
  ## Inserts a new creative asset.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserId: string (required)
  ##               : Advertiser ID of this creative. This is a required field.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595083 = newJObject()
  var query_595084 = newJObject()
  var body_595085 = newJObject()
  add(path_595083, "profileId", newJString(profileId))
  add(query_595084, "fields", newJString(fields))
  add(query_595084, "quotaUser", newJString(quotaUser))
  add(query_595084, "alt", newJString(alt))
  add(query_595084, "oauth_token", newJString(oauthToken))
  add(query_595084, "userIp", newJString(userIp))
  add(query_595084, "key", newJString(key))
  add(path_595083, "advertiserId", newJString(advertiserId))
  if body != nil:
    body_595085 = body
  add(query_595084, "prettyPrint", newJBool(prettyPrint))
  result = call_595082.call(path_595083, query_595084, nil, nil, body_595085)

var dfareportingCreativeAssetsInsert* = Call_DfareportingCreativeAssetsInsert_595068(
    name: "dfareportingCreativeAssetsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeAssets/{advertiserId}/creativeAssets",
    validator: validate_DfareportingCreativeAssetsInsert_595069,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeAssetsInsert_595070,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsUpdate_595108 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeFieldsUpdate_595110(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsUpdate_595109(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595111 = path.getOrDefault("profileId")
  valid_595111 = validateParameter(valid_595111, JString, required = true,
                                 default = nil)
  if valid_595111 != nil:
    section.add "profileId", valid_595111
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595112 = query.getOrDefault("fields")
  valid_595112 = validateParameter(valid_595112, JString, required = false,
                                 default = nil)
  if valid_595112 != nil:
    section.add "fields", valid_595112
  var valid_595113 = query.getOrDefault("quotaUser")
  valid_595113 = validateParameter(valid_595113, JString, required = false,
                                 default = nil)
  if valid_595113 != nil:
    section.add "quotaUser", valid_595113
  var valid_595114 = query.getOrDefault("alt")
  valid_595114 = validateParameter(valid_595114, JString, required = false,
                                 default = newJString("json"))
  if valid_595114 != nil:
    section.add "alt", valid_595114
  var valid_595115 = query.getOrDefault("oauth_token")
  valid_595115 = validateParameter(valid_595115, JString, required = false,
                                 default = nil)
  if valid_595115 != nil:
    section.add "oauth_token", valid_595115
  var valid_595116 = query.getOrDefault("userIp")
  valid_595116 = validateParameter(valid_595116, JString, required = false,
                                 default = nil)
  if valid_595116 != nil:
    section.add "userIp", valid_595116
  var valid_595117 = query.getOrDefault("key")
  valid_595117 = validateParameter(valid_595117, JString, required = false,
                                 default = nil)
  if valid_595117 != nil:
    section.add "key", valid_595117
  var valid_595118 = query.getOrDefault("prettyPrint")
  valid_595118 = validateParameter(valid_595118, JBool, required = false,
                                 default = newJBool(true))
  if valid_595118 != nil:
    section.add "prettyPrint", valid_595118
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595120: Call_DfareportingCreativeFieldsUpdate_595108;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field.
  ## 
  let valid = call_595120.validator(path, query, header, formData, body)
  let scheme = call_595120.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595120.url(scheme.get, call_595120.host, call_595120.base,
                         call_595120.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595120, url, valid)

proc call*(call_595121: Call_DfareportingCreativeFieldsUpdate_595108;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsUpdate
  ## Updates an existing creative field.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595122 = newJObject()
  var query_595123 = newJObject()
  var body_595124 = newJObject()
  add(path_595122, "profileId", newJString(profileId))
  add(query_595123, "fields", newJString(fields))
  add(query_595123, "quotaUser", newJString(quotaUser))
  add(query_595123, "alt", newJString(alt))
  add(query_595123, "oauth_token", newJString(oauthToken))
  add(query_595123, "userIp", newJString(userIp))
  add(query_595123, "key", newJString(key))
  if body != nil:
    body_595124 = body
  add(query_595123, "prettyPrint", newJBool(prettyPrint))
  result = call_595121.call(path_595122, query_595123, nil, nil, body_595124)

var dfareportingCreativeFieldsUpdate* = Call_DfareportingCreativeFieldsUpdate_595108(
    name: "dfareportingCreativeFieldsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsUpdate_595109,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsUpdate_595110,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsInsert_595125 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeFieldsInsert_595127(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsInsert_595126(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative field.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595128 = path.getOrDefault("profileId")
  valid_595128 = validateParameter(valid_595128, JString, required = true,
                                 default = nil)
  if valid_595128 != nil:
    section.add "profileId", valid_595128
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595129 = query.getOrDefault("fields")
  valid_595129 = validateParameter(valid_595129, JString, required = false,
                                 default = nil)
  if valid_595129 != nil:
    section.add "fields", valid_595129
  var valid_595130 = query.getOrDefault("quotaUser")
  valid_595130 = validateParameter(valid_595130, JString, required = false,
                                 default = nil)
  if valid_595130 != nil:
    section.add "quotaUser", valid_595130
  var valid_595131 = query.getOrDefault("alt")
  valid_595131 = validateParameter(valid_595131, JString, required = false,
                                 default = newJString("json"))
  if valid_595131 != nil:
    section.add "alt", valid_595131
  var valid_595132 = query.getOrDefault("oauth_token")
  valid_595132 = validateParameter(valid_595132, JString, required = false,
                                 default = nil)
  if valid_595132 != nil:
    section.add "oauth_token", valid_595132
  var valid_595133 = query.getOrDefault("userIp")
  valid_595133 = validateParameter(valid_595133, JString, required = false,
                                 default = nil)
  if valid_595133 != nil:
    section.add "userIp", valid_595133
  var valid_595134 = query.getOrDefault("key")
  valid_595134 = validateParameter(valid_595134, JString, required = false,
                                 default = nil)
  if valid_595134 != nil:
    section.add "key", valid_595134
  var valid_595135 = query.getOrDefault("prettyPrint")
  valid_595135 = validateParameter(valid_595135, JBool, required = false,
                                 default = newJBool(true))
  if valid_595135 != nil:
    section.add "prettyPrint", valid_595135
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595137: Call_DfareportingCreativeFieldsInsert_595125;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative field.
  ## 
  let valid = call_595137.validator(path, query, header, formData, body)
  let scheme = call_595137.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595137.url(scheme.get, call_595137.host, call_595137.base,
                         call_595137.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595137, url, valid)

proc call*(call_595138: Call_DfareportingCreativeFieldsInsert_595125;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsInsert
  ## Inserts a new creative field.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595139 = newJObject()
  var query_595140 = newJObject()
  var body_595141 = newJObject()
  add(path_595139, "profileId", newJString(profileId))
  add(query_595140, "fields", newJString(fields))
  add(query_595140, "quotaUser", newJString(quotaUser))
  add(query_595140, "alt", newJString(alt))
  add(query_595140, "oauth_token", newJString(oauthToken))
  add(query_595140, "userIp", newJString(userIp))
  add(query_595140, "key", newJString(key))
  if body != nil:
    body_595141 = body
  add(query_595140, "prettyPrint", newJBool(prettyPrint))
  result = call_595138.call(path_595139, query_595140, nil, nil, body_595141)

var dfareportingCreativeFieldsInsert* = Call_DfareportingCreativeFieldsInsert_595125(
    name: "dfareportingCreativeFieldsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsInsert_595126,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsInsert_595127,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsList_595086 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeFieldsList_595088(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsList_595087(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creative fields, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595089 = path.getOrDefault("profileId")
  valid_595089 = validateParameter(valid_595089, JString, required = true,
                                 default = nil)
  if valid_595089 != nil:
    section.add "profileId", valid_595089
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for creative fields by name or ID. Wildcards (*) are allowed. For example, "creativefield*2015" will return creative fields with names like "creativefield June 2015", "creativefield April 2015", or simply "creativefield 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativefield" will match creative fields with the name "my creativefield", "creativefield 2015", or simply "creativefield".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative fields with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only creative fields that belong to these advertisers.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595090 = query.getOrDefault("fields")
  valid_595090 = validateParameter(valid_595090, JString, required = false,
                                 default = nil)
  if valid_595090 != nil:
    section.add "fields", valid_595090
  var valid_595091 = query.getOrDefault("pageToken")
  valid_595091 = validateParameter(valid_595091, JString, required = false,
                                 default = nil)
  if valid_595091 != nil:
    section.add "pageToken", valid_595091
  var valid_595092 = query.getOrDefault("quotaUser")
  valid_595092 = validateParameter(valid_595092, JString, required = false,
                                 default = nil)
  if valid_595092 != nil:
    section.add "quotaUser", valid_595092
  var valid_595093 = query.getOrDefault("sortField")
  valid_595093 = validateParameter(valid_595093, JString, required = false,
                                 default = newJString("ID"))
  if valid_595093 != nil:
    section.add "sortField", valid_595093
  var valid_595094 = query.getOrDefault("alt")
  valid_595094 = validateParameter(valid_595094, JString, required = false,
                                 default = newJString("json"))
  if valid_595094 != nil:
    section.add "alt", valid_595094
  var valid_595095 = query.getOrDefault("searchString")
  valid_595095 = validateParameter(valid_595095, JString, required = false,
                                 default = nil)
  if valid_595095 != nil:
    section.add "searchString", valid_595095
  var valid_595096 = query.getOrDefault("oauth_token")
  valid_595096 = validateParameter(valid_595096, JString, required = false,
                                 default = nil)
  if valid_595096 != nil:
    section.add "oauth_token", valid_595096
  var valid_595097 = query.getOrDefault("userIp")
  valid_595097 = validateParameter(valid_595097, JString, required = false,
                                 default = nil)
  if valid_595097 != nil:
    section.add "userIp", valid_595097
  var valid_595098 = query.getOrDefault("maxResults")
  valid_595098 = validateParameter(valid_595098, JInt, required = false,
                                 default = newJInt(1000))
  if valid_595098 != nil:
    section.add "maxResults", valid_595098
  var valid_595099 = query.getOrDefault("ids")
  valid_595099 = validateParameter(valid_595099, JArray, required = false,
                                 default = nil)
  if valid_595099 != nil:
    section.add "ids", valid_595099
  var valid_595100 = query.getOrDefault("key")
  valid_595100 = validateParameter(valid_595100, JString, required = false,
                                 default = nil)
  if valid_595100 != nil:
    section.add "key", valid_595100
  var valid_595101 = query.getOrDefault("advertiserIds")
  valid_595101 = validateParameter(valid_595101, JArray, required = false,
                                 default = nil)
  if valid_595101 != nil:
    section.add "advertiserIds", valid_595101
  var valid_595102 = query.getOrDefault("sortOrder")
  valid_595102 = validateParameter(valid_595102, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_595102 != nil:
    section.add "sortOrder", valid_595102
  var valid_595103 = query.getOrDefault("prettyPrint")
  valid_595103 = validateParameter(valid_595103, JBool, required = false,
                                 default = newJBool(true))
  if valid_595103 != nil:
    section.add "prettyPrint", valid_595103
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595104: Call_DfareportingCreativeFieldsList_595086; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of creative fields, possibly filtered. This method supports paging.
  ## 
  let valid = call_595104.validator(path, query, header, formData, body)
  let scheme = call_595104.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595104.url(scheme.get, call_595104.host, call_595104.base,
                         call_595104.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595104, url, valid)

proc call*(call_595105: Call_DfareportingCreativeFieldsList_595086;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          advertiserIds: JsonNode = nil; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsList
  ## Retrieves a list of creative fields, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for creative fields by name or ID. Wildcards (*) are allowed. For example, "creativefield*2015" will return creative fields with names like "creativefield June 2015", "creativefield April 2015", or simply "creativefield 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativefield" will match creative fields with the name "my creativefield", "creativefield 2015", or simply "creativefield".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative fields with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only creative fields that belong to these advertisers.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595106 = newJObject()
  var query_595107 = newJObject()
  add(path_595106, "profileId", newJString(profileId))
  add(query_595107, "fields", newJString(fields))
  add(query_595107, "pageToken", newJString(pageToken))
  add(query_595107, "quotaUser", newJString(quotaUser))
  add(query_595107, "sortField", newJString(sortField))
  add(query_595107, "alt", newJString(alt))
  add(query_595107, "searchString", newJString(searchString))
  add(query_595107, "oauth_token", newJString(oauthToken))
  add(query_595107, "userIp", newJString(userIp))
  add(query_595107, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_595107.add "ids", ids
  add(query_595107, "key", newJString(key))
  if advertiserIds != nil:
    query_595107.add "advertiserIds", advertiserIds
  add(query_595107, "sortOrder", newJString(sortOrder))
  add(query_595107, "prettyPrint", newJBool(prettyPrint))
  result = call_595105.call(path_595106, query_595107, nil, nil, nil)

var dfareportingCreativeFieldsList* = Call_DfareportingCreativeFieldsList_595086(
    name: "dfareportingCreativeFieldsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsList_595087,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsList_595088,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsPatch_595142 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeFieldsPatch_595144(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsPatch_595143(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595145 = path.getOrDefault("profileId")
  valid_595145 = validateParameter(valid_595145, JString, required = true,
                                 default = nil)
  if valid_595145 != nil:
    section.add "profileId", valid_595145
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative Field ID
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595146 = query.getOrDefault("fields")
  valid_595146 = validateParameter(valid_595146, JString, required = false,
                                 default = nil)
  if valid_595146 != nil:
    section.add "fields", valid_595146
  var valid_595147 = query.getOrDefault("quotaUser")
  valid_595147 = validateParameter(valid_595147, JString, required = false,
                                 default = nil)
  if valid_595147 != nil:
    section.add "quotaUser", valid_595147
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_595148 = query.getOrDefault("id")
  valid_595148 = validateParameter(valid_595148, JString, required = true,
                                 default = nil)
  if valid_595148 != nil:
    section.add "id", valid_595148
  var valid_595149 = query.getOrDefault("alt")
  valid_595149 = validateParameter(valid_595149, JString, required = false,
                                 default = newJString("json"))
  if valid_595149 != nil:
    section.add "alt", valid_595149
  var valid_595150 = query.getOrDefault("oauth_token")
  valid_595150 = validateParameter(valid_595150, JString, required = false,
                                 default = nil)
  if valid_595150 != nil:
    section.add "oauth_token", valid_595150
  var valid_595151 = query.getOrDefault("userIp")
  valid_595151 = validateParameter(valid_595151, JString, required = false,
                                 default = nil)
  if valid_595151 != nil:
    section.add "userIp", valid_595151
  var valid_595152 = query.getOrDefault("key")
  valid_595152 = validateParameter(valid_595152, JString, required = false,
                                 default = nil)
  if valid_595152 != nil:
    section.add "key", valid_595152
  var valid_595153 = query.getOrDefault("prettyPrint")
  valid_595153 = validateParameter(valid_595153, JBool, required = false,
                                 default = newJBool(true))
  if valid_595153 != nil:
    section.add "prettyPrint", valid_595153
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595155: Call_DfareportingCreativeFieldsPatch_595142;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field. This method supports patch semantics.
  ## 
  let valid = call_595155.validator(path, query, header, formData, body)
  let scheme = call_595155.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595155.url(scheme.get, call_595155.host, call_595155.base,
                         call_595155.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595155, url, valid)

proc call*(call_595156: Call_DfareportingCreativeFieldsPatch_595142;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsPatch
  ## Updates an existing creative field. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative Field ID
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595157 = newJObject()
  var query_595158 = newJObject()
  var body_595159 = newJObject()
  add(path_595157, "profileId", newJString(profileId))
  add(query_595158, "fields", newJString(fields))
  add(query_595158, "quotaUser", newJString(quotaUser))
  add(query_595158, "id", newJString(id))
  add(query_595158, "alt", newJString(alt))
  add(query_595158, "oauth_token", newJString(oauthToken))
  add(query_595158, "userIp", newJString(userIp))
  add(query_595158, "key", newJString(key))
  if body != nil:
    body_595159 = body
  add(query_595158, "prettyPrint", newJBool(prettyPrint))
  result = call_595156.call(path_595157, query_595158, nil, nil, body_595159)

var dfareportingCreativeFieldsPatch* = Call_DfareportingCreativeFieldsPatch_595142(
    name: "dfareportingCreativeFieldsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields",
    validator: validate_DfareportingCreativeFieldsPatch_595143,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsPatch_595144,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesUpdate_595182 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeFieldValuesUpdate_595184(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesUpdate_595183(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field value.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595185 = path.getOrDefault("profileId")
  valid_595185 = validateParameter(valid_595185, JString, required = true,
                                 default = nil)
  if valid_595185 != nil:
    section.add "profileId", valid_595185
  var valid_595186 = path.getOrDefault("creativeFieldId")
  valid_595186 = validateParameter(valid_595186, JString, required = true,
                                 default = nil)
  if valid_595186 != nil:
    section.add "creativeFieldId", valid_595186
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595187 = query.getOrDefault("fields")
  valid_595187 = validateParameter(valid_595187, JString, required = false,
                                 default = nil)
  if valid_595187 != nil:
    section.add "fields", valid_595187
  var valid_595188 = query.getOrDefault("quotaUser")
  valid_595188 = validateParameter(valid_595188, JString, required = false,
                                 default = nil)
  if valid_595188 != nil:
    section.add "quotaUser", valid_595188
  var valid_595189 = query.getOrDefault("alt")
  valid_595189 = validateParameter(valid_595189, JString, required = false,
                                 default = newJString("json"))
  if valid_595189 != nil:
    section.add "alt", valid_595189
  var valid_595190 = query.getOrDefault("oauth_token")
  valid_595190 = validateParameter(valid_595190, JString, required = false,
                                 default = nil)
  if valid_595190 != nil:
    section.add "oauth_token", valid_595190
  var valid_595191 = query.getOrDefault("userIp")
  valid_595191 = validateParameter(valid_595191, JString, required = false,
                                 default = nil)
  if valid_595191 != nil:
    section.add "userIp", valid_595191
  var valid_595192 = query.getOrDefault("key")
  valid_595192 = validateParameter(valid_595192, JString, required = false,
                                 default = nil)
  if valid_595192 != nil:
    section.add "key", valid_595192
  var valid_595193 = query.getOrDefault("prettyPrint")
  valid_595193 = validateParameter(valid_595193, JBool, required = false,
                                 default = newJBool(true))
  if valid_595193 != nil:
    section.add "prettyPrint", valid_595193
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595195: Call_DfareportingCreativeFieldValuesUpdate_595182;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field value.
  ## 
  let valid = call_595195.validator(path, query, header, formData, body)
  let scheme = call_595195.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595195.url(scheme.get, call_595195.host, call_595195.base,
                         call_595195.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595195, url, valid)

proc call*(call_595196: Call_DfareportingCreativeFieldValuesUpdate_595182;
          profileId: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesUpdate
  ## Updates an existing creative field value.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595197 = newJObject()
  var query_595198 = newJObject()
  var body_595199 = newJObject()
  add(path_595197, "profileId", newJString(profileId))
  add(query_595198, "fields", newJString(fields))
  add(query_595198, "quotaUser", newJString(quotaUser))
  add(query_595198, "alt", newJString(alt))
  add(query_595198, "oauth_token", newJString(oauthToken))
  add(query_595198, "userIp", newJString(userIp))
  add(query_595198, "key", newJString(key))
  add(path_595197, "creativeFieldId", newJString(creativeFieldId))
  if body != nil:
    body_595199 = body
  add(query_595198, "prettyPrint", newJBool(prettyPrint))
  result = call_595196.call(path_595197, query_595198, nil, nil, body_595199)

var dfareportingCreativeFieldValuesUpdate* = Call_DfareportingCreativeFieldValuesUpdate_595182(
    name: "dfareportingCreativeFieldValuesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesUpdate_595183,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesUpdate_595184,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesInsert_595200 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeFieldValuesInsert_595202(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesInsert_595201(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative field value.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595203 = path.getOrDefault("profileId")
  valid_595203 = validateParameter(valid_595203, JString, required = true,
                                 default = nil)
  if valid_595203 != nil:
    section.add "profileId", valid_595203
  var valid_595204 = path.getOrDefault("creativeFieldId")
  valid_595204 = validateParameter(valid_595204, JString, required = true,
                                 default = nil)
  if valid_595204 != nil:
    section.add "creativeFieldId", valid_595204
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595205 = query.getOrDefault("fields")
  valid_595205 = validateParameter(valid_595205, JString, required = false,
                                 default = nil)
  if valid_595205 != nil:
    section.add "fields", valid_595205
  var valid_595206 = query.getOrDefault("quotaUser")
  valid_595206 = validateParameter(valid_595206, JString, required = false,
                                 default = nil)
  if valid_595206 != nil:
    section.add "quotaUser", valid_595206
  var valid_595207 = query.getOrDefault("alt")
  valid_595207 = validateParameter(valid_595207, JString, required = false,
                                 default = newJString("json"))
  if valid_595207 != nil:
    section.add "alt", valid_595207
  var valid_595208 = query.getOrDefault("oauth_token")
  valid_595208 = validateParameter(valid_595208, JString, required = false,
                                 default = nil)
  if valid_595208 != nil:
    section.add "oauth_token", valid_595208
  var valid_595209 = query.getOrDefault("userIp")
  valid_595209 = validateParameter(valid_595209, JString, required = false,
                                 default = nil)
  if valid_595209 != nil:
    section.add "userIp", valid_595209
  var valid_595210 = query.getOrDefault("key")
  valid_595210 = validateParameter(valid_595210, JString, required = false,
                                 default = nil)
  if valid_595210 != nil:
    section.add "key", valid_595210
  var valid_595211 = query.getOrDefault("prettyPrint")
  valid_595211 = validateParameter(valid_595211, JBool, required = false,
                                 default = newJBool(true))
  if valid_595211 != nil:
    section.add "prettyPrint", valid_595211
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595213: Call_DfareportingCreativeFieldValuesInsert_595200;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative field value.
  ## 
  let valid = call_595213.validator(path, query, header, formData, body)
  let scheme = call_595213.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595213.url(scheme.get, call_595213.host, call_595213.base,
                         call_595213.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595213, url, valid)

proc call*(call_595214: Call_DfareportingCreativeFieldValuesInsert_595200;
          profileId: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesInsert
  ## Inserts a new creative field value.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595215 = newJObject()
  var query_595216 = newJObject()
  var body_595217 = newJObject()
  add(path_595215, "profileId", newJString(profileId))
  add(query_595216, "fields", newJString(fields))
  add(query_595216, "quotaUser", newJString(quotaUser))
  add(query_595216, "alt", newJString(alt))
  add(query_595216, "oauth_token", newJString(oauthToken))
  add(query_595216, "userIp", newJString(userIp))
  add(query_595216, "key", newJString(key))
  add(path_595215, "creativeFieldId", newJString(creativeFieldId))
  if body != nil:
    body_595217 = body
  add(query_595216, "prettyPrint", newJBool(prettyPrint))
  result = call_595214.call(path_595215, query_595216, nil, nil, body_595217)

var dfareportingCreativeFieldValuesInsert* = Call_DfareportingCreativeFieldValuesInsert_595200(
    name: "dfareportingCreativeFieldValuesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesInsert_595201,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesInsert_595202,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesList_595160 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeFieldValuesList_595162(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesList_595161(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creative field values, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595163 = path.getOrDefault("profileId")
  valid_595163 = validateParameter(valid_595163, JString, required = true,
                                 default = nil)
  if valid_595163 != nil:
    section.add "profileId", valid_595163
  var valid_595164 = path.getOrDefault("creativeFieldId")
  valid_595164 = validateParameter(valid_595164, JString, required = true,
                                 default = nil)
  if valid_595164 != nil:
    section.add "creativeFieldId", valid_595164
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for creative field values by their values. Wildcards (e.g. *) are not allowed.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative field values with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595165 = query.getOrDefault("fields")
  valid_595165 = validateParameter(valid_595165, JString, required = false,
                                 default = nil)
  if valid_595165 != nil:
    section.add "fields", valid_595165
  var valid_595166 = query.getOrDefault("pageToken")
  valid_595166 = validateParameter(valid_595166, JString, required = false,
                                 default = nil)
  if valid_595166 != nil:
    section.add "pageToken", valid_595166
  var valid_595167 = query.getOrDefault("quotaUser")
  valid_595167 = validateParameter(valid_595167, JString, required = false,
                                 default = nil)
  if valid_595167 != nil:
    section.add "quotaUser", valid_595167
  var valid_595168 = query.getOrDefault("sortField")
  valid_595168 = validateParameter(valid_595168, JString, required = false,
                                 default = newJString("ID"))
  if valid_595168 != nil:
    section.add "sortField", valid_595168
  var valid_595169 = query.getOrDefault("alt")
  valid_595169 = validateParameter(valid_595169, JString, required = false,
                                 default = newJString("json"))
  if valid_595169 != nil:
    section.add "alt", valid_595169
  var valid_595170 = query.getOrDefault("searchString")
  valid_595170 = validateParameter(valid_595170, JString, required = false,
                                 default = nil)
  if valid_595170 != nil:
    section.add "searchString", valid_595170
  var valid_595171 = query.getOrDefault("oauth_token")
  valid_595171 = validateParameter(valid_595171, JString, required = false,
                                 default = nil)
  if valid_595171 != nil:
    section.add "oauth_token", valid_595171
  var valid_595172 = query.getOrDefault("userIp")
  valid_595172 = validateParameter(valid_595172, JString, required = false,
                                 default = nil)
  if valid_595172 != nil:
    section.add "userIp", valid_595172
  var valid_595173 = query.getOrDefault("maxResults")
  valid_595173 = validateParameter(valid_595173, JInt, required = false,
                                 default = newJInt(1000))
  if valid_595173 != nil:
    section.add "maxResults", valid_595173
  var valid_595174 = query.getOrDefault("ids")
  valid_595174 = validateParameter(valid_595174, JArray, required = false,
                                 default = nil)
  if valid_595174 != nil:
    section.add "ids", valid_595174
  var valid_595175 = query.getOrDefault("key")
  valid_595175 = validateParameter(valid_595175, JString, required = false,
                                 default = nil)
  if valid_595175 != nil:
    section.add "key", valid_595175
  var valid_595176 = query.getOrDefault("sortOrder")
  valid_595176 = validateParameter(valid_595176, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_595176 != nil:
    section.add "sortOrder", valid_595176
  var valid_595177 = query.getOrDefault("prettyPrint")
  valid_595177 = validateParameter(valid_595177, JBool, required = false,
                                 default = newJBool(true))
  if valid_595177 != nil:
    section.add "prettyPrint", valid_595177
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595178: Call_DfareportingCreativeFieldValuesList_595160;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of creative field values, possibly filtered. This method supports paging.
  ## 
  let valid = call_595178.validator(path, query, header, formData, body)
  let scheme = call_595178.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595178.url(scheme.get, call_595178.host, call_595178.base,
                         call_595178.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595178, url, valid)

proc call*(call_595179: Call_DfareportingCreativeFieldValuesList_595160;
          profileId: string; creativeFieldId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; searchString: string = ""; oauthToken: string = "";
          userIp: string = ""; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesList
  ## Retrieves a list of creative field values, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for creative field values by their values. Wildcards (e.g. *) are not allowed.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative field values with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595180 = newJObject()
  var query_595181 = newJObject()
  add(path_595180, "profileId", newJString(profileId))
  add(query_595181, "fields", newJString(fields))
  add(query_595181, "pageToken", newJString(pageToken))
  add(query_595181, "quotaUser", newJString(quotaUser))
  add(query_595181, "sortField", newJString(sortField))
  add(query_595181, "alt", newJString(alt))
  add(query_595181, "searchString", newJString(searchString))
  add(query_595181, "oauth_token", newJString(oauthToken))
  add(query_595181, "userIp", newJString(userIp))
  add(query_595181, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_595181.add "ids", ids
  add(query_595181, "key", newJString(key))
  add(query_595181, "sortOrder", newJString(sortOrder))
  add(path_595180, "creativeFieldId", newJString(creativeFieldId))
  add(query_595181, "prettyPrint", newJBool(prettyPrint))
  result = call_595179.call(path_595180, query_595181, nil, nil, nil)

var dfareportingCreativeFieldValuesList* = Call_DfareportingCreativeFieldValuesList_595160(
    name: "dfareportingCreativeFieldValuesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesList_595161,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesList_595162,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesPatch_595218 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeFieldValuesPatch_595220(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesPatch_595219(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative field value. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595221 = path.getOrDefault("profileId")
  valid_595221 = validateParameter(valid_595221, JString, required = true,
                                 default = nil)
  if valid_595221 != nil:
    section.add "profileId", valid_595221
  var valid_595222 = path.getOrDefault("creativeFieldId")
  valid_595222 = validateParameter(valid_595222, JString, required = true,
                                 default = nil)
  if valid_595222 != nil:
    section.add "creativeFieldId", valid_595222
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative Field Value ID
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595223 = query.getOrDefault("fields")
  valid_595223 = validateParameter(valid_595223, JString, required = false,
                                 default = nil)
  if valid_595223 != nil:
    section.add "fields", valid_595223
  var valid_595224 = query.getOrDefault("quotaUser")
  valid_595224 = validateParameter(valid_595224, JString, required = false,
                                 default = nil)
  if valid_595224 != nil:
    section.add "quotaUser", valid_595224
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_595225 = query.getOrDefault("id")
  valid_595225 = validateParameter(valid_595225, JString, required = true,
                                 default = nil)
  if valid_595225 != nil:
    section.add "id", valid_595225
  var valid_595226 = query.getOrDefault("alt")
  valid_595226 = validateParameter(valid_595226, JString, required = false,
                                 default = newJString("json"))
  if valid_595226 != nil:
    section.add "alt", valid_595226
  var valid_595227 = query.getOrDefault("oauth_token")
  valid_595227 = validateParameter(valid_595227, JString, required = false,
                                 default = nil)
  if valid_595227 != nil:
    section.add "oauth_token", valid_595227
  var valid_595228 = query.getOrDefault("userIp")
  valid_595228 = validateParameter(valid_595228, JString, required = false,
                                 default = nil)
  if valid_595228 != nil:
    section.add "userIp", valid_595228
  var valid_595229 = query.getOrDefault("key")
  valid_595229 = validateParameter(valid_595229, JString, required = false,
                                 default = nil)
  if valid_595229 != nil:
    section.add "key", valid_595229
  var valid_595230 = query.getOrDefault("prettyPrint")
  valid_595230 = validateParameter(valid_595230, JBool, required = false,
                                 default = newJBool(true))
  if valid_595230 != nil:
    section.add "prettyPrint", valid_595230
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595232: Call_DfareportingCreativeFieldValuesPatch_595218;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative field value. This method supports patch semantics.
  ## 
  let valid = call_595232.validator(path, query, header, formData, body)
  let scheme = call_595232.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595232.url(scheme.get, call_595232.host, call_595232.base,
                         call_595232.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595232, url, valid)

proc call*(call_595233: Call_DfareportingCreativeFieldValuesPatch_595218;
          profileId: string; id: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesPatch
  ## Updates an existing creative field value. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative Field Value ID
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595234 = newJObject()
  var query_595235 = newJObject()
  var body_595236 = newJObject()
  add(path_595234, "profileId", newJString(profileId))
  add(query_595235, "fields", newJString(fields))
  add(query_595235, "quotaUser", newJString(quotaUser))
  add(query_595235, "id", newJString(id))
  add(query_595235, "alt", newJString(alt))
  add(query_595235, "oauth_token", newJString(oauthToken))
  add(query_595235, "userIp", newJString(userIp))
  add(query_595235, "key", newJString(key))
  add(path_595234, "creativeFieldId", newJString(creativeFieldId))
  if body != nil:
    body_595236 = body
  add(query_595235, "prettyPrint", newJBool(prettyPrint))
  result = call_595233.call(path_595234, query_595235, nil, nil, body_595236)

var dfareportingCreativeFieldValuesPatch* = Call_DfareportingCreativeFieldValuesPatch_595218(
    name: "dfareportingCreativeFieldValuesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues",
    validator: validate_DfareportingCreativeFieldValuesPatch_595219,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesPatch_595220,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesGet_595237 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeFieldValuesGet_595239(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesGet_595238(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative field value by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field Value ID
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595240 = path.getOrDefault("profileId")
  valid_595240 = validateParameter(valid_595240, JString, required = true,
                                 default = nil)
  if valid_595240 != nil:
    section.add "profileId", valid_595240
  var valid_595241 = path.getOrDefault("id")
  valid_595241 = validateParameter(valid_595241, JString, required = true,
                                 default = nil)
  if valid_595241 != nil:
    section.add "id", valid_595241
  var valid_595242 = path.getOrDefault("creativeFieldId")
  valid_595242 = validateParameter(valid_595242, JString, required = true,
                                 default = nil)
  if valid_595242 != nil:
    section.add "creativeFieldId", valid_595242
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595243 = query.getOrDefault("fields")
  valid_595243 = validateParameter(valid_595243, JString, required = false,
                                 default = nil)
  if valid_595243 != nil:
    section.add "fields", valid_595243
  var valid_595244 = query.getOrDefault("quotaUser")
  valid_595244 = validateParameter(valid_595244, JString, required = false,
                                 default = nil)
  if valid_595244 != nil:
    section.add "quotaUser", valid_595244
  var valid_595245 = query.getOrDefault("alt")
  valid_595245 = validateParameter(valid_595245, JString, required = false,
                                 default = newJString("json"))
  if valid_595245 != nil:
    section.add "alt", valid_595245
  var valid_595246 = query.getOrDefault("oauth_token")
  valid_595246 = validateParameter(valid_595246, JString, required = false,
                                 default = nil)
  if valid_595246 != nil:
    section.add "oauth_token", valid_595246
  var valid_595247 = query.getOrDefault("userIp")
  valid_595247 = validateParameter(valid_595247, JString, required = false,
                                 default = nil)
  if valid_595247 != nil:
    section.add "userIp", valid_595247
  var valid_595248 = query.getOrDefault("key")
  valid_595248 = validateParameter(valid_595248, JString, required = false,
                                 default = nil)
  if valid_595248 != nil:
    section.add "key", valid_595248
  var valid_595249 = query.getOrDefault("prettyPrint")
  valid_595249 = validateParameter(valid_595249, JBool, required = false,
                                 default = newJBool(true))
  if valid_595249 != nil:
    section.add "prettyPrint", valid_595249
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595250: Call_DfareportingCreativeFieldValuesGet_595237;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one creative field value by ID.
  ## 
  let valid = call_595250.validator(path, query, header, formData, body)
  let scheme = call_595250.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595250.url(scheme.get, call_595250.host, call_595250.base,
                         call_595250.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595250, url, valid)

proc call*(call_595251: Call_DfareportingCreativeFieldValuesGet_595237;
          profileId: string; id: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesGet
  ## Gets one creative field value by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative Field Value ID
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595252 = newJObject()
  var query_595253 = newJObject()
  add(path_595252, "profileId", newJString(profileId))
  add(query_595253, "fields", newJString(fields))
  add(query_595253, "quotaUser", newJString(quotaUser))
  add(query_595253, "alt", newJString(alt))
  add(query_595253, "oauth_token", newJString(oauthToken))
  add(query_595253, "userIp", newJString(userIp))
  add(path_595252, "id", newJString(id))
  add(query_595253, "key", newJString(key))
  add(path_595252, "creativeFieldId", newJString(creativeFieldId))
  add(query_595253, "prettyPrint", newJBool(prettyPrint))
  result = call_595251.call(path_595252, query_595253, nil, nil, nil)

var dfareportingCreativeFieldValuesGet* = Call_DfareportingCreativeFieldValuesGet_595237(
    name: "dfareportingCreativeFieldValuesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues/{id}",
    validator: validate_DfareportingCreativeFieldValuesGet_595238,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesGet_595239,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldValuesDelete_595254 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeFieldValuesDelete_595256(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "creativeFieldId" in path, "`creativeFieldId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "creativeFieldId"),
               (kind: ConstantSegment, value: "/creativeFieldValues/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldValuesDelete_595255(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing creative field value.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field Value ID
  ##   creativeFieldId: JString (required)
  ##                  : Creative field ID for this creative field value.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595257 = path.getOrDefault("profileId")
  valid_595257 = validateParameter(valid_595257, JString, required = true,
                                 default = nil)
  if valid_595257 != nil:
    section.add "profileId", valid_595257
  var valid_595258 = path.getOrDefault("id")
  valid_595258 = validateParameter(valid_595258, JString, required = true,
                                 default = nil)
  if valid_595258 != nil:
    section.add "id", valid_595258
  var valid_595259 = path.getOrDefault("creativeFieldId")
  valid_595259 = validateParameter(valid_595259, JString, required = true,
                                 default = nil)
  if valid_595259 != nil:
    section.add "creativeFieldId", valid_595259
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595260 = query.getOrDefault("fields")
  valid_595260 = validateParameter(valid_595260, JString, required = false,
                                 default = nil)
  if valid_595260 != nil:
    section.add "fields", valid_595260
  var valid_595261 = query.getOrDefault("quotaUser")
  valid_595261 = validateParameter(valid_595261, JString, required = false,
                                 default = nil)
  if valid_595261 != nil:
    section.add "quotaUser", valid_595261
  var valid_595262 = query.getOrDefault("alt")
  valid_595262 = validateParameter(valid_595262, JString, required = false,
                                 default = newJString("json"))
  if valid_595262 != nil:
    section.add "alt", valid_595262
  var valid_595263 = query.getOrDefault("oauth_token")
  valid_595263 = validateParameter(valid_595263, JString, required = false,
                                 default = nil)
  if valid_595263 != nil:
    section.add "oauth_token", valid_595263
  var valid_595264 = query.getOrDefault("userIp")
  valid_595264 = validateParameter(valid_595264, JString, required = false,
                                 default = nil)
  if valid_595264 != nil:
    section.add "userIp", valid_595264
  var valid_595265 = query.getOrDefault("key")
  valid_595265 = validateParameter(valid_595265, JString, required = false,
                                 default = nil)
  if valid_595265 != nil:
    section.add "key", valid_595265
  var valid_595266 = query.getOrDefault("prettyPrint")
  valid_595266 = validateParameter(valid_595266, JBool, required = false,
                                 default = newJBool(true))
  if valid_595266 != nil:
    section.add "prettyPrint", valid_595266
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595267: Call_DfareportingCreativeFieldValuesDelete_595254;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing creative field value.
  ## 
  let valid = call_595267.validator(path, query, header, formData, body)
  let scheme = call_595267.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595267.url(scheme.get, call_595267.host, call_595267.base,
                         call_595267.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595267, url, valid)

proc call*(call_595268: Call_DfareportingCreativeFieldValuesDelete_595254;
          profileId: string; id: string; creativeFieldId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldValuesDelete
  ## Deletes an existing creative field value.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative Field Value ID
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldId: string (required)
  ##                  : Creative field ID for this creative field value.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595269 = newJObject()
  var query_595270 = newJObject()
  add(path_595269, "profileId", newJString(profileId))
  add(query_595270, "fields", newJString(fields))
  add(query_595270, "quotaUser", newJString(quotaUser))
  add(query_595270, "alt", newJString(alt))
  add(query_595270, "oauth_token", newJString(oauthToken))
  add(query_595270, "userIp", newJString(userIp))
  add(path_595269, "id", newJString(id))
  add(query_595270, "key", newJString(key))
  add(path_595269, "creativeFieldId", newJString(creativeFieldId))
  add(query_595270, "prettyPrint", newJBool(prettyPrint))
  result = call_595268.call(path_595269, query_595270, nil, nil, nil)

var dfareportingCreativeFieldValuesDelete* = Call_DfareportingCreativeFieldValuesDelete_595254(
    name: "dfareportingCreativeFieldValuesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues/{id}",
    validator: validate_DfareportingCreativeFieldValuesDelete_595255,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldValuesDelete_595256,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsGet_595271 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeFieldsGet_595273(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsGet_595272(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative field by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595274 = path.getOrDefault("profileId")
  valid_595274 = validateParameter(valid_595274, JString, required = true,
                                 default = nil)
  if valid_595274 != nil:
    section.add "profileId", valid_595274
  var valid_595275 = path.getOrDefault("id")
  valid_595275 = validateParameter(valid_595275, JString, required = true,
                                 default = nil)
  if valid_595275 != nil:
    section.add "id", valid_595275
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595276 = query.getOrDefault("fields")
  valid_595276 = validateParameter(valid_595276, JString, required = false,
                                 default = nil)
  if valid_595276 != nil:
    section.add "fields", valid_595276
  var valid_595277 = query.getOrDefault("quotaUser")
  valid_595277 = validateParameter(valid_595277, JString, required = false,
                                 default = nil)
  if valid_595277 != nil:
    section.add "quotaUser", valid_595277
  var valid_595278 = query.getOrDefault("alt")
  valid_595278 = validateParameter(valid_595278, JString, required = false,
                                 default = newJString("json"))
  if valid_595278 != nil:
    section.add "alt", valid_595278
  var valid_595279 = query.getOrDefault("oauth_token")
  valid_595279 = validateParameter(valid_595279, JString, required = false,
                                 default = nil)
  if valid_595279 != nil:
    section.add "oauth_token", valid_595279
  var valid_595280 = query.getOrDefault("userIp")
  valid_595280 = validateParameter(valid_595280, JString, required = false,
                                 default = nil)
  if valid_595280 != nil:
    section.add "userIp", valid_595280
  var valid_595281 = query.getOrDefault("key")
  valid_595281 = validateParameter(valid_595281, JString, required = false,
                                 default = nil)
  if valid_595281 != nil:
    section.add "key", valid_595281
  var valid_595282 = query.getOrDefault("prettyPrint")
  valid_595282 = validateParameter(valid_595282, JBool, required = false,
                                 default = newJBool(true))
  if valid_595282 != nil:
    section.add "prettyPrint", valid_595282
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595283: Call_DfareportingCreativeFieldsGet_595271; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one creative field by ID.
  ## 
  let valid = call_595283.validator(path, query, header, formData, body)
  let scheme = call_595283.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595283.url(scheme.get, call_595283.host, call_595283.base,
                         call_595283.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595283, url, valid)

proc call*(call_595284: Call_DfareportingCreativeFieldsGet_595271;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsGet
  ## Gets one creative field by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative Field ID
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595285 = newJObject()
  var query_595286 = newJObject()
  add(path_595285, "profileId", newJString(profileId))
  add(query_595286, "fields", newJString(fields))
  add(query_595286, "quotaUser", newJString(quotaUser))
  add(query_595286, "alt", newJString(alt))
  add(query_595286, "oauth_token", newJString(oauthToken))
  add(query_595286, "userIp", newJString(userIp))
  add(path_595285, "id", newJString(id))
  add(query_595286, "key", newJString(key))
  add(query_595286, "prettyPrint", newJBool(prettyPrint))
  result = call_595284.call(path_595285, query_595286, nil, nil, nil)

var dfareportingCreativeFieldsGet* = Call_DfareportingCreativeFieldsGet_595271(
    name: "dfareportingCreativeFieldsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/creativeFields/{id}",
    validator: validate_DfareportingCreativeFieldsGet_595272,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsGet_595273,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeFieldsDelete_595287 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeFieldsDelete_595289(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeFields/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeFieldsDelete_595288(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing creative field.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative Field ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595290 = path.getOrDefault("profileId")
  valid_595290 = validateParameter(valid_595290, JString, required = true,
                                 default = nil)
  if valid_595290 != nil:
    section.add "profileId", valid_595290
  var valid_595291 = path.getOrDefault("id")
  valid_595291 = validateParameter(valid_595291, JString, required = true,
                                 default = nil)
  if valid_595291 != nil:
    section.add "id", valid_595291
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595292 = query.getOrDefault("fields")
  valid_595292 = validateParameter(valid_595292, JString, required = false,
                                 default = nil)
  if valid_595292 != nil:
    section.add "fields", valid_595292
  var valid_595293 = query.getOrDefault("quotaUser")
  valid_595293 = validateParameter(valid_595293, JString, required = false,
                                 default = nil)
  if valid_595293 != nil:
    section.add "quotaUser", valid_595293
  var valid_595294 = query.getOrDefault("alt")
  valid_595294 = validateParameter(valid_595294, JString, required = false,
                                 default = newJString("json"))
  if valid_595294 != nil:
    section.add "alt", valid_595294
  var valid_595295 = query.getOrDefault("oauth_token")
  valid_595295 = validateParameter(valid_595295, JString, required = false,
                                 default = nil)
  if valid_595295 != nil:
    section.add "oauth_token", valid_595295
  var valid_595296 = query.getOrDefault("userIp")
  valid_595296 = validateParameter(valid_595296, JString, required = false,
                                 default = nil)
  if valid_595296 != nil:
    section.add "userIp", valid_595296
  var valid_595297 = query.getOrDefault("key")
  valid_595297 = validateParameter(valid_595297, JString, required = false,
                                 default = nil)
  if valid_595297 != nil:
    section.add "key", valid_595297
  var valid_595298 = query.getOrDefault("prettyPrint")
  valid_595298 = validateParameter(valid_595298, JBool, required = false,
                                 default = newJBool(true))
  if valid_595298 != nil:
    section.add "prettyPrint", valid_595298
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595299: Call_DfareportingCreativeFieldsDelete_595287;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing creative field.
  ## 
  let valid = call_595299.validator(path, query, header, formData, body)
  let scheme = call_595299.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595299.url(scheme.get, call_595299.host, call_595299.base,
                         call_595299.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595299, url, valid)

proc call*(call_595300: Call_DfareportingCreativeFieldsDelete_595287;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeFieldsDelete
  ## Deletes an existing creative field.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative Field ID
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595301 = newJObject()
  var query_595302 = newJObject()
  add(path_595301, "profileId", newJString(profileId))
  add(query_595302, "fields", newJString(fields))
  add(query_595302, "quotaUser", newJString(quotaUser))
  add(query_595302, "alt", newJString(alt))
  add(query_595302, "oauth_token", newJString(oauthToken))
  add(query_595302, "userIp", newJString(userIp))
  add(path_595301, "id", newJString(id))
  add(query_595302, "key", newJString(key))
  add(query_595302, "prettyPrint", newJBool(prettyPrint))
  result = call_595300.call(path_595301, query_595302, nil, nil, nil)

var dfareportingCreativeFieldsDelete* = Call_DfareportingCreativeFieldsDelete_595287(
    name: "dfareportingCreativeFieldsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/creativeFields/{id}",
    validator: validate_DfareportingCreativeFieldsDelete_595288,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeFieldsDelete_595289,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsUpdate_595326 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeGroupsUpdate_595328(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsUpdate_595327(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595329 = path.getOrDefault("profileId")
  valid_595329 = validateParameter(valid_595329, JString, required = true,
                                 default = nil)
  if valid_595329 != nil:
    section.add "profileId", valid_595329
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595330 = query.getOrDefault("fields")
  valid_595330 = validateParameter(valid_595330, JString, required = false,
                                 default = nil)
  if valid_595330 != nil:
    section.add "fields", valid_595330
  var valid_595331 = query.getOrDefault("quotaUser")
  valid_595331 = validateParameter(valid_595331, JString, required = false,
                                 default = nil)
  if valid_595331 != nil:
    section.add "quotaUser", valid_595331
  var valid_595332 = query.getOrDefault("alt")
  valid_595332 = validateParameter(valid_595332, JString, required = false,
                                 default = newJString("json"))
  if valid_595332 != nil:
    section.add "alt", valid_595332
  var valid_595333 = query.getOrDefault("oauth_token")
  valid_595333 = validateParameter(valid_595333, JString, required = false,
                                 default = nil)
  if valid_595333 != nil:
    section.add "oauth_token", valid_595333
  var valid_595334 = query.getOrDefault("userIp")
  valid_595334 = validateParameter(valid_595334, JString, required = false,
                                 default = nil)
  if valid_595334 != nil:
    section.add "userIp", valid_595334
  var valid_595335 = query.getOrDefault("key")
  valid_595335 = validateParameter(valid_595335, JString, required = false,
                                 default = nil)
  if valid_595335 != nil:
    section.add "key", valid_595335
  var valid_595336 = query.getOrDefault("prettyPrint")
  valid_595336 = validateParameter(valid_595336, JBool, required = false,
                                 default = newJBool(true))
  if valid_595336 != nil:
    section.add "prettyPrint", valid_595336
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595338: Call_DfareportingCreativeGroupsUpdate_595326;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative group.
  ## 
  let valid = call_595338.validator(path, query, header, formData, body)
  let scheme = call_595338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595338.url(scheme.get, call_595338.host, call_595338.base,
                         call_595338.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595338, url, valid)

proc call*(call_595339: Call_DfareportingCreativeGroupsUpdate_595326;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsUpdate
  ## Updates an existing creative group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595340 = newJObject()
  var query_595341 = newJObject()
  var body_595342 = newJObject()
  add(path_595340, "profileId", newJString(profileId))
  add(query_595341, "fields", newJString(fields))
  add(query_595341, "quotaUser", newJString(quotaUser))
  add(query_595341, "alt", newJString(alt))
  add(query_595341, "oauth_token", newJString(oauthToken))
  add(query_595341, "userIp", newJString(userIp))
  add(query_595341, "key", newJString(key))
  if body != nil:
    body_595342 = body
  add(query_595341, "prettyPrint", newJBool(prettyPrint))
  result = call_595339.call(path_595340, query_595341, nil, nil, body_595342)

var dfareportingCreativeGroupsUpdate* = Call_DfareportingCreativeGroupsUpdate_595326(
    name: "dfareportingCreativeGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsUpdate_595327,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsUpdate_595328,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsInsert_595343 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeGroupsInsert_595345(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsInsert_595344(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595346 = path.getOrDefault("profileId")
  valid_595346 = validateParameter(valid_595346, JString, required = true,
                                 default = nil)
  if valid_595346 != nil:
    section.add "profileId", valid_595346
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595347 = query.getOrDefault("fields")
  valid_595347 = validateParameter(valid_595347, JString, required = false,
                                 default = nil)
  if valid_595347 != nil:
    section.add "fields", valid_595347
  var valid_595348 = query.getOrDefault("quotaUser")
  valid_595348 = validateParameter(valid_595348, JString, required = false,
                                 default = nil)
  if valid_595348 != nil:
    section.add "quotaUser", valid_595348
  var valid_595349 = query.getOrDefault("alt")
  valid_595349 = validateParameter(valid_595349, JString, required = false,
                                 default = newJString("json"))
  if valid_595349 != nil:
    section.add "alt", valid_595349
  var valid_595350 = query.getOrDefault("oauth_token")
  valid_595350 = validateParameter(valid_595350, JString, required = false,
                                 default = nil)
  if valid_595350 != nil:
    section.add "oauth_token", valid_595350
  var valid_595351 = query.getOrDefault("userIp")
  valid_595351 = validateParameter(valid_595351, JString, required = false,
                                 default = nil)
  if valid_595351 != nil:
    section.add "userIp", valid_595351
  var valid_595352 = query.getOrDefault("key")
  valid_595352 = validateParameter(valid_595352, JString, required = false,
                                 default = nil)
  if valid_595352 != nil:
    section.add "key", valid_595352
  var valid_595353 = query.getOrDefault("prettyPrint")
  valid_595353 = validateParameter(valid_595353, JBool, required = false,
                                 default = newJBool(true))
  if valid_595353 != nil:
    section.add "prettyPrint", valid_595353
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595355: Call_DfareportingCreativeGroupsInsert_595343;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new creative group.
  ## 
  let valid = call_595355.validator(path, query, header, formData, body)
  let scheme = call_595355.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595355.url(scheme.get, call_595355.host, call_595355.base,
                         call_595355.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595355, url, valid)

proc call*(call_595356: Call_DfareportingCreativeGroupsInsert_595343;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsInsert
  ## Inserts a new creative group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595357 = newJObject()
  var query_595358 = newJObject()
  var body_595359 = newJObject()
  add(path_595357, "profileId", newJString(profileId))
  add(query_595358, "fields", newJString(fields))
  add(query_595358, "quotaUser", newJString(quotaUser))
  add(query_595358, "alt", newJString(alt))
  add(query_595358, "oauth_token", newJString(oauthToken))
  add(query_595358, "userIp", newJString(userIp))
  add(query_595358, "key", newJString(key))
  if body != nil:
    body_595359 = body
  add(query_595358, "prettyPrint", newJBool(prettyPrint))
  result = call_595356.call(path_595357, query_595358, nil, nil, body_595359)

var dfareportingCreativeGroupsInsert* = Call_DfareportingCreativeGroupsInsert_595343(
    name: "dfareportingCreativeGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsInsert_595344,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsInsert_595345,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsList_595303 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeGroupsList_595305(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsList_595304(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creative groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595306 = path.getOrDefault("profileId")
  valid_595306 = validateParameter(valid_595306, JString, required = true,
                                 default = nil)
  if valid_595306 != nil:
    section.add "profileId", valid_595306
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for creative groups by name or ID. Wildcards (*) are allowed. For example, "creativegroup*2015" will return creative groups with names like "creativegroup June 2015", "creativegroup April 2015", or simply "creativegroup 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativegroup" will match creative groups with the name "my creativegroup", "creativegroup 2015", or simply "creativegroup".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative groups with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only creative groups that belong to these advertisers.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   groupNumber: JInt
  ##              : Select only creative groups that belong to this subgroup.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595307 = query.getOrDefault("fields")
  valid_595307 = validateParameter(valid_595307, JString, required = false,
                                 default = nil)
  if valid_595307 != nil:
    section.add "fields", valid_595307
  var valid_595308 = query.getOrDefault("pageToken")
  valid_595308 = validateParameter(valid_595308, JString, required = false,
                                 default = nil)
  if valid_595308 != nil:
    section.add "pageToken", valid_595308
  var valid_595309 = query.getOrDefault("quotaUser")
  valid_595309 = validateParameter(valid_595309, JString, required = false,
                                 default = nil)
  if valid_595309 != nil:
    section.add "quotaUser", valid_595309
  var valid_595310 = query.getOrDefault("sortField")
  valid_595310 = validateParameter(valid_595310, JString, required = false,
                                 default = newJString("ID"))
  if valid_595310 != nil:
    section.add "sortField", valid_595310
  var valid_595311 = query.getOrDefault("alt")
  valid_595311 = validateParameter(valid_595311, JString, required = false,
                                 default = newJString("json"))
  if valid_595311 != nil:
    section.add "alt", valid_595311
  var valid_595312 = query.getOrDefault("searchString")
  valid_595312 = validateParameter(valid_595312, JString, required = false,
                                 default = nil)
  if valid_595312 != nil:
    section.add "searchString", valid_595312
  var valid_595313 = query.getOrDefault("oauth_token")
  valid_595313 = validateParameter(valid_595313, JString, required = false,
                                 default = nil)
  if valid_595313 != nil:
    section.add "oauth_token", valid_595313
  var valid_595314 = query.getOrDefault("userIp")
  valid_595314 = validateParameter(valid_595314, JString, required = false,
                                 default = nil)
  if valid_595314 != nil:
    section.add "userIp", valid_595314
  var valid_595315 = query.getOrDefault("maxResults")
  valid_595315 = validateParameter(valid_595315, JInt, required = false,
                                 default = newJInt(1000))
  if valid_595315 != nil:
    section.add "maxResults", valid_595315
  var valid_595316 = query.getOrDefault("ids")
  valid_595316 = validateParameter(valid_595316, JArray, required = false,
                                 default = nil)
  if valid_595316 != nil:
    section.add "ids", valid_595316
  var valid_595317 = query.getOrDefault("key")
  valid_595317 = validateParameter(valid_595317, JString, required = false,
                                 default = nil)
  if valid_595317 != nil:
    section.add "key", valid_595317
  var valid_595318 = query.getOrDefault("advertiserIds")
  valid_595318 = validateParameter(valid_595318, JArray, required = false,
                                 default = nil)
  if valid_595318 != nil:
    section.add "advertiserIds", valid_595318
  var valid_595319 = query.getOrDefault("sortOrder")
  valid_595319 = validateParameter(valid_595319, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_595319 != nil:
    section.add "sortOrder", valid_595319
  var valid_595320 = query.getOrDefault("groupNumber")
  valid_595320 = validateParameter(valid_595320, JInt, required = false, default = nil)
  if valid_595320 != nil:
    section.add "groupNumber", valid_595320
  var valid_595321 = query.getOrDefault("prettyPrint")
  valid_595321 = validateParameter(valid_595321, JBool, required = false,
                                 default = newJBool(true))
  if valid_595321 != nil:
    section.add "prettyPrint", valid_595321
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595322: Call_DfareportingCreativeGroupsList_595303; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of creative groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_595322.validator(path, query, header, formData, body)
  let scheme = call_595322.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595322.url(scheme.get, call_595322.host, call_595322.base,
                         call_595322.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595322, url, valid)

proc call*(call_595323: Call_DfareportingCreativeGroupsList_595303;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          advertiserIds: JsonNode = nil; sortOrder: string = "ASCENDING";
          groupNumber: int = 0; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsList
  ## Retrieves a list of creative groups, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for creative groups by name or ID. Wildcards (*) are allowed. For example, "creativegroup*2015" will return creative groups with names like "creativegroup June 2015", "creativegroup April 2015", or simply "creativegroup 2015". Most of the searches also add wild-cards implicitly at the start and the end of the search string. For example, a search string of "creativegroup" will match creative groups with the name "my creativegroup", "creativegroup 2015", or simply "creativegroup".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creative groups with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only creative groups that belong to these advertisers.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   groupNumber: int
  ##              : Select only creative groups that belong to this subgroup.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595324 = newJObject()
  var query_595325 = newJObject()
  add(path_595324, "profileId", newJString(profileId))
  add(query_595325, "fields", newJString(fields))
  add(query_595325, "pageToken", newJString(pageToken))
  add(query_595325, "quotaUser", newJString(quotaUser))
  add(query_595325, "sortField", newJString(sortField))
  add(query_595325, "alt", newJString(alt))
  add(query_595325, "searchString", newJString(searchString))
  add(query_595325, "oauth_token", newJString(oauthToken))
  add(query_595325, "userIp", newJString(userIp))
  add(query_595325, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_595325.add "ids", ids
  add(query_595325, "key", newJString(key))
  if advertiserIds != nil:
    query_595325.add "advertiserIds", advertiserIds
  add(query_595325, "sortOrder", newJString(sortOrder))
  add(query_595325, "groupNumber", newJInt(groupNumber))
  add(query_595325, "prettyPrint", newJBool(prettyPrint))
  result = call_595323.call(path_595324, query_595325, nil, nil, nil)

var dfareportingCreativeGroupsList* = Call_DfareportingCreativeGroupsList_595303(
    name: "dfareportingCreativeGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsList_595304,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsList_595305,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsPatch_595360 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeGroupsPatch_595362(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsPatch_595361(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595363 = path.getOrDefault("profileId")
  valid_595363 = validateParameter(valid_595363, JString, required = true,
                                 default = nil)
  if valid_595363 != nil:
    section.add "profileId", valid_595363
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative group ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595364 = query.getOrDefault("fields")
  valid_595364 = validateParameter(valid_595364, JString, required = false,
                                 default = nil)
  if valid_595364 != nil:
    section.add "fields", valid_595364
  var valid_595365 = query.getOrDefault("quotaUser")
  valid_595365 = validateParameter(valid_595365, JString, required = false,
                                 default = nil)
  if valid_595365 != nil:
    section.add "quotaUser", valid_595365
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_595366 = query.getOrDefault("id")
  valid_595366 = validateParameter(valid_595366, JString, required = true,
                                 default = nil)
  if valid_595366 != nil:
    section.add "id", valid_595366
  var valid_595367 = query.getOrDefault("alt")
  valid_595367 = validateParameter(valid_595367, JString, required = false,
                                 default = newJString("json"))
  if valid_595367 != nil:
    section.add "alt", valid_595367
  var valid_595368 = query.getOrDefault("oauth_token")
  valid_595368 = validateParameter(valid_595368, JString, required = false,
                                 default = nil)
  if valid_595368 != nil:
    section.add "oauth_token", valid_595368
  var valid_595369 = query.getOrDefault("userIp")
  valid_595369 = validateParameter(valid_595369, JString, required = false,
                                 default = nil)
  if valid_595369 != nil:
    section.add "userIp", valid_595369
  var valid_595370 = query.getOrDefault("key")
  valid_595370 = validateParameter(valid_595370, JString, required = false,
                                 default = nil)
  if valid_595370 != nil:
    section.add "key", valid_595370
  var valid_595371 = query.getOrDefault("prettyPrint")
  valid_595371 = validateParameter(valid_595371, JBool, required = false,
                                 default = newJBool(true))
  if valid_595371 != nil:
    section.add "prettyPrint", valid_595371
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595373: Call_DfareportingCreativeGroupsPatch_595360;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing creative group. This method supports patch semantics.
  ## 
  let valid = call_595373.validator(path, query, header, formData, body)
  let scheme = call_595373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595373.url(scheme.get, call_595373.host, call_595373.base,
                         call_595373.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595373, url, valid)

proc call*(call_595374: Call_DfareportingCreativeGroupsPatch_595360;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsPatch
  ## Updates an existing creative group. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595375 = newJObject()
  var query_595376 = newJObject()
  var body_595377 = newJObject()
  add(path_595375, "profileId", newJString(profileId))
  add(query_595376, "fields", newJString(fields))
  add(query_595376, "quotaUser", newJString(quotaUser))
  add(query_595376, "id", newJString(id))
  add(query_595376, "alt", newJString(alt))
  add(query_595376, "oauth_token", newJString(oauthToken))
  add(query_595376, "userIp", newJString(userIp))
  add(query_595376, "key", newJString(key))
  if body != nil:
    body_595377 = body
  add(query_595376, "prettyPrint", newJBool(prettyPrint))
  result = call_595374.call(path_595375, query_595376, nil, nil, body_595377)

var dfareportingCreativeGroupsPatch* = Call_DfareportingCreativeGroupsPatch_595360(
    name: "dfareportingCreativeGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creativeGroups",
    validator: validate_DfareportingCreativeGroupsPatch_595361,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsPatch_595362,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativeGroupsGet_595378 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativeGroupsGet_595380(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creativeGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativeGroupsGet_595379(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595381 = path.getOrDefault("profileId")
  valid_595381 = validateParameter(valid_595381, JString, required = true,
                                 default = nil)
  if valid_595381 != nil:
    section.add "profileId", valid_595381
  var valid_595382 = path.getOrDefault("id")
  valid_595382 = validateParameter(valid_595382, JString, required = true,
                                 default = nil)
  if valid_595382 != nil:
    section.add "id", valid_595382
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595383 = query.getOrDefault("fields")
  valid_595383 = validateParameter(valid_595383, JString, required = false,
                                 default = nil)
  if valid_595383 != nil:
    section.add "fields", valid_595383
  var valid_595384 = query.getOrDefault("quotaUser")
  valid_595384 = validateParameter(valid_595384, JString, required = false,
                                 default = nil)
  if valid_595384 != nil:
    section.add "quotaUser", valid_595384
  var valid_595385 = query.getOrDefault("alt")
  valid_595385 = validateParameter(valid_595385, JString, required = false,
                                 default = newJString("json"))
  if valid_595385 != nil:
    section.add "alt", valid_595385
  var valid_595386 = query.getOrDefault("oauth_token")
  valid_595386 = validateParameter(valid_595386, JString, required = false,
                                 default = nil)
  if valid_595386 != nil:
    section.add "oauth_token", valid_595386
  var valid_595387 = query.getOrDefault("userIp")
  valid_595387 = validateParameter(valid_595387, JString, required = false,
                                 default = nil)
  if valid_595387 != nil:
    section.add "userIp", valid_595387
  var valid_595388 = query.getOrDefault("key")
  valid_595388 = validateParameter(valid_595388, JString, required = false,
                                 default = nil)
  if valid_595388 != nil:
    section.add "key", valid_595388
  var valid_595389 = query.getOrDefault("prettyPrint")
  valid_595389 = validateParameter(valid_595389, JBool, required = false,
                                 default = newJBool(true))
  if valid_595389 != nil:
    section.add "prettyPrint", valid_595389
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595390: Call_DfareportingCreativeGroupsGet_595378; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one creative group by ID.
  ## 
  let valid = call_595390.validator(path, query, header, formData, body)
  let scheme = call_595390.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595390.url(scheme.get, call_595390.host, call_595390.base,
                         call_595390.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595390, url, valid)

proc call*(call_595391: Call_DfareportingCreativeGroupsGet_595378;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativeGroupsGet
  ## Gets one creative group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595392 = newJObject()
  var query_595393 = newJObject()
  add(path_595392, "profileId", newJString(profileId))
  add(query_595393, "fields", newJString(fields))
  add(query_595393, "quotaUser", newJString(quotaUser))
  add(query_595393, "alt", newJString(alt))
  add(query_595393, "oauth_token", newJString(oauthToken))
  add(query_595393, "userIp", newJString(userIp))
  add(path_595392, "id", newJString(id))
  add(query_595393, "key", newJString(key))
  add(query_595393, "prettyPrint", newJBool(prettyPrint))
  result = call_595391.call(path_595392, query_595393, nil, nil, nil)

var dfareportingCreativeGroupsGet* = Call_DfareportingCreativeGroupsGet_595378(
    name: "dfareportingCreativeGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/creativeGroups/{id}",
    validator: validate_DfareportingCreativeGroupsGet_595379,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativeGroupsGet_595380,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesUpdate_595425 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativesUpdate_595427(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesUpdate_595426(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595428 = path.getOrDefault("profileId")
  valid_595428 = validateParameter(valid_595428, JString, required = true,
                                 default = nil)
  if valid_595428 != nil:
    section.add "profileId", valid_595428
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595429 = query.getOrDefault("fields")
  valid_595429 = validateParameter(valid_595429, JString, required = false,
                                 default = nil)
  if valid_595429 != nil:
    section.add "fields", valid_595429
  var valid_595430 = query.getOrDefault("quotaUser")
  valid_595430 = validateParameter(valid_595430, JString, required = false,
                                 default = nil)
  if valid_595430 != nil:
    section.add "quotaUser", valid_595430
  var valid_595431 = query.getOrDefault("alt")
  valid_595431 = validateParameter(valid_595431, JString, required = false,
                                 default = newJString("json"))
  if valid_595431 != nil:
    section.add "alt", valid_595431
  var valid_595432 = query.getOrDefault("oauth_token")
  valid_595432 = validateParameter(valid_595432, JString, required = false,
                                 default = nil)
  if valid_595432 != nil:
    section.add "oauth_token", valid_595432
  var valid_595433 = query.getOrDefault("userIp")
  valid_595433 = validateParameter(valid_595433, JString, required = false,
                                 default = nil)
  if valid_595433 != nil:
    section.add "userIp", valid_595433
  var valid_595434 = query.getOrDefault("key")
  valid_595434 = validateParameter(valid_595434, JString, required = false,
                                 default = nil)
  if valid_595434 != nil:
    section.add "key", valid_595434
  var valid_595435 = query.getOrDefault("prettyPrint")
  valid_595435 = validateParameter(valid_595435, JBool, required = false,
                                 default = newJBool(true))
  if valid_595435 != nil:
    section.add "prettyPrint", valid_595435
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595437: Call_DfareportingCreativesUpdate_595425; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing creative.
  ## 
  let valid = call_595437.validator(path, query, header, formData, body)
  let scheme = call_595437.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595437.url(scheme.get, call_595437.host, call_595437.base,
                         call_595437.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595437, url, valid)

proc call*(call_595438: Call_DfareportingCreativesUpdate_595425; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativesUpdate
  ## Updates an existing creative.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595439 = newJObject()
  var query_595440 = newJObject()
  var body_595441 = newJObject()
  add(path_595439, "profileId", newJString(profileId))
  add(query_595440, "fields", newJString(fields))
  add(query_595440, "quotaUser", newJString(quotaUser))
  add(query_595440, "alt", newJString(alt))
  add(query_595440, "oauth_token", newJString(oauthToken))
  add(query_595440, "userIp", newJString(userIp))
  add(query_595440, "key", newJString(key))
  if body != nil:
    body_595441 = body
  add(query_595440, "prettyPrint", newJBool(prettyPrint))
  result = call_595438.call(path_595439, query_595440, nil, nil, body_595441)

var dfareportingCreativesUpdate* = Call_DfareportingCreativesUpdate_595425(
    name: "dfareportingCreativesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesUpdate_595426,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesUpdate_595427,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesInsert_595442 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativesInsert_595444(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesInsert_595443(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new creative.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595445 = path.getOrDefault("profileId")
  valid_595445 = validateParameter(valid_595445, JString, required = true,
                                 default = nil)
  if valid_595445 != nil:
    section.add "profileId", valid_595445
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595446 = query.getOrDefault("fields")
  valid_595446 = validateParameter(valid_595446, JString, required = false,
                                 default = nil)
  if valid_595446 != nil:
    section.add "fields", valid_595446
  var valid_595447 = query.getOrDefault("quotaUser")
  valid_595447 = validateParameter(valid_595447, JString, required = false,
                                 default = nil)
  if valid_595447 != nil:
    section.add "quotaUser", valid_595447
  var valid_595448 = query.getOrDefault("alt")
  valid_595448 = validateParameter(valid_595448, JString, required = false,
                                 default = newJString("json"))
  if valid_595448 != nil:
    section.add "alt", valid_595448
  var valid_595449 = query.getOrDefault("oauth_token")
  valid_595449 = validateParameter(valid_595449, JString, required = false,
                                 default = nil)
  if valid_595449 != nil:
    section.add "oauth_token", valid_595449
  var valid_595450 = query.getOrDefault("userIp")
  valid_595450 = validateParameter(valid_595450, JString, required = false,
                                 default = nil)
  if valid_595450 != nil:
    section.add "userIp", valid_595450
  var valid_595451 = query.getOrDefault("key")
  valid_595451 = validateParameter(valid_595451, JString, required = false,
                                 default = nil)
  if valid_595451 != nil:
    section.add "key", valid_595451
  var valid_595452 = query.getOrDefault("prettyPrint")
  valid_595452 = validateParameter(valid_595452, JBool, required = false,
                                 default = newJBool(true))
  if valid_595452 != nil:
    section.add "prettyPrint", valid_595452
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595454: Call_DfareportingCreativesInsert_595442; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new creative.
  ## 
  let valid = call_595454.validator(path, query, header, formData, body)
  let scheme = call_595454.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595454.url(scheme.get, call_595454.host, call_595454.base,
                         call_595454.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595454, url, valid)

proc call*(call_595455: Call_DfareportingCreativesInsert_595442; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativesInsert
  ## Inserts a new creative.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595456 = newJObject()
  var query_595457 = newJObject()
  var body_595458 = newJObject()
  add(path_595456, "profileId", newJString(profileId))
  add(query_595457, "fields", newJString(fields))
  add(query_595457, "quotaUser", newJString(quotaUser))
  add(query_595457, "alt", newJString(alt))
  add(query_595457, "oauth_token", newJString(oauthToken))
  add(query_595457, "userIp", newJString(userIp))
  add(query_595457, "key", newJString(key))
  if body != nil:
    body_595458 = body
  add(query_595457, "prettyPrint", newJBool(prettyPrint))
  result = call_595455.call(path_595456, query_595457, nil, nil, body_595458)

var dfareportingCreativesInsert* = Call_DfareportingCreativesInsert_595442(
    name: "dfareportingCreativesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesInsert_595443,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesInsert_595444,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesList_595394 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativesList_595396(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesList_595395(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of creatives, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595397 = path.getOrDefault("profileId")
  valid_595397 = validateParameter(valid_595397, JString, required = true,
                                 default = nil)
  if valid_595397 != nil:
    section.add "profileId", valid_595397
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "creative*2015" will return objects with names like "creative June 2015", "creative April 2015", or simply "creative 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "creative" will match objects with name "my creative", "creative 2015", or simply "creative".
  ##   advertiserId: JString
  ##               : Select only creatives with this advertiser ID.
  ##   types: JArray
  ##        : Select only creatives with these creative types.
  ##   sizeIds: JArray
  ##          : Select only creatives with these size IDs.
  ##   active: JBool
  ##         : Select only active creatives. Leave blank to select active and inactive creatives.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   studioCreativeId: JString
  ##                   : Select only creatives corresponding to this Studio creative ID.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   renderingIds: JArray
  ##               : Select only creatives with these rendering IDs.
  ##   archived: JBool
  ##           : Select only archived creatives. Leave blank to select archived and unarchived creatives.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creatives with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldIds: JArray
  ##                   : Select only creatives with these creative field IDs.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   companionCreativeIds: JArray
  ##                       : Select only in-stream video creatives with these companion IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: JString
  ##             : Select only creatives with this campaign ID.
  section = newJObject()
  var valid_595398 = query.getOrDefault("fields")
  valid_595398 = validateParameter(valid_595398, JString, required = false,
                                 default = nil)
  if valid_595398 != nil:
    section.add "fields", valid_595398
  var valid_595399 = query.getOrDefault("pageToken")
  valid_595399 = validateParameter(valid_595399, JString, required = false,
                                 default = nil)
  if valid_595399 != nil:
    section.add "pageToken", valid_595399
  var valid_595400 = query.getOrDefault("quotaUser")
  valid_595400 = validateParameter(valid_595400, JString, required = false,
                                 default = nil)
  if valid_595400 != nil:
    section.add "quotaUser", valid_595400
  var valid_595401 = query.getOrDefault("sortField")
  valid_595401 = validateParameter(valid_595401, JString, required = false,
                                 default = newJString("ID"))
  if valid_595401 != nil:
    section.add "sortField", valid_595401
  var valid_595402 = query.getOrDefault("alt")
  valid_595402 = validateParameter(valid_595402, JString, required = false,
                                 default = newJString("json"))
  if valid_595402 != nil:
    section.add "alt", valid_595402
  var valid_595403 = query.getOrDefault("searchString")
  valid_595403 = validateParameter(valid_595403, JString, required = false,
                                 default = nil)
  if valid_595403 != nil:
    section.add "searchString", valid_595403
  var valid_595404 = query.getOrDefault("advertiserId")
  valid_595404 = validateParameter(valid_595404, JString, required = false,
                                 default = nil)
  if valid_595404 != nil:
    section.add "advertiserId", valid_595404
  var valid_595405 = query.getOrDefault("types")
  valid_595405 = validateParameter(valid_595405, JArray, required = false,
                                 default = nil)
  if valid_595405 != nil:
    section.add "types", valid_595405
  var valid_595406 = query.getOrDefault("sizeIds")
  valid_595406 = validateParameter(valid_595406, JArray, required = false,
                                 default = nil)
  if valid_595406 != nil:
    section.add "sizeIds", valid_595406
  var valid_595407 = query.getOrDefault("active")
  valid_595407 = validateParameter(valid_595407, JBool, required = false, default = nil)
  if valid_595407 != nil:
    section.add "active", valid_595407
  var valid_595408 = query.getOrDefault("oauth_token")
  valid_595408 = validateParameter(valid_595408, JString, required = false,
                                 default = nil)
  if valid_595408 != nil:
    section.add "oauth_token", valid_595408
  var valid_595409 = query.getOrDefault("studioCreativeId")
  valid_595409 = validateParameter(valid_595409, JString, required = false,
                                 default = nil)
  if valid_595409 != nil:
    section.add "studioCreativeId", valid_595409
  var valid_595410 = query.getOrDefault("userIp")
  valid_595410 = validateParameter(valid_595410, JString, required = false,
                                 default = nil)
  if valid_595410 != nil:
    section.add "userIp", valid_595410
  var valid_595411 = query.getOrDefault("renderingIds")
  valid_595411 = validateParameter(valid_595411, JArray, required = false,
                                 default = nil)
  if valid_595411 != nil:
    section.add "renderingIds", valid_595411
  var valid_595412 = query.getOrDefault("archived")
  valid_595412 = validateParameter(valid_595412, JBool, required = false, default = nil)
  if valid_595412 != nil:
    section.add "archived", valid_595412
  var valid_595413 = query.getOrDefault("maxResults")
  valid_595413 = validateParameter(valid_595413, JInt, required = false,
                                 default = newJInt(1000))
  if valid_595413 != nil:
    section.add "maxResults", valid_595413
  var valid_595414 = query.getOrDefault("ids")
  valid_595414 = validateParameter(valid_595414, JArray, required = false,
                                 default = nil)
  if valid_595414 != nil:
    section.add "ids", valid_595414
  var valid_595415 = query.getOrDefault("key")
  valid_595415 = validateParameter(valid_595415, JString, required = false,
                                 default = nil)
  if valid_595415 != nil:
    section.add "key", valid_595415
  var valid_595416 = query.getOrDefault("creativeFieldIds")
  valid_595416 = validateParameter(valid_595416, JArray, required = false,
                                 default = nil)
  if valid_595416 != nil:
    section.add "creativeFieldIds", valid_595416
  var valid_595417 = query.getOrDefault("sortOrder")
  valid_595417 = validateParameter(valid_595417, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_595417 != nil:
    section.add "sortOrder", valid_595417
  var valid_595418 = query.getOrDefault("companionCreativeIds")
  valid_595418 = validateParameter(valid_595418, JArray, required = false,
                                 default = nil)
  if valid_595418 != nil:
    section.add "companionCreativeIds", valid_595418
  var valid_595419 = query.getOrDefault("prettyPrint")
  valid_595419 = validateParameter(valid_595419, JBool, required = false,
                                 default = newJBool(true))
  if valid_595419 != nil:
    section.add "prettyPrint", valid_595419
  var valid_595420 = query.getOrDefault("campaignId")
  valid_595420 = validateParameter(valid_595420, JString, required = false,
                                 default = nil)
  if valid_595420 != nil:
    section.add "campaignId", valid_595420
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595421: Call_DfareportingCreativesList_595394; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of creatives, possibly filtered. This method supports paging.
  ## 
  let valid = call_595421.validator(path, query, header, formData, body)
  let scheme = call_595421.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595421.url(scheme.get, call_595421.host, call_595421.base,
                         call_595421.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595421, url, valid)

proc call*(call_595422: Call_DfareportingCreativesList_595394; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; searchString: string = "";
          advertiserId: string = ""; types: JsonNode = nil; sizeIds: JsonNode = nil;
          active: bool = false; oauthToken: string = ""; studioCreativeId: string = "";
          userIp: string = ""; renderingIds: JsonNode = nil; archived: bool = false;
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          creativeFieldIds: JsonNode = nil; sortOrder: string = "ASCENDING";
          companionCreativeIds: JsonNode = nil; prettyPrint: bool = true;
          campaignId: string = ""): Recallable =
  ## dfareportingCreativesList
  ## Retrieves a list of creatives, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "creative*2015" will return objects with names like "creative June 2015", "creative April 2015", or simply "creative 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "creative" will match objects with name "my creative", "creative 2015", or simply "creative".
  ##   advertiserId: string
  ##               : Select only creatives with this advertiser ID.
  ##   types: JArray
  ##        : Select only creatives with these creative types.
  ##   sizeIds: JArray
  ##          : Select only creatives with these size IDs.
  ##   active: bool
  ##         : Select only active creatives. Leave blank to select active and inactive creatives.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   studioCreativeId: string
  ##                   : Select only creatives corresponding to this Studio creative ID.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   renderingIds: JArray
  ##               : Select only creatives with these rendering IDs.
  ##   archived: bool
  ##           : Select only archived creatives. Leave blank to select archived and unarchived creatives.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only creatives with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   creativeFieldIds: JArray
  ##                   : Select only creatives with these creative field IDs.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   companionCreativeIds: JArray
  ##                       : Select only in-stream video creatives with these companion IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: string
  ##             : Select only creatives with this campaign ID.
  var path_595423 = newJObject()
  var query_595424 = newJObject()
  add(path_595423, "profileId", newJString(profileId))
  add(query_595424, "fields", newJString(fields))
  add(query_595424, "pageToken", newJString(pageToken))
  add(query_595424, "quotaUser", newJString(quotaUser))
  add(query_595424, "sortField", newJString(sortField))
  add(query_595424, "alt", newJString(alt))
  add(query_595424, "searchString", newJString(searchString))
  add(query_595424, "advertiserId", newJString(advertiserId))
  if types != nil:
    query_595424.add "types", types
  if sizeIds != nil:
    query_595424.add "sizeIds", sizeIds
  add(query_595424, "active", newJBool(active))
  add(query_595424, "oauth_token", newJString(oauthToken))
  add(query_595424, "studioCreativeId", newJString(studioCreativeId))
  add(query_595424, "userIp", newJString(userIp))
  if renderingIds != nil:
    query_595424.add "renderingIds", renderingIds
  add(query_595424, "archived", newJBool(archived))
  add(query_595424, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_595424.add "ids", ids
  add(query_595424, "key", newJString(key))
  if creativeFieldIds != nil:
    query_595424.add "creativeFieldIds", creativeFieldIds
  add(query_595424, "sortOrder", newJString(sortOrder))
  if companionCreativeIds != nil:
    query_595424.add "companionCreativeIds", companionCreativeIds
  add(query_595424, "prettyPrint", newJBool(prettyPrint))
  add(query_595424, "campaignId", newJString(campaignId))
  result = call_595422.call(path_595423, query_595424, nil, nil, nil)

var dfareportingCreativesList* = Call_DfareportingCreativesList_595394(
    name: "dfareportingCreativesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesList_595395,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesList_595396,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesPatch_595459 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativesPatch_595461(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesPatch_595460(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing creative. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595462 = path.getOrDefault("profileId")
  valid_595462 = validateParameter(valid_595462, JString, required = true,
                                 default = nil)
  if valid_595462 != nil:
    section.add "profileId", valid_595462
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Creative ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595463 = query.getOrDefault("fields")
  valid_595463 = validateParameter(valid_595463, JString, required = false,
                                 default = nil)
  if valid_595463 != nil:
    section.add "fields", valid_595463
  var valid_595464 = query.getOrDefault("quotaUser")
  valid_595464 = validateParameter(valid_595464, JString, required = false,
                                 default = nil)
  if valid_595464 != nil:
    section.add "quotaUser", valid_595464
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_595465 = query.getOrDefault("id")
  valid_595465 = validateParameter(valid_595465, JString, required = true,
                                 default = nil)
  if valid_595465 != nil:
    section.add "id", valid_595465
  var valid_595466 = query.getOrDefault("alt")
  valid_595466 = validateParameter(valid_595466, JString, required = false,
                                 default = newJString("json"))
  if valid_595466 != nil:
    section.add "alt", valid_595466
  var valid_595467 = query.getOrDefault("oauth_token")
  valid_595467 = validateParameter(valid_595467, JString, required = false,
                                 default = nil)
  if valid_595467 != nil:
    section.add "oauth_token", valid_595467
  var valid_595468 = query.getOrDefault("userIp")
  valid_595468 = validateParameter(valid_595468, JString, required = false,
                                 default = nil)
  if valid_595468 != nil:
    section.add "userIp", valid_595468
  var valid_595469 = query.getOrDefault("key")
  valid_595469 = validateParameter(valid_595469, JString, required = false,
                                 default = nil)
  if valid_595469 != nil:
    section.add "key", valid_595469
  var valid_595470 = query.getOrDefault("prettyPrint")
  valid_595470 = validateParameter(valid_595470, JBool, required = false,
                                 default = newJBool(true))
  if valid_595470 != nil:
    section.add "prettyPrint", valid_595470
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595472: Call_DfareportingCreativesPatch_595459; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing creative. This method supports patch semantics.
  ## 
  let valid = call_595472.validator(path, query, header, formData, body)
  let scheme = call_595472.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595472.url(scheme.get, call_595472.host, call_595472.base,
                         call_595472.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595472, url, valid)

proc call*(call_595473: Call_DfareportingCreativesPatch_595459; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingCreativesPatch
  ## Updates an existing creative. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Creative ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595474 = newJObject()
  var query_595475 = newJObject()
  var body_595476 = newJObject()
  add(path_595474, "profileId", newJString(profileId))
  add(query_595475, "fields", newJString(fields))
  add(query_595475, "quotaUser", newJString(quotaUser))
  add(query_595475, "id", newJString(id))
  add(query_595475, "alt", newJString(alt))
  add(query_595475, "oauth_token", newJString(oauthToken))
  add(query_595475, "userIp", newJString(userIp))
  add(query_595475, "key", newJString(key))
  if body != nil:
    body_595476 = body
  add(query_595475, "prettyPrint", newJBool(prettyPrint))
  result = call_595473.call(path_595474, query_595475, nil, nil, body_595476)

var dfareportingCreativesPatch* = Call_DfareportingCreativesPatch_595459(
    name: "dfareportingCreativesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives",
    validator: validate_DfareportingCreativesPatch_595460,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesPatch_595461,
    schemes: {Scheme.Https})
type
  Call_DfareportingCreativesGet_595477 = ref object of OpenApiRestCall_593437
proc url_DfareportingCreativesGet_595479(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/creatives/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingCreativesGet_595478(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one creative by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Creative ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595480 = path.getOrDefault("profileId")
  valid_595480 = validateParameter(valid_595480, JString, required = true,
                                 default = nil)
  if valid_595480 != nil:
    section.add "profileId", valid_595480
  var valid_595481 = path.getOrDefault("id")
  valid_595481 = validateParameter(valid_595481, JString, required = true,
                                 default = nil)
  if valid_595481 != nil:
    section.add "id", valid_595481
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595482 = query.getOrDefault("fields")
  valid_595482 = validateParameter(valid_595482, JString, required = false,
                                 default = nil)
  if valid_595482 != nil:
    section.add "fields", valid_595482
  var valid_595483 = query.getOrDefault("quotaUser")
  valid_595483 = validateParameter(valid_595483, JString, required = false,
                                 default = nil)
  if valid_595483 != nil:
    section.add "quotaUser", valid_595483
  var valid_595484 = query.getOrDefault("alt")
  valid_595484 = validateParameter(valid_595484, JString, required = false,
                                 default = newJString("json"))
  if valid_595484 != nil:
    section.add "alt", valid_595484
  var valid_595485 = query.getOrDefault("oauth_token")
  valid_595485 = validateParameter(valid_595485, JString, required = false,
                                 default = nil)
  if valid_595485 != nil:
    section.add "oauth_token", valid_595485
  var valid_595486 = query.getOrDefault("userIp")
  valid_595486 = validateParameter(valid_595486, JString, required = false,
                                 default = nil)
  if valid_595486 != nil:
    section.add "userIp", valid_595486
  var valid_595487 = query.getOrDefault("key")
  valid_595487 = validateParameter(valid_595487, JString, required = false,
                                 default = nil)
  if valid_595487 != nil:
    section.add "key", valid_595487
  var valid_595488 = query.getOrDefault("prettyPrint")
  valid_595488 = validateParameter(valid_595488, JBool, required = false,
                                 default = newJBool(true))
  if valid_595488 != nil:
    section.add "prettyPrint", valid_595488
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595489: Call_DfareportingCreativesGet_595477; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one creative by ID.
  ## 
  let valid = call_595489.validator(path, query, header, formData, body)
  let scheme = call_595489.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595489.url(scheme.get, call_595489.host, call_595489.base,
                         call_595489.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595489, url, valid)

proc call*(call_595490: Call_DfareportingCreativesGet_595477; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingCreativesGet
  ## Gets one creative by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Creative ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595491 = newJObject()
  var query_595492 = newJObject()
  add(path_595491, "profileId", newJString(profileId))
  add(query_595492, "fields", newJString(fields))
  add(query_595492, "quotaUser", newJString(quotaUser))
  add(query_595492, "alt", newJString(alt))
  add(query_595492, "oauth_token", newJString(oauthToken))
  add(query_595492, "userIp", newJString(userIp))
  add(path_595491, "id", newJString(id))
  add(query_595492, "key", newJString(key))
  add(query_595492, "prettyPrint", newJBool(prettyPrint))
  result = call_595490.call(path_595491, query_595492, nil, nil, nil)

var dfareportingCreativesGet* = Call_DfareportingCreativesGet_595477(
    name: "dfareportingCreativesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/creatives/{id}",
    validator: validate_DfareportingCreativesGet_595478,
    base: "/dfareporting/v2.7", url: url_DfareportingCreativesGet_595479,
    schemes: {Scheme.Https})
type
  Call_DfareportingDimensionValuesQuery_595493 = ref object of OpenApiRestCall_593437
proc url_DfareportingDimensionValuesQuery_595495(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dimensionvalues/query")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDimensionValuesQuery_595494(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves list of report dimension values for a list of filters.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595496 = path.getOrDefault("profileId")
  valid_595496 = validateParameter(valid_595496, JString, required = true,
                                 default = nil)
  if valid_595496 != nil:
    section.add "profileId", valid_595496
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595497 = query.getOrDefault("fields")
  valid_595497 = validateParameter(valid_595497, JString, required = false,
                                 default = nil)
  if valid_595497 != nil:
    section.add "fields", valid_595497
  var valid_595498 = query.getOrDefault("pageToken")
  valid_595498 = validateParameter(valid_595498, JString, required = false,
                                 default = nil)
  if valid_595498 != nil:
    section.add "pageToken", valid_595498
  var valid_595499 = query.getOrDefault("quotaUser")
  valid_595499 = validateParameter(valid_595499, JString, required = false,
                                 default = nil)
  if valid_595499 != nil:
    section.add "quotaUser", valid_595499
  var valid_595500 = query.getOrDefault("alt")
  valid_595500 = validateParameter(valid_595500, JString, required = false,
                                 default = newJString("json"))
  if valid_595500 != nil:
    section.add "alt", valid_595500
  var valid_595501 = query.getOrDefault("oauth_token")
  valid_595501 = validateParameter(valid_595501, JString, required = false,
                                 default = nil)
  if valid_595501 != nil:
    section.add "oauth_token", valid_595501
  var valid_595502 = query.getOrDefault("userIp")
  valid_595502 = validateParameter(valid_595502, JString, required = false,
                                 default = nil)
  if valid_595502 != nil:
    section.add "userIp", valid_595502
  var valid_595503 = query.getOrDefault("maxResults")
  valid_595503 = validateParameter(valid_595503, JInt, required = false,
                                 default = newJInt(100))
  if valid_595503 != nil:
    section.add "maxResults", valid_595503
  var valid_595504 = query.getOrDefault("key")
  valid_595504 = validateParameter(valid_595504, JString, required = false,
                                 default = nil)
  if valid_595504 != nil:
    section.add "key", valid_595504
  var valid_595505 = query.getOrDefault("prettyPrint")
  valid_595505 = validateParameter(valid_595505, JBool, required = false,
                                 default = newJBool(true))
  if valid_595505 != nil:
    section.add "prettyPrint", valid_595505
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595507: Call_DfareportingDimensionValuesQuery_595493;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves list of report dimension values for a list of filters.
  ## 
  let valid = call_595507.validator(path, query, header, formData, body)
  let scheme = call_595507.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595507.url(scheme.get, call_595507.host, call_595507.base,
                         call_595507.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595507, url, valid)

proc call*(call_595508: Call_DfareportingDimensionValuesQuery_595493;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; maxResults: int = 100; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingDimensionValuesQuery
  ## Retrieves list of report dimension values for a list of filters.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595509 = newJObject()
  var query_595510 = newJObject()
  var body_595511 = newJObject()
  add(path_595509, "profileId", newJString(profileId))
  add(query_595510, "fields", newJString(fields))
  add(query_595510, "pageToken", newJString(pageToken))
  add(query_595510, "quotaUser", newJString(quotaUser))
  add(query_595510, "alt", newJString(alt))
  add(query_595510, "oauth_token", newJString(oauthToken))
  add(query_595510, "userIp", newJString(userIp))
  add(query_595510, "maxResults", newJInt(maxResults))
  add(query_595510, "key", newJString(key))
  if body != nil:
    body_595511 = body
  add(query_595510, "prettyPrint", newJBool(prettyPrint))
  result = call_595508.call(path_595509, query_595510, nil, nil, body_595511)

var dfareportingDimensionValuesQuery* = Call_DfareportingDimensionValuesQuery_595493(
    name: "dfareportingDimensionValuesQuery", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dimensionvalues/query",
    validator: validate_DfareportingDimensionValuesQuery_595494,
    base: "/dfareporting/v2.7", url: url_DfareportingDimensionValuesQuery_595495,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySiteContactsList_595512 = ref object of OpenApiRestCall_593437
proc url_DfareportingDirectorySiteContactsList_595514(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySiteContacts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySiteContactsList_595513(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of directory site contacts, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595515 = path.getOrDefault("profileId")
  valid_595515 = validateParameter(valid_595515, JString, required = true,
                                 default = nil)
  if valid_595515 != nil:
    section.add "profileId", valid_595515
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "directory site contact*2015" will return objects with names like "directory site contact June 2015", "directory site contact April 2015", or simply "directory site contact 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site contact" will match objects with name "my directory site contact", "directory site contact 2015", or simply "directory site contact".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only directory site contacts with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only directory site contacts with these directory site IDs. This is a required field.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595516 = query.getOrDefault("fields")
  valid_595516 = validateParameter(valid_595516, JString, required = false,
                                 default = nil)
  if valid_595516 != nil:
    section.add "fields", valid_595516
  var valid_595517 = query.getOrDefault("pageToken")
  valid_595517 = validateParameter(valid_595517, JString, required = false,
                                 default = nil)
  if valid_595517 != nil:
    section.add "pageToken", valid_595517
  var valid_595518 = query.getOrDefault("quotaUser")
  valid_595518 = validateParameter(valid_595518, JString, required = false,
                                 default = nil)
  if valid_595518 != nil:
    section.add "quotaUser", valid_595518
  var valid_595519 = query.getOrDefault("sortField")
  valid_595519 = validateParameter(valid_595519, JString, required = false,
                                 default = newJString("ID"))
  if valid_595519 != nil:
    section.add "sortField", valid_595519
  var valid_595520 = query.getOrDefault("alt")
  valid_595520 = validateParameter(valid_595520, JString, required = false,
                                 default = newJString("json"))
  if valid_595520 != nil:
    section.add "alt", valid_595520
  var valid_595521 = query.getOrDefault("searchString")
  valid_595521 = validateParameter(valid_595521, JString, required = false,
                                 default = nil)
  if valid_595521 != nil:
    section.add "searchString", valid_595521
  var valid_595522 = query.getOrDefault("oauth_token")
  valid_595522 = validateParameter(valid_595522, JString, required = false,
                                 default = nil)
  if valid_595522 != nil:
    section.add "oauth_token", valid_595522
  var valid_595523 = query.getOrDefault("userIp")
  valid_595523 = validateParameter(valid_595523, JString, required = false,
                                 default = nil)
  if valid_595523 != nil:
    section.add "userIp", valid_595523
  var valid_595524 = query.getOrDefault("maxResults")
  valid_595524 = validateParameter(valid_595524, JInt, required = false,
                                 default = newJInt(1000))
  if valid_595524 != nil:
    section.add "maxResults", valid_595524
  var valid_595525 = query.getOrDefault("ids")
  valid_595525 = validateParameter(valid_595525, JArray, required = false,
                                 default = nil)
  if valid_595525 != nil:
    section.add "ids", valid_595525
  var valid_595526 = query.getOrDefault("key")
  valid_595526 = validateParameter(valid_595526, JString, required = false,
                                 default = nil)
  if valid_595526 != nil:
    section.add "key", valid_595526
  var valid_595527 = query.getOrDefault("sortOrder")
  valid_595527 = validateParameter(valid_595527, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_595527 != nil:
    section.add "sortOrder", valid_595527
  var valid_595528 = query.getOrDefault("directorySiteIds")
  valid_595528 = validateParameter(valid_595528, JArray, required = false,
                                 default = nil)
  if valid_595528 != nil:
    section.add "directorySiteIds", valid_595528
  var valid_595529 = query.getOrDefault("prettyPrint")
  valid_595529 = validateParameter(valid_595529, JBool, required = false,
                                 default = newJBool(true))
  if valid_595529 != nil:
    section.add "prettyPrint", valid_595529
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595530: Call_DfareportingDirectorySiteContactsList_595512;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of directory site contacts, possibly filtered. This method supports paging.
  ## 
  let valid = call_595530.validator(path, query, header, formData, body)
  let scheme = call_595530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595530.url(scheme.get, call_595530.host, call_595530.base,
                         call_595530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595530, url, valid)

proc call*(call_595531: Call_DfareportingDirectorySiteContactsList_595512;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; directorySiteIds: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySiteContactsList
  ## Retrieves a list of directory site contacts, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or email. Wildcards (*) are allowed. For example, "directory site contact*2015" will return objects with names like "directory site contact June 2015", "directory site contact April 2015", or simply "directory site contact 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site contact" will match objects with name "my directory site contact", "directory site contact 2015", or simply "directory site contact".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only directory site contacts with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only directory site contacts with these directory site IDs. This is a required field.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595532 = newJObject()
  var query_595533 = newJObject()
  add(path_595532, "profileId", newJString(profileId))
  add(query_595533, "fields", newJString(fields))
  add(query_595533, "pageToken", newJString(pageToken))
  add(query_595533, "quotaUser", newJString(quotaUser))
  add(query_595533, "sortField", newJString(sortField))
  add(query_595533, "alt", newJString(alt))
  add(query_595533, "searchString", newJString(searchString))
  add(query_595533, "oauth_token", newJString(oauthToken))
  add(query_595533, "userIp", newJString(userIp))
  add(query_595533, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_595533.add "ids", ids
  add(query_595533, "key", newJString(key))
  add(query_595533, "sortOrder", newJString(sortOrder))
  if directorySiteIds != nil:
    query_595533.add "directorySiteIds", directorySiteIds
  add(query_595533, "prettyPrint", newJBool(prettyPrint))
  result = call_595531.call(path_595532, query_595533, nil, nil, nil)

var dfareportingDirectorySiteContactsList* = Call_DfareportingDirectorySiteContactsList_595512(
    name: "dfareportingDirectorySiteContactsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/directorySiteContacts",
    validator: validate_DfareportingDirectorySiteContactsList_595513,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySiteContactsList_595514,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySiteContactsGet_595534 = ref object of OpenApiRestCall_593437
proc url_DfareportingDirectorySiteContactsGet_595536(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySiteContacts/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySiteContactsGet_595535(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one directory site contact by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Directory site contact ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595537 = path.getOrDefault("profileId")
  valid_595537 = validateParameter(valid_595537, JString, required = true,
                                 default = nil)
  if valid_595537 != nil:
    section.add "profileId", valid_595537
  var valid_595538 = path.getOrDefault("id")
  valid_595538 = validateParameter(valid_595538, JString, required = true,
                                 default = nil)
  if valid_595538 != nil:
    section.add "id", valid_595538
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595539 = query.getOrDefault("fields")
  valid_595539 = validateParameter(valid_595539, JString, required = false,
                                 default = nil)
  if valid_595539 != nil:
    section.add "fields", valid_595539
  var valid_595540 = query.getOrDefault("quotaUser")
  valid_595540 = validateParameter(valid_595540, JString, required = false,
                                 default = nil)
  if valid_595540 != nil:
    section.add "quotaUser", valid_595540
  var valid_595541 = query.getOrDefault("alt")
  valid_595541 = validateParameter(valid_595541, JString, required = false,
                                 default = newJString("json"))
  if valid_595541 != nil:
    section.add "alt", valid_595541
  var valid_595542 = query.getOrDefault("oauth_token")
  valid_595542 = validateParameter(valid_595542, JString, required = false,
                                 default = nil)
  if valid_595542 != nil:
    section.add "oauth_token", valid_595542
  var valid_595543 = query.getOrDefault("userIp")
  valid_595543 = validateParameter(valid_595543, JString, required = false,
                                 default = nil)
  if valid_595543 != nil:
    section.add "userIp", valid_595543
  var valid_595544 = query.getOrDefault("key")
  valid_595544 = validateParameter(valid_595544, JString, required = false,
                                 default = nil)
  if valid_595544 != nil:
    section.add "key", valid_595544
  var valid_595545 = query.getOrDefault("prettyPrint")
  valid_595545 = validateParameter(valid_595545, JBool, required = false,
                                 default = newJBool(true))
  if valid_595545 != nil:
    section.add "prettyPrint", valid_595545
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595546: Call_DfareportingDirectorySiteContactsGet_595534;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one directory site contact by ID.
  ## 
  let valid = call_595546.validator(path, query, header, formData, body)
  let scheme = call_595546.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595546.url(scheme.get, call_595546.host, call_595546.base,
                         call_595546.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595546, url, valid)

proc call*(call_595547: Call_DfareportingDirectorySiteContactsGet_595534;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySiteContactsGet
  ## Gets one directory site contact by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Directory site contact ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595548 = newJObject()
  var query_595549 = newJObject()
  add(path_595548, "profileId", newJString(profileId))
  add(query_595549, "fields", newJString(fields))
  add(query_595549, "quotaUser", newJString(quotaUser))
  add(query_595549, "alt", newJString(alt))
  add(query_595549, "oauth_token", newJString(oauthToken))
  add(query_595549, "userIp", newJString(userIp))
  add(path_595548, "id", newJString(id))
  add(query_595549, "key", newJString(key))
  add(query_595549, "prettyPrint", newJBool(prettyPrint))
  result = call_595547.call(path_595548, query_595549, nil, nil, nil)

var dfareportingDirectorySiteContactsGet* = Call_DfareportingDirectorySiteContactsGet_595534(
    name: "dfareportingDirectorySiteContactsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/directorySiteContacts/{id}",
    validator: validate_DfareportingDirectorySiteContactsGet_595535,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySiteContactsGet_595536,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySitesInsert_595578 = ref object of OpenApiRestCall_593437
proc url_DfareportingDirectorySitesInsert_595580(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySitesInsert_595579(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new directory site.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595581 = path.getOrDefault("profileId")
  valid_595581 = validateParameter(valid_595581, JString, required = true,
                                 default = nil)
  if valid_595581 != nil:
    section.add "profileId", valid_595581
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595582 = query.getOrDefault("fields")
  valid_595582 = validateParameter(valid_595582, JString, required = false,
                                 default = nil)
  if valid_595582 != nil:
    section.add "fields", valid_595582
  var valid_595583 = query.getOrDefault("quotaUser")
  valid_595583 = validateParameter(valid_595583, JString, required = false,
                                 default = nil)
  if valid_595583 != nil:
    section.add "quotaUser", valid_595583
  var valid_595584 = query.getOrDefault("alt")
  valid_595584 = validateParameter(valid_595584, JString, required = false,
                                 default = newJString("json"))
  if valid_595584 != nil:
    section.add "alt", valid_595584
  var valid_595585 = query.getOrDefault("oauth_token")
  valid_595585 = validateParameter(valid_595585, JString, required = false,
                                 default = nil)
  if valid_595585 != nil:
    section.add "oauth_token", valid_595585
  var valid_595586 = query.getOrDefault("userIp")
  valid_595586 = validateParameter(valid_595586, JString, required = false,
                                 default = nil)
  if valid_595586 != nil:
    section.add "userIp", valid_595586
  var valid_595587 = query.getOrDefault("key")
  valid_595587 = validateParameter(valid_595587, JString, required = false,
                                 default = nil)
  if valid_595587 != nil:
    section.add "key", valid_595587
  var valid_595588 = query.getOrDefault("prettyPrint")
  valid_595588 = validateParameter(valid_595588, JBool, required = false,
                                 default = newJBool(true))
  if valid_595588 != nil:
    section.add "prettyPrint", valid_595588
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595590: Call_DfareportingDirectorySitesInsert_595578;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new directory site.
  ## 
  let valid = call_595590.validator(path, query, header, formData, body)
  let scheme = call_595590.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595590.url(scheme.get, call_595590.host, call_595590.base,
                         call_595590.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595590, url, valid)

proc call*(call_595591: Call_DfareportingDirectorySitesInsert_595578;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySitesInsert
  ## Inserts a new directory site.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595592 = newJObject()
  var query_595593 = newJObject()
  var body_595594 = newJObject()
  add(path_595592, "profileId", newJString(profileId))
  add(query_595593, "fields", newJString(fields))
  add(query_595593, "quotaUser", newJString(quotaUser))
  add(query_595593, "alt", newJString(alt))
  add(query_595593, "oauth_token", newJString(oauthToken))
  add(query_595593, "userIp", newJString(userIp))
  add(query_595593, "key", newJString(key))
  if body != nil:
    body_595594 = body
  add(query_595593, "prettyPrint", newJBool(prettyPrint))
  result = call_595591.call(path_595592, query_595593, nil, nil, body_595594)

var dfareportingDirectorySitesInsert* = Call_DfareportingDirectorySitesInsert_595578(
    name: "dfareportingDirectorySitesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/directorySites",
    validator: validate_DfareportingDirectorySitesInsert_595579,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySitesInsert_595580,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySitesList_595550 = ref object of OpenApiRestCall_593437
proc url_DfareportingDirectorySitesList_595552(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySitesList_595551(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of directory sites, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595553 = path.getOrDefault("profileId")
  valid_595553 = validateParameter(valid_595553, JString, required = true,
                                 default = nil)
  if valid_595553 != nil:
    section.add "profileId", valid_595553
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or URL. Wildcards (*) are allowed. For example, "directory site*2015" will return objects with names like "directory site June 2015", "directory site April 2015", or simply "directory site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site" will match objects with name "my directory site", "directory site 2015" or simply, "directory site".
  ##   countryId: JString
  ##            : Select only directory sites with this country ID.
  ##   active: JBool
  ##         : Select only active directory sites. Leave blank to retrieve both active and inactive directory sites.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   dfp_network_code: JString
  ##                   : Select only directory sites with this DFP network code.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only directory sites with these IDs.
  ##   parentId: JString
  ##           : Select only directory sites with this parent ID.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsInterstitialPlacements: JBool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   acceptsInStreamVideoPlacements: JBool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   acceptsPublisherPaidPlacements: JBool
  ##                                 : Select only directory sites that accept publisher paid placements. This field can be left blank.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595554 = query.getOrDefault("fields")
  valid_595554 = validateParameter(valid_595554, JString, required = false,
                                 default = nil)
  if valid_595554 != nil:
    section.add "fields", valid_595554
  var valid_595555 = query.getOrDefault("pageToken")
  valid_595555 = validateParameter(valid_595555, JString, required = false,
                                 default = nil)
  if valid_595555 != nil:
    section.add "pageToken", valid_595555
  var valid_595556 = query.getOrDefault("quotaUser")
  valid_595556 = validateParameter(valid_595556, JString, required = false,
                                 default = nil)
  if valid_595556 != nil:
    section.add "quotaUser", valid_595556
  var valid_595557 = query.getOrDefault("sortField")
  valid_595557 = validateParameter(valid_595557, JString, required = false,
                                 default = newJString("ID"))
  if valid_595557 != nil:
    section.add "sortField", valid_595557
  var valid_595558 = query.getOrDefault("alt")
  valid_595558 = validateParameter(valid_595558, JString, required = false,
                                 default = newJString("json"))
  if valid_595558 != nil:
    section.add "alt", valid_595558
  var valid_595559 = query.getOrDefault("searchString")
  valid_595559 = validateParameter(valid_595559, JString, required = false,
                                 default = nil)
  if valid_595559 != nil:
    section.add "searchString", valid_595559
  var valid_595560 = query.getOrDefault("countryId")
  valid_595560 = validateParameter(valid_595560, JString, required = false,
                                 default = nil)
  if valid_595560 != nil:
    section.add "countryId", valid_595560
  var valid_595561 = query.getOrDefault("active")
  valid_595561 = validateParameter(valid_595561, JBool, required = false, default = nil)
  if valid_595561 != nil:
    section.add "active", valid_595561
  var valid_595562 = query.getOrDefault("oauth_token")
  valid_595562 = validateParameter(valid_595562, JString, required = false,
                                 default = nil)
  if valid_595562 != nil:
    section.add "oauth_token", valid_595562
  var valid_595563 = query.getOrDefault("userIp")
  valid_595563 = validateParameter(valid_595563, JString, required = false,
                                 default = nil)
  if valid_595563 != nil:
    section.add "userIp", valid_595563
  var valid_595564 = query.getOrDefault("dfp_network_code")
  valid_595564 = validateParameter(valid_595564, JString, required = false,
                                 default = nil)
  if valid_595564 != nil:
    section.add "dfp_network_code", valid_595564
  var valid_595565 = query.getOrDefault("maxResults")
  valid_595565 = validateParameter(valid_595565, JInt, required = false,
                                 default = newJInt(1000))
  if valid_595565 != nil:
    section.add "maxResults", valid_595565
  var valid_595566 = query.getOrDefault("ids")
  valid_595566 = validateParameter(valid_595566, JArray, required = false,
                                 default = nil)
  if valid_595566 != nil:
    section.add "ids", valid_595566
  var valid_595567 = query.getOrDefault("parentId")
  valid_595567 = validateParameter(valid_595567, JString, required = false,
                                 default = nil)
  if valid_595567 != nil:
    section.add "parentId", valid_595567
  var valid_595568 = query.getOrDefault("key")
  valid_595568 = validateParameter(valid_595568, JString, required = false,
                                 default = nil)
  if valid_595568 != nil:
    section.add "key", valid_595568
  var valid_595569 = query.getOrDefault("acceptsInterstitialPlacements")
  valid_595569 = validateParameter(valid_595569, JBool, required = false, default = nil)
  if valid_595569 != nil:
    section.add "acceptsInterstitialPlacements", valid_595569
  var valid_595570 = query.getOrDefault("acceptsInStreamVideoPlacements")
  valid_595570 = validateParameter(valid_595570, JBool, required = false, default = nil)
  if valid_595570 != nil:
    section.add "acceptsInStreamVideoPlacements", valid_595570
  var valid_595571 = query.getOrDefault("sortOrder")
  valid_595571 = validateParameter(valid_595571, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_595571 != nil:
    section.add "sortOrder", valid_595571
  var valid_595572 = query.getOrDefault("acceptsPublisherPaidPlacements")
  valid_595572 = validateParameter(valid_595572, JBool, required = false, default = nil)
  if valid_595572 != nil:
    section.add "acceptsPublisherPaidPlacements", valid_595572
  var valid_595573 = query.getOrDefault("prettyPrint")
  valid_595573 = validateParameter(valid_595573, JBool, required = false,
                                 default = newJBool(true))
  if valid_595573 != nil:
    section.add "prettyPrint", valid_595573
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595574: Call_DfareportingDirectorySitesList_595550; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of directory sites, possibly filtered. This method supports paging.
  ## 
  let valid = call_595574.validator(path, query, header, formData, body)
  let scheme = call_595574.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595574.url(scheme.get, call_595574.host, call_595574.base,
                         call_595574.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595574, url, valid)

proc call*(call_595575: Call_DfareportingDirectorySitesList_595550;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; countryId: string = ""; active: bool = false;
          oauthToken: string = ""; userIp: string = ""; dfpNetworkCode: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; parentId: string = "";
          key: string = ""; acceptsInterstitialPlacements: bool = false;
          acceptsInStreamVideoPlacements: bool = false;
          sortOrder: string = "ASCENDING";
          acceptsPublisherPaidPlacements: bool = false; prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySitesList
  ## Retrieves a list of directory sites, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or URL. Wildcards (*) are allowed. For example, "directory site*2015" will return objects with names like "directory site June 2015", "directory site April 2015", or simply "directory site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "directory site" will match objects with name "my directory site", "directory site 2015" or simply, "directory site".
  ##   countryId: string
  ##            : Select only directory sites with this country ID.
  ##   active: bool
  ##         : Select only active directory sites. Leave blank to retrieve both active and inactive directory sites.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   dfpNetworkCode: string
  ##                 : Select only directory sites with this DFP network code.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only directory sites with these IDs.
  ##   parentId: string
  ##           : Select only directory sites with this parent ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsInterstitialPlacements: bool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   acceptsInStreamVideoPlacements: bool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   acceptsPublisherPaidPlacements: bool
  ##                                 : Select only directory sites that accept publisher paid placements. This field can be left blank.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595576 = newJObject()
  var query_595577 = newJObject()
  add(path_595576, "profileId", newJString(profileId))
  add(query_595577, "fields", newJString(fields))
  add(query_595577, "pageToken", newJString(pageToken))
  add(query_595577, "quotaUser", newJString(quotaUser))
  add(query_595577, "sortField", newJString(sortField))
  add(query_595577, "alt", newJString(alt))
  add(query_595577, "searchString", newJString(searchString))
  add(query_595577, "countryId", newJString(countryId))
  add(query_595577, "active", newJBool(active))
  add(query_595577, "oauth_token", newJString(oauthToken))
  add(query_595577, "userIp", newJString(userIp))
  add(query_595577, "dfp_network_code", newJString(dfpNetworkCode))
  add(query_595577, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_595577.add "ids", ids
  add(query_595577, "parentId", newJString(parentId))
  add(query_595577, "key", newJString(key))
  add(query_595577, "acceptsInterstitialPlacements",
      newJBool(acceptsInterstitialPlacements))
  add(query_595577, "acceptsInStreamVideoPlacements",
      newJBool(acceptsInStreamVideoPlacements))
  add(query_595577, "sortOrder", newJString(sortOrder))
  add(query_595577, "acceptsPublisherPaidPlacements",
      newJBool(acceptsPublisherPaidPlacements))
  add(query_595577, "prettyPrint", newJBool(prettyPrint))
  result = call_595575.call(path_595576, query_595577, nil, nil, nil)

var dfareportingDirectorySitesList* = Call_DfareportingDirectorySitesList_595550(
    name: "dfareportingDirectorySitesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/directorySites",
    validator: validate_DfareportingDirectorySitesList_595551,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySitesList_595552,
    schemes: {Scheme.Https})
type
  Call_DfareportingDirectorySitesGet_595595 = ref object of OpenApiRestCall_593437
proc url_DfareportingDirectorySitesGet_595597(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/directorySites/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDirectorySitesGet_595596(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one directory site by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Directory site ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595598 = path.getOrDefault("profileId")
  valid_595598 = validateParameter(valid_595598, JString, required = true,
                                 default = nil)
  if valid_595598 != nil:
    section.add "profileId", valid_595598
  var valid_595599 = path.getOrDefault("id")
  valid_595599 = validateParameter(valid_595599, JString, required = true,
                                 default = nil)
  if valid_595599 != nil:
    section.add "id", valid_595599
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595600 = query.getOrDefault("fields")
  valid_595600 = validateParameter(valid_595600, JString, required = false,
                                 default = nil)
  if valid_595600 != nil:
    section.add "fields", valid_595600
  var valid_595601 = query.getOrDefault("quotaUser")
  valid_595601 = validateParameter(valid_595601, JString, required = false,
                                 default = nil)
  if valid_595601 != nil:
    section.add "quotaUser", valid_595601
  var valid_595602 = query.getOrDefault("alt")
  valid_595602 = validateParameter(valid_595602, JString, required = false,
                                 default = newJString("json"))
  if valid_595602 != nil:
    section.add "alt", valid_595602
  var valid_595603 = query.getOrDefault("oauth_token")
  valid_595603 = validateParameter(valid_595603, JString, required = false,
                                 default = nil)
  if valid_595603 != nil:
    section.add "oauth_token", valid_595603
  var valid_595604 = query.getOrDefault("userIp")
  valid_595604 = validateParameter(valid_595604, JString, required = false,
                                 default = nil)
  if valid_595604 != nil:
    section.add "userIp", valid_595604
  var valid_595605 = query.getOrDefault("key")
  valid_595605 = validateParameter(valid_595605, JString, required = false,
                                 default = nil)
  if valid_595605 != nil:
    section.add "key", valid_595605
  var valid_595606 = query.getOrDefault("prettyPrint")
  valid_595606 = validateParameter(valid_595606, JBool, required = false,
                                 default = newJBool(true))
  if valid_595606 != nil:
    section.add "prettyPrint", valid_595606
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595607: Call_DfareportingDirectorySitesGet_595595; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one directory site by ID.
  ## 
  let valid = call_595607.validator(path, query, header, formData, body)
  let scheme = call_595607.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595607.url(scheme.get, call_595607.host, call_595607.base,
                         call_595607.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595607, url, valid)

proc call*(call_595608: Call_DfareportingDirectorySitesGet_595595;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingDirectorySitesGet
  ## Gets one directory site by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Directory site ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595609 = newJObject()
  var query_595610 = newJObject()
  add(path_595609, "profileId", newJString(profileId))
  add(query_595610, "fields", newJString(fields))
  add(query_595610, "quotaUser", newJString(quotaUser))
  add(query_595610, "alt", newJString(alt))
  add(query_595610, "oauth_token", newJString(oauthToken))
  add(query_595610, "userIp", newJString(userIp))
  add(path_595609, "id", newJString(id))
  add(query_595610, "key", newJString(key))
  add(query_595610, "prettyPrint", newJBool(prettyPrint))
  result = call_595608.call(path_595609, query_595610, nil, nil, nil)

var dfareportingDirectorySitesGet* = Call_DfareportingDirectorySitesGet_595595(
    name: "dfareportingDirectorySitesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/directorySites/{id}",
    validator: validate_DfareportingDirectorySitesGet_595596,
    base: "/dfareporting/v2.7", url: url_DfareportingDirectorySitesGet_595597,
    schemes: {Scheme.Https})
type
  Call_DfareportingDynamicTargetingKeysInsert_595630 = ref object of OpenApiRestCall_593437
proc url_DfareportingDynamicTargetingKeysInsert_595632(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dynamicTargetingKeys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDynamicTargetingKeysInsert_595631(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new dynamic targeting key. Keys must be created at the advertiser level before being assigned to the advertiser's ads, creatives, or placements. There is a maximum of 1000 keys per advertiser, out of which a maximum of 20 keys can be assigned per ad, creative, or placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595633 = path.getOrDefault("profileId")
  valid_595633 = validateParameter(valid_595633, JString, required = true,
                                 default = nil)
  if valid_595633 != nil:
    section.add "profileId", valid_595633
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595634 = query.getOrDefault("fields")
  valid_595634 = validateParameter(valid_595634, JString, required = false,
                                 default = nil)
  if valid_595634 != nil:
    section.add "fields", valid_595634
  var valid_595635 = query.getOrDefault("quotaUser")
  valid_595635 = validateParameter(valid_595635, JString, required = false,
                                 default = nil)
  if valid_595635 != nil:
    section.add "quotaUser", valid_595635
  var valid_595636 = query.getOrDefault("alt")
  valid_595636 = validateParameter(valid_595636, JString, required = false,
                                 default = newJString("json"))
  if valid_595636 != nil:
    section.add "alt", valid_595636
  var valid_595637 = query.getOrDefault("oauth_token")
  valid_595637 = validateParameter(valid_595637, JString, required = false,
                                 default = nil)
  if valid_595637 != nil:
    section.add "oauth_token", valid_595637
  var valid_595638 = query.getOrDefault("userIp")
  valid_595638 = validateParameter(valid_595638, JString, required = false,
                                 default = nil)
  if valid_595638 != nil:
    section.add "userIp", valid_595638
  var valid_595639 = query.getOrDefault("key")
  valid_595639 = validateParameter(valid_595639, JString, required = false,
                                 default = nil)
  if valid_595639 != nil:
    section.add "key", valid_595639
  var valid_595640 = query.getOrDefault("prettyPrint")
  valid_595640 = validateParameter(valid_595640, JBool, required = false,
                                 default = newJBool(true))
  if valid_595640 != nil:
    section.add "prettyPrint", valid_595640
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595642: Call_DfareportingDynamicTargetingKeysInsert_595630;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new dynamic targeting key. Keys must be created at the advertiser level before being assigned to the advertiser's ads, creatives, or placements. There is a maximum of 1000 keys per advertiser, out of which a maximum of 20 keys can be assigned per ad, creative, or placement.
  ## 
  let valid = call_595642.validator(path, query, header, formData, body)
  let scheme = call_595642.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595642.url(scheme.get, call_595642.host, call_595642.base,
                         call_595642.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595642, url, valid)

proc call*(call_595643: Call_DfareportingDynamicTargetingKeysInsert_595630;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingDynamicTargetingKeysInsert
  ## Inserts a new dynamic targeting key. Keys must be created at the advertiser level before being assigned to the advertiser's ads, creatives, or placements. There is a maximum of 1000 keys per advertiser, out of which a maximum of 20 keys can be assigned per ad, creative, or placement.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595644 = newJObject()
  var query_595645 = newJObject()
  var body_595646 = newJObject()
  add(path_595644, "profileId", newJString(profileId))
  add(query_595645, "fields", newJString(fields))
  add(query_595645, "quotaUser", newJString(quotaUser))
  add(query_595645, "alt", newJString(alt))
  add(query_595645, "oauth_token", newJString(oauthToken))
  add(query_595645, "userIp", newJString(userIp))
  add(query_595645, "key", newJString(key))
  if body != nil:
    body_595646 = body
  add(query_595645, "prettyPrint", newJBool(prettyPrint))
  result = call_595643.call(path_595644, query_595645, nil, nil, body_595646)

var dfareportingDynamicTargetingKeysInsert* = Call_DfareportingDynamicTargetingKeysInsert_595630(
    name: "dfareportingDynamicTargetingKeysInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dynamicTargetingKeys",
    validator: validate_DfareportingDynamicTargetingKeysInsert_595631,
    base: "/dfareporting/v2.7", url: url_DfareportingDynamicTargetingKeysInsert_595632,
    schemes: {Scheme.Https})
type
  Call_DfareportingDynamicTargetingKeysList_595611 = ref object of OpenApiRestCall_593437
proc url_DfareportingDynamicTargetingKeysList_595613(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dynamicTargetingKeys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDynamicTargetingKeysList_595612(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of dynamic targeting keys.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595614 = path.getOrDefault("profileId")
  valid_595614 = validateParameter(valid_595614, JString, required = true,
                                 default = nil)
  if valid_595614 != nil:
    section.add "profileId", valid_595614
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   advertiserId: JString
  ##               : Select only dynamic targeting keys whose object has this advertiser ID.
  ##   names: JArray
  ##        : Select only dynamic targeting keys exactly matching these names.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   objectId: JString
  ##           : Select only dynamic targeting keys with this object ID.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   objectType: JString
  ##             : Select only dynamic targeting keys with this object type.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595615 = query.getOrDefault("fields")
  valid_595615 = validateParameter(valid_595615, JString, required = false,
                                 default = nil)
  if valid_595615 != nil:
    section.add "fields", valid_595615
  var valid_595616 = query.getOrDefault("quotaUser")
  valid_595616 = validateParameter(valid_595616, JString, required = false,
                                 default = nil)
  if valid_595616 != nil:
    section.add "quotaUser", valid_595616
  var valid_595617 = query.getOrDefault("alt")
  valid_595617 = validateParameter(valid_595617, JString, required = false,
                                 default = newJString("json"))
  if valid_595617 != nil:
    section.add "alt", valid_595617
  var valid_595618 = query.getOrDefault("advertiserId")
  valid_595618 = validateParameter(valid_595618, JString, required = false,
                                 default = nil)
  if valid_595618 != nil:
    section.add "advertiserId", valid_595618
  var valid_595619 = query.getOrDefault("names")
  valid_595619 = validateParameter(valid_595619, JArray, required = false,
                                 default = nil)
  if valid_595619 != nil:
    section.add "names", valid_595619
  var valid_595620 = query.getOrDefault("oauth_token")
  valid_595620 = validateParameter(valid_595620, JString, required = false,
                                 default = nil)
  if valid_595620 != nil:
    section.add "oauth_token", valid_595620
  var valid_595621 = query.getOrDefault("objectId")
  valid_595621 = validateParameter(valid_595621, JString, required = false,
                                 default = nil)
  if valid_595621 != nil:
    section.add "objectId", valid_595621
  var valid_595622 = query.getOrDefault("userIp")
  valid_595622 = validateParameter(valid_595622, JString, required = false,
                                 default = nil)
  if valid_595622 != nil:
    section.add "userIp", valid_595622
  var valid_595623 = query.getOrDefault("objectType")
  valid_595623 = validateParameter(valid_595623, JString, required = false,
                                 default = newJString("OBJECT_AD"))
  if valid_595623 != nil:
    section.add "objectType", valid_595623
  var valid_595624 = query.getOrDefault("key")
  valid_595624 = validateParameter(valid_595624, JString, required = false,
                                 default = nil)
  if valid_595624 != nil:
    section.add "key", valid_595624
  var valid_595625 = query.getOrDefault("prettyPrint")
  valid_595625 = validateParameter(valid_595625, JBool, required = false,
                                 default = newJBool(true))
  if valid_595625 != nil:
    section.add "prettyPrint", valid_595625
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595626: Call_DfareportingDynamicTargetingKeysList_595611;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of dynamic targeting keys.
  ## 
  let valid = call_595626.validator(path, query, header, formData, body)
  let scheme = call_595626.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595626.url(scheme.get, call_595626.host, call_595626.base,
                         call_595626.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595626, url, valid)

proc call*(call_595627: Call_DfareportingDynamicTargetingKeysList_595611;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; advertiserId: string = ""; names: JsonNode = nil;
          oauthToken: string = ""; objectId: string = ""; userIp: string = "";
          objectType: string = "OBJECT_AD"; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingDynamicTargetingKeysList
  ## Retrieves a list of dynamic targeting keys.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   advertiserId: string
  ##               : Select only dynamic targeting keys whose object has this advertiser ID.
  ##   names: JArray
  ##        : Select only dynamic targeting keys exactly matching these names.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   objectId: string
  ##           : Select only dynamic targeting keys with this object ID.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   objectType: string
  ##             : Select only dynamic targeting keys with this object type.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595628 = newJObject()
  var query_595629 = newJObject()
  add(path_595628, "profileId", newJString(profileId))
  add(query_595629, "fields", newJString(fields))
  add(query_595629, "quotaUser", newJString(quotaUser))
  add(query_595629, "alt", newJString(alt))
  add(query_595629, "advertiserId", newJString(advertiserId))
  if names != nil:
    query_595629.add "names", names
  add(query_595629, "oauth_token", newJString(oauthToken))
  add(query_595629, "objectId", newJString(objectId))
  add(query_595629, "userIp", newJString(userIp))
  add(query_595629, "objectType", newJString(objectType))
  add(query_595629, "key", newJString(key))
  add(query_595629, "prettyPrint", newJBool(prettyPrint))
  result = call_595627.call(path_595628, query_595629, nil, nil, nil)

var dfareportingDynamicTargetingKeysList* = Call_DfareportingDynamicTargetingKeysList_595611(
    name: "dfareportingDynamicTargetingKeysList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dynamicTargetingKeys",
    validator: validate_DfareportingDynamicTargetingKeysList_595612,
    base: "/dfareporting/v2.7", url: url_DfareportingDynamicTargetingKeysList_595613,
    schemes: {Scheme.Https})
type
  Call_DfareportingDynamicTargetingKeysDelete_595647 = ref object of OpenApiRestCall_593437
proc url_DfareportingDynamicTargetingKeysDelete_595649(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "objectId" in path, "`objectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/dynamicTargetingKeys/"),
               (kind: VariableSegment, value: "objectId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingDynamicTargetingKeysDelete_595648(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing dynamic targeting key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   objectId: JString (required)
  ##           : ID of the object of this dynamic targeting key. This is a required field.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595650 = path.getOrDefault("profileId")
  valid_595650 = validateParameter(valid_595650, JString, required = true,
                                 default = nil)
  if valid_595650 != nil:
    section.add "profileId", valid_595650
  var valid_595651 = path.getOrDefault("objectId")
  valid_595651 = validateParameter(valid_595651, JString, required = true,
                                 default = nil)
  if valid_595651 != nil:
    section.add "objectId", valid_595651
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   objectType: JString (required)
  ##             : Type of the object of this dynamic targeting key. This is a required field.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: JString (required)
  ##       : Name of this dynamic targeting key. This is a required field. Must be less than 256 characters long and cannot contain commas. All characters are converted to lowercase.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595652 = query.getOrDefault("fields")
  valid_595652 = validateParameter(valid_595652, JString, required = false,
                                 default = nil)
  if valid_595652 != nil:
    section.add "fields", valid_595652
  var valid_595653 = query.getOrDefault("quotaUser")
  valid_595653 = validateParameter(valid_595653, JString, required = false,
                                 default = nil)
  if valid_595653 != nil:
    section.add "quotaUser", valid_595653
  var valid_595654 = query.getOrDefault("alt")
  valid_595654 = validateParameter(valid_595654, JString, required = false,
                                 default = newJString("json"))
  if valid_595654 != nil:
    section.add "alt", valid_595654
  var valid_595655 = query.getOrDefault("oauth_token")
  valid_595655 = validateParameter(valid_595655, JString, required = false,
                                 default = nil)
  if valid_595655 != nil:
    section.add "oauth_token", valid_595655
  var valid_595656 = query.getOrDefault("userIp")
  valid_595656 = validateParameter(valid_595656, JString, required = false,
                                 default = nil)
  if valid_595656 != nil:
    section.add "userIp", valid_595656
  assert query != nil,
        "query argument is necessary due to required `objectType` field"
  var valid_595657 = query.getOrDefault("objectType")
  valid_595657 = validateParameter(valid_595657, JString, required = true,
                                 default = newJString("OBJECT_AD"))
  if valid_595657 != nil:
    section.add "objectType", valid_595657
  var valid_595658 = query.getOrDefault("key")
  valid_595658 = validateParameter(valid_595658, JString, required = false,
                                 default = nil)
  if valid_595658 != nil:
    section.add "key", valid_595658
  var valid_595659 = query.getOrDefault("name")
  valid_595659 = validateParameter(valid_595659, JString, required = true,
                                 default = nil)
  if valid_595659 != nil:
    section.add "name", valid_595659
  var valid_595660 = query.getOrDefault("prettyPrint")
  valid_595660 = validateParameter(valid_595660, JBool, required = false,
                                 default = newJBool(true))
  if valid_595660 != nil:
    section.add "prettyPrint", valid_595660
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595661: Call_DfareportingDynamicTargetingKeysDelete_595647;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing dynamic targeting key.
  ## 
  let valid = call_595661.validator(path, query, header, formData, body)
  let scheme = call_595661.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595661.url(scheme.get, call_595661.host, call_595661.base,
                         call_595661.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595661, url, valid)

proc call*(call_595662: Call_DfareportingDynamicTargetingKeysDelete_595647;
          profileId: string; objectId: string; name: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; objectType: string = "OBJECT_AD"; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingDynamicTargetingKeysDelete
  ## Deletes an existing dynamic targeting key.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   objectId: string (required)
  ##           : ID of the object of this dynamic targeting key. This is a required field.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   objectType: string (required)
  ##             : Type of the object of this dynamic targeting key. This is a required field.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: string (required)
  ##       : Name of this dynamic targeting key. This is a required field. Must be less than 256 characters long and cannot contain commas. All characters are converted to lowercase.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595663 = newJObject()
  var query_595664 = newJObject()
  add(path_595663, "profileId", newJString(profileId))
  add(query_595664, "fields", newJString(fields))
  add(query_595664, "quotaUser", newJString(quotaUser))
  add(query_595664, "alt", newJString(alt))
  add(path_595663, "objectId", newJString(objectId))
  add(query_595664, "oauth_token", newJString(oauthToken))
  add(query_595664, "userIp", newJString(userIp))
  add(query_595664, "objectType", newJString(objectType))
  add(query_595664, "key", newJString(key))
  add(query_595664, "name", newJString(name))
  add(query_595664, "prettyPrint", newJBool(prettyPrint))
  result = call_595662.call(path_595663, query_595664, nil, nil, nil)

var dfareportingDynamicTargetingKeysDelete* = Call_DfareportingDynamicTargetingKeysDelete_595647(
    name: "dfareportingDynamicTargetingKeysDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/dynamicTargetingKeys/{objectId}",
    validator: validate_DfareportingDynamicTargetingKeysDelete_595648,
    base: "/dfareporting/v2.7", url: url_DfareportingDynamicTargetingKeysDelete_595649,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsUpdate_595690 = ref object of OpenApiRestCall_593437
proc url_DfareportingEventTagsUpdate_595692(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsUpdate_595691(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing event tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595693 = path.getOrDefault("profileId")
  valid_595693 = validateParameter(valid_595693, JString, required = true,
                                 default = nil)
  if valid_595693 != nil:
    section.add "profileId", valid_595693
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595694 = query.getOrDefault("fields")
  valid_595694 = validateParameter(valid_595694, JString, required = false,
                                 default = nil)
  if valid_595694 != nil:
    section.add "fields", valid_595694
  var valid_595695 = query.getOrDefault("quotaUser")
  valid_595695 = validateParameter(valid_595695, JString, required = false,
                                 default = nil)
  if valid_595695 != nil:
    section.add "quotaUser", valid_595695
  var valid_595696 = query.getOrDefault("alt")
  valid_595696 = validateParameter(valid_595696, JString, required = false,
                                 default = newJString("json"))
  if valid_595696 != nil:
    section.add "alt", valid_595696
  var valid_595697 = query.getOrDefault("oauth_token")
  valid_595697 = validateParameter(valid_595697, JString, required = false,
                                 default = nil)
  if valid_595697 != nil:
    section.add "oauth_token", valid_595697
  var valid_595698 = query.getOrDefault("userIp")
  valid_595698 = validateParameter(valid_595698, JString, required = false,
                                 default = nil)
  if valid_595698 != nil:
    section.add "userIp", valid_595698
  var valid_595699 = query.getOrDefault("key")
  valid_595699 = validateParameter(valid_595699, JString, required = false,
                                 default = nil)
  if valid_595699 != nil:
    section.add "key", valid_595699
  var valid_595700 = query.getOrDefault("prettyPrint")
  valid_595700 = validateParameter(valid_595700, JBool, required = false,
                                 default = newJBool(true))
  if valid_595700 != nil:
    section.add "prettyPrint", valid_595700
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595702: Call_DfareportingEventTagsUpdate_595690; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing event tag.
  ## 
  let valid = call_595702.validator(path, query, header, formData, body)
  let scheme = call_595702.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595702.url(scheme.get, call_595702.host, call_595702.base,
                         call_595702.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595702, url, valid)

proc call*(call_595703: Call_DfareportingEventTagsUpdate_595690; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsUpdate
  ## Updates an existing event tag.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595704 = newJObject()
  var query_595705 = newJObject()
  var body_595706 = newJObject()
  add(path_595704, "profileId", newJString(profileId))
  add(query_595705, "fields", newJString(fields))
  add(query_595705, "quotaUser", newJString(quotaUser))
  add(query_595705, "alt", newJString(alt))
  add(query_595705, "oauth_token", newJString(oauthToken))
  add(query_595705, "userIp", newJString(userIp))
  add(query_595705, "key", newJString(key))
  if body != nil:
    body_595706 = body
  add(query_595705, "prettyPrint", newJBool(prettyPrint))
  result = call_595703.call(path_595704, query_595705, nil, nil, body_595706)

var dfareportingEventTagsUpdate* = Call_DfareportingEventTagsUpdate_595690(
    name: "dfareportingEventTagsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsUpdate_595691,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsUpdate_595692,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsInsert_595707 = ref object of OpenApiRestCall_593437
proc url_DfareportingEventTagsInsert_595709(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsInsert_595708(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new event tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595710 = path.getOrDefault("profileId")
  valid_595710 = validateParameter(valid_595710, JString, required = true,
                                 default = nil)
  if valid_595710 != nil:
    section.add "profileId", valid_595710
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595711 = query.getOrDefault("fields")
  valid_595711 = validateParameter(valid_595711, JString, required = false,
                                 default = nil)
  if valid_595711 != nil:
    section.add "fields", valid_595711
  var valid_595712 = query.getOrDefault("quotaUser")
  valid_595712 = validateParameter(valid_595712, JString, required = false,
                                 default = nil)
  if valid_595712 != nil:
    section.add "quotaUser", valid_595712
  var valid_595713 = query.getOrDefault("alt")
  valid_595713 = validateParameter(valid_595713, JString, required = false,
                                 default = newJString("json"))
  if valid_595713 != nil:
    section.add "alt", valid_595713
  var valid_595714 = query.getOrDefault("oauth_token")
  valid_595714 = validateParameter(valid_595714, JString, required = false,
                                 default = nil)
  if valid_595714 != nil:
    section.add "oauth_token", valid_595714
  var valid_595715 = query.getOrDefault("userIp")
  valid_595715 = validateParameter(valid_595715, JString, required = false,
                                 default = nil)
  if valid_595715 != nil:
    section.add "userIp", valid_595715
  var valid_595716 = query.getOrDefault("key")
  valid_595716 = validateParameter(valid_595716, JString, required = false,
                                 default = nil)
  if valid_595716 != nil:
    section.add "key", valid_595716
  var valid_595717 = query.getOrDefault("prettyPrint")
  valid_595717 = validateParameter(valid_595717, JBool, required = false,
                                 default = newJBool(true))
  if valid_595717 != nil:
    section.add "prettyPrint", valid_595717
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595719: Call_DfareportingEventTagsInsert_595707; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new event tag.
  ## 
  let valid = call_595719.validator(path, query, header, formData, body)
  let scheme = call_595719.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595719.url(scheme.get, call_595719.host, call_595719.base,
                         call_595719.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595719, url, valid)

proc call*(call_595720: Call_DfareportingEventTagsInsert_595707; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsInsert
  ## Inserts a new event tag.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595721 = newJObject()
  var query_595722 = newJObject()
  var body_595723 = newJObject()
  add(path_595721, "profileId", newJString(profileId))
  add(query_595722, "fields", newJString(fields))
  add(query_595722, "quotaUser", newJString(quotaUser))
  add(query_595722, "alt", newJString(alt))
  add(query_595722, "oauth_token", newJString(oauthToken))
  add(query_595722, "userIp", newJString(userIp))
  add(query_595722, "key", newJString(key))
  if body != nil:
    body_595723 = body
  add(query_595722, "prettyPrint", newJBool(prettyPrint))
  result = call_595720.call(path_595721, query_595722, nil, nil, body_595723)

var dfareportingEventTagsInsert* = Call_DfareportingEventTagsInsert_595707(
    name: "dfareportingEventTagsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsInsert_595708,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsInsert_595709,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsList_595665 = ref object of OpenApiRestCall_593437
proc url_DfareportingEventTagsList_595667(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsList_595666(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of event tags, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595668 = path.getOrDefault("profileId")
  valid_595668 = validateParameter(valid_595668, JString, required = true,
                                 default = nil)
  if valid_595668 != nil:
    section.add "profileId", valid_595668
  result.add "path", section
  ## parameters in `query` object:
  ##   enabled: JBool
  ##          : Select only enabled event tags. What is considered enabled or disabled depends on the definitionsOnly parameter. When definitionsOnly is set to true, only the specified advertiser or campaign's event tags' enabledByDefault field is examined. When definitionsOnly is set to false, the specified ad or specified campaign's parent advertiser's or parent campaign's event tags' enabledByDefault and status fields are examined as well.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   definitionsOnly: JBool
  ##                  : Examine only the specified campaign or advertiser's event tags for matching selector criteria. When set to false, the parent advertiser and parent campaign of the specified ad or campaign is examined as well. In addition, when set to false, the status field is examined as well, along with the enabledByDefault field. This parameter can not be set to true when adId is specified as ads do not define their own even tags.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "eventtag*2015" will return objects with names like "eventtag June 2015", "eventtag April 2015", or simply "eventtag 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "eventtag" will match objects with name "my eventtag", "eventtag 2015", or simply "eventtag".
  ##   advertiserId: JString
  ##               : Select only event tags that belong to this advertiser.
  ##   eventTagTypes: JArray
  ##                : Select only event tags with the specified event tag types. Event tag types can be used to specify whether to use a third-party pixel, a third-party JavaScript URL, or a third-party click-through URL for either impression or click tracking.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   adId: JString
  ##       : Select only event tags that belong to this ad.
  ##   ids: JArray
  ##      : Select only event tags with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: JString
  ##             : Select only event tags that belong to this campaign.
  section = newJObject()
  var valid_595669 = query.getOrDefault("enabled")
  valid_595669 = validateParameter(valid_595669, JBool, required = false, default = nil)
  if valid_595669 != nil:
    section.add "enabled", valid_595669
  var valid_595670 = query.getOrDefault("fields")
  valid_595670 = validateParameter(valid_595670, JString, required = false,
                                 default = nil)
  if valid_595670 != nil:
    section.add "fields", valid_595670
  var valid_595671 = query.getOrDefault("quotaUser")
  valid_595671 = validateParameter(valid_595671, JString, required = false,
                                 default = nil)
  if valid_595671 != nil:
    section.add "quotaUser", valid_595671
  var valid_595672 = query.getOrDefault("sortField")
  valid_595672 = validateParameter(valid_595672, JString, required = false,
                                 default = newJString("ID"))
  if valid_595672 != nil:
    section.add "sortField", valid_595672
  var valid_595673 = query.getOrDefault("alt")
  valid_595673 = validateParameter(valid_595673, JString, required = false,
                                 default = newJString("json"))
  if valid_595673 != nil:
    section.add "alt", valid_595673
  var valid_595674 = query.getOrDefault("definitionsOnly")
  valid_595674 = validateParameter(valid_595674, JBool, required = false, default = nil)
  if valid_595674 != nil:
    section.add "definitionsOnly", valid_595674
  var valid_595675 = query.getOrDefault("searchString")
  valid_595675 = validateParameter(valid_595675, JString, required = false,
                                 default = nil)
  if valid_595675 != nil:
    section.add "searchString", valid_595675
  var valid_595676 = query.getOrDefault("advertiserId")
  valid_595676 = validateParameter(valid_595676, JString, required = false,
                                 default = nil)
  if valid_595676 != nil:
    section.add "advertiserId", valid_595676
  var valid_595677 = query.getOrDefault("eventTagTypes")
  valid_595677 = validateParameter(valid_595677, JArray, required = false,
                                 default = nil)
  if valid_595677 != nil:
    section.add "eventTagTypes", valid_595677
  var valid_595678 = query.getOrDefault("oauth_token")
  valid_595678 = validateParameter(valid_595678, JString, required = false,
                                 default = nil)
  if valid_595678 != nil:
    section.add "oauth_token", valid_595678
  var valid_595679 = query.getOrDefault("userIp")
  valid_595679 = validateParameter(valid_595679, JString, required = false,
                                 default = nil)
  if valid_595679 != nil:
    section.add "userIp", valid_595679
  var valid_595680 = query.getOrDefault("adId")
  valid_595680 = validateParameter(valid_595680, JString, required = false,
                                 default = nil)
  if valid_595680 != nil:
    section.add "adId", valid_595680
  var valid_595681 = query.getOrDefault("ids")
  valid_595681 = validateParameter(valid_595681, JArray, required = false,
                                 default = nil)
  if valid_595681 != nil:
    section.add "ids", valid_595681
  var valid_595682 = query.getOrDefault("key")
  valid_595682 = validateParameter(valid_595682, JString, required = false,
                                 default = nil)
  if valid_595682 != nil:
    section.add "key", valid_595682
  var valid_595683 = query.getOrDefault("sortOrder")
  valid_595683 = validateParameter(valid_595683, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_595683 != nil:
    section.add "sortOrder", valid_595683
  var valid_595684 = query.getOrDefault("prettyPrint")
  valid_595684 = validateParameter(valid_595684, JBool, required = false,
                                 default = newJBool(true))
  if valid_595684 != nil:
    section.add "prettyPrint", valid_595684
  var valid_595685 = query.getOrDefault("campaignId")
  valid_595685 = validateParameter(valid_595685, JString, required = false,
                                 default = nil)
  if valid_595685 != nil:
    section.add "campaignId", valid_595685
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595686: Call_DfareportingEventTagsList_595665; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of event tags, possibly filtered.
  ## 
  let valid = call_595686.validator(path, query, header, formData, body)
  let scheme = call_595686.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595686.url(scheme.get, call_595686.host, call_595686.base,
                         call_595686.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595686, url, valid)

proc call*(call_595687: Call_DfareportingEventTagsList_595665; profileId: string;
          enabled: bool = false; fields: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; definitionsOnly: bool = false;
          searchString: string = ""; advertiserId: string = "";
          eventTagTypes: JsonNode = nil; oauthToken: string = ""; userIp: string = "";
          adId: string = ""; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true;
          campaignId: string = ""): Recallable =
  ## dfareportingEventTagsList
  ## Retrieves a list of event tags, possibly filtered.
  ##   enabled: bool
  ##          : Select only enabled event tags. What is considered enabled or disabled depends on the definitionsOnly parameter. When definitionsOnly is set to true, only the specified advertiser or campaign's event tags' enabledByDefault field is examined. When definitionsOnly is set to false, the specified ad or specified campaign's parent advertiser's or parent campaign's event tags' enabledByDefault and status fields are examined as well.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   definitionsOnly: bool
  ##                  : Examine only the specified campaign or advertiser's event tags for matching selector criteria. When set to false, the parent advertiser and parent campaign of the specified ad or campaign is examined as well. In addition, when set to false, the status field is examined as well, along with the enabledByDefault field. This parameter can not be set to true when adId is specified as ads do not define their own even tags.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "eventtag*2015" will return objects with names like "eventtag June 2015", "eventtag April 2015", or simply "eventtag 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "eventtag" will match objects with name "my eventtag", "eventtag 2015", or simply "eventtag".
  ##   advertiserId: string
  ##               : Select only event tags that belong to this advertiser.
  ##   eventTagTypes: JArray
  ##                : Select only event tags with the specified event tag types. Event tag types can be used to specify whether to use a third-party pixel, a third-party JavaScript URL, or a third-party click-through URL for either impression or click tracking.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   adId: string
  ##       : Select only event tags that belong to this ad.
  ##   ids: JArray
  ##      : Select only event tags with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: string
  ##             : Select only event tags that belong to this campaign.
  var path_595688 = newJObject()
  var query_595689 = newJObject()
  add(query_595689, "enabled", newJBool(enabled))
  add(path_595688, "profileId", newJString(profileId))
  add(query_595689, "fields", newJString(fields))
  add(query_595689, "quotaUser", newJString(quotaUser))
  add(query_595689, "sortField", newJString(sortField))
  add(query_595689, "alt", newJString(alt))
  add(query_595689, "definitionsOnly", newJBool(definitionsOnly))
  add(query_595689, "searchString", newJString(searchString))
  add(query_595689, "advertiserId", newJString(advertiserId))
  if eventTagTypes != nil:
    query_595689.add "eventTagTypes", eventTagTypes
  add(query_595689, "oauth_token", newJString(oauthToken))
  add(query_595689, "userIp", newJString(userIp))
  add(query_595689, "adId", newJString(adId))
  if ids != nil:
    query_595689.add "ids", ids
  add(query_595689, "key", newJString(key))
  add(query_595689, "sortOrder", newJString(sortOrder))
  add(query_595689, "prettyPrint", newJBool(prettyPrint))
  add(query_595689, "campaignId", newJString(campaignId))
  result = call_595687.call(path_595688, query_595689, nil, nil, nil)

var dfareportingEventTagsList* = Call_DfareportingEventTagsList_595665(
    name: "dfareportingEventTagsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsList_595666,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsList_595667,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsPatch_595724 = ref object of OpenApiRestCall_593437
proc url_DfareportingEventTagsPatch_595726(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsPatch_595725(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing event tag. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595727 = path.getOrDefault("profileId")
  valid_595727 = validateParameter(valid_595727, JString, required = true,
                                 default = nil)
  if valid_595727 != nil:
    section.add "profileId", valid_595727
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Event tag ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595728 = query.getOrDefault("fields")
  valid_595728 = validateParameter(valid_595728, JString, required = false,
                                 default = nil)
  if valid_595728 != nil:
    section.add "fields", valid_595728
  var valid_595729 = query.getOrDefault("quotaUser")
  valid_595729 = validateParameter(valid_595729, JString, required = false,
                                 default = nil)
  if valid_595729 != nil:
    section.add "quotaUser", valid_595729
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_595730 = query.getOrDefault("id")
  valid_595730 = validateParameter(valid_595730, JString, required = true,
                                 default = nil)
  if valid_595730 != nil:
    section.add "id", valid_595730
  var valid_595731 = query.getOrDefault("alt")
  valid_595731 = validateParameter(valid_595731, JString, required = false,
                                 default = newJString("json"))
  if valid_595731 != nil:
    section.add "alt", valid_595731
  var valid_595732 = query.getOrDefault("oauth_token")
  valid_595732 = validateParameter(valid_595732, JString, required = false,
                                 default = nil)
  if valid_595732 != nil:
    section.add "oauth_token", valid_595732
  var valid_595733 = query.getOrDefault("userIp")
  valid_595733 = validateParameter(valid_595733, JString, required = false,
                                 default = nil)
  if valid_595733 != nil:
    section.add "userIp", valid_595733
  var valid_595734 = query.getOrDefault("key")
  valid_595734 = validateParameter(valid_595734, JString, required = false,
                                 default = nil)
  if valid_595734 != nil:
    section.add "key", valid_595734
  var valid_595735 = query.getOrDefault("prettyPrint")
  valid_595735 = validateParameter(valid_595735, JBool, required = false,
                                 default = newJBool(true))
  if valid_595735 != nil:
    section.add "prettyPrint", valid_595735
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595737: Call_DfareportingEventTagsPatch_595724; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing event tag. This method supports patch semantics.
  ## 
  let valid = call_595737.validator(path, query, header, formData, body)
  let scheme = call_595737.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595737.url(scheme.get, call_595737.host, call_595737.base,
                         call_595737.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595737, url, valid)

proc call*(call_595738: Call_DfareportingEventTagsPatch_595724; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsPatch
  ## Updates an existing event tag. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Event tag ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595739 = newJObject()
  var query_595740 = newJObject()
  var body_595741 = newJObject()
  add(path_595739, "profileId", newJString(profileId))
  add(query_595740, "fields", newJString(fields))
  add(query_595740, "quotaUser", newJString(quotaUser))
  add(query_595740, "id", newJString(id))
  add(query_595740, "alt", newJString(alt))
  add(query_595740, "oauth_token", newJString(oauthToken))
  add(query_595740, "userIp", newJString(userIp))
  add(query_595740, "key", newJString(key))
  if body != nil:
    body_595741 = body
  add(query_595740, "prettyPrint", newJBool(prettyPrint))
  result = call_595738.call(path_595739, query_595740, nil, nil, body_595741)

var dfareportingEventTagsPatch* = Call_DfareportingEventTagsPatch_595724(
    name: "dfareportingEventTagsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags",
    validator: validate_DfareportingEventTagsPatch_595725,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsPatch_595726,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsGet_595742 = ref object of OpenApiRestCall_593437
proc url_DfareportingEventTagsGet_595744(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsGet_595743(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one event tag by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Event tag ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595745 = path.getOrDefault("profileId")
  valid_595745 = validateParameter(valid_595745, JString, required = true,
                                 default = nil)
  if valid_595745 != nil:
    section.add "profileId", valid_595745
  var valid_595746 = path.getOrDefault("id")
  valid_595746 = validateParameter(valid_595746, JString, required = true,
                                 default = nil)
  if valid_595746 != nil:
    section.add "id", valid_595746
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595747 = query.getOrDefault("fields")
  valid_595747 = validateParameter(valid_595747, JString, required = false,
                                 default = nil)
  if valid_595747 != nil:
    section.add "fields", valid_595747
  var valid_595748 = query.getOrDefault("quotaUser")
  valid_595748 = validateParameter(valid_595748, JString, required = false,
                                 default = nil)
  if valid_595748 != nil:
    section.add "quotaUser", valid_595748
  var valid_595749 = query.getOrDefault("alt")
  valid_595749 = validateParameter(valid_595749, JString, required = false,
                                 default = newJString("json"))
  if valid_595749 != nil:
    section.add "alt", valid_595749
  var valid_595750 = query.getOrDefault("oauth_token")
  valid_595750 = validateParameter(valid_595750, JString, required = false,
                                 default = nil)
  if valid_595750 != nil:
    section.add "oauth_token", valid_595750
  var valid_595751 = query.getOrDefault("userIp")
  valid_595751 = validateParameter(valid_595751, JString, required = false,
                                 default = nil)
  if valid_595751 != nil:
    section.add "userIp", valid_595751
  var valid_595752 = query.getOrDefault("key")
  valid_595752 = validateParameter(valid_595752, JString, required = false,
                                 default = nil)
  if valid_595752 != nil:
    section.add "key", valid_595752
  var valid_595753 = query.getOrDefault("prettyPrint")
  valid_595753 = validateParameter(valid_595753, JBool, required = false,
                                 default = newJBool(true))
  if valid_595753 != nil:
    section.add "prettyPrint", valid_595753
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595754: Call_DfareportingEventTagsGet_595742; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one event tag by ID.
  ## 
  let valid = call_595754.validator(path, query, header, formData, body)
  let scheme = call_595754.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595754.url(scheme.get, call_595754.host, call_595754.base,
                         call_595754.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595754, url, valid)

proc call*(call_595755: Call_DfareportingEventTagsGet_595742; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsGet
  ## Gets one event tag by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Event tag ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595756 = newJObject()
  var query_595757 = newJObject()
  add(path_595756, "profileId", newJString(profileId))
  add(query_595757, "fields", newJString(fields))
  add(query_595757, "quotaUser", newJString(quotaUser))
  add(query_595757, "alt", newJString(alt))
  add(query_595757, "oauth_token", newJString(oauthToken))
  add(query_595757, "userIp", newJString(userIp))
  add(path_595756, "id", newJString(id))
  add(query_595757, "key", newJString(key))
  add(query_595757, "prettyPrint", newJBool(prettyPrint))
  result = call_595755.call(path_595756, query_595757, nil, nil, nil)

var dfareportingEventTagsGet* = Call_DfareportingEventTagsGet_595742(
    name: "dfareportingEventTagsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags/{id}",
    validator: validate_DfareportingEventTagsGet_595743,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsGet_595744,
    schemes: {Scheme.Https})
type
  Call_DfareportingEventTagsDelete_595758 = ref object of OpenApiRestCall_593437
proc url_DfareportingEventTagsDelete_595760(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/eventTags/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingEventTagsDelete_595759(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing event tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Event tag ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595761 = path.getOrDefault("profileId")
  valid_595761 = validateParameter(valid_595761, JString, required = true,
                                 default = nil)
  if valid_595761 != nil:
    section.add "profileId", valid_595761
  var valid_595762 = path.getOrDefault("id")
  valid_595762 = validateParameter(valid_595762, JString, required = true,
                                 default = nil)
  if valid_595762 != nil:
    section.add "id", valid_595762
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595763 = query.getOrDefault("fields")
  valid_595763 = validateParameter(valid_595763, JString, required = false,
                                 default = nil)
  if valid_595763 != nil:
    section.add "fields", valid_595763
  var valid_595764 = query.getOrDefault("quotaUser")
  valid_595764 = validateParameter(valid_595764, JString, required = false,
                                 default = nil)
  if valid_595764 != nil:
    section.add "quotaUser", valid_595764
  var valid_595765 = query.getOrDefault("alt")
  valid_595765 = validateParameter(valid_595765, JString, required = false,
                                 default = newJString("json"))
  if valid_595765 != nil:
    section.add "alt", valid_595765
  var valid_595766 = query.getOrDefault("oauth_token")
  valid_595766 = validateParameter(valid_595766, JString, required = false,
                                 default = nil)
  if valid_595766 != nil:
    section.add "oauth_token", valid_595766
  var valid_595767 = query.getOrDefault("userIp")
  valid_595767 = validateParameter(valid_595767, JString, required = false,
                                 default = nil)
  if valid_595767 != nil:
    section.add "userIp", valid_595767
  var valid_595768 = query.getOrDefault("key")
  valid_595768 = validateParameter(valid_595768, JString, required = false,
                                 default = nil)
  if valid_595768 != nil:
    section.add "key", valid_595768
  var valid_595769 = query.getOrDefault("prettyPrint")
  valid_595769 = validateParameter(valid_595769, JBool, required = false,
                                 default = newJBool(true))
  if valid_595769 != nil:
    section.add "prettyPrint", valid_595769
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595770: Call_DfareportingEventTagsDelete_595758; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing event tag.
  ## 
  let valid = call_595770.validator(path, query, header, formData, body)
  let scheme = call_595770.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595770.url(scheme.get, call_595770.host, call_595770.base,
                         call_595770.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595770, url, valid)

proc call*(call_595771: Call_DfareportingEventTagsDelete_595758; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingEventTagsDelete
  ## Deletes an existing event tag.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Event tag ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595772 = newJObject()
  var query_595773 = newJObject()
  add(path_595772, "profileId", newJString(profileId))
  add(query_595773, "fields", newJString(fields))
  add(query_595773, "quotaUser", newJString(quotaUser))
  add(query_595773, "alt", newJString(alt))
  add(query_595773, "oauth_token", newJString(oauthToken))
  add(query_595773, "userIp", newJString(userIp))
  add(path_595772, "id", newJString(id))
  add(query_595773, "key", newJString(key))
  add(query_595773, "prettyPrint", newJBool(prettyPrint))
  result = call_595771.call(path_595772, query_595773, nil, nil, nil)

var dfareportingEventTagsDelete* = Call_DfareportingEventTagsDelete_595758(
    name: "dfareportingEventTagsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/eventTags/{id}",
    validator: validate_DfareportingEventTagsDelete_595759,
    base: "/dfareporting/v2.7", url: url_DfareportingEventTagsDelete_595760,
    schemes: {Scheme.Https})
type
  Call_DfareportingFilesList_595774 = ref object of OpenApiRestCall_593437
proc url_DfareportingFilesList_595776(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFilesList_595775(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists files for a user profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595777 = path.getOrDefault("profileId")
  valid_595777 = validateParameter(valid_595777, JString, required = true,
                                 default = nil)
  if valid_595777 != nil:
    section.add "profileId", valid_595777
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : The field by which to sort the list.
  ##   scope: JString
  ##        : The scope that defines which results are returned.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595778 = query.getOrDefault("fields")
  valid_595778 = validateParameter(valid_595778, JString, required = false,
                                 default = nil)
  if valid_595778 != nil:
    section.add "fields", valid_595778
  var valid_595779 = query.getOrDefault("pageToken")
  valid_595779 = validateParameter(valid_595779, JString, required = false,
                                 default = nil)
  if valid_595779 != nil:
    section.add "pageToken", valid_595779
  var valid_595780 = query.getOrDefault("quotaUser")
  valid_595780 = validateParameter(valid_595780, JString, required = false,
                                 default = nil)
  if valid_595780 != nil:
    section.add "quotaUser", valid_595780
  var valid_595781 = query.getOrDefault("sortField")
  valid_595781 = validateParameter(valid_595781, JString, required = false,
                                 default = newJString("LAST_MODIFIED_TIME"))
  if valid_595781 != nil:
    section.add "sortField", valid_595781
  var valid_595782 = query.getOrDefault("scope")
  valid_595782 = validateParameter(valid_595782, JString, required = false,
                                 default = newJString("MINE"))
  if valid_595782 != nil:
    section.add "scope", valid_595782
  var valid_595783 = query.getOrDefault("alt")
  valid_595783 = validateParameter(valid_595783, JString, required = false,
                                 default = newJString("json"))
  if valid_595783 != nil:
    section.add "alt", valid_595783
  var valid_595784 = query.getOrDefault("oauth_token")
  valid_595784 = validateParameter(valid_595784, JString, required = false,
                                 default = nil)
  if valid_595784 != nil:
    section.add "oauth_token", valid_595784
  var valid_595785 = query.getOrDefault("userIp")
  valid_595785 = validateParameter(valid_595785, JString, required = false,
                                 default = nil)
  if valid_595785 != nil:
    section.add "userIp", valid_595785
  var valid_595786 = query.getOrDefault("maxResults")
  valid_595786 = validateParameter(valid_595786, JInt, required = false,
                                 default = newJInt(10))
  if valid_595786 != nil:
    section.add "maxResults", valid_595786
  var valid_595787 = query.getOrDefault("key")
  valid_595787 = validateParameter(valid_595787, JString, required = false,
                                 default = nil)
  if valid_595787 != nil:
    section.add "key", valid_595787
  var valid_595788 = query.getOrDefault("sortOrder")
  valid_595788 = validateParameter(valid_595788, JString, required = false,
                                 default = newJString("DESCENDING"))
  if valid_595788 != nil:
    section.add "sortOrder", valid_595788
  var valid_595789 = query.getOrDefault("prettyPrint")
  valid_595789 = validateParameter(valid_595789, JBool, required = false,
                                 default = newJBool(true))
  if valid_595789 != nil:
    section.add "prettyPrint", valid_595789
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595790: Call_DfareportingFilesList_595774; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists files for a user profile.
  ## 
  let valid = call_595790.validator(path, query, header, formData, body)
  let scheme = call_595790.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595790.url(scheme.get, call_595790.host, call_595790.base,
                         call_595790.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595790, url, valid)

proc call*(call_595791: Call_DfareportingFilesList_595774; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "LAST_MODIFIED_TIME"; scope: string = "MINE";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 10; key: string = ""; sortOrder: string = "DESCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingFilesList
  ## Lists files for a user profile.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : The field by which to sort the list.
  ##   scope: string
  ##        : The scope that defines which results are returned.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595792 = newJObject()
  var query_595793 = newJObject()
  add(path_595792, "profileId", newJString(profileId))
  add(query_595793, "fields", newJString(fields))
  add(query_595793, "pageToken", newJString(pageToken))
  add(query_595793, "quotaUser", newJString(quotaUser))
  add(query_595793, "sortField", newJString(sortField))
  add(query_595793, "scope", newJString(scope))
  add(query_595793, "alt", newJString(alt))
  add(query_595793, "oauth_token", newJString(oauthToken))
  add(query_595793, "userIp", newJString(userIp))
  add(query_595793, "maxResults", newJInt(maxResults))
  add(query_595793, "key", newJString(key))
  add(query_595793, "sortOrder", newJString(sortOrder))
  add(query_595793, "prettyPrint", newJBool(prettyPrint))
  result = call_595791.call(path_595792, query_595793, nil, nil, nil)

var dfareportingFilesList* = Call_DfareportingFilesList_595774(
    name: "dfareportingFilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/files",
    validator: validate_DfareportingFilesList_595775, base: "/dfareporting/v2.7",
    url: url_DfareportingFilesList_595776, schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesUpdate_595822 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightActivitiesUpdate_595824(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesUpdate_595823(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595825 = path.getOrDefault("profileId")
  valid_595825 = validateParameter(valid_595825, JString, required = true,
                                 default = nil)
  if valid_595825 != nil:
    section.add "profileId", valid_595825
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595826 = query.getOrDefault("fields")
  valid_595826 = validateParameter(valid_595826, JString, required = false,
                                 default = nil)
  if valid_595826 != nil:
    section.add "fields", valid_595826
  var valid_595827 = query.getOrDefault("quotaUser")
  valid_595827 = validateParameter(valid_595827, JString, required = false,
                                 default = nil)
  if valid_595827 != nil:
    section.add "quotaUser", valid_595827
  var valid_595828 = query.getOrDefault("alt")
  valid_595828 = validateParameter(valid_595828, JString, required = false,
                                 default = newJString("json"))
  if valid_595828 != nil:
    section.add "alt", valid_595828
  var valid_595829 = query.getOrDefault("oauth_token")
  valid_595829 = validateParameter(valid_595829, JString, required = false,
                                 default = nil)
  if valid_595829 != nil:
    section.add "oauth_token", valid_595829
  var valid_595830 = query.getOrDefault("userIp")
  valid_595830 = validateParameter(valid_595830, JString, required = false,
                                 default = nil)
  if valid_595830 != nil:
    section.add "userIp", valid_595830
  var valid_595831 = query.getOrDefault("key")
  valid_595831 = validateParameter(valid_595831, JString, required = false,
                                 default = nil)
  if valid_595831 != nil:
    section.add "key", valid_595831
  var valid_595832 = query.getOrDefault("prettyPrint")
  valid_595832 = validateParameter(valid_595832, JBool, required = false,
                                 default = newJBool(true))
  if valid_595832 != nil:
    section.add "prettyPrint", valid_595832
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595834: Call_DfareportingFloodlightActivitiesUpdate_595822;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity.
  ## 
  let valid = call_595834.validator(path, query, header, formData, body)
  let scheme = call_595834.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595834.url(scheme.get, call_595834.host, call_595834.base,
                         call_595834.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595834, url, valid)

proc call*(call_595835: Call_DfareportingFloodlightActivitiesUpdate_595822;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesUpdate
  ## Updates an existing floodlight activity.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595836 = newJObject()
  var query_595837 = newJObject()
  var body_595838 = newJObject()
  add(path_595836, "profileId", newJString(profileId))
  add(query_595837, "fields", newJString(fields))
  add(query_595837, "quotaUser", newJString(quotaUser))
  add(query_595837, "alt", newJString(alt))
  add(query_595837, "oauth_token", newJString(oauthToken))
  add(query_595837, "userIp", newJString(userIp))
  add(query_595837, "key", newJString(key))
  if body != nil:
    body_595838 = body
  add(query_595837, "prettyPrint", newJBool(prettyPrint))
  result = call_595835.call(path_595836, query_595837, nil, nil, body_595838)

var dfareportingFloodlightActivitiesUpdate* = Call_DfareportingFloodlightActivitiesUpdate_595822(
    name: "dfareportingFloodlightActivitiesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesUpdate_595823,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesUpdate_595824,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesInsert_595839 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightActivitiesInsert_595841(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesInsert_595840(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595842 = path.getOrDefault("profileId")
  valid_595842 = validateParameter(valid_595842, JString, required = true,
                                 default = nil)
  if valid_595842 != nil:
    section.add "profileId", valid_595842
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595843 = query.getOrDefault("fields")
  valid_595843 = validateParameter(valid_595843, JString, required = false,
                                 default = nil)
  if valid_595843 != nil:
    section.add "fields", valid_595843
  var valid_595844 = query.getOrDefault("quotaUser")
  valid_595844 = validateParameter(valid_595844, JString, required = false,
                                 default = nil)
  if valid_595844 != nil:
    section.add "quotaUser", valid_595844
  var valid_595845 = query.getOrDefault("alt")
  valid_595845 = validateParameter(valid_595845, JString, required = false,
                                 default = newJString("json"))
  if valid_595845 != nil:
    section.add "alt", valid_595845
  var valid_595846 = query.getOrDefault("oauth_token")
  valid_595846 = validateParameter(valid_595846, JString, required = false,
                                 default = nil)
  if valid_595846 != nil:
    section.add "oauth_token", valid_595846
  var valid_595847 = query.getOrDefault("userIp")
  valid_595847 = validateParameter(valid_595847, JString, required = false,
                                 default = nil)
  if valid_595847 != nil:
    section.add "userIp", valid_595847
  var valid_595848 = query.getOrDefault("key")
  valid_595848 = validateParameter(valid_595848, JString, required = false,
                                 default = nil)
  if valid_595848 != nil:
    section.add "key", valid_595848
  var valid_595849 = query.getOrDefault("prettyPrint")
  valid_595849 = validateParameter(valid_595849, JBool, required = false,
                                 default = newJBool(true))
  if valid_595849 != nil:
    section.add "prettyPrint", valid_595849
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595851: Call_DfareportingFloodlightActivitiesInsert_595839;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new floodlight activity.
  ## 
  let valid = call_595851.validator(path, query, header, formData, body)
  let scheme = call_595851.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595851.url(scheme.get, call_595851.host, call_595851.base,
                         call_595851.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595851, url, valid)

proc call*(call_595852: Call_DfareportingFloodlightActivitiesInsert_595839;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesInsert
  ## Inserts a new floodlight activity.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595853 = newJObject()
  var query_595854 = newJObject()
  var body_595855 = newJObject()
  add(path_595853, "profileId", newJString(profileId))
  add(query_595854, "fields", newJString(fields))
  add(query_595854, "quotaUser", newJString(quotaUser))
  add(query_595854, "alt", newJString(alt))
  add(query_595854, "oauth_token", newJString(oauthToken))
  add(query_595854, "userIp", newJString(userIp))
  add(query_595854, "key", newJString(key))
  if body != nil:
    body_595855 = body
  add(query_595854, "prettyPrint", newJBool(prettyPrint))
  result = call_595852.call(path_595853, query_595854, nil, nil, body_595855)

var dfareportingFloodlightActivitiesInsert* = Call_DfareportingFloodlightActivitiesInsert_595839(
    name: "dfareportingFloodlightActivitiesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesInsert_595840,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesInsert_595841,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesList_595794 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightActivitiesList_595796(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesList_595795(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of floodlight activities, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595797 = path.getOrDefault("profileId")
  valid_595797 = validateParameter(valid_595797, JString, required = true,
                                 default = nil)
  if valid_595797 != nil:
    section.add "profileId", valid_595797
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   tagString: JString
  ##            : Select only floodlight activities with the specified tag string.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivity*2015" will return objects with names like "floodlightactivity June 2015", "floodlightactivity April 2015", or simply "floodlightactivity 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivity" will match objects with name "my floodlightactivity activity", "floodlightactivity 2015", or simply "floodlightactivity".
  ##   advertiserId: JString
  ##               : Select only floodlight activities for the specified advertiser ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   floodlightActivityGroupIds: JArray
  ##                             : Select only floodlight activities with the specified floodlight activity group IDs.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   floodlightActivityGroupType: JString
  ##                              : Select only floodlight activities with the specified floodlight activity group type.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   floodlightConfigurationId: JString
  ##                            : Select only floodlight activities for the specified floodlight configuration ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   floodlightActivityGroupTagString: JString
  ##                                   : Select only floodlight activities with the specified floodlight activity group tag string.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only floodlight activities with the specified IDs. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   floodlightActivityGroupName: JString
  ##                              : Select only floodlight activities with the specified floodlight activity group name.
  section = newJObject()
  var valid_595798 = query.getOrDefault("fields")
  valid_595798 = validateParameter(valid_595798, JString, required = false,
                                 default = nil)
  if valid_595798 != nil:
    section.add "fields", valid_595798
  var valid_595799 = query.getOrDefault("pageToken")
  valid_595799 = validateParameter(valid_595799, JString, required = false,
                                 default = nil)
  if valid_595799 != nil:
    section.add "pageToken", valid_595799
  var valid_595800 = query.getOrDefault("quotaUser")
  valid_595800 = validateParameter(valid_595800, JString, required = false,
                                 default = nil)
  if valid_595800 != nil:
    section.add "quotaUser", valid_595800
  var valid_595801 = query.getOrDefault("sortField")
  valid_595801 = validateParameter(valid_595801, JString, required = false,
                                 default = newJString("ID"))
  if valid_595801 != nil:
    section.add "sortField", valid_595801
  var valid_595802 = query.getOrDefault("tagString")
  valid_595802 = validateParameter(valid_595802, JString, required = false,
                                 default = nil)
  if valid_595802 != nil:
    section.add "tagString", valid_595802
  var valid_595803 = query.getOrDefault("alt")
  valid_595803 = validateParameter(valid_595803, JString, required = false,
                                 default = newJString("json"))
  if valid_595803 != nil:
    section.add "alt", valid_595803
  var valid_595804 = query.getOrDefault("searchString")
  valid_595804 = validateParameter(valid_595804, JString, required = false,
                                 default = nil)
  if valid_595804 != nil:
    section.add "searchString", valid_595804
  var valid_595805 = query.getOrDefault("advertiserId")
  valid_595805 = validateParameter(valid_595805, JString, required = false,
                                 default = nil)
  if valid_595805 != nil:
    section.add "advertiserId", valid_595805
  var valid_595806 = query.getOrDefault("floodlightActivityGroupIds")
  valid_595806 = validateParameter(valid_595806, JArray, required = false,
                                 default = nil)
  if valid_595806 != nil:
    section.add "floodlightActivityGroupIds", valid_595806
  var valid_595807 = query.getOrDefault("oauth_token")
  valid_595807 = validateParameter(valid_595807, JString, required = false,
                                 default = nil)
  if valid_595807 != nil:
    section.add "oauth_token", valid_595807
  var valid_595808 = query.getOrDefault("floodlightActivityGroupType")
  valid_595808 = validateParameter(valid_595808, JString, required = false,
                                 default = newJString("COUNTER"))
  if valid_595808 != nil:
    section.add "floodlightActivityGroupType", valid_595808
  var valid_595809 = query.getOrDefault("userIp")
  valid_595809 = validateParameter(valid_595809, JString, required = false,
                                 default = nil)
  if valid_595809 != nil:
    section.add "userIp", valid_595809
  var valid_595810 = query.getOrDefault("floodlightConfigurationId")
  valid_595810 = validateParameter(valid_595810, JString, required = false,
                                 default = nil)
  if valid_595810 != nil:
    section.add "floodlightConfigurationId", valid_595810
  var valid_595811 = query.getOrDefault("floodlightActivityGroupTagString")
  valid_595811 = validateParameter(valid_595811, JString, required = false,
                                 default = nil)
  if valid_595811 != nil:
    section.add "floodlightActivityGroupTagString", valid_595811
  var valid_595812 = query.getOrDefault("maxResults")
  valid_595812 = validateParameter(valid_595812, JInt, required = false,
                                 default = newJInt(1000))
  if valid_595812 != nil:
    section.add "maxResults", valid_595812
  var valid_595813 = query.getOrDefault("ids")
  valid_595813 = validateParameter(valid_595813, JArray, required = false,
                                 default = nil)
  if valid_595813 != nil:
    section.add "ids", valid_595813
  var valid_595814 = query.getOrDefault("key")
  valid_595814 = validateParameter(valid_595814, JString, required = false,
                                 default = nil)
  if valid_595814 != nil:
    section.add "key", valid_595814
  var valid_595815 = query.getOrDefault("sortOrder")
  valid_595815 = validateParameter(valid_595815, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_595815 != nil:
    section.add "sortOrder", valid_595815
  var valid_595816 = query.getOrDefault("prettyPrint")
  valid_595816 = validateParameter(valid_595816, JBool, required = false,
                                 default = newJBool(true))
  if valid_595816 != nil:
    section.add "prettyPrint", valid_595816
  var valid_595817 = query.getOrDefault("floodlightActivityGroupName")
  valid_595817 = validateParameter(valid_595817, JString, required = false,
                                 default = nil)
  if valid_595817 != nil:
    section.add "floodlightActivityGroupName", valid_595817
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595818: Call_DfareportingFloodlightActivitiesList_595794;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of floodlight activities, possibly filtered. This method supports paging.
  ## 
  let valid = call_595818.validator(path, query, header, formData, body)
  let scheme = call_595818.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595818.url(scheme.get, call_595818.host, call_595818.base,
                         call_595818.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595818, url, valid)

proc call*(call_595819: Call_DfareportingFloodlightActivitiesList_595794;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; tagString: string = "";
          alt: string = "json"; searchString: string = ""; advertiserId: string = "";
          floodlightActivityGroupIds: JsonNode = nil; oauthToken: string = "";
          floodlightActivityGroupType: string = "COUNTER"; userIp: string = "";
          floodlightConfigurationId: string = "";
          floodlightActivityGroupTagString: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true; floodlightActivityGroupName: string = ""): Recallable =
  ## dfareportingFloodlightActivitiesList
  ## Retrieves a list of floodlight activities, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   tagString: string
  ##            : Select only floodlight activities with the specified tag string.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivity*2015" will return objects with names like "floodlightactivity June 2015", "floodlightactivity April 2015", or simply "floodlightactivity 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivity" will match objects with name "my floodlightactivity activity", "floodlightactivity 2015", or simply "floodlightactivity".
  ##   advertiserId: string
  ##               : Select only floodlight activities for the specified advertiser ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   floodlightActivityGroupIds: JArray
  ##                             : Select only floodlight activities with the specified floodlight activity group IDs.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   floodlightActivityGroupType: string
  ##                              : Select only floodlight activities with the specified floodlight activity group type.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   floodlightConfigurationId: string
  ##                            : Select only floodlight activities for the specified floodlight configuration ID. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   floodlightActivityGroupTagString: string
  ##                                   : Select only floodlight activities with the specified floodlight activity group tag string.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only floodlight activities with the specified IDs. Must specify either ids, advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   floodlightActivityGroupName: string
  ##                              : Select only floodlight activities with the specified floodlight activity group name.
  var path_595820 = newJObject()
  var query_595821 = newJObject()
  add(path_595820, "profileId", newJString(profileId))
  add(query_595821, "fields", newJString(fields))
  add(query_595821, "pageToken", newJString(pageToken))
  add(query_595821, "quotaUser", newJString(quotaUser))
  add(query_595821, "sortField", newJString(sortField))
  add(query_595821, "tagString", newJString(tagString))
  add(query_595821, "alt", newJString(alt))
  add(query_595821, "searchString", newJString(searchString))
  add(query_595821, "advertiserId", newJString(advertiserId))
  if floodlightActivityGroupIds != nil:
    query_595821.add "floodlightActivityGroupIds", floodlightActivityGroupIds
  add(query_595821, "oauth_token", newJString(oauthToken))
  add(query_595821, "floodlightActivityGroupType",
      newJString(floodlightActivityGroupType))
  add(query_595821, "userIp", newJString(userIp))
  add(query_595821, "floodlightConfigurationId",
      newJString(floodlightConfigurationId))
  add(query_595821, "floodlightActivityGroupTagString",
      newJString(floodlightActivityGroupTagString))
  add(query_595821, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_595821.add "ids", ids
  add(query_595821, "key", newJString(key))
  add(query_595821, "sortOrder", newJString(sortOrder))
  add(query_595821, "prettyPrint", newJBool(prettyPrint))
  add(query_595821, "floodlightActivityGroupName",
      newJString(floodlightActivityGroupName))
  result = call_595819.call(path_595820, query_595821, nil, nil, nil)

var dfareportingFloodlightActivitiesList* = Call_DfareportingFloodlightActivitiesList_595794(
    name: "dfareportingFloodlightActivitiesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesList_595795,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesList_595796,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesPatch_595856 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightActivitiesPatch_595858(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesPatch_595857(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595859 = path.getOrDefault("profileId")
  valid_595859 = validateParameter(valid_595859, JString, required = true,
                                 default = nil)
  if valid_595859 != nil:
    section.add "profileId", valid_595859
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Floodlight activity ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595860 = query.getOrDefault("fields")
  valid_595860 = validateParameter(valid_595860, JString, required = false,
                                 default = nil)
  if valid_595860 != nil:
    section.add "fields", valid_595860
  var valid_595861 = query.getOrDefault("quotaUser")
  valid_595861 = validateParameter(valid_595861, JString, required = false,
                                 default = nil)
  if valid_595861 != nil:
    section.add "quotaUser", valid_595861
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_595862 = query.getOrDefault("id")
  valid_595862 = validateParameter(valid_595862, JString, required = true,
                                 default = nil)
  if valid_595862 != nil:
    section.add "id", valid_595862
  var valid_595863 = query.getOrDefault("alt")
  valid_595863 = validateParameter(valid_595863, JString, required = false,
                                 default = newJString("json"))
  if valid_595863 != nil:
    section.add "alt", valid_595863
  var valid_595864 = query.getOrDefault("oauth_token")
  valid_595864 = validateParameter(valid_595864, JString, required = false,
                                 default = nil)
  if valid_595864 != nil:
    section.add "oauth_token", valid_595864
  var valid_595865 = query.getOrDefault("userIp")
  valid_595865 = validateParameter(valid_595865, JString, required = false,
                                 default = nil)
  if valid_595865 != nil:
    section.add "userIp", valid_595865
  var valid_595866 = query.getOrDefault("key")
  valid_595866 = validateParameter(valid_595866, JString, required = false,
                                 default = nil)
  if valid_595866 != nil:
    section.add "key", valid_595866
  var valid_595867 = query.getOrDefault("prettyPrint")
  valid_595867 = validateParameter(valid_595867, JBool, required = false,
                                 default = newJBool(true))
  if valid_595867 != nil:
    section.add "prettyPrint", valid_595867
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595869: Call_DfareportingFloodlightActivitiesPatch_595856;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity. This method supports patch semantics.
  ## 
  let valid = call_595869.validator(path, query, header, formData, body)
  let scheme = call_595869.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595869.url(scheme.get, call_595869.host, call_595869.base,
                         call_595869.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595869, url, valid)

proc call*(call_595870: Call_DfareportingFloodlightActivitiesPatch_595856;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesPatch
  ## Updates an existing floodlight activity. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Floodlight activity ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595871 = newJObject()
  var query_595872 = newJObject()
  var body_595873 = newJObject()
  add(path_595871, "profileId", newJString(profileId))
  add(query_595872, "fields", newJString(fields))
  add(query_595872, "quotaUser", newJString(quotaUser))
  add(query_595872, "id", newJString(id))
  add(query_595872, "alt", newJString(alt))
  add(query_595872, "oauth_token", newJString(oauthToken))
  add(query_595872, "userIp", newJString(userIp))
  add(query_595872, "key", newJString(key))
  if body != nil:
    body_595873 = body
  add(query_595872, "prettyPrint", newJBool(prettyPrint))
  result = call_595870.call(path_595871, query_595872, nil, nil, body_595873)

var dfareportingFloodlightActivitiesPatch* = Call_DfareportingFloodlightActivitiesPatch_595856(
    name: "dfareportingFloodlightActivitiesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities",
    validator: validate_DfareportingFloodlightActivitiesPatch_595857,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesPatch_595858,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesGeneratetag_595874 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightActivitiesGeneratetag_595876(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"), (kind: ConstantSegment,
        value: "/floodlightActivities/generatetag")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesGeneratetag_595875(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Generates a tag for a floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595877 = path.getOrDefault("profileId")
  valid_595877 = validateParameter(valid_595877, JString, required = true,
                                 default = nil)
  if valid_595877 != nil:
    section.add "profileId", valid_595877
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   floodlightActivityId: JString
  ##                       : Floodlight activity ID for which we want to generate a tag.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595878 = query.getOrDefault("fields")
  valid_595878 = validateParameter(valid_595878, JString, required = false,
                                 default = nil)
  if valid_595878 != nil:
    section.add "fields", valid_595878
  var valid_595879 = query.getOrDefault("quotaUser")
  valid_595879 = validateParameter(valid_595879, JString, required = false,
                                 default = nil)
  if valid_595879 != nil:
    section.add "quotaUser", valid_595879
  var valid_595880 = query.getOrDefault("alt")
  valid_595880 = validateParameter(valid_595880, JString, required = false,
                                 default = newJString("json"))
  if valid_595880 != nil:
    section.add "alt", valid_595880
  var valid_595881 = query.getOrDefault("oauth_token")
  valid_595881 = validateParameter(valid_595881, JString, required = false,
                                 default = nil)
  if valid_595881 != nil:
    section.add "oauth_token", valid_595881
  var valid_595882 = query.getOrDefault("floodlightActivityId")
  valid_595882 = validateParameter(valid_595882, JString, required = false,
                                 default = nil)
  if valid_595882 != nil:
    section.add "floodlightActivityId", valid_595882
  var valid_595883 = query.getOrDefault("userIp")
  valid_595883 = validateParameter(valid_595883, JString, required = false,
                                 default = nil)
  if valid_595883 != nil:
    section.add "userIp", valid_595883
  var valid_595884 = query.getOrDefault("key")
  valid_595884 = validateParameter(valid_595884, JString, required = false,
                                 default = nil)
  if valid_595884 != nil:
    section.add "key", valid_595884
  var valid_595885 = query.getOrDefault("prettyPrint")
  valid_595885 = validateParameter(valid_595885, JBool, required = false,
                                 default = newJBool(true))
  if valid_595885 != nil:
    section.add "prettyPrint", valid_595885
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595886: Call_DfareportingFloodlightActivitiesGeneratetag_595874;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Generates a tag for a floodlight activity.
  ## 
  let valid = call_595886.validator(path, query, header, formData, body)
  let scheme = call_595886.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595886.url(scheme.get, call_595886.host, call_595886.base,
                         call_595886.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595886, url, valid)

proc call*(call_595887: Call_DfareportingFloodlightActivitiesGeneratetag_595874;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = "";
          floodlightActivityId: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesGeneratetag
  ## Generates a tag for a floodlight activity.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   floodlightActivityId: string
  ##                       : Floodlight activity ID for which we want to generate a tag.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595888 = newJObject()
  var query_595889 = newJObject()
  add(path_595888, "profileId", newJString(profileId))
  add(query_595889, "fields", newJString(fields))
  add(query_595889, "quotaUser", newJString(quotaUser))
  add(query_595889, "alt", newJString(alt))
  add(query_595889, "oauth_token", newJString(oauthToken))
  add(query_595889, "floodlightActivityId", newJString(floodlightActivityId))
  add(query_595889, "userIp", newJString(userIp))
  add(query_595889, "key", newJString(key))
  add(query_595889, "prettyPrint", newJBool(prettyPrint))
  result = call_595887.call(path_595888, query_595889, nil, nil, nil)

var dfareportingFloodlightActivitiesGeneratetag* = Call_DfareportingFloodlightActivitiesGeneratetag_595874(
    name: "dfareportingFloodlightActivitiesGeneratetag",
    meth: HttpMethod.HttpPost, host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities/generatetag",
    validator: validate_DfareportingFloodlightActivitiesGeneratetag_595875,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivitiesGeneratetag_595876,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesGet_595890 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightActivitiesGet_595892(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesGet_595891(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one floodlight activity by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight activity ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595893 = path.getOrDefault("profileId")
  valid_595893 = validateParameter(valid_595893, JString, required = true,
                                 default = nil)
  if valid_595893 != nil:
    section.add "profileId", valid_595893
  var valid_595894 = path.getOrDefault("id")
  valid_595894 = validateParameter(valid_595894, JString, required = true,
                                 default = nil)
  if valid_595894 != nil:
    section.add "id", valid_595894
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595895 = query.getOrDefault("fields")
  valid_595895 = validateParameter(valid_595895, JString, required = false,
                                 default = nil)
  if valid_595895 != nil:
    section.add "fields", valid_595895
  var valid_595896 = query.getOrDefault("quotaUser")
  valid_595896 = validateParameter(valid_595896, JString, required = false,
                                 default = nil)
  if valid_595896 != nil:
    section.add "quotaUser", valid_595896
  var valid_595897 = query.getOrDefault("alt")
  valid_595897 = validateParameter(valid_595897, JString, required = false,
                                 default = newJString("json"))
  if valid_595897 != nil:
    section.add "alt", valid_595897
  var valid_595898 = query.getOrDefault("oauth_token")
  valid_595898 = validateParameter(valid_595898, JString, required = false,
                                 default = nil)
  if valid_595898 != nil:
    section.add "oauth_token", valid_595898
  var valid_595899 = query.getOrDefault("userIp")
  valid_595899 = validateParameter(valid_595899, JString, required = false,
                                 default = nil)
  if valid_595899 != nil:
    section.add "userIp", valid_595899
  var valid_595900 = query.getOrDefault("key")
  valid_595900 = validateParameter(valid_595900, JString, required = false,
                                 default = nil)
  if valid_595900 != nil:
    section.add "key", valid_595900
  var valid_595901 = query.getOrDefault("prettyPrint")
  valid_595901 = validateParameter(valid_595901, JBool, required = false,
                                 default = newJBool(true))
  if valid_595901 != nil:
    section.add "prettyPrint", valid_595901
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595902: Call_DfareportingFloodlightActivitiesGet_595890;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one floodlight activity by ID.
  ## 
  let valid = call_595902.validator(path, query, header, formData, body)
  let scheme = call_595902.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595902.url(scheme.get, call_595902.host, call_595902.base,
                         call_595902.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595902, url, valid)

proc call*(call_595903: Call_DfareportingFloodlightActivitiesGet_595890;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesGet
  ## Gets one floodlight activity by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Floodlight activity ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595904 = newJObject()
  var query_595905 = newJObject()
  add(path_595904, "profileId", newJString(profileId))
  add(query_595905, "fields", newJString(fields))
  add(query_595905, "quotaUser", newJString(quotaUser))
  add(query_595905, "alt", newJString(alt))
  add(query_595905, "oauth_token", newJString(oauthToken))
  add(query_595905, "userIp", newJString(userIp))
  add(path_595904, "id", newJString(id))
  add(query_595905, "key", newJString(key))
  add(query_595905, "prettyPrint", newJBool(prettyPrint))
  result = call_595903.call(path_595904, query_595905, nil, nil, nil)

var dfareportingFloodlightActivitiesGet* = Call_DfareportingFloodlightActivitiesGet_595890(
    name: "dfareportingFloodlightActivitiesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities/{id}",
    validator: validate_DfareportingFloodlightActivitiesGet_595891,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesGet_595892,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivitiesDelete_595906 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightActivitiesDelete_595908(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivities/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivitiesDelete_595907(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing floodlight activity.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight activity ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595909 = path.getOrDefault("profileId")
  valid_595909 = validateParameter(valid_595909, JString, required = true,
                                 default = nil)
  if valid_595909 != nil:
    section.add "profileId", valid_595909
  var valid_595910 = path.getOrDefault("id")
  valid_595910 = validateParameter(valid_595910, JString, required = true,
                                 default = nil)
  if valid_595910 != nil:
    section.add "id", valid_595910
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595911 = query.getOrDefault("fields")
  valid_595911 = validateParameter(valid_595911, JString, required = false,
                                 default = nil)
  if valid_595911 != nil:
    section.add "fields", valid_595911
  var valid_595912 = query.getOrDefault("quotaUser")
  valid_595912 = validateParameter(valid_595912, JString, required = false,
                                 default = nil)
  if valid_595912 != nil:
    section.add "quotaUser", valid_595912
  var valid_595913 = query.getOrDefault("alt")
  valid_595913 = validateParameter(valid_595913, JString, required = false,
                                 default = newJString("json"))
  if valid_595913 != nil:
    section.add "alt", valid_595913
  var valid_595914 = query.getOrDefault("oauth_token")
  valid_595914 = validateParameter(valid_595914, JString, required = false,
                                 default = nil)
  if valid_595914 != nil:
    section.add "oauth_token", valid_595914
  var valid_595915 = query.getOrDefault("userIp")
  valid_595915 = validateParameter(valid_595915, JString, required = false,
                                 default = nil)
  if valid_595915 != nil:
    section.add "userIp", valid_595915
  var valid_595916 = query.getOrDefault("key")
  valid_595916 = validateParameter(valid_595916, JString, required = false,
                                 default = nil)
  if valid_595916 != nil:
    section.add "key", valid_595916
  var valid_595917 = query.getOrDefault("prettyPrint")
  valid_595917 = validateParameter(valid_595917, JBool, required = false,
                                 default = newJBool(true))
  if valid_595917 != nil:
    section.add "prettyPrint", valid_595917
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595918: Call_DfareportingFloodlightActivitiesDelete_595906;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing floodlight activity.
  ## 
  let valid = call_595918.validator(path, query, header, formData, body)
  let scheme = call_595918.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595918.url(scheme.get, call_595918.host, call_595918.base,
                         call_595918.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595918, url, valid)

proc call*(call_595919: Call_DfareportingFloodlightActivitiesDelete_595906;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivitiesDelete
  ## Deletes an existing floodlight activity.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Floodlight activity ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595920 = newJObject()
  var query_595921 = newJObject()
  add(path_595920, "profileId", newJString(profileId))
  add(query_595921, "fields", newJString(fields))
  add(query_595921, "quotaUser", newJString(quotaUser))
  add(query_595921, "alt", newJString(alt))
  add(query_595921, "oauth_token", newJString(oauthToken))
  add(query_595921, "userIp", newJString(userIp))
  add(path_595920, "id", newJString(id))
  add(query_595921, "key", newJString(key))
  add(query_595921, "prettyPrint", newJBool(prettyPrint))
  result = call_595919.call(path_595920, query_595921, nil, nil, nil)

var dfareportingFloodlightActivitiesDelete* = Call_DfareportingFloodlightActivitiesDelete_595906(
    name: "dfareportingFloodlightActivitiesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivities/{id}",
    validator: validate_DfareportingFloodlightActivitiesDelete_595907,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivitiesDelete_595908,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsUpdate_595946 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightActivityGroupsUpdate_595948(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsUpdate_595947(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595949 = path.getOrDefault("profileId")
  valid_595949 = validateParameter(valid_595949, JString, required = true,
                                 default = nil)
  if valid_595949 != nil:
    section.add "profileId", valid_595949
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595950 = query.getOrDefault("fields")
  valid_595950 = validateParameter(valid_595950, JString, required = false,
                                 default = nil)
  if valid_595950 != nil:
    section.add "fields", valid_595950
  var valid_595951 = query.getOrDefault("quotaUser")
  valid_595951 = validateParameter(valid_595951, JString, required = false,
                                 default = nil)
  if valid_595951 != nil:
    section.add "quotaUser", valid_595951
  var valid_595952 = query.getOrDefault("alt")
  valid_595952 = validateParameter(valid_595952, JString, required = false,
                                 default = newJString("json"))
  if valid_595952 != nil:
    section.add "alt", valid_595952
  var valid_595953 = query.getOrDefault("oauth_token")
  valid_595953 = validateParameter(valid_595953, JString, required = false,
                                 default = nil)
  if valid_595953 != nil:
    section.add "oauth_token", valid_595953
  var valid_595954 = query.getOrDefault("userIp")
  valid_595954 = validateParameter(valid_595954, JString, required = false,
                                 default = nil)
  if valid_595954 != nil:
    section.add "userIp", valid_595954
  var valid_595955 = query.getOrDefault("key")
  valid_595955 = validateParameter(valid_595955, JString, required = false,
                                 default = nil)
  if valid_595955 != nil:
    section.add "key", valid_595955
  var valid_595956 = query.getOrDefault("prettyPrint")
  valid_595956 = validateParameter(valid_595956, JBool, required = false,
                                 default = newJBool(true))
  if valid_595956 != nil:
    section.add "prettyPrint", valid_595956
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595958: Call_DfareportingFloodlightActivityGroupsUpdate_595946;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity group.
  ## 
  let valid = call_595958.validator(path, query, header, formData, body)
  let scheme = call_595958.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595958.url(scheme.get, call_595958.host, call_595958.base,
                         call_595958.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595958, url, valid)

proc call*(call_595959: Call_DfareportingFloodlightActivityGroupsUpdate_595946;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsUpdate
  ## Updates an existing floodlight activity group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595960 = newJObject()
  var query_595961 = newJObject()
  var body_595962 = newJObject()
  add(path_595960, "profileId", newJString(profileId))
  add(query_595961, "fields", newJString(fields))
  add(query_595961, "quotaUser", newJString(quotaUser))
  add(query_595961, "alt", newJString(alt))
  add(query_595961, "oauth_token", newJString(oauthToken))
  add(query_595961, "userIp", newJString(userIp))
  add(query_595961, "key", newJString(key))
  if body != nil:
    body_595962 = body
  add(query_595961, "prettyPrint", newJBool(prettyPrint))
  result = call_595959.call(path_595960, query_595961, nil, nil, body_595962)

var dfareportingFloodlightActivityGroupsUpdate* = Call_DfareportingFloodlightActivityGroupsUpdate_595946(
    name: "dfareportingFloodlightActivityGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsUpdate_595947,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivityGroupsUpdate_595948,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsInsert_595963 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightActivityGroupsInsert_595965(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsInsert_595964(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new floodlight activity group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595966 = path.getOrDefault("profileId")
  valid_595966 = validateParameter(valid_595966, JString, required = true,
                                 default = nil)
  if valid_595966 != nil:
    section.add "profileId", valid_595966
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595967 = query.getOrDefault("fields")
  valid_595967 = validateParameter(valid_595967, JString, required = false,
                                 default = nil)
  if valid_595967 != nil:
    section.add "fields", valid_595967
  var valid_595968 = query.getOrDefault("quotaUser")
  valid_595968 = validateParameter(valid_595968, JString, required = false,
                                 default = nil)
  if valid_595968 != nil:
    section.add "quotaUser", valid_595968
  var valid_595969 = query.getOrDefault("alt")
  valid_595969 = validateParameter(valid_595969, JString, required = false,
                                 default = newJString("json"))
  if valid_595969 != nil:
    section.add "alt", valid_595969
  var valid_595970 = query.getOrDefault("oauth_token")
  valid_595970 = validateParameter(valid_595970, JString, required = false,
                                 default = nil)
  if valid_595970 != nil:
    section.add "oauth_token", valid_595970
  var valid_595971 = query.getOrDefault("userIp")
  valid_595971 = validateParameter(valid_595971, JString, required = false,
                                 default = nil)
  if valid_595971 != nil:
    section.add "userIp", valid_595971
  var valid_595972 = query.getOrDefault("key")
  valid_595972 = validateParameter(valid_595972, JString, required = false,
                                 default = nil)
  if valid_595972 != nil:
    section.add "key", valid_595972
  var valid_595973 = query.getOrDefault("prettyPrint")
  valid_595973 = validateParameter(valid_595973, JBool, required = false,
                                 default = newJBool(true))
  if valid_595973 != nil:
    section.add "prettyPrint", valid_595973
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595975: Call_DfareportingFloodlightActivityGroupsInsert_595963;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new floodlight activity group.
  ## 
  let valid = call_595975.validator(path, query, header, formData, body)
  let scheme = call_595975.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595975.url(scheme.get, call_595975.host, call_595975.base,
                         call_595975.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595975, url, valid)

proc call*(call_595976: Call_DfareportingFloodlightActivityGroupsInsert_595963;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsInsert
  ## Inserts a new floodlight activity group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595977 = newJObject()
  var query_595978 = newJObject()
  var body_595979 = newJObject()
  add(path_595977, "profileId", newJString(profileId))
  add(query_595978, "fields", newJString(fields))
  add(query_595978, "quotaUser", newJString(quotaUser))
  add(query_595978, "alt", newJString(alt))
  add(query_595978, "oauth_token", newJString(oauthToken))
  add(query_595978, "userIp", newJString(userIp))
  add(query_595978, "key", newJString(key))
  if body != nil:
    body_595979 = body
  add(query_595978, "prettyPrint", newJBool(prettyPrint))
  result = call_595976.call(path_595977, query_595978, nil, nil, body_595979)

var dfareportingFloodlightActivityGroupsInsert* = Call_DfareportingFloodlightActivityGroupsInsert_595963(
    name: "dfareportingFloodlightActivityGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsInsert_595964,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivityGroupsInsert_595965,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsList_595922 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightActivityGroupsList_595924(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsList_595923(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of floodlight activity groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595925 = path.getOrDefault("profileId")
  valid_595925 = validateParameter(valid_595925, JString, required = true,
                                 default = nil)
  if valid_595925 != nil:
    section.add "profileId", valid_595925
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivitygroup*2015" will return objects with names like "floodlightactivitygroup June 2015", "floodlightactivitygroup April 2015", or simply "floodlightactivitygroup 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivitygroup" will match objects with name "my floodlightactivitygroup activity", "floodlightactivitygroup 2015", or simply "floodlightactivitygroup".
  ##   advertiserId: JString
  ##               : Select only floodlight activity groups with the specified advertiser ID. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   type: JString
  ##       : Select only floodlight activity groups with the specified floodlight activity group type.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   floodlightConfigurationId: JString
  ##                            : Select only floodlight activity groups with the specified floodlight configuration ID. Must specify either advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only floodlight activity groups with the specified IDs. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595926 = query.getOrDefault("fields")
  valid_595926 = validateParameter(valid_595926, JString, required = false,
                                 default = nil)
  if valid_595926 != nil:
    section.add "fields", valid_595926
  var valid_595927 = query.getOrDefault("pageToken")
  valid_595927 = validateParameter(valid_595927, JString, required = false,
                                 default = nil)
  if valid_595927 != nil:
    section.add "pageToken", valid_595927
  var valid_595928 = query.getOrDefault("quotaUser")
  valid_595928 = validateParameter(valid_595928, JString, required = false,
                                 default = nil)
  if valid_595928 != nil:
    section.add "quotaUser", valid_595928
  var valid_595929 = query.getOrDefault("sortField")
  valid_595929 = validateParameter(valid_595929, JString, required = false,
                                 default = newJString("ID"))
  if valid_595929 != nil:
    section.add "sortField", valid_595929
  var valid_595930 = query.getOrDefault("alt")
  valid_595930 = validateParameter(valid_595930, JString, required = false,
                                 default = newJString("json"))
  if valid_595930 != nil:
    section.add "alt", valid_595930
  var valid_595931 = query.getOrDefault("searchString")
  valid_595931 = validateParameter(valid_595931, JString, required = false,
                                 default = nil)
  if valid_595931 != nil:
    section.add "searchString", valid_595931
  var valid_595932 = query.getOrDefault("advertiserId")
  valid_595932 = validateParameter(valid_595932, JString, required = false,
                                 default = nil)
  if valid_595932 != nil:
    section.add "advertiserId", valid_595932
  var valid_595933 = query.getOrDefault("type")
  valid_595933 = validateParameter(valid_595933, JString, required = false,
                                 default = newJString("COUNTER"))
  if valid_595933 != nil:
    section.add "type", valid_595933
  var valid_595934 = query.getOrDefault("oauth_token")
  valid_595934 = validateParameter(valid_595934, JString, required = false,
                                 default = nil)
  if valid_595934 != nil:
    section.add "oauth_token", valid_595934
  var valid_595935 = query.getOrDefault("userIp")
  valid_595935 = validateParameter(valid_595935, JString, required = false,
                                 default = nil)
  if valid_595935 != nil:
    section.add "userIp", valid_595935
  var valid_595936 = query.getOrDefault("floodlightConfigurationId")
  valid_595936 = validateParameter(valid_595936, JString, required = false,
                                 default = nil)
  if valid_595936 != nil:
    section.add "floodlightConfigurationId", valid_595936
  var valid_595937 = query.getOrDefault("maxResults")
  valid_595937 = validateParameter(valid_595937, JInt, required = false,
                                 default = newJInt(1000))
  if valid_595937 != nil:
    section.add "maxResults", valid_595937
  var valid_595938 = query.getOrDefault("ids")
  valid_595938 = validateParameter(valid_595938, JArray, required = false,
                                 default = nil)
  if valid_595938 != nil:
    section.add "ids", valid_595938
  var valid_595939 = query.getOrDefault("key")
  valid_595939 = validateParameter(valid_595939, JString, required = false,
                                 default = nil)
  if valid_595939 != nil:
    section.add "key", valid_595939
  var valid_595940 = query.getOrDefault("sortOrder")
  valid_595940 = validateParameter(valid_595940, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_595940 != nil:
    section.add "sortOrder", valid_595940
  var valid_595941 = query.getOrDefault("prettyPrint")
  valid_595941 = validateParameter(valid_595941, JBool, required = false,
                                 default = newJBool(true))
  if valid_595941 != nil:
    section.add "prettyPrint", valid_595941
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595942: Call_DfareportingFloodlightActivityGroupsList_595922;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of floodlight activity groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_595942.validator(path, query, header, formData, body)
  let scheme = call_595942.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595942.url(scheme.get, call_595942.host, call_595942.base,
                         call_595942.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595942, url, valid)

proc call*(call_595943: Call_DfareportingFloodlightActivityGroupsList_595922;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; advertiserId: string = "";
          `type`: string = "COUNTER"; oauthToken: string = ""; userIp: string = "";
          floodlightConfigurationId: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsList
  ## Retrieves a list of floodlight activity groups, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "floodlightactivitygroup*2015" will return objects with names like "floodlightactivitygroup June 2015", "floodlightactivitygroup April 2015", or simply "floodlightactivitygroup 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "floodlightactivitygroup" will match objects with name "my floodlightactivitygroup activity", "floodlightactivitygroup 2015", or simply "floodlightactivitygroup".
  ##   advertiserId: string
  ##               : Select only floodlight activity groups with the specified advertiser ID. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   type: string
  ##       : Select only floodlight activity groups with the specified floodlight activity group type.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   floodlightConfigurationId: string
  ##                            : Select only floodlight activity groups with the specified floodlight configuration ID. Must specify either advertiserId, or floodlightConfigurationId for a non-empty result.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only floodlight activity groups with the specified IDs. Must specify either advertiserId or floodlightConfigurationId for a non-empty result.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595944 = newJObject()
  var query_595945 = newJObject()
  add(path_595944, "profileId", newJString(profileId))
  add(query_595945, "fields", newJString(fields))
  add(query_595945, "pageToken", newJString(pageToken))
  add(query_595945, "quotaUser", newJString(quotaUser))
  add(query_595945, "sortField", newJString(sortField))
  add(query_595945, "alt", newJString(alt))
  add(query_595945, "searchString", newJString(searchString))
  add(query_595945, "advertiserId", newJString(advertiserId))
  add(query_595945, "type", newJString(`type`))
  add(query_595945, "oauth_token", newJString(oauthToken))
  add(query_595945, "userIp", newJString(userIp))
  add(query_595945, "floodlightConfigurationId",
      newJString(floodlightConfigurationId))
  add(query_595945, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_595945.add "ids", ids
  add(query_595945, "key", newJString(key))
  add(query_595945, "sortOrder", newJString(sortOrder))
  add(query_595945, "prettyPrint", newJBool(prettyPrint))
  result = call_595943.call(path_595944, query_595945, nil, nil, nil)

var dfareportingFloodlightActivityGroupsList* = Call_DfareportingFloodlightActivityGroupsList_595922(
    name: "dfareportingFloodlightActivityGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsList_595923,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivityGroupsList_595924,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsPatch_595980 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightActivityGroupsPatch_595982(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsPatch_595981(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight activity group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_595983 = path.getOrDefault("profileId")
  valid_595983 = validateParameter(valid_595983, JString, required = true,
                                 default = nil)
  if valid_595983 != nil:
    section.add "profileId", valid_595983
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Floodlight activity Group ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_595984 = query.getOrDefault("fields")
  valid_595984 = validateParameter(valid_595984, JString, required = false,
                                 default = nil)
  if valid_595984 != nil:
    section.add "fields", valid_595984
  var valid_595985 = query.getOrDefault("quotaUser")
  valid_595985 = validateParameter(valid_595985, JString, required = false,
                                 default = nil)
  if valid_595985 != nil:
    section.add "quotaUser", valid_595985
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_595986 = query.getOrDefault("id")
  valid_595986 = validateParameter(valid_595986, JString, required = true,
                                 default = nil)
  if valid_595986 != nil:
    section.add "id", valid_595986
  var valid_595987 = query.getOrDefault("alt")
  valid_595987 = validateParameter(valid_595987, JString, required = false,
                                 default = newJString("json"))
  if valid_595987 != nil:
    section.add "alt", valid_595987
  var valid_595988 = query.getOrDefault("oauth_token")
  valid_595988 = validateParameter(valid_595988, JString, required = false,
                                 default = nil)
  if valid_595988 != nil:
    section.add "oauth_token", valid_595988
  var valid_595989 = query.getOrDefault("userIp")
  valid_595989 = validateParameter(valid_595989, JString, required = false,
                                 default = nil)
  if valid_595989 != nil:
    section.add "userIp", valid_595989
  var valid_595990 = query.getOrDefault("key")
  valid_595990 = validateParameter(valid_595990, JString, required = false,
                                 default = nil)
  if valid_595990 != nil:
    section.add "key", valid_595990
  var valid_595991 = query.getOrDefault("prettyPrint")
  valid_595991 = validateParameter(valid_595991, JBool, required = false,
                                 default = newJBool(true))
  if valid_595991 != nil:
    section.add "prettyPrint", valid_595991
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595993: Call_DfareportingFloodlightActivityGroupsPatch_595980;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight activity group. This method supports patch semantics.
  ## 
  let valid = call_595993.validator(path, query, header, formData, body)
  let scheme = call_595993.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595993.url(scheme.get, call_595993.host, call_595993.base,
                         call_595993.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595993, url, valid)

proc call*(call_595994: Call_DfareportingFloodlightActivityGroupsPatch_595980;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsPatch
  ## Updates an existing floodlight activity group. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Floodlight activity Group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_595995 = newJObject()
  var query_595996 = newJObject()
  var body_595997 = newJObject()
  add(path_595995, "profileId", newJString(profileId))
  add(query_595996, "fields", newJString(fields))
  add(query_595996, "quotaUser", newJString(quotaUser))
  add(query_595996, "id", newJString(id))
  add(query_595996, "alt", newJString(alt))
  add(query_595996, "oauth_token", newJString(oauthToken))
  add(query_595996, "userIp", newJString(userIp))
  add(query_595996, "key", newJString(key))
  if body != nil:
    body_595997 = body
  add(query_595996, "prettyPrint", newJBool(prettyPrint))
  result = call_595994.call(path_595995, query_595996, nil, nil, body_595997)

var dfareportingFloodlightActivityGroupsPatch* = Call_DfareportingFloodlightActivityGroupsPatch_595980(
    name: "dfareportingFloodlightActivityGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups",
    validator: validate_DfareportingFloodlightActivityGroupsPatch_595981,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightActivityGroupsPatch_595982,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightActivityGroupsGet_595998 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightActivityGroupsGet_596000(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightActivityGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightActivityGroupsGet_595999(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one floodlight activity group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight activity Group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596001 = path.getOrDefault("profileId")
  valid_596001 = validateParameter(valid_596001, JString, required = true,
                                 default = nil)
  if valid_596001 != nil:
    section.add "profileId", valid_596001
  var valid_596002 = path.getOrDefault("id")
  valid_596002 = validateParameter(valid_596002, JString, required = true,
                                 default = nil)
  if valid_596002 != nil:
    section.add "id", valid_596002
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596003 = query.getOrDefault("fields")
  valid_596003 = validateParameter(valid_596003, JString, required = false,
                                 default = nil)
  if valid_596003 != nil:
    section.add "fields", valid_596003
  var valid_596004 = query.getOrDefault("quotaUser")
  valid_596004 = validateParameter(valid_596004, JString, required = false,
                                 default = nil)
  if valid_596004 != nil:
    section.add "quotaUser", valid_596004
  var valid_596005 = query.getOrDefault("alt")
  valid_596005 = validateParameter(valid_596005, JString, required = false,
                                 default = newJString("json"))
  if valid_596005 != nil:
    section.add "alt", valid_596005
  var valid_596006 = query.getOrDefault("oauth_token")
  valid_596006 = validateParameter(valid_596006, JString, required = false,
                                 default = nil)
  if valid_596006 != nil:
    section.add "oauth_token", valid_596006
  var valid_596007 = query.getOrDefault("userIp")
  valid_596007 = validateParameter(valid_596007, JString, required = false,
                                 default = nil)
  if valid_596007 != nil:
    section.add "userIp", valid_596007
  var valid_596008 = query.getOrDefault("key")
  valid_596008 = validateParameter(valid_596008, JString, required = false,
                                 default = nil)
  if valid_596008 != nil:
    section.add "key", valid_596008
  var valid_596009 = query.getOrDefault("prettyPrint")
  valid_596009 = validateParameter(valid_596009, JBool, required = false,
                                 default = newJBool(true))
  if valid_596009 != nil:
    section.add "prettyPrint", valid_596009
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596010: Call_DfareportingFloodlightActivityGroupsGet_595998;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one floodlight activity group by ID.
  ## 
  let valid = call_596010.validator(path, query, header, formData, body)
  let scheme = call_596010.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596010.url(scheme.get, call_596010.host, call_596010.base,
                         call_596010.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596010, url, valid)

proc call*(call_596011: Call_DfareportingFloodlightActivityGroupsGet_595998;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightActivityGroupsGet
  ## Gets one floodlight activity group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Floodlight activity Group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596012 = newJObject()
  var query_596013 = newJObject()
  add(path_596012, "profileId", newJString(profileId))
  add(query_596013, "fields", newJString(fields))
  add(query_596013, "quotaUser", newJString(quotaUser))
  add(query_596013, "alt", newJString(alt))
  add(query_596013, "oauth_token", newJString(oauthToken))
  add(query_596013, "userIp", newJString(userIp))
  add(path_596012, "id", newJString(id))
  add(query_596013, "key", newJString(key))
  add(query_596013, "prettyPrint", newJBool(prettyPrint))
  result = call_596011.call(path_596012, query_596013, nil, nil, nil)

var dfareportingFloodlightActivityGroupsGet* = Call_DfareportingFloodlightActivityGroupsGet_595998(
    name: "dfareportingFloodlightActivityGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightActivityGroups/{id}",
    validator: validate_DfareportingFloodlightActivityGroupsGet_595999,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightActivityGroupsGet_596000,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsUpdate_596030 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightConfigurationsUpdate_596032(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsUpdate_596031(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596033 = path.getOrDefault("profileId")
  valid_596033 = validateParameter(valid_596033, JString, required = true,
                                 default = nil)
  if valid_596033 != nil:
    section.add "profileId", valid_596033
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596034 = query.getOrDefault("fields")
  valid_596034 = validateParameter(valid_596034, JString, required = false,
                                 default = nil)
  if valid_596034 != nil:
    section.add "fields", valid_596034
  var valid_596035 = query.getOrDefault("quotaUser")
  valid_596035 = validateParameter(valid_596035, JString, required = false,
                                 default = nil)
  if valid_596035 != nil:
    section.add "quotaUser", valid_596035
  var valid_596036 = query.getOrDefault("alt")
  valid_596036 = validateParameter(valid_596036, JString, required = false,
                                 default = newJString("json"))
  if valid_596036 != nil:
    section.add "alt", valid_596036
  var valid_596037 = query.getOrDefault("oauth_token")
  valid_596037 = validateParameter(valid_596037, JString, required = false,
                                 default = nil)
  if valid_596037 != nil:
    section.add "oauth_token", valid_596037
  var valid_596038 = query.getOrDefault("userIp")
  valid_596038 = validateParameter(valid_596038, JString, required = false,
                                 default = nil)
  if valid_596038 != nil:
    section.add "userIp", valid_596038
  var valid_596039 = query.getOrDefault("key")
  valid_596039 = validateParameter(valid_596039, JString, required = false,
                                 default = nil)
  if valid_596039 != nil:
    section.add "key", valid_596039
  var valid_596040 = query.getOrDefault("prettyPrint")
  valid_596040 = validateParameter(valid_596040, JBool, required = false,
                                 default = newJBool(true))
  if valid_596040 != nil:
    section.add "prettyPrint", valid_596040
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596042: Call_DfareportingFloodlightConfigurationsUpdate_596030;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight configuration.
  ## 
  let valid = call_596042.validator(path, query, header, formData, body)
  let scheme = call_596042.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596042.url(scheme.get, call_596042.host, call_596042.base,
                         call_596042.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596042, url, valid)

proc call*(call_596043: Call_DfareportingFloodlightConfigurationsUpdate_596030;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightConfigurationsUpdate
  ## Updates an existing floodlight configuration.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596044 = newJObject()
  var query_596045 = newJObject()
  var body_596046 = newJObject()
  add(path_596044, "profileId", newJString(profileId))
  add(query_596045, "fields", newJString(fields))
  add(query_596045, "quotaUser", newJString(quotaUser))
  add(query_596045, "alt", newJString(alt))
  add(query_596045, "oauth_token", newJString(oauthToken))
  add(query_596045, "userIp", newJString(userIp))
  add(query_596045, "key", newJString(key))
  if body != nil:
    body_596046 = body
  add(query_596045, "prettyPrint", newJBool(prettyPrint))
  result = call_596043.call(path_596044, query_596045, nil, nil, body_596046)

var dfareportingFloodlightConfigurationsUpdate* = Call_DfareportingFloodlightConfigurationsUpdate_596030(
    name: "dfareportingFloodlightConfigurationsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations",
    validator: validate_DfareportingFloodlightConfigurationsUpdate_596031,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightConfigurationsUpdate_596032,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsList_596014 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightConfigurationsList_596016(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsList_596015(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of floodlight configurations, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596017 = path.getOrDefault("profileId")
  valid_596017 = validateParameter(valid_596017, JString, required = true,
                                 default = nil)
  if valid_596017 != nil:
    section.add "profileId", valid_596017
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Set of IDs of floodlight configurations to retrieve. Required field; otherwise an empty list will be returned.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596018 = query.getOrDefault("fields")
  valid_596018 = validateParameter(valid_596018, JString, required = false,
                                 default = nil)
  if valid_596018 != nil:
    section.add "fields", valid_596018
  var valid_596019 = query.getOrDefault("quotaUser")
  valid_596019 = validateParameter(valid_596019, JString, required = false,
                                 default = nil)
  if valid_596019 != nil:
    section.add "quotaUser", valid_596019
  var valid_596020 = query.getOrDefault("alt")
  valid_596020 = validateParameter(valid_596020, JString, required = false,
                                 default = newJString("json"))
  if valid_596020 != nil:
    section.add "alt", valid_596020
  var valid_596021 = query.getOrDefault("oauth_token")
  valid_596021 = validateParameter(valid_596021, JString, required = false,
                                 default = nil)
  if valid_596021 != nil:
    section.add "oauth_token", valid_596021
  var valid_596022 = query.getOrDefault("userIp")
  valid_596022 = validateParameter(valid_596022, JString, required = false,
                                 default = nil)
  if valid_596022 != nil:
    section.add "userIp", valid_596022
  var valid_596023 = query.getOrDefault("ids")
  valid_596023 = validateParameter(valid_596023, JArray, required = false,
                                 default = nil)
  if valid_596023 != nil:
    section.add "ids", valid_596023
  var valid_596024 = query.getOrDefault("key")
  valid_596024 = validateParameter(valid_596024, JString, required = false,
                                 default = nil)
  if valid_596024 != nil:
    section.add "key", valid_596024
  var valid_596025 = query.getOrDefault("prettyPrint")
  valid_596025 = validateParameter(valid_596025, JBool, required = false,
                                 default = newJBool(true))
  if valid_596025 != nil:
    section.add "prettyPrint", valid_596025
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596026: Call_DfareportingFloodlightConfigurationsList_596014;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of floodlight configurations, possibly filtered.
  ## 
  let valid = call_596026.validator(path, query, header, formData, body)
  let scheme = call_596026.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596026.url(scheme.get, call_596026.host, call_596026.base,
                         call_596026.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596026, url, valid)

proc call*(call_596027: Call_DfareportingFloodlightConfigurationsList_596014;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          ids: JsonNode = nil; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightConfigurationsList
  ## Retrieves a list of floodlight configurations, possibly filtered.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Set of IDs of floodlight configurations to retrieve. Required field; otherwise an empty list will be returned.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596028 = newJObject()
  var query_596029 = newJObject()
  add(path_596028, "profileId", newJString(profileId))
  add(query_596029, "fields", newJString(fields))
  add(query_596029, "quotaUser", newJString(quotaUser))
  add(query_596029, "alt", newJString(alt))
  add(query_596029, "oauth_token", newJString(oauthToken))
  add(query_596029, "userIp", newJString(userIp))
  if ids != nil:
    query_596029.add "ids", ids
  add(query_596029, "key", newJString(key))
  add(query_596029, "prettyPrint", newJBool(prettyPrint))
  result = call_596027.call(path_596028, query_596029, nil, nil, nil)

var dfareportingFloodlightConfigurationsList* = Call_DfareportingFloodlightConfigurationsList_596014(
    name: "dfareportingFloodlightConfigurationsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations",
    validator: validate_DfareportingFloodlightConfigurationsList_596015,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightConfigurationsList_596016,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsPatch_596047 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightConfigurationsPatch_596049(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsPatch_596048(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing floodlight configuration. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596050 = path.getOrDefault("profileId")
  valid_596050 = validateParameter(valid_596050, JString, required = true,
                                 default = nil)
  if valid_596050 != nil:
    section.add "profileId", valid_596050
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Floodlight configuration ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596051 = query.getOrDefault("fields")
  valid_596051 = validateParameter(valid_596051, JString, required = false,
                                 default = nil)
  if valid_596051 != nil:
    section.add "fields", valid_596051
  var valid_596052 = query.getOrDefault("quotaUser")
  valid_596052 = validateParameter(valid_596052, JString, required = false,
                                 default = nil)
  if valid_596052 != nil:
    section.add "quotaUser", valid_596052
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_596053 = query.getOrDefault("id")
  valid_596053 = validateParameter(valid_596053, JString, required = true,
                                 default = nil)
  if valid_596053 != nil:
    section.add "id", valid_596053
  var valid_596054 = query.getOrDefault("alt")
  valid_596054 = validateParameter(valid_596054, JString, required = false,
                                 default = newJString("json"))
  if valid_596054 != nil:
    section.add "alt", valid_596054
  var valid_596055 = query.getOrDefault("oauth_token")
  valid_596055 = validateParameter(valid_596055, JString, required = false,
                                 default = nil)
  if valid_596055 != nil:
    section.add "oauth_token", valid_596055
  var valid_596056 = query.getOrDefault("userIp")
  valid_596056 = validateParameter(valid_596056, JString, required = false,
                                 default = nil)
  if valid_596056 != nil:
    section.add "userIp", valid_596056
  var valid_596057 = query.getOrDefault("key")
  valid_596057 = validateParameter(valid_596057, JString, required = false,
                                 default = nil)
  if valid_596057 != nil:
    section.add "key", valid_596057
  var valid_596058 = query.getOrDefault("prettyPrint")
  valid_596058 = validateParameter(valid_596058, JBool, required = false,
                                 default = newJBool(true))
  if valid_596058 != nil:
    section.add "prettyPrint", valid_596058
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596060: Call_DfareportingFloodlightConfigurationsPatch_596047;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing floodlight configuration. This method supports patch semantics.
  ## 
  let valid = call_596060.validator(path, query, header, formData, body)
  let scheme = call_596060.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596060.url(scheme.get, call_596060.host, call_596060.base,
                         call_596060.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596060, url, valid)

proc call*(call_596061: Call_DfareportingFloodlightConfigurationsPatch_596047;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightConfigurationsPatch
  ## Updates an existing floodlight configuration. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Floodlight configuration ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596062 = newJObject()
  var query_596063 = newJObject()
  var body_596064 = newJObject()
  add(path_596062, "profileId", newJString(profileId))
  add(query_596063, "fields", newJString(fields))
  add(query_596063, "quotaUser", newJString(quotaUser))
  add(query_596063, "id", newJString(id))
  add(query_596063, "alt", newJString(alt))
  add(query_596063, "oauth_token", newJString(oauthToken))
  add(query_596063, "userIp", newJString(userIp))
  add(query_596063, "key", newJString(key))
  if body != nil:
    body_596064 = body
  add(query_596063, "prettyPrint", newJBool(prettyPrint))
  result = call_596061.call(path_596062, query_596063, nil, nil, body_596064)

var dfareportingFloodlightConfigurationsPatch* = Call_DfareportingFloodlightConfigurationsPatch_596047(
    name: "dfareportingFloodlightConfigurationsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations",
    validator: validate_DfareportingFloodlightConfigurationsPatch_596048,
    base: "/dfareporting/v2.7",
    url: url_DfareportingFloodlightConfigurationsPatch_596049,
    schemes: {Scheme.Https})
type
  Call_DfareportingFloodlightConfigurationsGet_596065 = ref object of OpenApiRestCall_593437
proc url_DfareportingFloodlightConfigurationsGet_596067(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/floodlightConfigurations/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingFloodlightConfigurationsGet_596066(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one floodlight configuration by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Floodlight configuration ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596068 = path.getOrDefault("profileId")
  valid_596068 = validateParameter(valid_596068, JString, required = true,
                                 default = nil)
  if valid_596068 != nil:
    section.add "profileId", valid_596068
  var valid_596069 = path.getOrDefault("id")
  valid_596069 = validateParameter(valid_596069, JString, required = true,
                                 default = nil)
  if valid_596069 != nil:
    section.add "id", valid_596069
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596070 = query.getOrDefault("fields")
  valid_596070 = validateParameter(valid_596070, JString, required = false,
                                 default = nil)
  if valid_596070 != nil:
    section.add "fields", valid_596070
  var valid_596071 = query.getOrDefault("quotaUser")
  valid_596071 = validateParameter(valid_596071, JString, required = false,
                                 default = nil)
  if valid_596071 != nil:
    section.add "quotaUser", valid_596071
  var valid_596072 = query.getOrDefault("alt")
  valid_596072 = validateParameter(valid_596072, JString, required = false,
                                 default = newJString("json"))
  if valid_596072 != nil:
    section.add "alt", valid_596072
  var valid_596073 = query.getOrDefault("oauth_token")
  valid_596073 = validateParameter(valid_596073, JString, required = false,
                                 default = nil)
  if valid_596073 != nil:
    section.add "oauth_token", valid_596073
  var valid_596074 = query.getOrDefault("userIp")
  valid_596074 = validateParameter(valid_596074, JString, required = false,
                                 default = nil)
  if valid_596074 != nil:
    section.add "userIp", valid_596074
  var valid_596075 = query.getOrDefault("key")
  valid_596075 = validateParameter(valid_596075, JString, required = false,
                                 default = nil)
  if valid_596075 != nil:
    section.add "key", valid_596075
  var valid_596076 = query.getOrDefault("prettyPrint")
  valid_596076 = validateParameter(valid_596076, JBool, required = false,
                                 default = newJBool(true))
  if valid_596076 != nil:
    section.add "prettyPrint", valid_596076
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596077: Call_DfareportingFloodlightConfigurationsGet_596065;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one floodlight configuration by ID.
  ## 
  let valid = call_596077.validator(path, query, header, formData, body)
  let scheme = call_596077.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596077.url(scheme.get, call_596077.host, call_596077.base,
                         call_596077.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596077, url, valid)

proc call*(call_596078: Call_DfareportingFloodlightConfigurationsGet_596065;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingFloodlightConfigurationsGet
  ## Gets one floodlight configuration by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Floodlight configuration ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596079 = newJObject()
  var query_596080 = newJObject()
  add(path_596079, "profileId", newJString(profileId))
  add(query_596080, "fields", newJString(fields))
  add(query_596080, "quotaUser", newJString(quotaUser))
  add(query_596080, "alt", newJString(alt))
  add(query_596080, "oauth_token", newJString(oauthToken))
  add(query_596080, "userIp", newJString(userIp))
  add(path_596079, "id", newJString(id))
  add(query_596080, "key", newJString(key))
  add(query_596080, "prettyPrint", newJBool(prettyPrint))
  result = call_596078.call(path_596079, query_596080, nil, nil, nil)

var dfareportingFloodlightConfigurationsGet* = Call_DfareportingFloodlightConfigurationsGet_596065(
    name: "dfareportingFloodlightConfigurationsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/floodlightConfigurations/{id}",
    validator: validate_DfareportingFloodlightConfigurationsGet_596066,
    base: "/dfareporting/v2.7", url: url_DfareportingFloodlightConfigurationsGet_596067,
    schemes: {Scheme.Https})
type
  Call_DfareportingLanguagesList_596081 = ref object of OpenApiRestCall_593437
proc url_DfareportingLanguagesList_596083(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/languages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingLanguagesList_596082(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of languages.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596084 = path.getOrDefault("profileId")
  valid_596084 = validateParameter(valid_596084, JString, required = true,
                                 default = nil)
  if valid_596084 != nil:
    section.add "profileId", valid_596084
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596085 = query.getOrDefault("fields")
  valid_596085 = validateParameter(valid_596085, JString, required = false,
                                 default = nil)
  if valid_596085 != nil:
    section.add "fields", valid_596085
  var valid_596086 = query.getOrDefault("quotaUser")
  valid_596086 = validateParameter(valid_596086, JString, required = false,
                                 default = nil)
  if valid_596086 != nil:
    section.add "quotaUser", valid_596086
  var valid_596087 = query.getOrDefault("alt")
  valid_596087 = validateParameter(valid_596087, JString, required = false,
                                 default = newJString("json"))
  if valid_596087 != nil:
    section.add "alt", valid_596087
  var valid_596088 = query.getOrDefault("oauth_token")
  valid_596088 = validateParameter(valid_596088, JString, required = false,
                                 default = nil)
  if valid_596088 != nil:
    section.add "oauth_token", valid_596088
  var valid_596089 = query.getOrDefault("userIp")
  valid_596089 = validateParameter(valid_596089, JString, required = false,
                                 default = nil)
  if valid_596089 != nil:
    section.add "userIp", valid_596089
  var valid_596090 = query.getOrDefault("key")
  valid_596090 = validateParameter(valid_596090, JString, required = false,
                                 default = nil)
  if valid_596090 != nil:
    section.add "key", valid_596090
  var valid_596091 = query.getOrDefault("prettyPrint")
  valid_596091 = validateParameter(valid_596091, JBool, required = false,
                                 default = newJBool(true))
  if valid_596091 != nil:
    section.add "prettyPrint", valid_596091
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596092: Call_DfareportingLanguagesList_596081; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of languages.
  ## 
  let valid = call_596092.validator(path, query, header, formData, body)
  let scheme = call_596092.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596092.url(scheme.get, call_596092.host, call_596092.base,
                         call_596092.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596092, url, valid)

proc call*(call_596093: Call_DfareportingLanguagesList_596081; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingLanguagesList
  ## Retrieves a list of languages.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596094 = newJObject()
  var query_596095 = newJObject()
  add(path_596094, "profileId", newJString(profileId))
  add(query_596095, "fields", newJString(fields))
  add(query_596095, "quotaUser", newJString(quotaUser))
  add(query_596095, "alt", newJString(alt))
  add(query_596095, "oauth_token", newJString(oauthToken))
  add(query_596095, "userIp", newJString(userIp))
  add(query_596095, "key", newJString(key))
  add(query_596095, "prettyPrint", newJBool(prettyPrint))
  result = call_596093.call(path_596094, query_596095, nil, nil, nil)

var dfareportingLanguagesList* = Call_DfareportingLanguagesList_596081(
    name: "dfareportingLanguagesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/languages",
    validator: validate_DfareportingLanguagesList_596082,
    base: "/dfareporting/v2.7", url: url_DfareportingLanguagesList_596083,
    schemes: {Scheme.Https})
type
  Call_DfareportingMetrosList_596096 = ref object of OpenApiRestCall_593437
proc url_DfareportingMetrosList_596098(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/metros")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingMetrosList_596097(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of metros.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596099 = path.getOrDefault("profileId")
  valid_596099 = validateParameter(valid_596099, JString, required = true,
                                 default = nil)
  if valid_596099 != nil:
    section.add "profileId", valid_596099
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596100 = query.getOrDefault("fields")
  valid_596100 = validateParameter(valid_596100, JString, required = false,
                                 default = nil)
  if valid_596100 != nil:
    section.add "fields", valid_596100
  var valid_596101 = query.getOrDefault("quotaUser")
  valid_596101 = validateParameter(valid_596101, JString, required = false,
                                 default = nil)
  if valid_596101 != nil:
    section.add "quotaUser", valid_596101
  var valid_596102 = query.getOrDefault("alt")
  valid_596102 = validateParameter(valid_596102, JString, required = false,
                                 default = newJString("json"))
  if valid_596102 != nil:
    section.add "alt", valid_596102
  var valid_596103 = query.getOrDefault("oauth_token")
  valid_596103 = validateParameter(valid_596103, JString, required = false,
                                 default = nil)
  if valid_596103 != nil:
    section.add "oauth_token", valid_596103
  var valid_596104 = query.getOrDefault("userIp")
  valid_596104 = validateParameter(valid_596104, JString, required = false,
                                 default = nil)
  if valid_596104 != nil:
    section.add "userIp", valid_596104
  var valid_596105 = query.getOrDefault("key")
  valid_596105 = validateParameter(valid_596105, JString, required = false,
                                 default = nil)
  if valid_596105 != nil:
    section.add "key", valid_596105
  var valid_596106 = query.getOrDefault("prettyPrint")
  valid_596106 = validateParameter(valid_596106, JBool, required = false,
                                 default = newJBool(true))
  if valid_596106 != nil:
    section.add "prettyPrint", valid_596106
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596107: Call_DfareportingMetrosList_596096; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of metros.
  ## 
  let valid = call_596107.validator(path, query, header, formData, body)
  let scheme = call_596107.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596107.url(scheme.get, call_596107.host, call_596107.base,
                         call_596107.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596107, url, valid)

proc call*(call_596108: Call_DfareportingMetrosList_596096; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingMetrosList
  ## Retrieves a list of metros.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596109 = newJObject()
  var query_596110 = newJObject()
  add(path_596109, "profileId", newJString(profileId))
  add(query_596110, "fields", newJString(fields))
  add(query_596110, "quotaUser", newJString(quotaUser))
  add(query_596110, "alt", newJString(alt))
  add(query_596110, "oauth_token", newJString(oauthToken))
  add(query_596110, "userIp", newJString(userIp))
  add(query_596110, "key", newJString(key))
  add(query_596110, "prettyPrint", newJBool(prettyPrint))
  result = call_596108.call(path_596109, query_596110, nil, nil, nil)

var dfareportingMetrosList* = Call_DfareportingMetrosList_596096(
    name: "dfareportingMetrosList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/metros",
    validator: validate_DfareportingMetrosList_596097, base: "/dfareporting/v2.7",
    url: url_DfareportingMetrosList_596098, schemes: {Scheme.Https})
type
  Call_DfareportingMobileCarriersList_596111 = ref object of OpenApiRestCall_593437
proc url_DfareportingMobileCarriersList_596113(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/mobileCarriers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingMobileCarriersList_596112(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of mobile carriers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596114 = path.getOrDefault("profileId")
  valid_596114 = validateParameter(valid_596114, JString, required = true,
                                 default = nil)
  if valid_596114 != nil:
    section.add "profileId", valid_596114
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596115 = query.getOrDefault("fields")
  valid_596115 = validateParameter(valid_596115, JString, required = false,
                                 default = nil)
  if valid_596115 != nil:
    section.add "fields", valid_596115
  var valid_596116 = query.getOrDefault("quotaUser")
  valid_596116 = validateParameter(valid_596116, JString, required = false,
                                 default = nil)
  if valid_596116 != nil:
    section.add "quotaUser", valid_596116
  var valid_596117 = query.getOrDefault("alt")
  valid_596117 = validateParameter(valid_596117, JString, required = false,
                                 default = newJString("json"))
  if valid_596117 != nil:
    section.add "alt", valid_596117
  var valid_596118 = query.getOrDefault("oauth_token")
  valid_596118 = validateParameter(valid_596118, JString, required = false,
                                 default = nil)
  if valid_596118 != nil:
    section.add "oauth_token", valid_596118
  var valid_596119 = query.getOrDefault("userIp")
  valid_596119 = validateParameter(valid_596119, JString, required = false,
                                 default = nil)
  if valid_596119 != nil:
    section.add "userIp", valid_596119
  var valid_596120 = query.getOrDefault("key")
  valid_596120 = validateParameter(valid_596120, JString, required = false,
                                 default = nil)
  if valid_596120 != nil:
    section.add "key", valid_596120
  var valid_596121 = query.getOrDefault("prettyPrint")
  valid_596121 = validateParameter(valid_596121, JBool, required = false,
                                 default = newJBool(true))
  if valid_596121 != nil:
    section.add "prettyPrint", valid_596121
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596122: Call_DfareportingMobileCarriersList_596111; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of mobile carriers.
  ## 
  let valid = call_596122.validator(path, query, header, formData, body)
  let scheme = call_596122.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596122.url(scheme.get, call_596122.host, call_596122.base,
                         call_596122.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596122, url, valid)

proc call*(call_596123: Call_DfareportingMobileCarriersList_596111;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingMobileCarriersList
  ## Retrieves a list of mobile carriers.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596124 = newJObject()
  var query_596125 = newJObject()
  add(path_596124, "profileId", newJString(profileId))
  add(query_596125, "fields", newJString(fields))
  add(query_596125, "quotaUser", newJString(quotaUser))
  add(query_596125, "alt", newJString(alt))
  add(query_596125, "oauth_token", newJString(oauthToken))
  add(query_596125, "userIp", newJString(userIp))
  add(query_596125, "key", newJString(key))
  add(query_596125, "prettyPrint", newJBool(prettyPrint))
  result = call_596123.call(path_596124, query_596125, nil, nil, nil)

var dfareportingMobileCarriersList* = Call_DfareportingMobileCarriersList_596111(
    name: "dfareportingMobileCarriersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/mobileCarriers",
    validator: validate_DfareportingMobileCarriersList_596112,
    base: "/dfareporting/v2.7", url: url_DfareportingMobileCarriersList_596113,
    schemes: {Scheme.Https})
type
  Call_DfareportingMobileCarriersGet_596126 = ref object of OpenApiRestCall_593437
proc url_DfareportingMobileCarriersGet_596128(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/mobileCarriers/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingMobileCarriersGet_596127(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one mobile carrier by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Mobile carrier ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596129 = path.getOrDefault("profileId")
  valid_596129 = validateParameter(valid_596129, JString, required = true,
                                 default = nil)
  if valid_596129 != nil:
    section.add "profileId", valid_596129
  var valid_596130 = path.getOrDefault("id")
  valid_596130 = validateParameter(valid_596130, JString, required = true,
                                 default = nil)
  if valid_596130 != nil:
    section.add "id", valid_596130
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596131 = query.getOrDefault("fields")
  valid_596131 = validateParameter(valid_596131, JString, required = false,
                                 default = nil)
  if valid_596131 != nil:
    section.add "fields", valid_596131
  var valid_596132 = query.getOrDefault("quotaUser")
  valid_596132 = validateParameter(valid_596132, JString, required = false,
                                 default = nil)
  if valid_596132 != nil:
    section.add "quotaUser", valid_596132
  var valid_596133 = query.getOrDefault("alt")
  valid_596133 = validateParameter(valid_596133, JString, required = false,
                                 default = newJString("json"))
  if valid_596133 != nil:
    section.add "alt", valid_596133
  var valid_596134 = query.getOrDefault("oauth_token")
  valid_596134 = validateParameter(valid_596134, JString, required = false,
                                 default = nil)
  if valid_596134 != nil:
    section.add "oauth_token", valid_596134
  var valid_596135 = query.getOrDefault("userIp")
  valid_596135 = validateParameter(valid_596135, JString, required = false,
                                 default = nil)
  if valid_596135 != nil:
    section.add "userIp", valid_596135
  var valid_596136 = query.getOrDefault("key")
  valid_596136 = validateParameter(valid_596136, JString, required = false,
                                 default = nil)
  if valid_596136 != nil:
    section.add "key", valid_596136
  var valid_596137 = query.getOrDefault("prettyPrint")
  valid_596137 = validateParameter(valid_596137, JBool, required = false,
                                 default = newJBool(true))
  if valid_596137 != nil:
    section.add "prettyPrint", valid_596137
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596138: Call_DfareportingMobileCarriersGet_596126; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one mobile carrier by ID.
  ## 
  let valid = call_596138.validator(path, query, header, formData, body)
  let scheme = call_596138.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596138.url(scheme.get, call_596138.host, call_596138.base,
                         call_596138.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596138, url, valid)

proc call*(call_596139: Call_DfareportingMobileCarriersGet_596126;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingMobileCarriersGet
  ## Gets one mobile carrier by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Mobile carrier ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596140 = newJObject()
  var query_596141 = newJObject()
  add(path_596140, "profileId", newJString(profileId))
  add(query_596141, "fields", newJString(fields))
  add(query_596141, "quotaUser", newJString(quotaUser))
  add(query_596141, "alt", newJString(alt))
  add(query_596141, "oauth_token", newJString(oauthToken))
  add(query_596141, "userIp", newJString(userIp))
  add(path_596140, "id", newJString(id))
  add(query_596141, "key", newJString(key))
  add(query_596141, "prettyPrint", newJBool(prettyPrint))
  result = call_596139.call(path_596140, query_596141, nil, nil, nil)

var dfareportingMobileCarriersGet* = Call_DfareportingMobileCarriersGet_596126(
    name: "dfareportingMobileCarriersGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/mobileCarriers/{id}",
    validator: validate_DfareportingMobileCarriersGet_596127,
    base: "/dfareporting/v2.7", url: url_DfareportingMobileCarriersGet_596128,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemVersionsList_596142 = ref object of OpenApiRestCall_593437
proc url_DfareportingOperatingSystemVersionsList_596144(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystemVersions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemVersionsList_596143(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of operating system versions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596145 = path.getOrDefault("profileId")
  valid_596145 = validateParameter(valid_596145, JString, required = true,
                                 default = nil)
  if valid_596145 != nil:
    section.add "profileId", valid_596145
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596146 = query.getOrDefault("fields")
  valid_596146 = validateParameter(valid_596146, JString, required = false,
                                 default = nil)
  if valid_596146 != nil:
    section.add "fields", valid_596146
  var valid_596147 = query.getOrDefault("quotaUser")
  valid_596147 = validateParameter(valid_596147, JString, required = false,
                                 default = nil)
  if valid_596147 != nil:
    section.add "quotaUser", valid_596147
  var valid_596148 = query.getOrDefault("alt")
  valid_596148 = validateParameter(valid_596148, JString, required = false,
                                 default = newJString("json"))
  if valid_596148 != nil:
    section.add "alt", valid_596148
  var valid_596149 = query.getOrDefault("oauth_token")
  valid_596149 = validateParameter(valid_596149, JString, required = false,
                                 default = nil)
  if valid_596149 != nil:
    section.add "oauth_token", valid_596149
  var valid_596150 = query.getOrDefault("userIp")
  valid_596150 = validateParameter(valid_596150, JString, required = false,
                                 default = nil)
  if valid_596150 != nil:
    section.add "userIp", valid_596150
  var valid_596151 = query.getOrDefault("key")
  valid_596151 = validateParameter(valid_596151, JString, required = false,
                                 default = nil)
  if valid_596151 != nil:
    section.add "key", valid_596151
  var valid_596152 = query.getOrDefault("prettyPrint")
  valid_596152 = validateParameter(valid_596152, JBool, required = false,
                                 default = newJBool(true))
  if valid_596152 != nil:
    section.add "prettyPrint", valid_596152
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596153: Call_DfareportingOperatingSystemVersionsList_596142;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of operating system versions.
  ## 
  let valid = call_596153.validator(path, query, header, formData, body)
  let scheme = call_596153.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596153.url(scheme.get, call_596153.host, call_596153.base,
                         call_596153.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596153, url, valid)

proc call*(call_596154: Call_DfareportingOperatingSystemVersionsList_596142;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOperatingSystemVersionsList
  ## Retrieves a list of operating system versions.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596155 = newJObject()
  var query_596156 = newJObject()
  add(path_596155, "profileId", newJString(profileId))
  add(query_596156, "fields", newJString(fields))
  add(query_596156, "quotaUser", newJString(quotaUser))
  add(query_596156, "alt", newJString(alt))
  add(query_596156, "oauth_token", newJString(oauthToken))
  add(query_596156, "userIp", newJString(userIp))
  add(query_596156, "key", newJString(key))
  add(query_596156, "prettyPrint", newJBool(prettyPrint))
  result = call_596154.call(path_596155, query_596156, nil, nil, nil)

var dfareportingOperatingSystemVersionsList* = Call_DfareportingOperatingSystemVersionsList_596142(
    name: "dfareportingOperatingSystemVersionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystemVersions",
    validator: validate_DfareportingOperatingSystemVersionsList_596143,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemVersionsList_596144,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemVersionsGet_596157 = ref object of OpenApiRestCall_593437
proc url_DfareportingOperatingSystemVersionsGet_596159(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystemVersions/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemVersionsGet_596158(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one operating system version by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Operating system version ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596160 = path.getOrDefault("profileId")
  valid_596160 = validateParameter(valid_596160, JString, required = true,
                                 default = nil)
  if valid_596160 != nil:
    section.add "profileId", valid_596160
  var valid_596161 = path.getOrDefault("id")
  valid_596161 = validateParameter(valid_596161, JString, required = true,
                                 default = nil)
  if valid_596161 != nil:
    section.add "id", valid_596161
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596162 = query.getOrDefault("fields")
  valid_596162 = validateParameter(valid_596162, JString, required = false,
                                 default = nil)
  if valid_596162 != nil:
    section.add "fields", valid_596162
  var valid_596163 = query.getOrDefault("quotaUser")
  valid_596163 = validateParameter(valid_596163, JString, required = false,
                                 default = nil)
  if valid_596163 != nil:
    section.add "quotaUser", valid_596163
  var valid_596164 = query.getOrDefault("alt")
  valid_596164 = validateParameter(valid_596164, JString, required = false,
                                 default = newJString("json"))
  if valid_596164 != nil:
    section.add "alt", valid_596164
  var valid_596165 = query.getOrDefault("oauth_token")
  valid_596165 = validateParameter(valid_596165, JString, required = false,
                                 default = nil)
  if valid_596165 != nil:
    section.add "oauth_token", valid_596165
  var valid_596166 = query.getOrDefault("userIp")
  valid_596166 = validateParameter(valid_596166, JString, required = false,
                                 default = nil)
  if valid_596166 != nil:
    section.add "userIp", valid_596166
  var valid_596167 = query.getOrDefault("key")
  valid_596167 = validateParameter(valid_596167, JString, required = false,
                                 default = nil)
  if valid_596167 != nil:
    section.add "key", valid_596167
  var valid_596168 = query.getOrDefault("prettyPrint")
  valid_596168 = validateParameter(valid_596168, JBool, required = false,
                                 default = newJBool(true))
  if valid_596168 != nil:
    section.add "prettyPrint", valid_596168
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596169: Call_DfareportingOperatingSystemVersionsGet_596157;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one operating system version by ID.
  ## 
  let valid = call_596169.validator(path, query, header, formData, body)
  let scheme = call_596169.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596169.url(scheme.get, call_596169.host, call_596169.base,
                         call_596169.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596169, url, valid)

proc call*(call_596170: Call_DfareportingOperatingSystemVersionsGet_596157;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOperatingSystemVersionsGet
  ## Gets one operating system version by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Operating system version ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596171 = newJObject()
  var query_596172 = newJObject()
  add(path_596171, "profileId", newJString(profileId))
  add(query_596172, "fields", newJString(fields))
  add(query_596172, "quotaUser", newJString(quotaUser))
  add(query_596172, "alt", newJString(alt))
  add(query_596172, "oauth_token", newJString(oauthToken))
  add(query_596172, "userIp", newJString(userIp))
  add(path_596171, "id", newJString(id))
  add(query_596172, "key", newJString(key))
  add(query_596172, "prettyPrint", newJBool(prettyPrint))
  result = call_596170.call(path_596171, query_596172, nil, nil, nil)

var dfareportingOperatingSystemVersionsGet* = Call_DfareportingOperatingSystemVersionsGet_596157(
    name: "dfareportingOperatingSystemVersionsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystemVersions/{id}",
    validator: validate_DfareportingOperatingSystemVersionsGet_596158,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemVersionsGet_596159,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemsList_596173 = ref object of OpenApiRestCall_593437
proc url_DfareportingOperatingSystemsList_596175(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystems")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemsList_596174(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of operating systems.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596176 = path.getOrDefault("profileId")
  valid_596176 = validateParameter(valid_596176, JString, required = true,
                                 default = nil)
  if valid_596176 != nil:
    section.add "profileId", valid_596176
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596177 = query.getOrDefault("fields")
  valid_596177 = validateParameter(valid_596177, JString, required = false,
                                 default = nil)
  if valid_596177 != nil:
    section.add "fields", valid_596177
  var valid_596178 = query.getOrDefault("quotaUser")
  valid_596178 = validateParameter(valid_596178, JString, required = false,
                                 default = nil)
  if valid_596178 != nil:
    section.add "quotaUser", valid_596178
  var valid_596179 = query.getOrDefault("alt")
  valid_596179 = validateParameter(valid_596179, JString, required = false,
                                 default = newJString("json"))
  if valid_596179 != nil:
    section.add "alt", valid_596179
  var valid_596180 = query.getOrDefault("oauth_token")
  valid_596180 = validateParameter(valid_596180, JString, required = false,
                                 default = nil)
  if valid_596180 != nil:
    section.add "oauth_token", valid_596180
  var valid_596181 = query.getOrDefault("userIp")
  valid_596181 = validateParameter(valid_596181, JString, required = false,
                                 default = nil)
  if valid_596181 != nil:
    section.add "userIp", valid_596181
  var valid_596182 = query.getOrDefault("key")
  valid_596182 = validateParameter(valid_596182, JString, required = false,
                                 default = nil)
  if valid_596182 != nil:
    section.add "key", valid_596182
  var valid_596183 = query.getOrDefault("prettyPrint")
  valid_596183 = validateParameter(valid_596183, JBool, required = false,
                                 default = newJBool(true))
  if valid_596183 != nil:
    section.add "prettyPrint", valid_596183
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596184: Call_DfareportingOperatingSystemsList_596173;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of operating systems.
  ## 
  let valid = call_596184.validator(path, query, header, formData, body)
  let scheme = call_596184.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596184.url(scheme.get, call_596184.host, call_596184.base,
                         call_596184.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596184, url, valid)

proc call*(call_596185: Call_DfareportingOperatingSystemsList_596173;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOperatingSystemsList
  ## Retrieves a list of operating systems.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596186 = newJObject()
  var query_596187 = newJObject()
  add(path_596186, "profileId", newJString(profileId))
  add(query_596187, "fields", newJString(fields))
  add(query_596187, "quotaUser", newJString(quotaUser))
  add(query_596187, "alt", newJString(alt))
  add(query_596187, "oauth_token", newJString(oauthToken))
  add(query_596187, "userIp", newJString(userIp))
  add(query_596187, "key", newJString(key))
  add(query_596187, "prettyPrint", newJBool(prettyPrint))
  result = call_596185.call(path_596186, query_596187, nil, nil, nil)

var dfareportingOperatingSystemsList* = Call_DfareportingOperatingSystemsList_596173(
    name: "dfareportingOperatingSystemsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystems",
    validator: validate_DfareportingOperatingSystemsList_596174,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemsList_596175,
    schemes: {Scheme.Https})
type
  Call_DfareportingOperatingSystemsGet_596188 = ref object of OpenApiRestCall_593437
proc url_DfareportingOperatingSystemsGet_596190(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "dartId" in path, "`dartId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/operatingSystems/"),
               (kind: VariableSegment, value: "dartId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOperatingSystemsGet_596189(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one operating system by DART ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   dartId: JString (required)
  ##         : Operating system DART ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596191 = path.getOrDefault("profileId")
  valid_596191 = validateParameter(valid_596191, JString, required = true,
                                 default = nil)
  if valid_596191 != nil:
    section.add "profileId", valid_596191
  var valid_596192 = path.getOrDefault("dartId")
  valid_596192 = validateParameter(valid_596192, JString, required = true,
                                 default = nil)
  if valid_596192 != nil:
    section.add "dartId", valid_596192
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596193 = query.getOrDefault("fields")
  valid_596193 = validateParameter(valid_596193, JString, required = false,
                                 default = nil)
  if valid_596193 != nil:
    section.add "fields", valid_596193
  var valid_596194 = query.getOrDefault("quotaUser")
  valid_596194 = validateParameter(valid_596194, JString, required = false,
                                 default = nil)
  if valid_596194 != nil:
    section.add "quotaUser", valid_596194
  var valid_596195 = query.getOrDefault("alt")
  valid_596195 = validateParameter(valid_596195, JString, required = false,
                                 default = newJString("json"))
  if valid_596195 != nil:
    section.add "alt", valid_596195
  var valid_596196 = query.getOrDefault("oauth_token")
  valid_596196 = validateParameter(valid_596196, JString, required = false,
                                 default = nil)
  if valid_596196 != nil:
    section.add "oauth_token", valid_596196
  var valid_596197 = query.getOrDefault("userIp")
  valid_596197 = validateParameter(valid_596197, JString, required = false,
                                 default = nil)
  if valid_596197 != nil:
    section.add "userIp", valid_596197
  var valid_596198 = query.getOrDefault("key")
  valid_596198 = validateParameter(valid_596198, JString, required = false,
                                 default = nil)
  if valid_596198 != nil:
    section.add "key", valid_596198
  var valid_596199 = query.getOrDefault("prettyPrint")
  valid_596199 = validateParameter(valid_596199, JBool, required = false,
                                 default = newJBool(true))
  if valid_596199 != nil:
    section.add "prettyPrint", valid_596199
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596200: Call_DfareportingOperatingSystemsGet_596188;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one operating system by DART ID.
  ## 
  let valid = call_596200.validator(path, query, header, formData, body)
  let scheme = call_596200.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596200.url(scheme.get, call_596200.host, call_596200.base,
                         call_596200.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596200, url, valid)

proc call*(call_596201: Call_DfareportingOperatingSystemsGet_596188;
          profileId: string; dartId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOperatingSystemsGet
  ## Gets one operating system by DART ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   dartId: string (required)
  ##         : Operating system DART ID.
  var path_596202 = newJObject()
  var query_596203 = newJObject()
  add(path_596202, "profileId", newJString(profileId))
  add(query_596203, "fields", newJString(fields))
  add(query_596203, "quotaUser", newJString(quotaUser))
  add(query_596203, "alt", newJString(alt))
  add(query_596203, "oauth_token", newJString(oauthToken))
  add(query_596203, "userIp", newJString(userIp))
  add(query_596203, "key", newJString(key))
  add(query_596203, "prettyPrint", newJBool(prettyPrint))
  add(path_596202, "dartId", newJString(dartId))
  result = call_596201.call(path_596202, query_596203, nil, nil, nil)

var dfareportingOperatingSystemsGet* = Call_DfareportingOperatingSystemsGet_596188(
    name: "dfareportingOperatingSystemsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/operatingSystems/{dartId}",
    validator: validate_DfareportingOperatingSystemsGet_596189,
    base: "/dfareporting/v2.7", url: url_DfareportingOperatingSystemsGet_596190,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsUpdate_596238 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementGroupsUpdate_596240(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsUpdate_596239(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596241 = path.getOrDefault("profileId")
  valid_596241 = validateParameter(valid_596241, JString, required = true,
                                 default = nil)
  if valid_596241 != nil:
    section.add "profileId", valid_596241
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596242 = query.getOrDefault("fields")
  valid_596242 = validateParameter(valid_596242, JString, required = false,
                                 default = nil)
  if valid_596242 != nil:
    section.add "fields", valid_596242
  var valid_596243 = query.getOrDefault("quotaUser")
  valid_596243 = validateParameter(valid_596243, JString, required = false,
                                 default = nil)
  if valid_596243 != nil:
    section.add "quotaUser", valid_596243
  var valid_596244 = query.getOrDefault("alt")
  valid_596244 = validateParameter(valid_596244, JString, required = false,
                                 default = newJString("json"))
  if valid_596244 != nil:
    section.add "alt", valid_596244
  var valid_596245 = query.getOrDefault("oauth_token")
  valid_596245 = validateParameter(valid_596245, JString, required = false,
                                 default = nil)
  if valid_596245 != nil:
    section.add "oauth_token", valid_596245
  var valid_596246 = query.getOrDefault("userIp")
  valid_596246 = validateParameter(valid_596246, JString, required = false,
                                 default = nil)
  if valid_596246 != nil:
    section.add "userIp", valid_596246
  var valid_596247 = query.getOrDefault("key")
  valid_596247 = validateParameter(valid_596247, JString, required = false,
                                 default = nil)
  if valid_596247 != nil:
    section.add "key", valid_596247
  var valid_596248 = query.getOrDefault("prettyPrint")
  valid_596248 = validateParameter(valid_596248, JBool, required = false,
                                 default = newJBool(true))
  if valid_596248 != nil:
    section.add "prettyPrint", valid_596248
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596250: Call_DfareportingPlacementGroupsUpdate_596238;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement group.
  ## 
  let valid = call_596250.validator(path, query, header, formData, body)
  let scheme = call_596250.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596250.url(scheme.get, call_596250.host, call_596250.base,
                         call_596250.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596250, url, valid)

proc call*(call_596251: Call_DfareportingPlacementGroupsUpdate_596238;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementGroupsUpdate
  ## Updates an existing placement group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596252 = newJObject()
  var query_596253 = newJObject()
  var body_596254 = newJObject()
  add(path_596252, "profileId", newJString(profileId))
  add(query_596253, "fields", newJString(fields))
  add(query_596253, "quotaUser", newJString(quotaUser))
  add(query_596253, "alt", newJString(alt))
  add(query_596253, "oauth_token", newJString(oauthToken))
  add(query_596253, "userIp", newJString(userIp))
  add(query_596253, "key", newJString(key))
  if body != nil:
    body_596254 = body
  add(query_596253, "prettyPrint", newJBool(prettyPrint))
  result = call_596251.call(path_596252, query_596253, nil, nil, body_596254)

var dfareportingPlacementGroupsUpdate* = Call_DfareportingPlacementGroupsUpdate_596238(
    name: "dfareportingPlacementGroupsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsUpdate_596239,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsUpdate_596240,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsInsert_596255 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementGroupsInsert_596257(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsInsert_596256(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new placement group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596258 = path.getOrDefault("profileId")
  valid_596258 = validateParameter(valid_596258, JString, required = true,
                                 default = nil)
  if valid_596258 != nil:
    section.add "profileId", valid_596258
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596259 = query.getOrDefault("fields")
  valid_596259 = validateParameter(valid_596259, JString, required = false,
                                 default = nil)
  if valid_596259 != nil:
    section.add "fields", valid_596259
  var valid_596260 = query.getOrDefault("quotaUser")
  valid_596260 = validateParameter(valid_596260, JString, required = false,
                                 default = nil)
  if valid_596260 != nil:
    section.add "quotaUser", valid_596260
  var valid_596261 = query.getOrDefault("alt")
  valid_596261 = validateParameter(valid_596261, JString, required = false,
                                 default = newJString("json"))
  if valid_596261 != nil:
    section.add "alt", valid_596261
  var valid_596262 = query.getOrDefault("oauth_token")
  valid_596262 = validateParameter(valid_596262, JString, required = false,
                                 default = nil)
  if valid_596262 != nil:
    section.add "oauth_token", valid_596262
  var valid_596263 = query.getOrDefault("userIp")
  valid_596263 = validateParameter(valid_596263, JString, required = false,
                                 default = nil)
  if valid_596263 != nil:
    section.add "userIp", valid_596263
  var valid_596264 = query.getOrDefault("key")
  valid_596264 = validateParameter(valid_596264, JString, required = false,
                                 default = nil)
  if valid_596264 != nil:
    section.add "key", valid_596264
  var valid_596265 = query.getOrDefault("prettyPrint")
  valid_596265 = validateParameter(valid_596265, JBool, required = false,
                                 default = newJBool(true))
  if valid_596265 != nil:
    section.add "prettyPrint", valid_596265
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596267: Call_DfareportingPlacementGroupsInsert_596255;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new placement group.
  ## 
  let valid = call_596267.validator(path, query, header, formData, body)
  let scheme = call_596267.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596267.url(scheme.get, call_596267.host, call_596267.base,
                         call_596267.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596267, url, valid)

proc call*(call_596268: Call_DfareportingPlacementGroupsInsert_596255;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementGroupsInsert
  ## Inserts a new placement group.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596269 = newJObject()
  var query_596270 = newJObject()
  var body_596271 = newJObject()
  add(path_596269, "profileId", newJString(profileId))
  add(query_596270, "fields", newJString(fields))
  add(query_596270, "quotaUser", newJString(quotaUser))
  add(query_596270, "alt", newJString(alt))
  add(query_596270, "oauth_token", newJString(oauthToken))
  add(query_596270, "userIp", newJString(userIp))
  add(query_596270, "key", newJString(key))
  if body != nil:
    body_596271 = body
  add(query_596270, "prettyPrint", newJBool(prettyPrint))
  result = call_596268.call(path_596269, query_596270, nil, nil, body_596271)

var dfareportingPlacementGroupsInsert* = Call_DfareportingPlacementGroupsInsert_596255(
    name: "dfareportingPlacementGroupsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsInsert_596256,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsInsert_596257,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsList_596204 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementGroupsList_596206(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsList_596205(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of placement groups, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596207 = path.getOrDefault("profileId")
  valid_596207 = validateParameter(valid_596207, JString, required = true,
                                 default = nil)
  if valid_596207 != nil:
    section.add "profileId", valid_596207
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placement groups that are associated with these content categories.
  ##   alt: JString
  ##      : Data format for the response.
  ##   placementGroupType: JString
  ##                     : Select only placement groups belonging with this group type. A package is a simple group of placements that acts as a single pricing point for a group of tags. A roadblock is a group of placements that not only acts as a single pricing point but also assumes that all the tags in it will be served at the same time. A roadblock requires one of its assigned placements to be marked as primary for reporting.
  ##   searchString: JString
  ##               : Allows searching for placement groups by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placement groups with names like "placement group June 2015", "placement group May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementgroup" will match placement groups with name "my placementgroup", "placementgroup 2015", or simply "placementgroup".
  ##   minEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   siteIds: JArray
  ##          : Select only placement groups that are associated with these sites.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   maxStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   campaignIds: JArray
  ##              : Select only placement groups that belong to these campaigns.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: JBool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   maxEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placement groups with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only placement groups that belong to these advertisers.
  ##   minStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only placement groups that are associated with these directory sites.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   placementStrategyIds: JArray
  ##                       : Select only placement groups that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placement groups with these pricing types.
  section = newJObject()
  var valid_596208 = query.getOrDefault("fields")
  valid_596208 = validateParameter(valid_596208, JString, required = false,
                                 default = nil)
  if valid_596208 != nil:
    section.add "fields", valid_596208
  var valid_596209 = query.getOrDefault("pageToken")
  valid_596209 = validateParameter(valid_596209, JString, required = false,
                                 default = nil)
  if valid_596209 != nil:
    section.add "pageToken", valid_596209
  var valid_596210 = query.getOrDefault("quotaUser")
  valid_596210 = validateParameter(valid_596210, JString, required = false,
                                 default = nil)
  if valid_596210 != nil:
    section.add "quotaUser", valid_596210
  var valid_596211 = query.getOrDefault("sortField")
  valid_596211 = validateParameter(valid_596211, JString, required = false,
                                 default = newJString("ID"))
  if valid_596211 != nil:
    section.add "sortField", valid_596211
  var valid_596212 = query.getOrDefault("contentCategoryIds")
  valid_596212 = validateParameter(valid_596212, JArray, required = false,
                                 default = nil)
  if valid_596212 != nil:
    section.add "contentCategoryIds", valid_596212
  var valid_596213 = query.getOrDefault("alt")
  valid_596213 = validateParameter(valid_596213, JString, required = false,
                                 default = newJString("json"))
  if valid_596213 != nil:
    section.add "alt", valid_596213
  var valid_596214 = query.getOrDefault("placementGroupType")
  valid_596214 = validateParameter(valid_596214, JString, required = false,
                                 default = newJString("PLACEMENT_PACKAGE"))
  if valid_596214 != nil:
    section.add "placementGroupType", valid_596214
  var valid_596215 = query.getOrDefault("searchString")
  valid_596215 = validateParameter(valid_596215, JString, required = false,
                                 default = nil)
  if valid_596215 != nil:
    section.add "searchString", valid_596215
  var valid_596216 = query.getOrDefault("minEndDate")
  valid_596216 = validateParameter(valid_596216, JString, required = false,
                                 default = nil)
  if valid_596216 != nil:
    section.add "minEndDate", valid_596216
  var valid_596217 = query.getOrDefault("siteIds")
  valid_596217 = validateParameter(valid_596217, JArray, required = false,
                                 default = nil)
  if valid_596217 != nil:
    section.add "siteIds", valid_596217
  var valid_596218 = query.getOrDefault("oauth_token")
  valid_596218 = validateParameter(valid_596218, JString, required = false,
                                 default = nil)
  if valid_596218 != nil:
    section.add "oauth_token", valid_596218
  var valid_596219 = query.getOrDefault("maxStartDate")
  valid_596219 = validateParameter(valid_596219, JString, required = false,
                                 default = nil)
  if valid_596219 != nil:
    section.add "maxStartDate", valid_596219
  var valid_596220 = query.getOrDefault("campaignIds")
  valid_596220 = validateParameter(valid_596220, JArray, required = false,
                                 default = nil)
  if valid_596220 != nil:
    section.add "campaignIds", valid_596220
  var valid_596221 = query.getOrDefault("userIp")
  valid_596221 = validateParameter(valid_596221, JString, required = false,
                                 default = nil)
  if valid_596221 != nil:
    section.add "userIp", valid_596221
  var valid_596222 = query.getOrDefault("archived")
  valid_596222 = validateParameter(valid_596222, JBool, required = false, default = nil)
  if valid_596222 != nil:
    section.add "archived", valid_596222
  var valid_596223 = query.getOrDefault("maxEndDate")
  valid_596223 = validateParameter(valid_596223, JString, required = false,
                                 default = nil)
  if valid_596223 != nil:
    section.add "maxEndDate", valid_596223
  var valid_596224 = query.getOrDefault("maxResults")
  valid_596224 = validateParameter(valid_596224, JInt, required = false,
                                 default = newJInt(800))
  if valid_596224 != nil:
    section.add "maxResults", valid_596224
  var valid_596225 = query.getOrDefault("ids")
  valid_596225 = validateParameter(valid_596225, JArray, required = false,
                                 default = nil)
  if valid_596225 != nil:
    section.add "ids", valid_596225
  var valid_596226 = query.getOrDefault("key")
  valid_596226 = validateParameter(valid_596226, JString, required = false,
                                 default = nil)
  if valid_596226 != nil:
    section.add "key", valid_596226
  var valid_596227 = query.getOrDefault("advertiserIds")
  valid_596227 = validateParameter(valid_596227, JArray, required = false,
                                 default = nil)
  if valid_596227 != nil:
    section.add "advertiserIds", valid_596227
  var valid_596228 = query.getOrDefault("minStartDate")
  valid_596228 = validateParameter(valid_596228, JString, required = false,
                                 default = nil)
  if valid_596228 != nil:
    section.add "minStartDate", valid_596228
  var valid_596229 = query.getOrDefault("sortOrder")
  valid_596229 = validateParameter(valid_596229, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_596229 != nil:
    section.add "sortOrder", valid_596229
  var valid_596230 = query.getOrDefault("directorySiteIds")
  valid_596230 = validateParameter(valid_596230, JArray, required = false,
                                 default = nil)
  if valid_596230 != nil:
    section.add "directorySiteIds", valid_596230
  var valid_596231 = query.getOrDefault("prettyPrint")
  valid_596231 = validateParameter(valid_596231, JBool, required = false,
                                 default = newJBool(true))
  if valid_596231 != nil:
    section.add "prettyPrint", valid_596231
  var valid_596232 = query.getOrDefault("placementStrategyIds")
  valid_596232 = validateParameter(valid_596232, JArray, required = false,
                                 default = nil)
  if valid_596232 != nil:
    section.add "placementStrategyIds", valid_596232
  var valid_596233 = query.getOrDefault("pricingTypes")
  valid_596233 = validateParameter(valid_596233, JArray, required = false,
                                 default = nil)
  if valid_596233 != nil:
    section.add "pricingTypes", valid_596233
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596234: Call_DfareportingPlacementGroupsList_596204;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of placement groups, possibly filtered. This method supports paging.
  ## 
  let valid = call_596234.validator(path, query, header, formData, body)
  let scheme = call_596234.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596234.url(scheme.get, call_596234.host, call_596234.base,
                         call_596234.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596234, url, valid)

proc call*(call_596235: Call_DfareportingPlacementGroupsList_596204;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID";
          contentCategoryIds: JsonNode = nil; alt: string = "json";
          placementGroupType: string = "PLACEMENT_PACKAGE";
          searchString: string = ""; minEndDate: string = ""; siteIds: JsonNode = nil;
          oauthToken: string = ""; maxStartDate: string = "";
          campaignIds: JsonNode = nil; userIp: string = ""; archived: bool = false;
          maxEndDate: string = ""; maxResults: int = 800; ids: JsonNode = nil;
          key: string = ""; advertiserIds: JsonNode = nil; minStartDate: string = "";
          sortOrder: string = "ASCENDING"; directorySiteIds: JsonNode = nil;
          prettyPrint: bool = true; placementStrategyIds: JsonNode = nil;
          pricingTypes: JsonNode = nil): Recallable =
  ## dfareportingPlacementGroupsList
  ## Retrieves a list of placement groups, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placement groups that are associated with these content categories.
  ##   alt: string
  ##      : Data format for the response.
  ##   placementGroupType: string
  ##                     : Select only placement groups belonging with this group type. A package is a simple group of placements that acts as a single pricing point for a group of tags. A roadblock is a group of placements that not only acts as a single pricing point but also assumes that all the tags in it will be served at the same time. A roadblock requires one of its assigned placements to be marked as primary for reporting.
  ##   searchString: string
  ##               : Allows searching for placement groups by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placement groups with names like "placement group June 2015", "placement group May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementgroup" will match placement groups with name "my placementgroup", "placementgroup 2015", or simply "placementgroup".
  ##   minEndDate: string
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   siteIds: JArray
  ##          : Select only placement groups that are associated with these sites.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   maxStartDate: string
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   campaignIds: JArray
  ##              : Select only placement groups that belong to these campaigns.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: bool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   maxEndDate: string
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placement groups with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only placement groups that belong to these advertisers.
  ##   minStartDate: string
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only placement groups that are associated with these directory sites.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   placementStrategyIds: JArray
  ##                       : Select only placement groups that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placement groups with these pricing types.
  var path_596236 = newJObject()
  var query_596237 = newJObject()
  add(path_596236, "profileId", newJString(profileId))
  add(query_596237, "fields", newJString(fields))
  add(query_596237, "pageToken", newJString(pageToken))
  add(query_596237, "quotaUser", newJString(quotaUser))
  add(query_596237, "sortField", newJString(sortField))
  if contentCategoryIds != nil:
    query_596237.add "contentCategoryIds", contentCategoryIds
  add(query_596237, "alt", newJString(alt))
  add(query_596237, "placementGroupType", newJString(placementGroupType))
  add(query_596237, "searchString", newJString(searchString))
  add(query_596237, "minEndDate", newJString(minEndDate))
  if siteIds != nil:
    query_596237.add "siteIds", siteIds
  add(query_596237, "oauth_token", newJString(oauthToken))
  add(query_596237, "maxStartDate", newJString(maxStartDate))
  if campaignIds != nil:
    query_596237.add "campaignIds", campaignIds
  add(query_596237, "userIp", newJString(userIp))
  add(query_596237, "archived", newJBool(archived))
  add(query_596237, "maxEndDate", newJString(maxEndDate))
  add(query_596237, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_596237.add "ids", ids
  add(query_596237, "key", newJString(key))
  if advertiserIds != nil:
    query_596237.add "advertiserIds", advertiserIds
  add(query_596237, "minStartDate", newJString(minStartDate))
  add(query_596237, "sortOrder", newJString(sortOrder))
  if directorySiteIds != nil:
    query_596237.add "directorySiteIds", directorySiteIds
  add(query_596237, "prettyPrint", newJBool(prettyPrint))
  if placementStrategyIds != nil:
    query_596237.add "placementStrategyIds", placementStrategyIds
  if pricingTypes != nil:
    query_596237.add "pricingTypes", pricingTypes
  result = call_596235.call(path_596236, query_596237, nil, nil, nil)

var dfareportingPlacementGroupsList* = Call_DfareportingPlacementGroupsList_596204(
    name: "dfareportingPlacementGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsList_596205,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsList_596206,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsPatch_596272 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementGroupsPatch_596274(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsPatch_596273(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement group. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596275 = path.getOrDefault("profileId")
  valid_596275 = validateParameter(valid_596275, JString, required = true,
                                 default = nil)
  if valid_596275 != nil:
    section.add "profileId", valid_596275
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Placement group ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596276 = query.getOrDefault("fields")
  valid_596276 = validateParameter(valid_596276, JString, required = false,
                                 default = nil)
  if valid_596276 != nil:
    section.add "fields", valid_596276
  var valid_596277 = query.getOrDefault("quotaUser")
  valid_596277 = validateParameter(valid_596277, JString, required = false,
                                 default = nil)
  if valid_596277 != nil:
    section.add "quotaUser", valid_596277
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_596278 = query.getOrDefault("id")
  valid_596278 = validateParameter(valid_596278, JString, required = true,
                                 default = nil)
  if valid_596278 != nil:
    section.add "id", valid_596278
  var valid_596279 = query.getOrDefault("alt")
  valid_596279 = validateParameter(valid_596279, JString, required = false,
                                 default = newJString("json"))
  if valid_596279 != nil:
    section.add "alt", valid_596279
  var valid_596280 = query.getOrDefault("oauth_token")
  valid_596280 = validateParameter(valid_596280, JString, required = false,
                                 default = nil)
  if valid_596280 != nil:
    section.add "oauth_token", valid_596280
  var valid_596281 = query.getOrDefault("userIp")
  valid_596281 = validateParameter(valid_596281, JString, required = false,
                                 default = nil)
  if valid_596281 != nil:
    section.add "userIp", valid_596281
  var valid_596282 = query.getOrDefault("key")
  valid_596282 = validateParameter(valid_596282, JString, required = false,
                                 default = nil)
  if valid_596282 != nil:
    section.add "key", valid_596282
  var valid_596283 = query.getOrDefault("prettyPrint")
  valid_596283 = validateParameter(valid_596283, JBool, required = false,
                                 default = newJBool(true))
  if valid_596283 != nil:
    section.add "prettyPrint", valid_596283
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596285: Call_DfareportingPlacementGroupsPatch_596272;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement group. This method supports patch semantics.
  ## 
  let valid = call_596285.validator(path, query, header, formData, body)
  let scheme = call_596285.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596285.url(scheme.get, call_596285.host, call_596285.base,
                         call_596285.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596285, url, valid)

proc call*(call_596286: Call_DfareportingPlacementGroupsPatch_596272;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementGroupsPatch
  ## Updates an existing placement group. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Placement group ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596287 = newJObject()
  var query_596288 = newJObject()
  var body_596289 = newJObject()
  add(path_596287, "profileId", newJString(profileId))
  add(query_596288, "fields", newJString(fields))
  add(query_596288, "quotaUser", newJString(quotaUser))
  add(query_596288, "id", newJString(id))
  add(query_596288, "alt", newJString(alt))
  add(query_596288, "oauth_token", newJString(oauthToken))
  add(query_596288, "userIp", newJString(userIp))
  add(query_596288, "key", newJString(key))
  if body != nil:
    body_596289 = body
  add(query_596288, "prettyPrint", newJBool(prettyPrint))
  result = call_596286.call(path_596287, query_596288, nil, nil, body_596289)

var dfareportingPlacementGroupsPatch* = Call_DfareportingPlacementGroupsPatch_596272(
    name: "dfareportingPlacementGroupsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups",
    validator: validate_DfareportingPlacementGroupsPatch_596273,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsPatch_596274,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementGroupsGet_596290 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementGroupsGet_596292(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementGroupsGet_596291(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one placement group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596293 = path.getOrDefault("profileId")
  valid_596293 = validateParameter(valid_596293, JString, required = true,
                                 default = nil)
  if valid_596293 != nil:
    section.add "profileId", valid_596293
  var valid_596294 = path.getOrDefault("id")
  valid_596294 = validateParameter(valid_596294, JString, required = true,
                                 default = nil)
  if valid_596294 != nil:
    section.add "id", valid_596294
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596295 = query.getOrDefault("fields")
  valid_596295 = validateParameter(valid_596295, JString, required = false,
                                 default = nil)
  if valid_596295 != nil:
    section.add "fields", valid_596295
  var valid_596296 = query.getOrDefault("quotaUser")
  valid_596296 = validateParameter(valid_596296, JString, required = false,
                                 default = nil)
  if valid_596296 != nil:
    section.add "quotaUser", valid_596296
  var valid_596297 = query.getOrDefault("alt")
  valid_596297 = validateParameter(valid_596297, JString, required = false,
                                 default = newJString("json"))
  if valid_596297 != nil:
    section.add "alt", valid_596297
  var valid_596298 = query.getOrDefault("oauth_token")
  valid_596298 = validateParameter(valid_596298, JString, required = false,
                                 default = nil)
  if valid_596298 != nil:
    section.add "oauth_token", valid_596298
  var valid_596299 = query.getOrDefault("userIp")
  valid_596299 = validateParameter(valid_596299, JString, required = false,
                                 default = nil)
  if valid_596299 != nil:
    section.add "userIp", valid_596299
  var valid_596300 = query.getOrDefault("key")
  valid_596300 = validateParameter(valid_596300, JString, required = false,
                                 default = nil)
  if valid_596300 != nil:
    section.add "key", valid_596300
  var valid_596301 = query.getOrDefault("prettyPrint")
  valid_596301 = validateParameter(valid_596301, JBool, required = false,
                                 default = newJBool(true))
  if valid_596301 != nil:
    section.add "prettyPrint", valid_596301
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596302: Call_DfareportingPlacementGroupsGet_596290; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one placement group by ID.
  ## 
  let valid = call_596302.validator(path, query, header, formData, body)
  let scheme = call_596302.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596302.url(scheme.get, call_596302.host, call_596302.base,
                         call_596302.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596302, url, valid)

proc call*(call_596303: Call_DfareportingPlacementGroupsGet_596290;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementGroupsGet
  ## Gets one placement group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Placement group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596304 = newJObject()
  var query_596305 = newJObject()
  add(path_596304, "profileId", newJString(profileId))
  add(query_596305, "fields", newJString(fields))
  add(query_596305, "quotaUser", newJString(quotaUser))
  add(query_596305, "alt", newJString(alt))
  add(query_596305, "oauth_token", newJString(oauthToken))
  add(query_596305, "userIp", newJString(userIp))
  add(path_596304, "id", newJString(id))
  add(query_596305, "key", newJString(key))
  add(query_596305, "prettyPrint", newJBool(prettyPrint))
  result = call_596303.call(path_596304, query_596305, nil, nil, nil)

var dfareportingPlacementGroupsGet* = Call_DfareportingPlacementGroupsGet_596290(
    name: "dfareportingPlacementGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementGroups/{id}",
    validator: validate_DfareportingPlacementGroupsGet_596291,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementGroupsGet_596292,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesUpdate_596327 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementStrategiesUpdate_596329(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesUpdate_596328(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement strategy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596330 = path.getOrDefault("profileId")
  valid_596330 = validateParameter(valid_596330, JString, required = true,
                                 default = nil)
  if valid_596330 != nil:
    section.add "profileId", valid_596330
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596331 = query.getOrDefault("fields")
  valid_596331 = validateParameter(valid_596331, JString, required = false,
                                 default = nil)
  if valid_596331 != nil:
    section.add "fields", valid_596331
  var valid_596332 = query.getOrDefault("quotaUser")
  valid_596332 = validateParameter(valid_596332, JString, required = false,
                                 default = nil)
  if valid_596332 != nil:
    section.add "quotaUser", valid_596332
  var valid_596333 = query.getOrDefault("alt")
  valid_596333 = validateParameter(valid_596333, JString, required = false,
                                 default = newJString("json"))
  if valid_596333 != nil:
    section.add "alt", valid_596333
  var valid_596334 = query.getOrDefault("oauth_token")
  valid_596334 = validateParameter(valid_596334, JString, required = false,
                                 default = nil)
  if valid_596334 != nil:
    section.add "oauth_token", valid_596334
  var valid_596335 = query.getOrDefault("userIp")
  valid_596335 = validateParameter(valid_596335, JString, required = false,
                                 default = nil)
  if valid_596335 != nil:
    section.add "userIp", valid_596335
  var valid_596336 = query.getOrDefault("key")
  valid_596336 = validateParameter(valid_596336, JString, required = false,
                                 default = nil)
  if valid_596336 != nil:
    section.add "key", valid_596336
  var valid_596337 = query.getOrDefault("prettyPrint")
  valid_596337 = validateParameter(valid_596337, JBool, required = false,
                                 default = newJBool(true))
  if valid_596337 != nil:
    section.add "prettyPrint", valid_596337
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596339: Call_DfareportingPlacementStrategiesUpdate_596327;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement strategy.
  ## 
  let valid = call_596339.validator(path, query, header, formData, body)
  let scheme = call_596339.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596339.url(scheme.get, call_596339.host, call_596339.base,
                         call_596339.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596339, url, valid)

proc call*(call_596340: Call_DfareportingPlacementStrategiesUpdate_596327;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesUpdate
  ## Updates an existing placement strategy.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596341 = newJObject()
  var query_596342 = newJObject()
  var body_596343 = newJObject()
  add(path_596341, "profileId", newJString(profileId))
  add(query_596342, "fields", newJString(fields))
  add(query_596342, "quotaUser", newJString(quotaUser))
  add(query_596342, "alt", newJString(alt))
  add(query_596342, "oauth_token", newJString(oauthToken))
  add(query_596342, "userIp", newJString(userIp))
  add(query_596342, "key", newJString(key))
  if body != nil:
    body_596343 = body
  add(query_596342, "prettyPrint", newJBool(prettyPrint))
  result = call_596340.call(path_596341, query_596342, nil, nil, body_596343)

var dfareportingPlacementStrategiesUpdate* = Call_DfareportingPlacementStrategiesUpdate_596327(
    name: "dfareportingPlacementStrategiesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesUpdate_596328,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesUpdate_596329,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesInsert_596344 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementStrategiesInsert_596346(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesInsert_596345(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new placement strategy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596347 = path.getOrDefault("profileId")
  valid_596347 = validateParameter(valid_596347, JString, required = true,
                                 default = nil)
  if valid_596347 != nil:
    section.add "profileId", valid_596347
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596348 = query.getOrDefault("fields")
  valid_596348 = validateParameter(valid_596348, JString, required = false,
                                 default = nil)
  if valid_596348 != nil:
    section.add "fields", valid_596348
  var valid_596349 = query.getOrDefault("quotaUser")
  valid_596349 = validateParameter(valid_596349, JString, required = false,
                                 default = nil)
  if valid_596349 != nil:
    section.add "quotaUser", valid_596349
  var valid_596350 = query.getOrDefault("alt")
  valid_596350 = validateParameter(valid_596350, JString, required = false,
                                 default = newJString("json"))
  if valid_596350 != nil:
    section.add "alt", valid_596350
  var valid_596351 = query.getOrDefault("oauth_token")
  valid_596351 = validateParameter(valid_596351, JString, required = false,
                                 default = nil)
  if valid_596351 != nil:
    section.add "oauth_token", valid_596351
  var valid_596352 = query.getOrDefault("userIp")
  valid_596352 = validateParameter(valid_596352, JString, required = false,
                                 default = nil)
  if valid_596352 != nil:
    section.add "userIp", valid_596352
  var valid_596353 = query.getOrDefault("key")
  valid_596353 = validateParameter(valid_596353, JString, required = false,
                                 default = nil)
  if valid_596353 != nil:
    section.add "key", valid_596353
  var valid_596354 = query.getOrDefault("prettyPrint")
  valid_596354 = validateParameter(valid_596354, JBool, required = false,
                                 default = newJBool(true))
  if valid_596354 != nil:
    section.add "prettyPrint", valid_596354
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596356: Call_DfareportingPlacementStrategiesInsert_596344;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new placement strategy.
  ## 
  let valid = call_596356.validator(path, query, header, formData, body)
  let scheme = call_596356.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596356.url(scheme.get, call_596356.host, call_596356.base,
                         call_596356.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596356, url, valid)

proc call*(call_596357: Call_DfareportingPlacementStrategiesInsert_596344;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesInsert
  ## Inserts a new placement strategy.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596358 = newJObject()
  var query_596359 = newJObject()
  var body_596360 = newJObject()
  add(path_596358, "profileId", newJString(profileId))
  add(query_596359, "fields", newJString(fields))
  add(query_596359, "quotaUser", newJString(quotaUser))
  add(query_596359, "alt", newJString(alt))
  add(query_596359, "oauth_token", newJString(oauthToken))
  add(query_596359, "userIp", newJString(userIp))
  add(query_596359, "key", newJString(key))
  if body != nil:
    body_596360 = body
  add(query_596359, "prettyPrint", newJBool(prettyPrint))
  result = call_596357.call(path_596358, query_596359, nil, nil, body_596360)

var dfareportingPlacementStrategiesInsert* = Call_DfareportingPlacementStrategiesInsert_596344(
    name: "dfareportingPlacementStrategiesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesInsert_596345,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesInsert_596346,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesList_596306 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementStrategiesList_596308(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesList_596307(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of placement strategies, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596309 = path.getOrDefault("profileId")
  valid_596309 = validateParameter(valid_596309, JString, required = true,
                                 default = nil)
  if valid_596309 != nil:
    section.add "profileId", valid_596309
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "placementstrategy*2015" will return objects with names like "placementstrategy June 2015", "placementstrategy April 2015", or simply "placementstrategy 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementstrategy" will match objects with name "my placementstrategy", "placementstrategy 2015", or simply "placementstrategy".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placement strategies with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596310 = query.getOrDefault("fields")
  valid_596310 = validateParameter(valid_596310, JString, required = false,
                                 default = nil)
  if valid_596310 != nil:
    section.add "fields", valid_596310
  var valid_596311 = query.getOrDefault("pageToken")
  valid_596311 = validateParameter(valid_596311, JString, required = false,
                                 default = nil)
  if valid_596311 != nil:
    section.add "pageToken", valid_596311
  var valid_596312 = query.getOrDefault("quotaUser")
  valid_596312 = validateParameter(valid_596312, JString, required = false,
                                 default = nil)
  if valid_596312 != nil:
    section.add "quotaUser", valid_596312
  var valid_596313 = query.getOrDefault("sortField")
  valid_596313 = validateParameter(valid_596313, JString, required = false,
                                 default = newJString("ID"))
  if valid_596313 != nil:
    section.add "sortField", valid_596313
  var valid_596314 = query.getOrDefault("alt")
  valid_596314 = validateParameter(valid_596314, JString, required = false,
                                 default = newJString("json"))
  if valid_596314 != nil:
    section.add "alt", valid_596314
  var valid_596315 = query.getOrDefault("searchString")
  valid_596315 = validateParameter(valid_596315, JString, required = false,
                                 default = nil)
  if valid_596315 != nil:
    section.add "searchString", valid_596315
  var valid_596316 = query.getOrDefault("oauth_token")
  valid_596316 = validateParameter(valid_596316, JString, required = false,
                                 default = nil)
  if valid_596316 != nil:
    section.add "oauth_token", valid_596316
  var valid_596317 = query.getOrDefault("userIp")
  valid_596317 = validateParameter(valid_596317, JString, required = false,
                                 default = nil)
  if valid_596317 != nil:
    section.add "userIp", valid_596317
  var valid_596318 = query.getOrDefault("maxResults")
  valid_596318 = validateParameter(valid_596318, JInt, required = false,
                                 default = newJInt(1000))
  if valid_596318 != nil:
    section.add "maxResults", valid_596318
  var valid_596319 = query.getOrDefault("ids")
  valid_596319 = validateParameter(valid_596319, JArray, required = false,
                                 default = nil)
  if valid_596319 != nil:
    section.add "ids", valid_596319
  var valid_596320 = query.getOrDefault("key")
  valid_596320 = validateParameter(valid_596320, JString, required = false,
                                 default = nil)
  if valid_596320 != nil:
    section.add "key", valid_596320
  var valid_596321 = query.getOrDefault("sortOrder")
  valid_596321 = validateParameter(valid_596321, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_596321 != nil:
    section.add "sortOrder", valid_596321
  var valid_596322 = query.getOrDefault("prettyPrint")
  valid_596322 = validateParameter(valid_596322, JBool, required = false,
                                 default = newJBool(true))
  if valid_596322 != nil:
    section.add "prettyPrint", valid_596322
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596323: Call_DfareportingPlacementStrategiesList_596306;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of placement strategies, possibly filtered. This method supports paging.
  ## 
  let valid = call_596323.validator(path, query, header, formData, body)
  let scheme = call_596323.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596323.url(scheme.get, call_596323.host, call_596323.base,
                         call_596323.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596323, url, valid)

proc call*(call_596324: Call_DfareportingPlacementStrategiesList_596306;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesList
  ## Retrieves a list of placement strategies, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "placementstrategy*2015" will return objects with names like "placementstrategy June 2015", "placementstrategy April 2015", or simply "placementstrategy 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placementstrategy" will match objects with name "my placementstrategy", "placementstrategy 2015", or simply "placementstrategy".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placement strategies with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596325 = newJObject()
  var query_596326 = newJObject()
  add(path_596325, "profileId", newJString(profileId))
  add(query_596326, "fields", newJString(fields))
  add(query_596326, "pageToken", newJString(pageToken))
  add(query_596326, "quotaUser", newJString(quotaUser))
  add(query_596326, "sortField", newJString(sortField))
  add(query_596326, "alt", newJString(alt))
  add(query_596326, "searchString", newJString(searchString))
  add(query_596326, "oauth_token", newJString(oauthToken))
  add(query_596326, "userIp", newJString(userIp))
  add(query_596326, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_596326.add "ids", ids
  add(query_596326, "key", newJString(key))
  add(query_596326, "sortOrder", newJString(sortOrder))
  add(query_596326, "prettyPrint", newJBool(prettyPrint))
  result = call_596324.call(path_596325, query_596326, nil, nil, nil)

var dfareportingPlacementStrategiesList* = Call_DfareportingPlacementStrategiesList_596306(
    name: "dfareportingPlacementStrategiesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesList_596307,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesList_596308,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesPatch_596361 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementStrategiesPatch_596363(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesPatch_596362(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement strategy. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596364 = path.getOrDefault("profileId")
  valid_596364 = validateParameter(valid_596364, JString, required = true,
                                 default = nil)
  if valid_596364 != nil:
    section.add "profileId", valid_596364
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Placement strategy ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596365 = query.getOrDefault("fields")
  valid_596365 = validateParameter(valid_596365, JString, required = false,
                                 default = nil)
  if valid_596365 != nil:
    section.add "fields", valid_596365
  var valid_596366 = query.getOrDefault("quotaUser")
  valid_596366 = validateParameter(valid_596366, JString, required = false,
                                 default = nil)
  if valid_596366 != nil:
    section.add "quotaUser", valid_596366
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_596367 = query.getOrDefault("id")
  valid_596367 = validateParameter(valid_596367, JString, required = true,
                                 default = nil)
  if valid_596367 != nil:
    section.add "id", valid_596367
  var valid_596368 = query.getOrDefault("alt")
  valid_596368 = validateParameter(valid_596368, JString, required = false,
                                 default = newJString("json"))
  if valid_596368 != nil:
    section.add "alt", valid_596368
  var valid_596369 = query.getOrDefault("oauth_token")
  valid_596369 = validateParameter(valid_596369, JString, required = false,
                                 default = nil)
  if valid_596369 != nil:
    section.add "oauth_token", valid_596369
  var valid_596370 = query.getOrDefault("userIp")
  valid_596370 = validateParameter(valid_596370, JString, required = false,
                                 default = nil)
  if valid_596370 != nil:
    section.add "userIp", valid_596370
  var valid_596371 = query.getOrDefault("key")
  valid_596371 = validateParameter(valid_596371, JString, required = false,
                                 default = nil)
  if valid_596371 != nil:
    section.add "key", valid_596371
  var valid_596372 = query.getOrDefault("prettyPrint")
  valid_596372 = validateParameter(valid_596372, JBool, required = false,
                                 default = newJBool(true))
  if valid_596372 != nil:
    section.add "prettyPrint", valid_596372
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596374: Call_DfareportingPlacementStrategiesPatch_596361;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing placement strategy. This method supports patch semantics.
  ## 
  let valid = call_596374.validator(path, query, header, formData, body)
  let scheme = call_596374.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596374.url(scheme.get, call_596374.host, call_596374.base,
                         call_596374.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596374, url, valid)

proc call*(call_596375: Call_DfareportingPlacementStrategiesPatch_596361;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesPatch
  ## Updates an existing placement strategy. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Placement strategy ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596376 = newJObject()
  var query_596377 = newJObject()
  var body_596378 = newJObject()
  add(path_596376, "profileId", newJString(profileId))
  add(query_596377, "fields", newJString(fields))
  add(query_596377, "quotaUser", newJString(quotaUser))
  add(query_596377, "id", newJString(id))
  add(query_596377, "alt", newJString(alt))
  add(query_596377, "oauth_token", newJString(oauthToken))
  add(query_596377, "userIp", newJString(userIp))
  add(query_596377, "key", newJString(key))
  if body != nil:
    body_596378 = body
  add(query_596377, "prettyPrint", newJBool(prettyPrint))
  result = call_596375.call(path_596376, query_596377, nil, nil, body_596378)

var dfareportingPlacementStrategiesPatch* = Call_DfareportingPlacementStrategiesPatch_596361(
    name: "dfareportingPlacementStrategiesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies",
    validator: validate_DfareportingPlacementStrategiesPatch_596362,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesPatch_596363,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesGet_596379 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementStrategiesGet_596381(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesGet_596380(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one placement strategy by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement strategy ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596382 = path.getOrDefault("profileId")
  valid_596382 = validateParameter(valid_596382, JString, required = true,
                                 default = nil)
  if valid_596382 != nil:
    section.add "profileId", valid_596382
  var valid_596383 = path.getOrDefault("id")
  valid_596383 = validateParameter(valid_596383, JString, required = true,
                                 default = nil)
  if valid_596383 != nil:
    section.add "id", valid_596383
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596384 = query.getOrDefault("fields")
  valid_596384 = validateParameter(valid_596384, JString, required = false,
                                 default = nil)
  if valid_596384 != nil:
    section.add "fields", valid_596384
  var valid_596385 = query.getOrDefault("quotaUser")
  valid_596385 = validateParameter(valid_596385, JString, required = false,
                                 default = nil)
  if valid_596385 != nil:
    section.add "quotaUser", valid_596385
  var valid_596386 = query.getOrDefault("alt")
  valid_596386 = validateParameter(valid_596386, JString, required = false,
                                 default = newJString("json"))
  if valid_596386 != nil:
    section.add "alt", valid_596386
  var valid_596387 = query.getOrDefault("oauth_token")
  valid_596387 = validateParameter(valid_596387, JString, required = false,
                                 default = nil)
  if valid_596387 != nil:
    section.add "oauth_token", valid_596387
  var valid_596388 = query.getOrDefault("userIp")
  valid_596388 = validateParameter(valid_596388, JString, required = false,
                                 default = nil)
  if valid_596388 != nil:
    section.add "userIp", valid_596388
  var valid_596389 = query.getOrDefault("key")
  valid_596389 = validateParameter(valid_596389, JString, required = false,
                                 default = nil)
  if valid_596389 != nil:
    section.add "key", valid_596389
  var valid_596390 = query.getOrDefault("prettyPrint")
  valid_596390 = validateParameter(valid_596390, JBool, required = false,
                                 default = newJBool(true))
  if valid_596390 != nil:
    section.add "prettyPrint", valid_596390
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596391: Call_DfareportingPlacementStrategiesGet_596379;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one placement strategy by ID.
  ## 
  let valid = call_596391.validator(path, query, header, formData, body)
  let scheme = call_596391.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596391.url(scheme.get, call_596391.host, call_596391.base,
                         call_596391.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596391, url, valid)

proc call*(call_596392: Call_DfareportingPlacementStrategiesGet_596379;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesGet
  ## Gets one placement strategy by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Placement strategy ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596393 = newJObject()
  var query_596394 = newJObject()
  add(path_596393, "profileId", newJString(profileId))
  add(query_596394, "fields", newJString(fields))
  add(query_596394, "quotaUser", newJString(quotaUser))
  add(query_596394, "alt", newJString(alt))
  add(query_596394, "oauth_token", newJString(oauthToken))
  add(query_596394, "userIp", newJString(userIp))
  add(path_596393, "id", newJString(id))
  add(query_596394, "key", newJString(key))
  add(query_596394, "prettyPrint", newJBool(prettyPrint))
  result = call_596392.call(path_596393, query_596394, nil, nil, nil)

var dfareportingPlacementStrategiesGet* = Call_DfareportingPlacementStrategiesGet_596379(
    name: "dfareportingPlacementStrategiesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies/{id}",
    validator: validate_DfareportingPlacementStrategiesGet_596380,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesGet_596381,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementStrategiesDelete_596395 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementStrategiesDelete_596397(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placementStrategies/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementStrategiesDelete_596396(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing placement strategy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement strategy ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596398 = path.getOrDefault("profileId")
  valid_596398 = validateParameter(valid_596398, JString, required = true,
                                 default = nil)
  if valid_596398 != nil:
    section.add "profileId", valid_596398
  var valid_596399 = path.getOrDefault("id")
  valid_596399 = validateParameter(valid_596399, JString, required = true,
                                 default = nil)
  if valid_596399 != nil:
    section.add "id", valid_596399
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596400 = query.getOrDefault("fields")
  valid_596400 = validateParameter(valid_596400, JString, required = false,
                                 default = nil)
  if valid_596400 != nil:
    section.add "fields", valid_596400
  var valid_596401 = query.getOrDefault("quotaUser")
  valid_596401 = validateParameter(valid_596401, JString, required = false,
                                 default = nil)
  if valid_596401 != nil:
    section.add "quotaUser", valid_596401
  var valid_596402 = query.getOrDefault("alt")
  valid_596402 = validateParameter(valid_596402, JString, required = false,
                                 default = newJString("json"))
  if valid_596402 != nil:
    section.add "alt", valid_596402
  var valid_596403 = query.getOrDefault("oauth_token")
  valid_596403 = validateParameter(valid_596403, JString, required = false,
                                 default = nil)
  if valid_596403 != nil:
    section.add "oauth_token", valid_596403
  var valid_596404 = query.getOrDefault("userIp")
  valid_596404 = validateParameter(valid_596404, JString, required = false,
                                 default = nil)
  if valid_596404 != nil:
    section.add "userIp", valid_596404
  var valid_596405 = query.getOrDefault("key")
  valid_596405 = validateParameter(valid_596405, JString, required = false,
                                 default = nil)
  if valid_596405 != nil:
    section.add "key", valid_596405
  var valid_596406 = query.getOrDefault("prettyPrint")
  valid_596406 = validateParameter(valid_596406, JBool, required = false,
                                 default = newJBool(true))
  if valid_596406 != nil:
    section.add "prettyPrint", valid_596406
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596407: Call_DfareportingPlacementStrategiesDelete_596395;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes an existing placement strategy.
  ## 
  let valid = call_596407.validator(path, query, header, formData, body)
  let scheme = call_596407.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596407.url(scheme.get, call_596407.host, call_596407.base,
                         call_596407.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596407, url, valid)

proc call*(call_596408: Call_DfareportingPlacementStrategiesDelete_596395;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementStrategiesDelete
  ## Deletes an existing placement strategy.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Placement strategy ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596409 = newJObject()
  var query_596410 = newJObject()
  add(path_596409, "profileId", newJString(profileId))
  add(query_596410, "fields", newJString(fields))
  add(query_596410, "quotaUser", newJString(quotaUser))
  add(query_596410, "alt", newJString(alt))
  add(query_596410, "oauth_token", newJString(oauthToken))
  add(query_596410, "userIp", newJString(userIp))
  add(path_596409, "id", newJString(id))
  add(query_596410, "key", newJString(key))
  add(query_596410, "prettyPrint", newJBool(prettyPrint))
  result = call_596408.call(path_596409, query_596410, nil, nil, nil)

var dfareportingPlacementStrategiesDelete* = Call_DfareportingPlacementStrategiesDelete_596395(
    name: "dfareportingPlacementStrategiesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placementStrategies/{id}",
    validator: validate_DfareportingPlacementStrategiesDelete_596396,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementStrategiesDelete_596397,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsUpdate_596448 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementsUpdate_596450(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsUpdate_596449(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596451 = path.getOrDefault("profileId")
  valid_596451 = validateParameter(valid_596451, JString, required = true,
                                 default = nil)
  if valid_596451 != nil:
    section.add "profileId", valid_596451
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596452 = query.getOrDefault("fields")
  valid_596452 = validateParameter(valid_596452, JString, required = false,
                                 default = nil)
  if valid_596452 != nil:
    section.add "fields", valid_596452
  var valid_596453 = query.getOrDefault("quotaUser")
  valid_596453 = validateParameter(valid_596453, JString, required = false,
                                 default = nil)
  if valid_596453 != nil:
    section.add "quotaUser", valid_596453
  var valid_596454 = query.getOrDefault("alt")
  valid_596454 = validateParameter(valid_596454, JString, required = false,
                                 default = newJString("json"))
  if valid_596454 != nil:
    section.add "alt", valid_596454
  var valid_596455 = query.getOrDefault("oauth_token")
  valid_596455 = validateParameter(valid_596455, JString, required = false,
                                 default = nil)
  if valid_596455 != nil:
    section.add "oauth_token", valid_596455
  var valid_596456 = query.getOrDefault("userIp")
  valid_596456 = validateParameter(valid_596456, JString, required = false,
                                 default = nil)
  if valid_596456 != nil:
    section.add "userIp", valid_596456
  var valid_596457 = query.getOrDefault("key")
  valid_596457 = validateParameter(valid_596457, JString, required = false,
                                 default = nil)
  if valid_596457 != nil:
    section.add "key", valid_596457
  var valid_596458 = query.getOrDefault("prettyPrint")
  valid_596458 = validateParameter(valid_596458, JBool, required = false,
                                 default = newJBool(true))
  if valid_596458 != nil:
    section.add "prettyPrint", valid_596458
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596460: Call_DfareportingPlacementsUpdate_596448; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing placement.
  ## 
  let valid = call_596460.validator(path, query, header, formData, body)
  let scheme = call_596460.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596460.url(scheme.get, call_596460.host, call_596460.base,
                         call_596460.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596460, url, valid)

proc call*(call_596461: Call_DfareportingPlacementsUpdate_596448;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementsUpdate
  ## Updates an existing placement.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596462 = newJObject()
  var query_596463 = newJObject()
  var body_596464 = newJObject()
  add(path_596462, "profileId", newJString(profileId))
  add(query_596463, "fields", newJString(fields))
  add(query_596463, "quotaUser", newJString(quotaUser))
  add(query_596463, "alt", newJString(alt))
  add(query_596463, "oauth_token", newJString(oauthToken))
  add(query_596463, "userIp", newJString(userIp))
  add(query_596463, "key", newJString(key))
  if body != nil:
    body_596464 = body
  add(query_596463, "prettyPrint", newJBool(prettyPrint))
  result = call_596461.call(path_596462, query_596463, nil, nil, body_596464)

var dfareportingPlacementsUpdate* = Call_DfareportingPlacementsUpdate_596448(
    name: "dfareportingPlacementsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsUpdate_596449,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsUpdate_596450,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsInsert_596465 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementsInsert_596467(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsInsert_596466(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596468 = path.getOrDefault("profileId")
  valid_596468 = validateParameter(valid_596468, JString, required = true,
                                 default = nil)
  if valid_596468 != nil:
    section.add "profileId", valid_596468
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596469 = query.getOrDefault("fields")
  valid_596469 = validateParameter(valid_596469, JString, required = false,
                                 default = nil)
  if valid_596469 != nil:
    section.add "fields", valid_596469
  var valid_596470 = query.getOrDefault("quotaUser")
  valid_596470 = validateParameter(valid_596470, JString, required = false,
                                 default = nil)
  if valid_596470 != nil:
    section.add "quotaUser", valid_596470
  var valid_596471 = query.getOrDefault("alt")
  valid_596471 = validateParameter(valid_596471, JString, required = false,
                                 default = newJString("json"))
  if valid_596471 != nil:
    section.add "alt", valid_596471
  var valid_596472 = query.getOrDefault("oauth_token")
  valid_596472 = validateParameter(valid_596472, JString, required = false,
                                 default = nil)
  if valid_596472 != nil:
    section.add "oauth_token", valid_596472
  var valid_596473 = query.getOrDefault("userIp")
  valid_596473 = validateParameter(valid_596473, JString, required = false,
                                 default = nil)
  if valid_596473 != nil:
    section.add "userIp", valid_596473
  var valid_596474 = query.getOrDefault("key")
  valid_596474 = validateParameter(valid_596474, JString, required = false,
                                 default = nil)
  if valid_596474 != nil:
    section.add "key", valid_596474
  var valid_596475 = query.getOrDefault("prettyPrint")
  valid_596475 = validateParameter(valid_596475, JBool, required = false,
                                 default = newJBool(true))
  if valid_596475 != nil:
    section.add "prettyPrint", valid_596475
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596477: Call_DfareportingPlacementsInsert_596465; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new placement.
  ## 
  let valid = call_596477.validator(path, query, header, formData, body)
  let scheme = call_596477.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596477.url(scheme.get, call_596477.host, call_596477.base,
                         call_596477.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596477, url, valid)

proc call*(call_596478: Call_DfareportingPlacementsInsert_596465;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementsInsert
  ## Inserts a new placement.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596479 = newJObject()
  var query_596480 = newJObject()
  var body_596481 = newJObject()
  add(path_596479, "profileId", newJString(profileId))
  add(query_596480, "fields", newJString(fields))
  add(query_596480, "quotaUser", newJString(quotaUser))
  add(query_596480, "alt", newJString(alt))
  add(query_596480, "oauth_token", newJString(oauthToken))
  add(query_596480, "userIp", newJString(userIp))
  add(query_596480, "key", newJString(key))
  if body != nil:
    body_596481 = body
  add(query_596480, "prettyPrint", newJBool(prettyPrint))
  result = call_596478.call(path_596479, query_596480, nil, nil, body_596481)

var dfareportingPlacementsInsert* = Call_DfareportingPlacementsInsert_596465(
    name: "dfareportingPlacementsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsInsert_596466,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsInsert_596467,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsList_596411 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementsList_596413(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsList_596412(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of placements, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596414 = path.getOrDefault("profileId")
  valid_596414 = validateParameter(valid_596414, JString, required = true,
                                 default = nil)
  if valid_596414 != nil:
    section.add "profileId", valid_596414
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placements that are associated with these content categories.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for placements by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placements with names like "placement June 2015", "placement May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placement" will match placements with name "my placement", "placement 2015", or simply "placement".
  ##   minEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   sizeIds: JArray
  ##          : Select only placements that are associated with these sizes.
  ##   siteIds: JArray
  ##          : Select only placements that are associated with these sites.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   maxStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   campaignIds: JArray
  ##              : Select only placements that belong to these campaigns.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: JBool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   maxEndDate: JString
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placements with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only placements that belong to these advertisers.
  ##   minStartDate: JString
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   paymentSource: JString
  ##                : Select only placements with this payment source.
  ##   compatibilities: JArray
  ##                  : Select only placements that are associated with these compatibilities. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering in in-stream video ads developed with the VAST standard.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only placements that are associated with these directory sites.
  ##   groupIds: JArray
  ##           : Select only placements that belong to these placement groups.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   placementStrategyIds: JArray
  ##                       : Select only placements that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placements with these pricing types.
  section = newJObject()
  var valid_596415 = query.getOrDefault("fields")
  valid_596415 = validateParameter(valid_596415, JString, required = false,
                                 default = nil)
  if valid_596415 != nil:
    section.add "fields", valid_596415
  var valid_596416 = query.getOrDefault("pageToken")
  valid_596416 = validateParameter(valid_596416, JString, required = false,
                                 default = nil)
  if valid_596416 != nil:
    section.add "pageToken", valid_596416
  var valid_596417 = query.getOrDefault("quotaUser")
  valid_596417 = validateParameter(valid_596417, JString, required = false,
                                 default = nil)
  if valid_596417 != nil:
    section.add "quotaUser", valid_596417
  var valid_596418 = query.getOrDefault("sortField")
  valid_596418 = validateParameter(valid_596418, JString, required = false,
                                 default = newJString("ID"))
  if valid_596418 != nil:
    section.add "sortField", valid_596418
  var valid_596419 = query.getOrDefault("contentCategoryIds")
  valid_596419 = validateParameter(valid_596419, JArray, required = false,
                                 default = nil)
  if valid_596419 != nil:
    section.add "contentCategoryIds", valid_596419
  var valid_596420 = query.getOrDefault("alt")
  valid_596420 = validateParameter(valid_596420, JString, required = false,
                                 default = newJString("json"))
  if valid_596420 != nil:
    section.add "alt", valid_596420
  var valid_596421 = query.getOrDefault("searchString")
  valid_596421 = validateParameter(valid_596421, JString, required = false,
                                 default = nil)
  if valid_596421 != nil:
    section.add "searchString", valid_596421
  var valid_596422 = query.getOrDefault("minEndDate")
  valid_596422 = validateParameter(valid_596422, JString, required = false,
                                 default = nil)
  if valid_596422 != nil:
    section.add "minEndDate", valid_596422
  var valid_596423 = query.getOrDefault("sizeIds")
  valid_596423 = validateParameter(valid_596423, JArray, required = false,
                                 default = nil)
  if valid_596423 != nil:
    section.add "sizeIds", valid_596423
  var valid_596424 = query.getOrDefault("siteIds")
  valid_596424 = validateParameter(valid_596424, JArray, required = false,
                                 default = nil)
  if valid_596424 != nil:
    section.add "siteIds", valid_596424
  var valid_596425 = query.getOrDefault("oauth_token")
  valid_596425 = validateParameter(valid_596425, JString, required = false,
                                 default = nil)
  if valid_596425 != nil:
    section.add "oauth_token", valid_596425
  var valid_596426 = query.getOrDefault("maxStartDate")
  valid_596426 = validateParameter(valid_596426, JString, required = false,
                                 default = nil)
  if valid_596426 != nil:
    section.add "maxStartDate", valid_596426
  var valid_596427 = query.getOrDefault("campaignIds")
  valid_596427 = validateParameter(valid_596427, JArray, required = false,
                                 default = nil)
  if valid_596427 != nil:
    section.add "campaignIds", valid_596427
  var valid_596428 = query.getOrDefault("userIp")
  valid_596428 = validateParameter(valid_596428, JString, required = false,
                                 default = nil)
  if valid_596428 != nil:
    section.add "userIp", valid_596428
  var valid_596429 = query.getOrDefault("archived")
  valid_596429 = validateParameter(valid_596429, JBool, required = false, default = nil)
  if valid_596429 != nil:
    section.add "archived", valid_596429
  var valid_596430 = query.getOrDefault("maxEndDate")
  valid_596430 = validateParameter(valid_596430, JString, required = false,
                                 default = nil)
  if valid_596430 != nil:
    section.add "maxEndDate", valid_596430
  var valid_596431 = query.getOrDefault("maxResults")
  valid_596431 = validateParameter(valid_596431, JInt, required = false,
                                 default = newJInt(1000))
  if valid_596431 != nil:
    section.add "maxResults", valid_596431
  var valid_596432 = query.getOrDefault("ids")
  valid_596432 = validateParameter(valid_596432, JArray, required = false,
                                 default = nil)
  if valid_596432 != nil:
    section.add "ids", valid_596432
  var valid_596433 = query.getOrDefault("key")
  valid_596433 = validateParameter(valid_596433, JString, required = false,
                                 default = nil)
  if valid_596433 != nil:
    section.add "key", valid_596433
  var valid_596434 = query.getOrDefault("advertiserIds")
  valid_596434 = validateParameter(valid_596434, JArray, required = false,
                                 default = nil)
  if valid_596434 != nil:
    section.add "advertiserIds", valid_596434
  var valid_596435 = query.getOrDefault("minStartDate")
  valid_596435 = validateParameter(valid_596435, JString, required = false,
                                 default = nil)
  if valid_596435 != nil:
    section.add "minStartDate", valid_596435
  var valid_596436 = query.getOrDefault("paymentSource")
  valid_596436 = validateParameter(valid_596436, JString, required = false,
                                 default = newJString("PLACEMENT_AGENCY_PAID"))
  if valid_596436 != nil:
    section.add "paymentSource", valid_596436
  var valid_596437 = query.getOrDefault("compatibilities")
  valid_596437 = validateParameter(valid_596437, JArray, required = false,
                                 default = nil)
  if valid_596437 != nil:
    section.add "compatibilities", valid_596437
  var valid_596438 = query.getOrDefault("sortOrder")
  valid_596438 = validateParameter(valid_596438, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_596438 != nil:
    section.add "sortOrder", valid_596438
  var valid_596439 = query.getOrDefault("directorySiteIds")
  valid_596439 = validateParameter(valid_596439, JArray, required = false,
                                 default = nil)
  if valid_596439 != nil:
    section.add "directorySiteIds", valid_596439
  var valid_596440 = query.getOrDefault("groupIds")
  valid_596440 = validateParameter(valid_596440, JArray, required = false,
                                 default = nil)
  if valid_596440 != nil:
    section.add "groupIds", valid_596440
  var valid_596441 = query.getOrDefault("prettyPrint")
  valid_596441 = validateParameter(valid_596441, JBool, required = false,
                                 default = newJBool(true))
  if valid_596441 != nil:
    section.add "prettyPrint", valid_596441
  var valid_596442 = query.getOrDefault("placementStrategyIds")
  valid_596442 = validateParameter(valid_596442, JArray, required = false,
                                 default = nil)
  if valid_596442 != nil:
    section.add "placementStrategyIds", valid_596442
  var valid_596443 = query.getOrDefault("pricingTypes")
  valid_596443 = validateParameter(valid_596443, JArray, required = false,
                                 default = nil)
  if valid_596443 != nil:
    section.add "pricingTypes", valid_596443
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596444: Call_DfareportingPlacementsList_596411; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of placements, possibly filtered. This method supports paging.
  ## 
  let valid = call_596444.validator(path, query, header, formData, body)
  let scheme = call_596444.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596444.url(scheme.get, call_596444.host, call_596444.base,
                         call_596444.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596444, url, valid)

proc call*(call_596445: Call_DfareportingPlacementsList_596411; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; contentCategoryIds: JsonNode = nil;
          alt: string = "json"; searchString: string = ""; minEndDate: string = "";
          sizeIds: JsonNode = nil; siteIds: JsonNode = nil; oauthToken: string = "";
          maxStartDate: string = ""; campaignIds: JsonNode = nil; userIp: string = "";
          archived: bool = false; maxEndDate: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; advertiserIds: JsonNode = nil;
          minStartDate: string = "";
          paymentSource: string = "PLACEMENT_AGENCY_PAID";
          compatibilities: JsonNode = nil; sortOrder: string = "ASCENDING";
          directorySiteIds: JsonNode = nil; groupIds: JsonNode = nil;
          prettyPrint: bool = true; placementStrategyIds: JsonNode = nil;
          pricingTypes: JsonNode = nil): Recallable =
  ## dfareportingPlacementsList
  ## Retrieves a list of placements, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   contentCategoryIds: JArray
  ##                     : Select only placements that are associated with these content categories.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for placements by name or ID. Wildcards (*) are allowed. For example, "placement*2015" will return placements with names like "placement June 2015", "placement May 2015", or simply "placements 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "placement" will match placements with name "my placement", "placement 2015", or simply "placement".
  ##   minEndDate: string
  ##             : Select only placements or placement groups whose end date is on or after the specified minEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   sizeIds: JArray
  ##          : Select only placements that are associated with these sizes.
  ##   siteIds: JArray
  ##          : Select only placements that are associated with these sites.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   maxStartDate: string
  ##               : Select only placements or placement groups whose start date is on or before the specified maxStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   campaignIds: JArray
  ##              : Select only placements that belong to these campaigns.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   archived: bool
  ##           : Select only archived placements. Don't set this field to select both archived and non-archived placements.
  ##   maxEndDate: string
  ##             : Select only placements or placement groups whose end date is on or before the specified maxEndDate. The date should be formatted as "yyyy-MM-dd".
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only placements with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only placements that belong to these advertisers.
  ##   minStartDate: string
  ##               : Select only placements or placement groups whose start date is on or after the specified minStartDate. The date should be formatted as "yyyy-MM-dd".
  ##   paymentSource: string
  ##                : Select only placements with this payment source.
  ##   compatibilities: JArray
  ##                  : Select only placements that are associated with these compatibilities. DISPLAY and DISPLAY_INTERSTITIAL refer to rendering either on desktop or on mobile devices for regular or interstitial ads respectively. APP and APP_INTERSTITIAL are for rendering in mobile apps. IN_STREAM_VIDEO refers to rendering in in-stream video ads developed with the VAST standard.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   directorySiteIds: JArray
  ##                   : Select only placements that are associated with these directory sites.
  ##   groupIds: JArray
  ##           : Select only placements that belong to these placement groups.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   placementStrategyIds: JArray
  ##                       : Select only placements that are associated with these placement strategies.
  ##   pricingTypes: JArray
  ##               : Select only placements with these pricing types.
  var path_596446 = newJObject()
  var query_596447 = newJObject()
  add(path_596446, "profileId", newJString(profileId))
  add(query_596447, "fields", newJString(fields))
  add(query_596447, "pageToken", newJString(pageToken))
  add(query_596447, "quotaUser", newJString(quotaUser))
  add(query_596447, "sortField", newJString(sortField))
  if contentCategoryIds != nil:
    query_596447.add "contentCategoryIds", contentCategoryIds
  add(query_596447, "alt", newJString(alt))
  add(query_596447, "searchString", newJString(searchString))
  add(query_596447, "minEndDate", newJString(minEndDate))
  if sizeIds != nil:
    query_596447.add "sizeIds", sizeIds
  if siteIds != nil:
    query_596447.add "siteIds", siteIds
  add(query_596447, "oauth_token", newJString(oauthToken))
  add(query_596447, "maxStartDate", newJString(maxStartDate))
  if campaignIds != nil:
    query_596447.add "campaignIds", campaignIds
  add(query_596447, "userIp", newJString(userIp))
  add(query_596447, "archived", newJBool(archived))
  add(query_596447, "maxEndDate", newJString(maxEndDate))
  add(query_596447, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_596447.add "ids", ids
  add(query_596447, "key", newJString(key))
  if advertiserIds != nil:
    query_596447.add "advertiserIds", advertiserIds
  add(query_596447, "minStartDate", newJString(minStartDate))
  add(query_596447, "paymentSource", newJString(paymentSource))
  if compatibilities != nil:
    query_596447.add "compatibilities", compatibilities
  add(query_596447, "sortOrder", newJString(sortOrder))
  if directorySiteIds != nil:
    query_596447.add "directorySiteIds", directorySiteIds
  if groupIds != nil:
    query_596447.add "groupIds", groupIds
  add(query_596447, "prettyPrint", newJBool(prettyPrint))
  if placementStrategyIds != nil:
    query_596447.add "placementStrategyIds", placementStrategyIds
  if pricingTypes != nil:
    query_596447.add "pricingTypes", pricingTypes
  result = call_596445.call(path_596446, query_596447, nil, nil, nil)

var dfareportingPlacementsList* = Call_DfareportingPlacementsList_596411(
    name: "dfareportingPlacementsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsList_596412,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsList_596413,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsPatch_596482 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementsPatch_596484(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsPatch_596483(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing placement. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596485 = path.getOrDefault("profileId")
  valid_596485 = validateParameter(valid_596485, JString, required = true,
                                 default = nil)
  if valid_596485 != nil:
    section.add "profileId", valid_596485
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Placement ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596486 = query.getOrDefault("fields")
  valid_596486 = validateParameter(valid_596486, JString, required = false,
                                 default = nil)
  if valid_596486 != nil:
    section.add "fields", valid_596486
  var valid_596487 = query.getOrDefault("quotaUser")
  valid_596487 = validateParameter(valid_596487, JString, required = false,
                                 default = nil)
  if valid_596487 != nil:
    section.add "quotaUser", valid_596487
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_596488 = query.getOrDefault("id")
  valid_596488 = validateParameter(valid_596488, JString, required = true,
                                 default = nil)
  if valid_596488 != nil:
    section.add "id", valid_596488
  var valid_596489 = query.getOrDefault("alt")
  valid_596489 = validateParameter(valid_596489, JString, required = false,
                                 default = newJString("json"))
  if valid_596489 != nil:
    section.add "alt", valid_596489
  var valid_596490 = query.getOrDefault("oauth_token")
  valid_596490 = validateParameter(valid_596490, JString, required = false,
                                 default = nil)
  if valid_596490 != nil:
    section.add "oauth_token", valid_596490
  var valid_596491 = query.getOrDefault("userIp")
  valid_596491 = validateParameter(valid_596491, JString, required = false,
                                 default = nil)
  if valid_596491 != nil:
    section.add "userIp", valid_596491
  var valid_596492 = query.getOrDefault("key")
  valid_596492 = validateParameter(valid_596492, JString, required = false,
                                 default = nil)
  if valid_596492 != nil:
    section.add "key", valid_596492
  var valid_596493 = query.getOrDefault("prettyPrint")
  valid_596493 = validateParameter(valid_596493, JBool, required = false,
                                 default = newJBool(true))
  if valid_596493 != nil:
    section.add "prettyPrint", valid_596493
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596495: Call_DfareportingPlacementsPatch_596482; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing placement. This method supports patch semantics.
  ## 
  let valid = call_596495.validator(path, query, header, formData, body)
  let scheme = call_596495.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596495.url(scheme.get, call_596495.host, call_596495.base,
                         call_596495.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596495, url, valid)

proc call*(call_596496: Call_DfareportingPlacementsPatch_596482; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementsPatch
  ## Updates an existing placement. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Placement ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596497 = newJObject()
  var query_596498 = newJObject()
  var body_596499 = newJObject()
  add(path_596497, "profileId", newJString(profileId))
  add(query_596498, "fields", newJString(fields))
  add(query_596498, "quotaUser", newJString(quotaUser))
  add(query_596498, "id", newJString(id))
  add(query_596498, "alt", newJString(alt))
  add(query_596498, "oauth_token", newJString(oauthToken))
  add(query_596498, "userIp", newJString(userIp))
  add(query_596498, "key", newJString(key))
  if body != nil:
    body_596499 = body
  add(query_596498, "prettyPrint", newJBool(prettyPrint))
  result = call_596496.call(path_596497, query_596498, nil, nil, body_596499)

var dfareportingPlacementsPatch* = Call_DfareportingPlacementsPatch_596482(
    name: "dfareportingPlacementsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/placements",
    validator: validate_DfareportingPlacementsPatch_596483,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsPatch_596484,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsGeneratetags_596500 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementsGeneratetags_596502(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements/generatetags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsGeneratetags_596501(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Generates tags for a placement.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596503 = path.getOrDefault("profileId")
  valid_596503 = validateParameter(valid_596503, JString, required = true,
                                 default = nil)
  if valid_596503 != nil:
    section.add "profileId", valid_596503
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: JString
  ##             : Generate placements belonging to this campaign. This is a required field.
  ##   tagFormats: JArray
  ##             : Tag formats to generate for these placements.
  ## 
  ## Note: PLACEMENT_TAG_STANDARD can only be generated for 1x1 placements.
  ##   placementIds: JArray
  ##               : Generate tags for these placements.
  section = newJObject()
  var valid_596504 = query.getOrDefault("fields")
  valid_596504 = validateParameter(valid_596504, JString, required = false,
                                 default = nil)
  if valid_596504 != nil:
    section.add "fields", valid_596504
  var valid_596505 = query.getOrDefault("quotaUser")
  valid_596505 = validateParameter(valid_596505, JString, required = false,
                                 default = nil)
  if valid_596505 != nil:
    section.add "quotaUser", valid_596505
  var valid_596506 = query.getOrDefault("alt")
  valid_596506 = validateParameter(valid_596506, JString, required = false,
                                 default = newJString("json"))
  if valid_596506 != nil:
    section.add "alt", valid_596506
  var valid_596507 = query.getOrDefault("oauth_token")
  valid_596507 = validateParameter(valid_596507, JString, required = false,
                                 default = nil)
  if valid_596507 != nil:
    section.add "oauth_token", valid_596507
  var valid_596508 = query.getOrDefault("userIp")
  valid_596508 = validateParameter(valid_596508, JString, required = false,
                                 default = nil)
  if valid_596508 != nil:
    section.add "userIp", valid_596508
  var valid_596509 = query.getOrDefault("key")
  valid_596509 = validateParameter(valid_596509, JString, required = false,
                                 default = nil)
  if valid_596509 != nil:
    section.add "key", valid_596509
  var valid_596510 = query.getOrDefault("prettyPrint")
  valid_596510 = validateParameter(valid_596510, JBool, required = false,
                                 default = newJBool(true))
  if valid_596510 != nil:
    section.add "prettyPrint", valid_596510
  var valid_596511 = query.getOrDefault("campaignId")
  valid_596511 = validateParameter(valid_596511, JString, required = false,
                                 default = nil)
  if valid_596511 != nil:
    section.add "campaignId", valid_596511
  var valid_596512 = query.getOrDefault("tagFormats")
  valid_596512 = validateParameter(valid_596512, JArray, required = false,
                                 default = nil)
  if valid_596512 != nil:
    section.add "tagFormats", valid_596512
  var valid_596513 = query.getOrDefault("placementIds")
  valid_596513 = validateParameter(valid_596513, JArray, required = false,
                                 default = nil)
  if valid_596513 != nil:
    section.add "placementIds", valid_596513
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596514: Call_DfareportingPlacementsGeneratetags_596500;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Generates tags for a placement.
  ## 
  let valid = call_596514.validator(path, query, header, formData, body)
  let scheme = call_596514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596514.url(scheme.get, call_596514.host, call_596514.base,
                         call_596514.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596514, url, valid)

proc call*(call_596515: Call_DfareportingPlacementsGeneratetags_596500;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true; campaignId: string = "";
          tagFormats: JsonNode = nil; placementIds: JsonNode = nil): Recallable =
  ## dfareportingPlacementsGeneratetags
  ## Generates tags for a placement.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  ##   campaignId: string
  ##             : Generate placements belonging to this campaign. This is a required field.
  ##   tagFormats: JArray
  ##             : Tag formats to generate for these placements.
  ## 
  ## Note: PLACEMENT_TAG_STANDARD can only be generated for 1x1 placements.
  ##   placementIds: JArray
  ##               : Generate tags for these placements.
  var path_596516 = newJObject()
  var query_596517 = newJObject()
  add(path_596516, "profileId", newJString(profileId))
  add(query_596517, "fields", newJString(fields))
  add(query_596517, "quotaUser", newJString(quotaUser))
  add(query_596517, "alt", newJString(alt))
  add(query_596517, "oauth_token", newJString(oauthToken))
  add(query_596517, "userIp", newJString(userIp))
  add(query_596517, "key", newJString(key))
  add(query_596517, "prettyPrint", newJBool(prettyPrint))
  add(query_596517, "campaignId", newJString(campaignId))
  if tagFormats != nil:
    query_596517.add "tagFormats", tagFormats
  if placementIds != nil:
    query_596517.add "placementIds", placementIds
  result = call_596515.call(path_596516, query_596517, nil, nil, nil)

var dfareportingPlacementsGeneratetags* = Call_DfareportingPlacementsGeneratetags_596500(
    name: "dfareportingPlacementsGeneratetags", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placements/generatetags",
    validator: validate_DfareportingPlacementsGeneratetags_596501,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsGeneratetags_596502,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlacementsGet_596518 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlacementsGet_596520(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/placements/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlacementsGet_596519(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one placement by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Placement ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596521 = path.getOrDefault("profileId")
  valid_596521 = validateParameter(valid_596521, JString, required = true,
                                 default = nil)
  if valid_596521 != nil:
    section.add "profileId", valid_596521
  var valid_596522 = path.getOrDefault("id")
  valid_596522 = validateParameter(valid_596522, JString, required = true,
                                 default = nil)
  if valid_596522 != nil:
    section.add "id", valid_596522
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596523 = query.getOrDefault("fields")
  valid_596523 = validateParameter(valid_596523, JString, required = false,
                                 default = nil)
  if valid_596523 != nil:
    section.add "fields", valid_596523
  var valid_596524 = query.getOrDefault("quotaUser")
  valid_596524 = validateParameter(valid_596524, JString, required = false,
                                 default = nil)
  if valid_596524 != nil:
    section.add "quotaUser", valid_596524
  var valid_596525 = query.getOrDefault("alt")
  valid_596525 = validateParameter(valid_596525, JString, required = false,
                                 default = newJString("json"))
  if valid_596525 != nil:
    section.add "alt", valid_596525
  var valid_596526 = query.getOrDefault("oauth_token")
  valid_596526 = validateParameter(valid_596526, JString, required = false,
                                 default = nil)
  if valid_596526 != nil:
    section.add "oauth_token", valid_596526
  var valid_596527 = query.getOrDefault("userIp")
  valid_596527 = validateParameter(valid_596527, JString, required = false,
                                 default = nil)
  if valid_596527 != nil:
    section.add "userIp", valid_596527
  var valid_596528 = query.getOrDefault("key")
  valid_596528 = validateParameter(valid_596528, JString, required = false,
                                 default = nil)
  if valid_596528 != nil:
    section.add "key", valid_596528
  var valid_596529 = query.getOrDefault("prettyPrint")
  valid_596529 = validateParameter(valid_596529, JBool, required = false,
                                 default = newJBool(true))
  if valid_596529 != nil:
    section.add "prettyPrint", valid_596529
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596530: Call_DfareportingPlacementsGet_596518; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one placement by ID.
  ## 
  let valid = call_596530.validator(path, query, header, formData, body)
  let scheme = call_596530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596530.url(scheme.get, call_596530.host, call_596530.base,
                         call_596530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596530, url, valid)

proc call*(call_596531: Call_DfareportingPlacementsGet_596518; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingPlacementsGet
  ## Gets one placement by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Placement ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596532 = newJObject()
  var query_596533 = newJObject()
  add(path_596532, "profileId", newJString(profileId))
  add(query_596533, "fields", newJString(fields))
  add(query_596533, "quotaUser", newJString(quotaUser))
  add(query_596533, "alt", newJString(alt))
  add(query_596533, "oauth_token", newJString(oauthToken))
  add(query_596533, "userIp", newJString(userIp))
  add(path_596532, "id", newJString(id))
  add(query_596533, "key", newJString(key))
  add(query_596533, "prettyPrint", newJBool(prettyPrint))
  result = call_596531.call(path_596532, query_596533, nil, nil, nil)

var dfareportingPlacementsGet* = Call_DfareportingPlacementsGet_596518(
    name: "dfareportingPlacementsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/placements/{id}",
    validator: validate_DfareportingPlacementsGet_596519,
    base: "/dfareporting/v2.7", url: url_DfareportingPlacementsGet_596520,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlatformTypesList_596534 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlatformTypesList_596536(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/platformTypes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlatformTypesList_596535(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of platform types.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596537 = path.getOrDefault("profileId")
  valid_596537 = validateParameter(valid_596537, JString, required = true,
                                 default = nil)
  if valid_596537 != nil:
    section.add "profileId", valid_596537
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596538 = query.getOrDefault("fields")
  valid_596538 = validateParameter(valid_596538, JString, required = false,
                                 default = nil)
  if valid_596538 != nil:
    section.add "fields", valid_596538
  var valid_596539 = query.getOrDefault("quotaUser")
  valid_596539 = validateParameter(valid_596539, JString, required = false,
                                 default = nil)
  if valid_596539 != nil:
    section.add "quotaUser", valid_596539
  var valid_596540 = query.getOrDefault("alt")
  valid_596540 = validateParameter(valid_596540, JString, required = false,
                                 default = newJString("json"))
  if valid_596540 != nil:
    section.add "alt", valid_596540
  var valid_596541 = query.getOrDefault("oauth_token")
  valid_596541 = validateParameter(valid_596541, JString, required = false,
                                 default = nil)
  if valid_596541 != nil:
    section.add "oauth_token", valid_596541
  var valid_596542 = query.getOrDefault("userIp")
  valid_596542 = validateParameter(valid_596542, JString, required = false,
                                 default = nil)
  if valid_596542 != nil:
    section.add "userIp", valid_596542
  var valid_596543 = query.getOrDefault("key")
  valid_596543 = validateParameter(valid_596543, JString, required = false,
                                 default = nil)
  if valid_596543 != nil:
    section.add "key", valid_596543
  var valid_596544 = query.getOrDefault("prettyPrint")
  valid_596544 = validateParameter(valid_596544, JBool, required = false,
                                 default = newJBool(true))
  if valid_596544 != nil:
    section.add "prettyPrint", valid_596544
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596545: Call_DfareportingPlatformTypesList_596534; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of platform types.
  ## 
  let valid = call_596545.validator(path, query, header, formData, body)
  let scheme = call_596545.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596545.url(scheme.get, call_596545.host, call_596545.base,
                         call_596545.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596545, url, valid)

proc call*(call_596546: Call_DfareportingPlatformTypesList_596534;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlatformTypesList
  ## Retrieves a list of platform types.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596547 = newJObject()
  var query_596548 = newJObject()
  add(path_596547, "profileId", newJString(profileId))
  add(query_596548, "fields", newJString(fields))
  add(query_596548, "quotaUser", newJString(quotaUser))
  add(query_596548, "alt", newJString(alt))
  add(query_596548, "oauth_token", newJString(oauthToken))
  add(query_596548, "userIp", newJString(userIp))
  add(query_596548, "key", newJString(key))
  add(query_596548, "prettyPrint", newJBool(prettyPrint))
  result = call_596546.call(path_596547, query_596548, nil, nil, nil)

var dfareportingPlatformTypesList* = Call_DfareportingPlatformTypesList_596534(
    name: "dfareportingPlatformTypesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/platformTypes",
    validator: validate_DfareportingPlatformTypesList_596535,
    base: "/dfareporting/v2.7", url: url_DfareportingPlatformTypesList_596536,
    schemes: {Scheme.Https})
type
  Call_DfareportingPlatformTypesGet_596549 = ref object of OpenApiRestCall_593437
proc url_DfareportingPlatformTypesGet_596551(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/platformTypes/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPlatformTypesGet_596550(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one platform type by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Platform type ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596552 = path.getOrDefault("profileId")
  valid_596552 = validateParameter(valid_596552, JString, required = true,
                                 default = nil)
  if valid_596552 != nil:
    section.add "profileId", valid_596552
  var valid_596553 = path.getOrDefault("id")
  valid_596553 = validateParameter(valid_596553, JString, required = true,
                                 default = nil)
  if valid_596553 != nil:
    section.add "id", valid_596553
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596554 = query.getOrDefault("fields")
  valid_596554 = validateParameter(valid_596554, JString, required = false,
                                 default = nil)
  if valid_596554 != nil:
    section.add "fields", valid_596554
  var valid_596555 = query.getOrDefault("quotaUser")
  valid_596555 = validateParameter(valid_596555, JString, required = false,
                                 default = nil)
  if valid_596555 != nil:
    section.add "quotaUser", valid_596555
  var valid_596556 = query.getOrDefault("alt")
  valid_596556 = validateParameter(valid_596556, JString, required = false,
                                 default = newJString("json"))
  if valid_596556 != nil:
    section.add "alt", valid_596556
  var valid_596557 = query.getOrDefault("oauth_token")
  valid_596557 = validateParameter(valid_596557, JString, required = false,
                                 default = nil)
  if valid_596557 != nil:
    section.add "oauth_token", valid_596557
  var valid_596558 = query.getOrDefault("userIp")
  valid_596558 = validateParameter(valid_596558, JString, required = false,
                                 default = nil)
  if valid_596558 != nil:
    section.add "userIp", valid_596558
  var valid_596559 = query.getOrDefault("key")
  valid_596559 = validateParameter(valid_596559, JString, required = false,
                                 default = nil)
  if valid_596559 != nil:
    section.add "key", valid_596559
  var valid_596560 = query.getOrDefault("prettyPrint")
  valid_596560 = validateParameter(valid_596560, JBool, required = false,
                                 default = newJBool(true))
  if valid_596560 != nil:
    section.add "prettyPrint", valid_596560
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596561: Call_DfareportingPlatformTypesGet_596549; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one platform type by ID.
  ## 
  let valid = call_596561.validator(path, query, header, formData, body)
  let scheme = call_596561.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596561.url(scheme.get, call_596561.host, call_596561.base,
                         call_596561.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596561, url, valid)

proc call*(call_596562: Call_DfareportingPlatformTypesGet_596549;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingPlatformTypesGet
  ## Gets one platform type by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Platform type ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596563 = newJObject()
  var query_596564 = newJObject()
  add(path_596563, "profileId", newJString(profileId))
  add(query_596564, "fields", newJString(fields))
  add(query_596564, "quotaUser", newJString(quotaUser))
  add(query_596564, "alt", newJString(alt))
  add(query_596564, "oauth_token", newJString(oauthToken))
  add(query_596564, "userIp", newJString(userIp))
  add(path_596563, "id", newJString(id))
  add(query_596564, "key", newJString(key))
  add(query_596564, "prettyPrint", newJBool(prettyPrint))
  result = call_596562.call(path_596563, query_596564, nil, nil, nil)

var dfareportingPlatformTypesGet* = Call_DfareportingPlatformTypesGet_596549(
    name: "dfareportingPlatformTypesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/platformTypes/{id}",
    validator: validate_DfareportingPlatformTypesGet_596550,
    base: "/dfareporting/v2.7", url: url_DfareportingPlatformTypesGet_596551,
    schemes: {Scheme.Https})
type
  Call_DfareportingPostalCodesList_596565 = ref object of OpenApiRestCall_593437
proc url_DfareportingPostalCodesList_596567(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/postalCodes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPostalCodesList_596566(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of postal codes.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596568 = path.getOrDefault("profileId")
  valid_596568 = validateParameter(valid_596568, JString, required = true,
                                 default = nil)
  if valid_596568 != nil:
    section.add "profileId", valid_596568
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596569 = query.getOrDefault("fields")
  valid_596569 = validateParameter(valid_596569, JString, required = false,
                                 default = nil)
  if valid_596569 != nil:
    section.add "fields", valid_596569
  var valid_596570 = query.getOrDefault("quotaUser")
  valid_596570 = validateParameter(valid_596570, JString, required = false,
                                 default = nil)
  if valid_596570 != nil:
    section.add "quotaUser", valid_596570
  var valid_596571 = query.getOrDefault("alt")
  valid_596571 = validateParameter(valid_596571, JString, required = false,
                                 default = newJString("json"))
  if valid_596571 != nil:
    section.add "alt", valid_596571
  var valid_596572 = query.getOrDefault("oauth_token")
  valid_596572 = validateParameter(valid_596572, JString, required = false,
                                 default = nil)
  if valid_596572 != nil:
    section.add "oauth_token", valid_596572
  var valid_596573 = query.getOrDefault("userIp")
  valid_596573 = validateParameter(valid_596573, JString, required = false,
                                 default = nil)
  if valid_596573 != nil:
    section.add "userIp", valid_596573
  var valid_596574 = query.getOrDefault("key")
  valid_596574 = validateParameter(valid_596574, JString, required = false,
                                 default = nil)
  if valid_596574 != nil:
    section.add "key", valid_596574
  var valid_596575 = query.getOrDefault("prettyPrint")
  valid_596575 = validateParameter(valid_596575, JBool, required = false,
                                 default = newJBool(true))
  if valid_596575 != nil:
    section.add "prettyPrint", valid_596575
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596576: Call_DfareportingPostalCodesList_596565; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of postal codes.
  ## 
  let valid = call_596576.validator(path, query, header, formData, body)
  let scheme = call_596576.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596576.url(scheme.get, call_596576.host, call_596576.base,
                         call_596576.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596576, url, valid)

proc call*(call_596577: Call_DfareportingPostalCodesList_596565; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingPostalCodesList
  ## Retrieves a list of postal codes.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596578 = newJObject()
  var query_596579 = newJObject()
  add(path_596578, "profileId", newJString(profileId))
  add(query_596579, "fields", newJString(fields))
  add(query_596579, "quotaUser", newJString(quotaUser))
  add(query_596579, "alt", newJString(alt))
  add(query_596579, "oauth_token", newJString(oauthToken))
  add(query_596579, "userIp", newJString(userIp))
  add(query_596579, "key", newJString(key))
  add(query_596579, "prettyPrint", newJBool(prettyPrint))
  result = call_596577.call(path_596578, query_596579, nil, nil, nil)

var dfareportingPostalCodesList* = Call_DfareportingPostalCodesList_596565(
    name: "dfareportingPostalCodesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/postalCodes",
    validator: validate_DfareportingPostalCodesList_596566,
    base: "/dfareporting/v2.7", url: url_DfareportingPostalCodesList_596567,
    schemes: {Scheme.Https})
type
  Call_DfareportingPostalCodesGet_596580 = ref object of OpenApiRestCall_593437
proc url_DfareportingPostalCodesGet_596582(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "code" in path, "`code` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/postalCodes/"),
               (kind: VariableSegment, value: "code")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingPostalCodesGet_596581(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one postal code by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   code: JString (required)
  ##       : Postal code ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596583 = path.getOrDefault("profileId")
  valid_596583 = validateParameter(valid_596583, JString, required = true,
                                 default = nil)
  if valid_596583 != nil:
    section.add "profileId", valid_596583
  var valid_596584 = path.getOrDefault("code")
  valid_596584 = validateParameter(valid_596584, JString, required = true,
                                 default = nil)
  if valid_596584 != nil:
    section.add "code", valid_596584
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596585 = query.getOrDefault("fields")
  valid_596585 = validateParameter(valid_596585, JString, required = false,
                                 default = nil)
  if valid_596585 != nil:
    section.add "fields", valid_596585
  var valid_596586 = query.getOrDefault("quotaUser")
  valid_596586 = validateParameter(valid_596586, JString, required = false,
                                 default = nil)
  if valid_596586 != nil:
    section.add "quotaUser", valid_596586
  var valid_596587 = query.getOrDefault("alt")
  valid_596587 = validateParameter(valid_596587, JString, required = false,
                                 default = newJString("json"))
  if valid_596587 != nil:
    section.add "alt", valid_596587
  var valid_596588 = query.getOrDefault("oauth_token")
  valid_596588 = validateParameter(valid_596588, JString, required = false,
                                 default = nil)
  if valid_596588 != nil:
    section.add "oauth_token", valid_596588
  var valid_596589 = query.getOrDefault("userIp")
  valid_596589 = validateParameter(valid_596589, JString, required = false,
                                 default = nil)
  if valid_596589 != nil:
    section.add "userIp", valid_596589
  var valid_596590 = query.getOrDefault("key")
  valid_596590 = validateParameter(valid_596590, JString, required = false,
                                 default = nil)
  if valid_596590 != nil:
    section.add "key", valid_596590
  var valid_596591 = query.getOrDefault("prettyPrint")
  valid_596591 = validateParameter(valid_596591, JBool, required = false,
                                 default = newJBool(true))
  if valid_596591 != nil:
    section.add "prettyPrint", valid_596591
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596592: Call_DfareportingPostalCodesGet_596580; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one postal code by ID.
  ## 
  let valid = call_596592.validator(path, query, header, formData, body)
  let scheme = call_596592.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596592.url(scheme.get, call_596592.host, call_596592.base,
                         call_596592.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596592, url, valid)

proc call*(call_596593: Call_DfareportingPostalCodesGet_596580; profileId: string;
          code: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingPostalCodesGet
  ## Gets one postal code by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   code: string (required)
  ##       : Postal code ID.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596594 = newJObject()
  var query_596595 = newJObject()
  add(path_596594, "profileId", newJString(profileId))
  add(query_596595, "fields", newJString(fields))
  add(query_596595, "quotaUser", newJString(quotaUser))
  add(query_596595, "alt", newJString(alt))
  add(query_596595, "oauth_token", newJString(oauthToken))
  add(query_596595, "userIp", newJString(userIp))
  add(query_596595, "key", newJString(key))
  add(path_596594, "code", newJString(code))
  add(query_596595, "prettyPrint", newJBool(prettyPrint))
  result = call_596593.call(path_596594, query_596595, nil, nil, nil)

var dfareportingPostalCodesGet* = Call_DfareportingPostalCodesGet_596580(
    name: "dfareportingPostalCodesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/postalCodes/{code}",
    validator: validate_DfareportingPostalCodesGet_596581,
    base: "/dfareporting/v2.7", url: url_DfareportingPostalCodesGet_596582,
    schemes: {Scheme.Https})
type
  Call_DfareportingProjectsList_596596 = ref object of OpenApiRestCall_593437
proc url_DfareportingProjectsList_596598(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingProjectsList_596597(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of projects, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596599 = path.getOrDefault("profileId")
  valid_596599 = validateParameter(valid_596599, JString, required = true,
                                 default = nil)
  if valid_596599 != nil:
    section.add "profileId", valid_596599
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for projects by name or ID. Wildcards (*) are allowed. For example, "project*2015" will return projects with names like "project June 2015", "project April 2015", or simply "project 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "project" will match projects with name "my project", "project 2015", or simply "project".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only projects with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only projects with these advertiser IDs.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596600 = query.getOrDefault("fields")
  valid_596600 = validateParameter(valid_596600, JString, required = false,
                                 default = nil)
  if valid_596600 != nil:
    section.add "fields", valid_596600
  var valid_596601 = query.getOrDefault("pageToken")
  valid_596601 = validateParameter(valid_596601, JString, required = false,
                                 default = nil)
  if valid_596601 != nil:
    section.add "pageToken", valid_596601
  var valid_596602 = query.getOrDefault("quotaUser")
  valid_596602 = validateParameter(valid_596602, JString, required = false,
                                 default = nil)
  if valid_596602 != nil:
    section.add "quotaUser", valid_596602
  var valid_596603 = query.getOrDefault("sortField")
  valid_596603 = validateParameter(valid_596603, JString, required = false,
                                 default = newJString("ID"))
  if valid_596603 != nil:
    section.add "sortField", valid_596603
  var valid_596604 = query.getOrDefault("alt")
  valid_596604 = validateParameter(valid_596604, JString, required = false,
                                 default = newJString("json"))
  if valid_596604 != nil:
    section.add "alt", valid_596604
  var valid_596605 = query.getOrDefault("searchString")
  valid_596605 = validateParameter(valid_596605, JString, required = false,
                                 default = nil)
  if valid_596605 != nil:
    section.add "searchString", valid_596605
  var valid_596606 = query.getOrDefault("oauth_token")
  valid_596606 = validateParameter(valid_596606, JString, required = false,
                                 default = nil)
  if valid_596606 != nil:
    section.add "oauth_token", valid_596606
  var valid_596607 = query.getOrDefault("userIp")
  valid_596607 = validateParameter(valid_596607, JString, required = false,
                                 default = nil)
  if valid_596607 != nil:
    section.add "userIp", valid_596607
  var valid_596608 = query.getOrDefault("maxResults")
  valid_596608 = validateParameter(valid_596608, JInt, required = false,
                                 default = newJInt(1000))
  if valid_596608 != nil:
    section.add "maxResults", valid_596608
  var valid_596609 = query.getOrDefault("ids")
  valid_596609 = validateParameter(valid_596609, JArray, required = false,
                                 default = nil)
  if valid_596609 != nil:
    section.add "ids", valid_596609
  var valid_596610 = query.getOrDefault("key")
  valid_596610 = validateParameter(valid_596610, JString, required = false,
                                 default = nil)
  if valid_596610 != nil:
    section.add "key", valid_596610
  var valid_596611 = query.getOrDefault("advertiserIds")
  valid_596611 = validateParameter(valid_596611, JArray, required = false,
                                 default = nil)
  if valid_596611 != nil:
    section.add "advertiserIds", valid_596611
  var valid_596612 = query.getOrDefault("sortOrder")
  valid_596612 = validateParameter(valid_596612, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_596612 != nil:
    section.add "sortOrder", valid_596612
  var valid_596613 = query.getOrDefault("prettyPrint")
  valid_596613 = validateParameter(valid_596613, JBool, required = false,
                                 default = newJBool(true))
  if valid_596613 != nil:
    section.add "prettyPrint", valid_596613
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596614: Call_DfareportingProjectsList_596596; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of projects, possibly filtered. This method supports paging.
  ## 
  let valid = call_596614.validator(path, query, header, formData, body)
  let scheme = call_596614.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596614.url(scheme.get, call_596614.host, call_596614.base,
                         call_596614.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596614, url, valid)

proc call*(call_596615: Call_DfareportingProjectsList_596596; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; searchString: string = "";
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; advertiserIds: JsonNode = nil;
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingProjectsList
  ## Retrieves a list of projects, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for projects by name or ID. Wildcards (*) are allowed. For example, "project*2015" will return projects with names like "project June 2015", "project April 2015", or simply "project 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "project" will match projects with name "my project", "project 2015", or simply "project".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only projects with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   advertiserIds: JArray
  ##                : Select only projects with these advertiser IDs.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596616 = newJObject()
  var query_596617 = newJObject()
  add(path_596616, "profileId", newJString(profileId))
  add(query_596617, "fields", newJString(fields))
  add(query_596617, "pageToken", newJString(pageToken))
  add(query_596617, "quotaUser", newJString(quotaUser))
  add(query_596617, "sortField", newJString(sortField))
  add(query_596617, "alt", newJString(alt))
  add(query_596617, "searchString", newJString(searchString))
  add(query_596617, "oauth_token", newJString(oauthToken))
  add(query_596617, "userIp", newJString(userIp))
  add(query_596617, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_596617.add "ids", ids
  add(query_596617, "key", newJString(key))
  if advertiserIds != nil:
    query_596617.add "advertiserIds", advertiserIds
  add(query_596617, "sortOrder", newJString(sortOrder))
  add(query_596617, "prettyPrint", newJBool(prettyPrint))
  result = call_596615.call(path_596616, query_596617, nil, nil, nil)

var dfareportingProjectsList* = Call_DfareportingProjectsList_596596(
    name: "dfareportingProjectsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects",
    validator: validate_DfareportingProjectsList_596597,
    base: "/dfareporting/v2.7", url: url_DfareportingProjectsList_596598,
    schemes: {Scheme.Https})
type
  Call_DfareportingProjectsGet_596618 = ref object of OpenApiRestCall_593437
proc url_DfareportingProjectsGet_596620(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingProjectsGet_596619(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one project by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Project ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596621 = path.getOrDefault("profileId")
  valid_596621 = validateParameter(valid_596621, JString, required = true,
                                 default = nil)
  if valid_596621 != nil:
    section.add "profileId", valid_596621
  var valid_596622 = path.getOrDefault("id")
  valid_596622 = validateParameter(valid_596622, JString, required = true,
                                 default = nil)
  if valid_596622 != nil:
    section.add "id", valid_596622
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596623 = query.getOrDefault("fields")
  valid_596623 = validateParameter(valid_596623, JString, required = false,
                                 default = nil)
  if valid_596623 != nil:
    section.add "fields", valid_596623
  var valid_596624 = query.getOrDefault("quotaUser")
  valid_596624 = validateParameter(valid_596624, JString, required = false,
                                 default = nil)
  if valid_596624 != nil:
    section.add "quotaUser", valid_596624
  var valid_596625 = query.getOrDefault("alt")
  valid_596625 = validateParameter(valid_596625, JString, required = false,
                                 default = newJString("json"))
  if valid_596625 != nil:
    section.add "alt", valid_596625
  var valid_596626 = query.getOrDefault("oauth_token")
  valid_596626 = validateParameter(valid_596626, JString, required = false,
                                 default = nil)
  if valid_596626 != nil:
    section.add "oauth_token", valid_596626
  var valid_596627 = query.getOrDefault("userIp")
  valid_596627 = validateParameter(valid_596627, JString, required = false,
                                 default = nil)
  if valid_596627 != nil:
    section.add "userIp", valid_596627
  var valid_596628 = query.getOrDefault("key")
  valid_596628 = validateParameter(valid_596628, JString, required = false,
                                 default = nil)
  if valid_596628 != nil:
    section.add "key", valid_596628
  var valid_596629 = query.getOrDefault("prettyPrint")
  valid_596629 = validateParameter(valid_596629, JBool, required = false,
                                 default = newJBool(true))
  if valid_596629 != nil:
    section.add "prettyPrint", valid_596629
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596630: Call_DfareportingProjectsGet_596618; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one project by ID.
  ## 
  let valid = call_596630.validator(path, query, header, formData, body)
  let scheme = call_596630.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596630.url(scheme.get, call_596630.host, call_596630.base,
                         call_596630.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596630, url, valid)

proc call*(call_596631: Call_DfareportingProjectsGet_596618; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingProjectsGet
  ## Gets one project by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Project ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596632 = newJObject()
  var query_596633 = newJObject()
  add(path_596632, "profileId", newJString(profileId))
  add(query_596633, "fields", newJString(fields))
  add(query_596633, "quotaUser", newJString(quotaUser))
  add(query_596633, "alt", newJString(alt))
  add(query_596633, "oauth_token", newJString(oauthToken))
  add(query_596633, "userIp", newJString(userIp))
  add(path_596632, "id", newJString(id))
  add(query_596633, "key", newJString(key))
  add(query_596633, "prettyPrint", newJBool(prettyPrint))
  result = call_596631.call(path_596632, query_596633, nil, nil, nil)

var dfareportingProjectsGet* = Call_DfareportingProjectsGet_596618(
    name: "dfareportingProjectsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects/{id}",
    validator: validate_DfareportingProjectsGet_596619,
    base: "/dfareporting/v2.7", url: url_DfareportingProjectsGet_596620,
    schemes: {Scheme.Https})
type
  Call_DfareportingInventoryItemsList_596634 = ref object of OpenApiRestCall_593437
proc url_DfareportingInventoryItemsList_596636(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/inventoryItems")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingInventoryItemsList_596635(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of inventory items, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596637 = path.getOrDefault("profileId")
  valid_596637 = validateParameter(valid_596637, JString, required = true,
                                 default = nil)
  if valid_596637 != nil:
    section.add "profileId", valid_596637
  var valid_596638 = path.getOrDefault("projectId")
  valid_596638 = validateParameter(valid_596638, JString, required = true,
                                 default = nil)
  if valid_596638 != nil:
    section.add "projectId", valid_596638
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   inPlan: JBool
  ##         : Select only inventory items that are in plan.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   orderId: JArray
  ##          : Select only inventory items that belong to specified orders.
  ##   type: JString
  ##       : Select only inventory items with this type.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only inventory items that are associated with these sites.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only inventory items with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596639 = query.getOrDefault("fields")
  valid_596639 = validateParameter(valid_596639, JString, required = false,
                                 default = nil)
  if valid_596639 != nil:
    section.add "fields", valid_596639
  var valid_596640 = query.getOrDefault("inPlan")
  valid_596640 = validateParameter(valid_596640, JBool, required = false, default = nil)
  if valid_596640 != nil:
    section.add "inPlan", valid_596640
  var valid_596641 = query.getOrDefault("quotaUser")
  valid_596641 = validateParameter(valid_596641, JString, required = false,
                                 default = nil)
  if valid_596641 != nil:
    section.add "quotaUser", valid_596641
  var valid_596642 = query.getOrDefault("pageToken")
  valid_596642 = validateParameter(valid_596642, JString, required = false,
                                 default = nil)
  if valid_596642 != nil:
    section.add "pageToken", valid_596642
  var valid_596643 = query.getOrDefault("sortField")
  valid_596643 = validateParameter(valid_596643, JString, required = false,
                                 default = newJString("ID"))
  if valid_596643 != nil:
    section.add "sortField", valid_596643
  var valid_596644 = query.getOrDefault("alt")
  valid_596644 = validateParameter(valid_596644, JString, required = false,
                                 default = newJString("json"))
  if valid_596644 != nil:
    section.add "alt", valid_596644
  var valid_596645 = query.getOrDefault("orderId")
  valid_596645 = validateParameter(valid_596645, JArray, required = false,
                                 default = nil)
  if valid_596645 != nil:
    section.add "orderId", valid_596645
  var valid_596646 = query.getOrDefault("type")
  valid_596646 = validateParameter(valid_596646, JString, required = false, default = newJString(
      "PLANNING_PLACEMENT_TYPE_CREDIT"))
  if valid_596646 != nil:
    section.add "type", valid_596646
  var valid_596647 = query.getOrDefault("oauth_token")
  valid_596647 = validateParameter(valid_596647, JString, required = false,
                                 default = nil)
  if valid_596647 != nil:
    section.add "oauth_token", valid_596647
  var valid_596648 = query.getOrDefault("userIp")
  valid_596648 = validateParameter(valid_596648, JString, required = false,
                                 default = nil)
  if valid_596648 != nil:
    section.add "userIp", valid_596648
  var valid_596649 = query.getOrDefault("siteId")
  valid_596649 = validateParameter(valid_596649, JArray, required = false,
                                 default = nil)
  if valid_596649 != nil:
    section.add "siteId", valid_596649
  var valid_596650 = query.getOrDefault("maxResults")
  valid_596650 = validateParameter(valid_596650, JInt, required = false,
                                 default = newJInt(1000))
  if valid_596650 != nil:
    section.add "maxResults", valid_596650
  var valid_596651 = query.getOrDefault("ids")
  valid_596651 = validateParameter(valid_596651, JArray, required = false,
                                 default = nil)
  if valid_596651 != nil:
    section.add "ids", valid_596651
  var valid_596652 = query.getOrDefault("key")
  valid_596652 = validateParameter(valid_596652, JString, required = false,
                                 default = nil)
  if valid_596652 != nil:
    section.add "key", valid_596652
  var valid_596653 = query.getOrDefault("sortOrder")
  valid_596653 = validateParameter(valid_596653, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_596653 != nil:
    section.add "sortOrder", valid_596653
  var valid_596654 = query.getOrDefault("prettyPrint")
  valid_596654 = validateParameter(valid_596654, JBool, required = false,
                                 default = newJBool(true))
  if valid_596654 != nil:
    section.add "prettyPrint", valid_596654
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596655: Call_DfareportingInventoryItemsList_596634; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of inventory items, possibly filtered. This method supports paging.
  ## 
  let valid = call_596655.validator(path, query, header, formData, body)
  let scheme = call_596655.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596655.url(scheme.get, call_596655.host, call_596655.base,
                         call_596655.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596655, url, valid)

proc call*(call_596656: Call_DfareportingInventoryItemsList_596634;
          profileId: string; projectId: string; fields: string = "";
          inPlan: bool = false; quotaUser: string = ""; pageToken: string = "";
          sortField: string = "ID"; alt: string = "json"; orderId: JsonNode = nil;
          `type`: string = "PLANNING_PLACEMENT_TYPE_CREDIT";
          oauthToken: string = ""; userIp: string = ""; siteId: JsonNode = nil;
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingInventoryItemsList
  ## Retrieves a list of inventory items, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   inPlan: bool
  ##         : Select only inventory items that are in plan.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   orderId: JArray
  ##          : Select only inventory items that belong to specified orders.
  ##   type: string
  ##       : Select only inventory items with this type.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only inventory items that are associated with these sites.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only inventory items with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596657 = newJObject()
  var query_596658 = newJObject()
  add(path_596657, "profileId", newJString(profileId))
  add(query_596658, "fields", newJString(fields))
  add(query_596658, "inPlan", newJBool(inPlan))
  add(query_596658, "quotaUser", newJString(quotaUser))
  add(query_596658, "pageToken", newJString(pageToken))
  add(query_596658, "sortField", newJString(sortField))
  add(query_596658, "alt", newJString(alt))
  if orderId != nil:
    query_596658.add "orderId", orderId
  add(query_596658, "type", newJString(`type`))
  add(query_596658, "oauth_token", newJString(oauthToken))
  add(query_596658, "userIp", newJString(userIp))
  if siteId != nil:
    query_596658.add "siteId", siteId
  add(query_596658, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_596658.add "ids", ids
  add(query_596658, "key", newJString(key))
  add(path_596657, "projectId", newJString(projectId))
  add(query_596658, "sortOrder", newJString(sortOrder))
  add(query_596658, "prettyPrint", newJBool(prettyPrint))
  result = call_596656.call(path_596657, query_596658, nil, nil, nil)

var dfareportingInventoryItemsList* = Call_DfareportingInventoryItemsList_596634(
    name: "dfareportingInventoryItemsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/inventoryItems",
    validator: validate_DfareportingInventoryItemsList_596635,
    base: "/dfareporting/v2.7", url: url_DfareportingInventoryItemsList_596636,
    schemes: {Scheme.Https})
type
  Call_DfareportingInventoryItemsGet_596659 = ref object of OpenApiRestCall_593437
proc url_DfareportingInventoryItemsGet_596661(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/inventoryItems/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingInventoryItemsGet_596660(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one inventory item by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Inventory item ID.
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596662 = path.getOrDefault("profileId")
  valid_596662 = validateParameter(valid_596662, JString, required = true,
                                 default = nil)
  if valid_596662 != nil:
    section.add "profileId", valid_596662
  var valid_596663 = path.getOrDefault("id")
  valid_596663 = validateParameter(valid_596663, JString, required = true,
                                 default = nil)
  if valid_596663 != nil:
    section.add "id", valid_596663
  var valid_596664 = path.getOrDefault("projectId")
  valid_596664 = validateParameter(valid_596664, JString, required = true,
                                 default = nil)
  if valid_596664 != nil:
    section.add "projectId", valid_596664
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596665 = query.getOrDefault("fields")
  valid_596665 = validateParameter(valid_596665, JString, required = false,
                                 default = nil)
  if valid_596665 != nil:
    section.add "fields", valid_596665
  var valid_596666 = query.getOrDefault("quotaUser")
  valid_596666 = validateParameter(valid_596666, JString, required = false,
                                 default = nil)
  if valid_596666 != nil:
    section.add "quotaUser", valid_596666
  var valid_596667 = query.getOrDefault("alt")
  valid_596667 = validateParameter(valid_596667, JString, required = false,
                                 default = newJString("json"))
  if valid_596667 != nil:
    section.add "alt", valid_596667
  var valid_596668 = query.getOrDefault("oauth_token")
  valid_596668 = validateParameter(valid_596668, JString, required = false,
                                 default = nil)
  if valid_596668 != nil:
    section.add "oauth_token", valid_596668
  var valid_596669 = query.getOrDefault("userIp")
  valid_596669 = validateParameter(valid_596669, JString, required = false,
                                 default = nil)
  if valid_596669 != nil:
    section.add "userIp", valid_596669
  var valid_596670 = query.getOrDefault("key")
  valid_596670 = validateParameter(valid_596670, JString, required = false,
                                 default = nil)
  if valid_596670 != nil:
    section.add "key", valid_596670
  var valid_596671 = query.getOrDefault("prettyPrint")
  valid_596671 = validateParameter(valid_596671, JBool, required = false,
                                 default = newJBool(true))
  if valid_596671 != nil:
    section.add "prettyPrint", valid_596671
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596672: Call_DfareportingInventoryItemsGet_596659; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one inventory item by ID.
  ## 
  let valid = call_596672.validator(path, query, header, formData, body)
  let scheme = call_596672.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596672.url(scheme.get, call_596672.host, call_596672.base,
                         call_596672.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596672, url, valid)

proc call*(call_596673: Call_DfareportingInventoryItemsGet_596659;
          profileId: string; id: string; projectId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingInventoryItemsGet
  ## Gets one inventory item by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Inventory item ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596674 = newJObject()
  var query_596675 = newJObject()
  add(path_596674, "profileId", newJString(profileId))
  add(query_596675, "fields", newJString(fields))
  add(query_596675, "quotaUser", newJString(quotaUser))
  add(query_596675, "alt", newJString(alt))
  add(query_596675, "oauth_token", newJString(oauthToken))
  add(query_596675, "userIp", newJString(userIp))
  add(path_596674, "id", newJString(id))
  add(query_596675, "key", newJString(key))
  add(path_596674, "projectId", newJString(projectId))
  add(query_596675, "prettyPrint", newJBool(prettyPrint))
  result = call_596673.call(path_596674, query_596675, nil, nil, nil)

var dfareportingInventoryItemsGet* = Call_DfareportingInventoryItemsGet_596659(
    name: "dfareportingInventoryItemsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects/{projectId}/inventoryItems/{id}",
    validator: validate_DfareportingInventoryItemsGet_596660,
    base: "/dfareporting/v2.7", url: url_DfareportingInventoryItemsGet_596661,
    schemes: {Scheme.Https})
type
  Call_DfareportingOrderDocumentsList_596676 = ref object of OpenApiRestCall_593437
proc url_DfareportingOrderDocumentsList_596678(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orderDocuments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrderDocumentsList_596677(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of order documents, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596679 = path.getOrDefault("profileId")
  valid_596679 = validateParameter(valid_596679, JString, required = true,
                                 default = nil)
  if valid_596679 != nil:
    section.add "profileId", valid_596679
  var valid_596680 = path.getOrDefault("projectId")
  valid_596680 = validateParameter(valid_596680, JString, required = true,
                                 default = nil)
  if valid_596680 != nil:
    section.add "projectId", valid_596680
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for order documents by name or ID. Wildcards (*) are allowed. For example, "orderdocument*2015" will return order documents with names like "orderdocument June 2015", "orderdocument April 2015", or simply "orderdocument 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "orderdocument" will match order documents with name "my orderdocument", "orderdocument 2015", or simply "orderdocument".
  ##   orderId: JArray
  ##          : Select only order documents for specified orders.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only order documents that are associated with these sites.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only order documents with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   approved: JBool
  ##           : Select only order documents that have been approved by at least one user.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596681 = query.getOrDefault("fields")
  valid_596681 = validateParameter(valid_596681, JString, required = false,
                                 default = nil)
  if valid_596681 != nil:
    section.add "fields", valid_596681
  var valid_596682 = query.getOrDefault("pageToken")
  valid_596682 = validateParameter(valid_596682, JString, required = false,
                                 default = nil)
  if valid_596682 != nil:
    section.add "pageToken", valid_596682
  var valid_596683 = query.getOrDefault("quotaUser")
  valid_596683 = validateParameter(valid_596683, JString, required = false,
                                 default = nil)
  if valid_596683 != nil:
    section.add "quotaUser", valid_596683
  var valid_596684 = query.getOrDefault("sortField")
  valid_596684 = validateParameter(valid_596684, JString, required = false,
                                 default = newJString("ID"))
  if valid_596684 != nil:
    section.add "sortField", valid_596684
  var valid_596685 = query.getOrDefault("alt")
  valid_596685 = validateParameter(valid_596685, JString, required = false,
                                 default = newJString("json"))
  if valid_596685 != nil:
    section.add "alt", valid_596685
  var valid_596686 = query.getOrDefault("searchString")
  valid_596686 = validateParameter(valid_596686, JString, required = false,
                                 default = nil)
  if valid_596686 != nil:
    section.add "searchString", valid_596686
  var valid_596687 = query.getOrDefault("orderId")
  valid_596687 = validateParameter(valid_596687, JArray, required = false,
                                 default = nil)
  if valid_596687 != nil:
    section.add "orderId", valid_596687
  var valid_596688 = query.getOrDefault("oauth_token")
  valid_596688 = validateParameter(valid_596688, JString, required = false,
                                 default = nil)
  if valid_596688 != nil:
    section.add "oauth_token", valid_596688
  var valid_596689 = query.getOrDefault("userIp")
  valid_596689 = validateParameter(valid_596689, JString, required = false,
                                 default = nil)
  if valid_596689 != nil:
    section.add "userIp", valid_596689
  var valid_596690 = query.getOrDefault("siteId")
  valid_596690 = validateParameter(valid_596690, JArray, required = false,
                                 default = nil)
  if valid_596690 != nil:
    section.add "siteId", valid_596690
  var valid_596691 = query.getOrDefault("maxResults")
  valid_596691 = validateParameter(valid_596691, JInt, required = false,
                                 default = newJInt(1000))
  if valid_596691 != nil:
    section.add "maxResults", valid_596691
  var valid_596692 = query.getOrDefault("ids")
  valid_596692 = validateParameter(valid_596692, JArray, required = false,
                                 default = nil)
  if valid_596692 != nil:
    section.add "ids", valid_596692
  var valid_596693 = query.getOrDefault("key")
  valid_596693 = validateParameter(valid_596693, JString, required = false,
                                 default = nil)
  if valid_596693 != nil:
    section.add "key", valid_596693
  var valid_596694 = query.getOrDefault("sortOrder")
  valid_596694 = validateParameter(valid_596694, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_596694 != nil:
    section.add "sortOrder", valid_596694
  var valid_596695 = query.getOrDefault("approved")
  valid_596695 = validateParameter(valid_596695, JBool, required = false, default = nil)
  if valid_596695 != nil:
    section.add "approved", valid_596695
  var valid_596696 = query.getOrDefault("prettyPrint")
  valid_596696 = validateParameter(valid_596696, JBool, required = false,
                                 default = newJBool(true))
  if valid_596696 != nil:
    section.add "prettyPrint", valid_596696
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596697: Call_DfareportingOrderDocumentsList_596676; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of order documents, possibly filtered. This method supports paging.
  ## 
  let valid = call_596697.validator(path, query, header, formData, body)
  let scheme = call_596697.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596697.url(scheme.get, call_596697.host, call_596697.base,
                         call_596697.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596697, url, valid)

proc call*(call_596698: Call_DfareportingOrderDocumentsList_596676;
          profileId: string; projectId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; searchString: string = ""; orderId: JsonNode = nil;
          oauthToken: string = ""; userIp: string = ""; siteId: JsonNode = nil;
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; approved: bool = false;
          prettyPrint: bool = true): Recallable =
  ## dfareportingOrderDocumentsList
  ## Retrieves a list of order documents, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for order documents by name or ID. Wildcards (*) are allowed. For example, "orderdocument*2015" will return order documents with names like "orderdocument June 2015", "orderdocument April 2015", or simply "orderdocument 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "orderdocument" will match order documents with name "my orderdocument", "orderdocument 2015", or simply "orderdocument".
  ##   orderId: JArray
  ##          : Select only order documents for specified orders.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only order documents that are associated with these sites.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only order documents with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   approved: bool
  ##           : Select only order documents that have been approved by at least one user.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596699 = newJObject()
  var query_596700 = newJObject()
  add(path_596699, "profileId", newJString(profileId))
  add(query_596700, "fields", newJString(fields))
  add(query_596700, "pageToken", newJString(pageToken))
  add(query_596700, "quotaUser", newJString(quotaUser))
  add(query_596700, "sortField", newJString(sortField))
  add(query_596700, "alt", newJString(alt))
  add(query_596700, "searchString", newJString(searchString))
  if orderId != nil:
    query_596700.add "orderId", orderId
  add(query_596700, "oauth_token", newJString(oauthToken))
  add(query_596700, "userIp", newJString(userIp))
  if siteId != nil:
    query_596700.add "siteId", siteId
  add(query_596700, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_596700.add "ids", ids
  add(query_596700, "key", newJString(key))
  add(path_596699, "projectId", newJString(projectId))
  add(query_596700, "sortOrder", newJString(sortOrder))
  add(query_596700, "approved", newJBool(approved))
  add(query_596700, "prettyPrint", newJBool(prettyPrint))
  result = call_596698.call(path_596699, query_596700, nil, nil, nil)

var dfareportingOrderDocumentsList* = Call_DfareportingOrderDocumentsList_596676(
    name: "dfareportingOrderDocumentsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/orderDocuments",
    validator: validate_DfareportingOrderDocumentsList_596677,
    base: "/dfareporting/v2.7", url: url_DfareportingOrderDocumentsList_596678,
    schemes: {Scheme.Https})
type
  Call_DfareportingOrderDocumentsGet_596701 = ref object of OpenApiRestCall_593437
proc url_DfareportingOrderDocumentsGet_596703(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orderDocuments/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrderDocumentsGet_596702(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one order document by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Order document ID.
  ##   projectId: JString (required)
  ##            : Project ID for order documents.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596704 = path.getOrDefault("profileId")
  valid_596704 = validateParameter(valid_596704, JString, required = true,
                                 default = nil)
  if valid_596704 != nil:
    section.add "profileId", valid_596704
  var valid_596705 = path.getOrDefault("id")
  valid_596705 = validateParameter(valid_596705, JString, required = true,
                                 default = nil)
  if valid_596705 != nil:
    section.add "id", valid_596705
  var valid_596706 = path.getOrDefault("projectId")
  valid_596706 = validateParameter(valid_596706, JString, required = true,
                                 default = nil)
  if valid_596706 != nil:
    section.add "projectId", valid_596706
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596707 = query.getOrDefault("fields")
  valid_596707 = validateParameter(valid_596707, JString, required = false,
                                 default = nil)
  if valid_596707 != nil:
    section.add "fields", valid_596707
  var valid_596708 = query.getOrDefault("quotaUser")
  valid_596708 = validateParameter(valid_596708, JString, required = false,
                                 default = nil)
  if valid_596708 != nil:
    section.add "quotaUser", valid_596708
  var valid_596709 = query.getOrDefault("alt")
  valid_596709 = validateParameter(valid_596709, JString, required = false,
                                 default = newJString("json"))
  if valid_596709 != nil:
    section.add "alt", valid_596709
  var valid_596710 = query.getOrDefault("oauth_token")
  valid_596710 = validateParameter(valid_596710, JString, required = false,
                                 default = nil)
  if valid_596710 != nil:
    section.add "oauth_token", valid_596710
  var valid_596711 = query.getOrDefault("userIp")
  valid_596711 = validateParameter(valid_596711, JString, required = false,
                                 default = nil)
  if valid_596711 != nil:
    section.add "userIp", valid_596711
  var valid_596712 = query.getOrDefault("key")
  valid_596712 = validateParameter(valid_596712, JString, required = false,
                                 default = nil)
  if valid_596712 != nil:
    section.add "key", valid_596712
  var valid_596713 = query.getOrDefault("prettyPrint")
  valid_596713 = validateParameter(valid_596713, JBool, required = false,
                                 default = newJBool(true))
  if valid_596713 != nil:
    section.add "prettyPrint", valid_596713
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596714: Call_DfareportingOrderDocumentsGet_596701; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one order document by ID.
  ## 
  let valid = call_596714.validator(path, query, header, formData, body)
  let scheme = call_596714.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596714.url(scheme.get, call_596714.host, call_596714.base,
                         call_596714.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596714, url, valid)

proc call*(call_596715: Call_DfareportingOrderDocumentsGet_596701;
          profileId: string; id: string; projectId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOrderDocumentsGet
  ## Gets one order document by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Order document ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for order documents.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596716 = newJObject()
  var query_596717 = newJObject()
  add(path_596716, "profileId", newJString(profileId))
  add(query_596717, "fields", newJString(fields))
  add(query_596717, "quotaUser", newJString(quotaUser))
  add(query_596717, "alt", newJString(alt))
  add(query_596717, "oauth_token", newJString(oauthToken))
  add(query_596717, "userIp", newJString(userIp))
  add(path_596716, "id", newJString(id))
  add(query_596717, "key", newJString(key))
  add(path_596716, "projectId", newJString(projectId))
  add(query_596717, "prettyPrint", newJBool(prettyPrint))
  result = call_596715.call(path_596716, query_596717, nil, nil, nil)

var dfareportingOrderDocumentsGet* = Call_DfareportingOrderDocumentsGet_596701(
    name: "dfareportingOrderDocumentsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/projects/{projectId}/orderDocuments/{id}",
    validator: validate_DfareportingOrderDocumentsGet_596702,
    base: "/dfareporting/v2.7", url: url_DfareportingOrderDocumentsGet_596703,
    schemes: {Scheme.Https})
type
  Call_DfareportingOrdersList_596718 = ref object of OpenApiRestCall_593437
proc url_DfareportingOrdersList_596720(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orders")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrdersList_596719(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of orders, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   projectId: JString (required)
  ##            : Project ID for orders.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596721 = path.getOrDefault("profileId")
  valid_596721 = validateParameter(valid_596721, JString, required = true,
                                 default = nil)
  if valid_596721 != nil:
    section.add "profileId", valid_596721
  var valid_596722 = path.getOrDefault("projectId")
  valid_596722 = validateParameter(valid_596722, JString, required = true,
                                 default = nil)
  if valid_596722 != nil:
    section.add "projectId", valid_596722
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for orders by name or ID. Wildcards (*) are allowed. For example, "order*2015" will return orders with names like "order June 2015", "order April 2015", or simply "order 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "order" will match orders with name "my order", "order 2015", or simply "order".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only orders that are associated with these site IDs.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only orders with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596723 = query.getOrDefault("fields")
  valid_596723 = validateParameter(valid_596723, JString, required = false,
                                 default = nil)
  if valid_596723 != nil:
    section.add "fields", valid_596723
  var valid_596724 = query.getOrDefault("pageToken")
  valid_596724 = validateParameter(valid_596724, JString, required = false,
                                 default = nil)
  if valid_596724 != nil:
    section.add "pageToken", valid_596724
  var valid_596725 = query.getOrDefault("quotaUser")
  valid_596725 = validateParameter(valid_596725, JString, required = false,
                                 default = nil)
  if valid_596725 != nil:
    section.add "quotaUser", valid_596725
  var valid_596726 = query.getOrDefault("sortField")
  valid_596726 = validateParameter(valid_596726, JString, required = false,
                                 default = newJString("ID"))
  if valid_596726 != nil:
    section.add "sortField", valid_596726
  var valid_596727 = query.getOrDefault("alt")
  valid_596727 = validateParameter(valid_596727, JString, required = false,
                                 default = newJString("json"))
  if valid_596727 != nil:
    section.add "alt", valid_596727
  var valid_596728 = query.getOrDefault("searchString")
  valid_596728 = validateParameter(valid_596728, JString, required = false,
                                 default = nil)
  if valid_596728 != nil:
    section.add "searchString", valid_596728
  var valid_596729 = query.getOrDefault("oauth_token")
  valid_596729 = validateParameter(valid_596729, JString, required = false,
                                 default = nil)
  if valid_596729 != nil:
    section.add "oauth_token", valid_596729
  var valid_596730 = query.getOrDefault("userIp")
  valid_596730 = validateParameter(valid_596730, JString, required = false,
                                 default = nil)
  if valid_596730 != nil:
    section.add "userIp", valid_596730
  var valid_596731 = query.getOrDefault("siteId")
  valid_596731 = validateParameter(valid_596731, JArray, required = false,
                                 default = nil)
  if valid_596731 != nil:
    section.add "siteId", valid_596731
  var valid_596732 = query.getOrDefault("maxResults")
  valid_596732 = validateParameter(valid_596732, JInt, required = false,
                                 default = newJInt(1000))
  if valid_596732 != nil:
    section.add "maxResults", valid_596732
  var valid_596733 = query.getOrDefault("ids")
  valid_596733 = validateParameter(valid_596733, JArray, required = false,
                                 default = nil)
  if valid_596733 != nil:
    section.add "ids", valid_596733
  var valid_596734 = query.getOrDefault("key")
  valid_596734 = validateParameter(valid_596734, JString, required = false,
                                 default = nil)
  if valid_596734 != nil:
    section.add "key", valid_596734
  var valid_596735 = query.getOrDefault("sortOrder")
  valid_596735 = validateParameter(valid_596735, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_596735 != nil:
    section.add "sortOrder", valid_596735
  var valid_596736 = query.getOrDefault("prettyPrint")
  valid_596736 = validateParameter(valid_596736, JBool, required = false,
                                 default = newJBool(true))
  if valid_596736 != nil:
    section.add "prettyPrint", valid_596736
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596737: Call_DfareportingOrdersList_596718; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of orders, possibly filtered. This method supports paging.
  ## 
  let valid = call_596737.validator(path, query, header, formData, body)
  let scheme = call_596737.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596737.url(scheme.get, call_596737.host, call_596737.base,
                         call_596737.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596737, url, valid)

proc call*(call_596738: Call_DfareportingOrdersList_596718; profileId: string;
          projectId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = ""; userIp: string = "";
          siteId: JsonNode = nil; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingOrdersList
  ## Retrieves a list of orders, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for orders by name or ID. Wildcards (*) are allowed. For example, "order*2015" will return orders with names like "order June 2015", "order April 2015", or simply "order 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "order" will match orders with name "my order", "order 2015", or simply "order".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   siteId: JArray
  ##         : Select only orders that are associated with these site IDs.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only orders with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for orders.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596739 = newJObject()
  var query_596740 = newJObject()
  add(path_596739, "profileId", newJString(profileId))
  add(query_596740, "fields", newJString(fields))
  add(query_596740, "pageToken", newJString(pageToken))
  add(query_596740, "quotaUser", newJString(quotaUser))
  add(query_596740, "sortField", newJString(sortField))
  add(query_596740, "alt", newJString(alt))
  add(query_596740, "searchString", newJString(searchString))
  add(query_596740, "oauth_token", newJString(oauthToken))
  add(query_596740, "userIp", newJString(userIp))
  if siteId != nil:
    query_596740.add "siteId", siteId
  add(query_596740, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_596740.add "ids", ids
  add(query_596740, "key", newJString(key))
  add(path_596739, "projectId", newJString(projectId))
  add(query_596740, "sortOrder", newJString(sortOrder))
  add(query_596740, "prettyPrint", newJBool(prettyPrint))
  result = call_596738.call(path_596739, query_596740, nil, nil, nil)

var dfareportingOrdersList* = Call_DfareportingOrdersList_596718(
    name: "dfareportingOrdersList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/orders",
    validator: validate_DfareportingOrdersList_596719, base: "/dfareporting/v2.7",
    url: url_DfareportingOrdersList_596720, schemes: {Scheme.Https})
type
  Call_DfareportingOrdersGet_596741 = ref object of OpenApiRestCall_593437
proc url_DfareportingOrdersGet_596743(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "projectId" in path, "`projectId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "projectId"),
               (kind: ConstantSegment, value: "/orders/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingOrdersGet_596742(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one order by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Order ID.
  ##   projectId: JString (required)
  ##            : Project ID for orders.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596744 = path.getOrDefault("profileId")
  valid_596744 = validateParameter(valid_596744, JString, required = true,
                                 default = nil)
  if valid_596744 != nil:
    section.add "profileId", valid_596744
  var valid_596745 = path.getOrDefault("id")
  valid_596745 = validateParameter(valid_596745, JString, required = true,
                                 default = nil)
  if valid_596745 != nil:
    section.add "id", valid_596745
  var valid_596746 = path.getOrDefault("projectId")
  valid_596746 = validateParameter(valid_596746, JString, required = true,
                                 default = nil)
  if valid_596746 != nil:
    section.add "projectId", valid_596746
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596747 = query.getOrDefault("fields")
  valid_596747 = validateParameter(valid_596747, JString, required = false,
                                 default = nil)
  if valid_596747 != nil:
    section.add "fields", valid_596747
  var valid_596748 = query.getOrDefault("quotaUser")
  valid_596748 = validateParameter(valid_596748, JString, required = false,
                                 default = nil)
  if valid_596748 != nil:
    section.add "quotaUser", valid_596748
  var valid_596749 = query.getOrDefault("alt")
  valid_596749 = validateParameter(valid_596749, JString, required = false,
                                 default = newJString("json"))
  if valid_596749 != nil:
    section.add "alt", valid_596749
  var valid_596750 = query.getOrDefault("oauth_token")
  valid_596750 = validateParameter(valid_596750, JString, required = false,
                                 default = nil)
  if valid_596750 != nil:
    section.add "oauth_token", valid_596750
  var valid_596751 = query.getOrDefault("userIp")
  valid_596751 = validateParameter(valid_596751, JString, required = false,
                                 default = nil)
  if valid_596751 != nil:
    section.add "userIp", valid_596751
  var valid_596752 = query.getOrDefault("key")
  valid_596752 = validateParameter(valid_596752, JString, required = false,
                                 default = nil)
  if valid_596752 != nil:
    section.add "key", valid_596752
  var valid_596753 = query.getOrDefault("prettyPrint")
  valid_596753 = validateParameter(valid_596753, JBool, required = false,
                                 default = newJBool(true))
  if valid_596753 != nil:
    section.add "prettyPrint", valid_596753
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596754: Call_DfareportingOrdersGet_596741; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one order by ID.
  ## 
  let valid = call_596754.validator(path, query, header, formData, body)
  let scheme = call_596754.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596754.url(scheme.get, call_596754.host, call_596754.base,
                         call_596754.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596754, url, valid)

proc call*(call_596755: Call_DfareportingOrdersGet_596741; profileId: string;
          id: string; projectId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingOrdersGet
  ## Gets one order by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Order ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   projectId: string (required)
  ##            : Project ID for orders.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596756 = newJObject()
  var query_596757 = newJObject()
  add(path_596756, "profileId", newJString(profileId))
  add(query_596757, "fields", newJString(fields))
  add(query_596757, "quotaUser", newJString(quotaUser))
  add(query_596757, "alt", newJString(alt))
  add(query_596757, "oauth_token", newJString(oauthToken))
  add(query_596757, "userIp", newJString(userIp))
  add(path_596756, "id", newJString(id))
  add(query_596757, "key", newJString(key))
  add(path_596756, "projectId", newJString(projectId))
  add(query_596757, "prettyPrint", newJBool(prettyPrint))
  result = call_596755.call(path_596756, query_596757, nil, nil, nil)

var dfareportingOrdersGet* = Call_DfareportingOrdersGet_596741(
    name: "dfareportingOrdersGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/projects/{projectId}/orders/{id}",
    validator: validate_DfareportingOrdersGet_596742, base: "/dfareporting/v2.7",
    url: url_DfareportingOrdersGet_596743, schemes: {Scheme.Https})
type
  Call_DfareportingRegionsList_596758 = ref object of OpenApiRestCall_593437
proc url_DfareportingRegionsList_596760(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/regions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRegionsList_596759(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of regions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596761 = path.getOrDefault("profileId")
  valid_596761 = validateParameter(valid_596761, JString, required = true,
                                 default = nil)
  if valid_596761 != nil:
    section.add "profileId", valid_596761
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596762 = query.getOrDefault("fields")
  valid_596762 = validateParameter(valid_596762, JString, required = false,
                                 default = nil)
  if valid_596762 != nil:
    section.add "fields", valid_596762
  var valid_596763 = query.getOrDefault("quotaUser")
  valid_596763 = validateParameter(valid_596763, JString, required = false,
                                 default = nil)
  if valid_596763 != nil:
    section.add "quotaUser", valid_596763
  var valid_596764 = query.getOrDefault("alt")
  valid_596764 = validateParameter(valid_596764, JString, required = false,
                                 default = newJString("json"))
  if valid_596764 != nil:
    section.add "alt", valid_596764
  var valid_596765 = query.getOrDefault("oauth_token")
  valid_596765 = validateParameter(valid_596765, JString, required = false,
                                 default = nil)
  if valid_596765 != nil:
    section.add "oauth_token", valid_596765
  var valid_596766 = query.getOrDefault("userIp")
  valid_596766 = validateParameter(valid_596766, JString, required = false,
                                 default = nil)
  if valid_596766 != nil:
    section.add "userIp", valid_596766
  var valid_596767 = query.getOrDefault("key")
  valid_596767 = validateParameter(valid_596767, JString, required = false,
                                 default = nil)
  if valid_596767 != nil:
    section.add "key", valid_596767
  var valid_596768 = query.getOrDefault("prettyPrint")
  valid_596768 = validateParameter(valid_596768, JBool, required = false,
                                 default = newJBool(true))
  if valid_596768 != nil:
    section.add "prettyPrint", valid_596768
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596769: Call_DfareportingRegionsList_596758; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of regions.
  ## 
  let valid = call_596769.validator(path, query, header, formData, body)
  let scheme = call_596769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596769.url(scheme.get, call_596769.host, call_596769.base,
                         call_596769.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596769, url, valid)

proc call*(call_596770: Call_DfareportingRegionsList_596758; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingRegionsList
  ## Retrieves a list of regions.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596771 = newJObject()
  var query_596772 = newJObject()
  add(path_596771, "profileId", newJString(profileId))
  add(query_596772, "fields", newJString(fields))
  add(query_596772, "quotaUser", newJString(quotaUser))
  add(query_596772, "alt", newJString(alt))
  add(query_596772, "oauth_token", newJString(oauthToken))
  add(query_596772, "userIp", newJString(userIp))
  add(query_596772, "key", newJString(key))
  add(query_596772, "prettyPrint", newJBool(prettyPrint))
  result = call_596770.call(path_596771, query_596772, nil, nil, nil)

var dfareportingRegionsList* = Call_DfareportingRegionsList_596758(
    name: "dfareportingRegionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/regions",
    validator: validate_DfareportingRegionsList_596759,
    base: "/dfareporting/v2.7", url: url_DfareportingRegionsList_596760,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListSharesUpdate_596773 = ref object of OpenApiRestCall_593437
proc url_DfareportingRemarketingListSharesUpdate_596775(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingListShares")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListSharesUpdate_596774(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list share.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596776 = path.getOrDefault("profileId")
  valid_596776 = validateParameter(valid_596776, JString, required = true,
                                 default = nil)
  if valid_596776 != nil:
    section.add "profileId", valid_596776
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596777 = query.getOrDefault("fields")
  valid_596777 = validateParameter(valid_596777, JString, required = false,
                                 default = nil)
  if valid_596777 != nil:
    section.add "fields", valid_596777
  var valid_596778 = query.getOrDefault("quotaUser")
  valid_596778 = validateParameter(valid_596778, JString, required = false,
                                 default = nil)
  if valid_596778 != nil:
    section.add "quotaUser", valid_596778
  var valid_596779 = query.getOrDefault("alt")
  valid_596779 = validateParameter(valid_596779, JString, required = false,
                                 default = newJString("json"))
  if valid_596779 != nil:
    section.add "alt", valid_596779
  var valid_596780 = query.getOrDefault("oauth_token")
  valid_596780 = validateParameter(valid_596780, JString, required = false,
                                 default = nil)
  if valid_596780 != nil:
    section.add "oauth_token", valid_596780
  var valid_596781 = query.getOrDefault("userIp")
  valid_596781 = validateParameter(valid_596781, JString, required = false,
                                 default = nil)
  if valid_596781 != nil:
    section.add "userIp", valid_596781
  var valid_596782 = query.getOrDefault("key")
  valid_596782 = validateParameter(valid_596782, JString, required = false,
                                 default = nil)
  if valid_596782 != nil:
    section.add "key", valid_596782
  var valid_596783 = query.getOrDefault("prettyPrint")
  valid_596783 = validateParameter(valid_596783, JBool, required = false,
                                 default = newJBool(true))
  if valid_596783 != nil:
    section.add "prettyPrint", valid_596783
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596785: Call_DfareportingRemarketingListSharesUpdate_596773;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list share.
  ## 
  let valid = call_596785.validator(path, query, header, formData, body)
  let scheme = call_596785.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596785.url(scheme.get, call_596785.host, call_596785.base,
                         call_596785.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596785, url, valid)

proc call*(call_596786: Call_DfareportingRemarketingListSharesUpdate_596773;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListSharesUpdate
  ## Updates an existing remarketing list share.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596787 = newJObject()
  var query_596788 = newJObject()
  var body_596789 = newJObject()
  add(path_596787, "profileId", newJString(profileId))
  add(query_596788, "fields", newJString(fields))
  add(query_596788, "quotaUser", newJString(quotaUser))
  add(query_596788, "alt", newJString(alt))
  add(query_596788, "oauth_token", newJString(oauthToken))
  add(query_596788, "userIp", newJString(userIp))
  add(query_596788, "key", newJString(key))
  if body != nil:
    body_596789 = body
  add(query_596788, "prettyPrint", newJBool(prettyPrint))
  result = call_596786.call(path_596787, query_596788, nil, nil, body_596789)

var dfareportingRemarketingListSharesUpdate* = Call_DfareportingRemarketingListSharesUpdate_596773(
    name: "dfareportingRemarketingListSharesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingListShares",
    validator: validate_DfareportingRemarketingListSharesUpdate_596774,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListSharesUpdate_596775,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListSharesPatch_596790 = ref object of OpenApiRestCall_593437
proc url_DfareportingRemarketingListSharesPatch_596792(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingListShares")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListSharesPatch_596791(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list share. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596793 = path.getOrDefault("profileId")
  valid_596793 = validateParameter(valid_596793, JString, required = true,
                                 default = nil)
  if valid_596793 != nil:
    section.add "profileId", valid_596793
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   remarketingListId: JString (required)
  ##                    : Remarketing list ID.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596794 = query.getOrDefault("fields")
  valid_596794 = validateParameter(valid_596794, JString, required = false,
                                 default = nil)
  if valid_596794 != nil:
    section.add "fields", valid_596794
  var valid_596795 = query.getOrDefault("quotaUser")
  valid_596795 = validateParameter(valid_596795, JString, required = false,
                                 default = nil)
  if valid_596795 != nil:
    section.add "quotaUser", valid_596795
  var valid_596796 = query.getOrDefault("alt")
  valid_596796 = validateParameter(valid_596796, JString, required = false,
                                 default = newJString("json"))
  if valid_596796 != nil:
    section.add "alt", valid_596796
  var valid_596797 = query.getOrDefault("oauth_token")
  valid_596797 = validateParameter(valid_596797, JString, required = false,
                                 default = nil)
  if valid_596797 != nil:
    section.add "oauth_token", valid_596797
  var valid_596798 = query.getOrDefault("userIp")
  valid_596798 = validateParameter(valid_596798, JString, required = false,
                                 default = nil)
  if valid_596798 != nil:
    section.add "userIp", valid_596798
  var valid_596799 = query.getOrDefault("key")
  valid_596799 = validateParameter(valid_596799, JString, required = false,
                                 default = nil)
  if valid_596799 != nil:
    section.add "key", valid_596799
  assert query != nil,
        "query argument is necessary due to required `remarketingListId` field"
  var valid_596800 = query.getOrDefault("remarketingListId")
  valid_596800 = validateParameter(valid_596800, JString, required = true,
                                 default = nil)
  if valid_596800 != nil:
    section.add "remarketingListId", valid_596800
  var valid_596801 = query.getOrDefault("prettyPrint")
  valid_596801 = validateParameter(valid_596801, JBool, required = false,
                                 default = newJBool(true))
  if valid_596801 != nil:
    section.add "prettyPrint", valid_596801
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596803: Call_DfareportingRemarketingListSharesPatch_596790;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list share. This method supports patch semantics.
  ## 
  let valid = call_596803.validator(path, query, header, formData, body)
  let scheme = call_596803.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596803.url(scheme.get, call_596803.host, call_596803.base,
                         call_596803.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596803, url, valid)

proc call*(call_596804: Call_DfareportingRemarketingListSharesPatch_596790;
          profileId: string; remarketingListId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; body: JsonNode = nil;
          prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListSharesPatch
  ## Updates an existing remarketing list share. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   remarketingListId: string (required)
  ##                    : Remarketing list ID.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596805 = newJObject()
  var query_596806 = newJObject()
  var body_596807 = newJObject()
  add(path_596805, "profileId", newJString(profileId))
  add(query_596806, "fields", newJString(fields))
  add(query_596806, "quotaUser", newJString(quotaUser))
  add(query_596806, "alt", newJString(alt))
  add(query_596806, "oauth_token", newJString(oauthToken))
  add(query_596806, "userIp", newJString(userIp))
  add(query_596806, "key", newJString(key))
  add(query_596806, "remarketingListId", newJString(remarketingListId))
  if body != nil:
    body_596807 = body
  add(query_596806, "prettyPrint", newJBool(prettyPrint))
  result = call_596804.call(path_596805, query_596806, nil, nil, body_596807)

var dfareportingRemarketingListSharesPatch* = Call_DfareportingRemarketingListSharesPatch_596790(
    name: "dfareportingRemarketingListSharesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingListShares",
    validator: validate_DfareportingRemarketingListSharesPatch_596791,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListSharesPatch_596792,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListSharesGet_596808 = ref object of OpenApiRestCall_593437
proc url_DfareportingRemarketingListSharesGet_596810(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "remarketingListId" in path,
        "`remarketingListId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingListShares/"),
               (kind: VariableSegment, value: "remarketingListId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListSharesGet_596809(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one remarketing list share by remarketing list ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   remarketingListId: JString (required)
  ##                    : Remarketing list ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596811 = path.getOrDefault("profileId")
  valid_596811 = validateParameter(valid_596811, JString, required = true,
                                 default = nil)
  if valid_596811 != nil:
    section.add "profileId", valid_596811
  var valid_596812 = path.getOrDefault("remarketingListId")
  valid_596812 = validateParameter(valid_596812, JString, required = true,
                                 default = nil)
  if valid_596812 != nil:
    section.add "remarketingListId", valid_596812
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596813 = query.getOrDefault("fields")
  valid_596813 = validateParameter(valid_596813, JString, required = false,
                                 default = nil)
  if valid_596813 != nil:
    section.add "fields", valid_596813
  var valid_596814 = query.getOrDefault("quotaUser")
  valid_596814 = validateParameter(valid_596814, JString, required = false,
                                 default = nil)
  if valid_596814 != nil:
    section.add "quotaUser", valid_596814
  var valid_596815 = query.getOrDefault("alt")
  valid_596815 = validateParameter(valid_596815, JString, required = false,
                                 default = newJString("json"))
  if valid_596815 != nil:
    section.add "alt", valid_596815
  var valid_596816 = query.getOrDefault("oauth_token")
  valid_596816 = validateParameter(valid_596816, JString, required = false,
                                 default = nil)
  if valid_596816 != nil:
    section.add "oauth_token", valid_596816
  var valid_596817 = query.getOrDefault("userIp")
  valid_596817 = validateParameter(valid_596817, JString, required = false,
                                 default = nil)
  if valid_596817 != nil:
    section.add "userIp", valid_596817
  var valid_596818 = query.getOrDefault("key")
  valid_596818 = validateParameter(valid_596818, JString, required = false,
                                 default = nil)
  if valid_596818 != nil:
    section.add "key", valid_596818
  var valid_596819 = query.getOrDefault("prettyPrint")
  valid_596819 = validateParameter(valid_596819, JBool, required = false,
                                 default = newJBool(true))
  if valid_596819 != nil:
    section.add "prettyPrint", valid_596819
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596820: Call_DfareportingRemarketingListSharesGet_596808;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one remarketing list share by remarketing list ID.
  ## 
  let valid = call_596820.validator(path, query, header, formData, body)
  let scheme = call_596820.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596820.url(scheme.get, call_596820.host, call_596820.base,
                         call_596820.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596820, url, valid)

proc call*(call_596821: Call_DfareportingRemarketingListSharesGet_596808;
          profileId: string; remarketingListId: string; fields: string = "";
          quotaUser: string = ""; alt: string = "json"; oauthToken: string = "";
          userIp: string = ""; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListSharesGet
  ## Gets one remarketing list share by remarketing list ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   remarketingListId: string (required)
  ##                    : Remarketing list ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596822 = newJObject()
  var query_596823 = newJObject()
  add(path_596822, "profileId", newJString(profileId))
  add(query_596823, "fields", newJString(fields))
  add(query_596823, "quotaUser", newJString(quotaUser))
  add(query_596823, "alt", newJString(alt))
  add(query_596823, "oauth_token", newJString(oauthToken))
  add(query_596823, "userIp", newJString(userIp))
  add(path_596822, "remarketingListId", newJString(remarketingListId))
  add(query_596823, "key", newJString(key))
  add(query_596823, "prettyPrint", newJBool(prettyPrint))
  result = call_596821.call(path_596822, query_596823, nil, nil, nil)

var dfareportingRemarketingListSharesGet* = Call_DfareportingRemarketingListSharesGet_596808(
    name: "dfareportingRemarketingListSharesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/remarketingListShares/{remarketingListId}",
    validator: validate_DfareportingRemarketingListSharesGet_596809,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListSharesGet_596810,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsUpdate_596847 = ref object of OpenApiRestCall_593437
proc url_DfareportingRemarketingListsUpdate_596849(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsUpdate_596848(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596850 = path.getOrDefault("profileId")
  valid_596850 = validateParameter(valid_596850, JString, required = true,
                                 default = nil)
  if valid_596850 != nil:
    section.add "profileId", valid_596850
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596851 = query.getOrDefault("fields")
  valid_596851 = validateParameter(valid_596851, JString, required = false,
                                 default = nil)
  if valid_596851 != nil:
    section.add "fields", valid_596851
  var valid_596852 = query.getOrDefault("quotaUser")
  valid_596852 = validateParameter(valid_596852, JString, required = false,
                                 default = nil)
  if valid_596852 != nil:
    section.add "quotaUser", valid_596852
  var valid_596853 = query.getOrDefault("alt")
  valid_596853 = validateParameter(valid_596853, JString, required = false,
                                 default = newJString("json"))
  if valid_596853 != nil:
    section.add "alt", valid_596853
  var valid_596854 = query.getOrDefault("oauth_token")
  valid_596854 = validateParameter(valid_596854, JString, required = false,
                                 default = nil)
  if valid_596854 != nil:
    section.add "oauth_token", valid_596854
  var valid_596855 = query.getOrDefault("userIp")
  valid_596855 = validateParameter(valid_596855, JString, required = false,
                                 default = nil)
  if valid_596855 != nil:
    section.add "userIp", valid_596855
  var valid_596856 = query.getOrDefault("key")
  valid_596856 = validateParameter(valid_596856, JString, required = false,
                                 default = nil)
  if valid_596856 != nil:
    section.add "key", valid_596856
  var valid_596857 = query.getOrDefault("prettyPrint")
  valid_596857 = validateParameter(valid_596857, JBool, required = false,
                                 default = newJBool(true))
  if valid_596857 != nil:
    section.add "prettyPrint", valid_596857
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596859: Call_DfareportingRemarketingListsUpdate_596847;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list.
  ## 
  let valid = call_596859.validator(path, query, header, formData, body)
  let scheme = call_596859.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596859.url(scheme.get, call_596859.host, call_596859.base,
                         call_596859.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596859, url, valid)

proc call*(call_596860: Call_DfareportingRemarketingListsUpdate_596847;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsUpdate
  ## Updates an existing remarketing list.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596861 = newJObject()
  var query_596862 = newJObject()
  var body_596863 = newJObject()
  add(path_596861, "profileId", newJString(profileId))
  add(query_596862, "fields", newJString(fields))
  add(query_596862, "quotaUser", newJString(quotaUser))
  add(query_596862, "alt", newJString(alt))
  add(query_596862, "oauth_token", newJString(oauthToken))
  add(query_596862, "userIp", newJString(userIp))
  add(query_596862, "key", newJString(key))
  if body != nil:
    body_596863 = body
  add(query_596862, "prettyPrint", newJBool(prettyPrint))
  result = call_596860.call(path_596861, query_596862, nil, nil, body_596863)

var dfareportingRemarketingListsUpdate* = Call_DfareportingRemarketingListsUpdate_596847(
    name: "dfareportingRemarketingListsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsUpdate_596848,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsUpdate_596849,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsInsert_596864 = ref object of OpenApiRestCall_593437
proc url_DfareportingRemarketingListsInsert_596866(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsInsert_596865(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new remarketing list.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596867 = path.getOrDefault("profileId")
  valid_596867 = validateParameter(valid_596867, JString, required = true,
                                 default = nil)
  if valid_596867 != nil:
    section.add "profileId", valid_596867
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596868 = query.getOrDefault("fields")
  valid_596868 = validateParameter(valid_596868, JString, required = false,
                                 default = nil)
  if valid_596868 != nil:
    section.add "fields", valid_596868
  var valid_596869 = query.getOrDefault("quotaUser")
  valid_596869 = validateParameter(valid_596869, JString, required = false,
                                 default = nil)
  if valid_596869 != nil:
    section.add "quotaUser", valid_596869
  var valid_596870 = query.getOrDefault("alt")
  valid_596870 = validateParameter(valid_596870, JString, required = false,
                                 default = newJString("json"))
  if valid_596870 != nil:
    section.add "alt", valid_596870
  var valid_596871 = query.getOrDefault("oauth_token")
  valid_596871 = validateParameter(valid_596871, JString, required = false,
                                 default = nil)
  if valid_596871 != nil:
    section.add "oauth_token", valid_596871
  var valid_596872 = query.getOrDefault("userIp")
  valid_596872 = validateParameter(valid_596872, JString, required = false,
                                 default = nil)
  if valid_596872 != nil:
    section.add "userIp", valid_596872
  var valid_596873 = query.getOrDefault("key")
  valid_596873 = validateParameter(valid_596873, JString, required = false,
                                 default = nil)
  if valid_596873 != nil:
    section.add "key", valid_596873
  var valid_596874 = query.getOrDefault("prettyPrint")
  valid_596874 = validateParameter(valid_596874, JBool, required = false,
                                 default = newJBool(true))
  if valid_596874 != nil:
    section.add "prettyPrint", valid_596874
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596876: Call_DfareportingRemarketingListsInsert_596864;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new remarketing list.
  ## 
  let valid = call_596876.validator(path, query, header, formData, body)
  let scheme = call_596876.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596876.url(scheme.get, call_596876.host, call_596876.base,
                         call_596876.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596876, url, valid)

proc call*(call_596877: Call_DfareportingRemarketingListsInsert_596864;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsInsert
  ## Inserts a new remarketing list.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596878 = newJObject()
  var query_596879 = newJObject()
  var body_596880 = newJObject()
  add(path_596878, "profileId", newJString(profileId))
  add(query_596879, "fields", newJString(fields))
  add(query_596879, "quotaUser", newJString(quotaUser))
  add(query_596879, "alt", newJString(alt))
  add(query_596879, "oauth_token", newJString(oauthToken))
  add(query_596879, "userIp", newJString(userIp))
  add(query_596879, "key", newJString(key))
  if body != nil:
    body_596880 = body
  add(query_596879, "prettyPrint", newJBool(prettyPrint))
  result = call_596877.call(path_596878, query_596879, nil, nil, body_596880)

var dfareportingRemarketingListsInsert* = Call_DfareportingRemarketingListsInsert_596864(
    name: "dfareportingRemarketingListsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsInsert_596865,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsInsert_596866,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsList_596824 = ref object of OpenApiRestCall_593437
proc url_DfareportingRemarketingListsList_596826(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsList_596825(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of remarketing lists, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596827 = path.getOrDefault("profileId")
  valid_596827 = validateParameter(valid_596827, JString, required = true,
                                 default = nil)
  if valid_596827 != nil:
    section.add "profileId", valid_596827
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   advertiserId: JString (required)
  ##               : Select only remarketing lists owned by this advertiser.
  ##   active: JBool
  ##         : Select only active or only inactive remarketing lists.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   floodlightActivityId: JString
  ##                       : Select only remarketing lists that have this floodlight activity ID.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: JString
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596828 = query.getOrDefault("fields")
  valid_596828 = validateParameter(valid_596828, JString, required = false,
                                 default = nil)
  if valid_596828 != nil:
    section.add "fields", valid_596828
  var valid_596829 = query.getOrDefault("pageToken")
  valid_596829 = validateParameter(valid_596829, JString, required = false,
                                 default = nil)
  if valid_596829 != nil:
    section.add "pageToken", valid_596829
  var valid_596830 = query.getOrDefault("quotaUser")
  valid_596830 = validateParameter(valid_596830, JString, required = false,
                                 default = nil)
  if valid_596830 != nil:
    section.add "quotaUser", valid_596830
  var valid_596831 = query.getOrDefault("sortField")
  valid_596831 = validateParameter(valid_596831, JString, required = false,
                                 default = newJString("ID"))
  if valid_596831 != nil:
    section.add "sortField", valid_596831
  var valid_596832 = query.getOrDefault("alt")
  valid_596832 = validateParameter(valid_596832, JString, required = false,
                                 default = newJString("json"))
  if valid_596832 != nil:
    section.add "alt", valid_596832
  assert query != nil,
        "query argument is necessary due to required `advertiserId` field"
  var valid_596833 = query.getOrDefault("advertiserId")
  valid_596833 = validateParameter(valid_596833, JString, required = true,
                                 default = nil)
  if valid_596833 != nil:
    section.add "advertiserId", valid_596833
  var valid_596834 = query.getOrDefault("active")
  valid_596834 = validateParameter(valid_596834, JBool, required = false, default = nil)
  if valid_596834 != nil:
    section.add "active", valid_596834
  var valid_596835 = query.getOrDefault("oauth_token")
  valid_596835 = validateParameter(valid_596835, JString, required = false,
                                 default = nil)
  if valid_596835 != nil:
    section.add "oauth_token", valid_596835
  var valid_596836 = query.getOrDefault("floodlightActivityId")
  valid_596836 = validateParameter(valid_596836, JString, required = false,
                                 default = nil)
  if valid_596836 != nil:
    section.add "floodlightActivityId", valid_596836
  var valid_596837 = query.getOrDefault("userIp")
  valid_596837 = validateParameter(valid_596837, JString, required = false,
                                 default = nil)
  if valid_596837 != nil:
    section.add "userIp", valid_596837
  var valid_596838 = query.getOrDefault("maxResults")
  valid_596838 = validateParameter(valid_596838, JInt, required = false,
                                 default = newJInt(1000))
  if valid_596838 != nil:
    section.add "maxResults", valid_596838
  var valid_596839 = query.getOrDefault("key")
  valid_596839 = validateParameter(valid_596839, JString, required = false,
                                 default = nil)
  if valid_596839 != nil:
    section.add "key", valid_596839
  var valid_596840 = query.getOrDefault("name")
  valid_596840 = validateParameter(valid_596840, JString, required = false,
                                 default = nil)
  if valid_596840 != nil:
    section.add "name", valid_596840
  var valid_596841 = query.getOrDefault("sortOrder")
  valid_596841 = validateParameter(valid_596841, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_596841 != nil:
    section.add "sortOrder", valid_596841
  var valid_596842 = query.getOrDefault("prettyPrint")
  valid_596842 = validateParameter(valid_596842, JBool, required = false,
                                 default = newJBool(true))
  if valid_596842 != nil:
    section.add "prettyPrint", valid_596842
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596843: Call_DfareportingRemarketingListsList_596824;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of remarketing lists, possibly filtered. This method supports paging.
  ## 
  let valid = call_596843.validator(path, query, header, formData, body)
  let scheme = call_596843.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596843.url(scheme.get, call_596843.host, call_596843.base,
                         call_596843.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596843, url, valid)

proc call*(call_596844: Call_DfareportingRemarketingListsList_596824;
          profileId: string; advertiserId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; active: bool = false; oauthToken: string = "";
          floodlightActivityId: string = ""; userIp: string = "";
          maxResults: int = 1000; key: string = ""; name: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsList
  ## Retrieves a list of remarketing lists, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   advertiserId: string (required)
  ##               : Select only remarketing lists owned by this advertiser.
  ##   active: bool
  ##         : Select only active or only inactive remarketing lists.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   floodlightActivityId: string
  ##                       : Select only remarketing lists that have this floodlight activity ID.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: string
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596845 = newJObject()
  var query_596846 = newJObject()
  add(path_596845, "profileId", newJString(profileId))
  add(query_596846, "fields", newJString(fields))
  add(query_596846, "pageToken", newJString(pageToken))
  add(query_596846, "quotaUser", newJString(quotaUser))
  add(query_596846, "sortField", newJString(sortField))
  add(query_596846, "alt", newJString(alt))
  add(query_596846, "advertiserId", newJString(advertiserId))
  add(query_596846, "active", newJBool(active))
  add(query_596846, "oauth_token", newJString(oauthToken))
  add(query_596846, "floodlightActivityId", newJString(floodlightActivityId))
  add(query_596846, "userIp", newJString(userIp))
  add(query_596846, "maxResults", newJInt(maxResults))
  add(query_596846, "key", newJString(key))
  add(query_596846, "name", newJString(name))
  add(query_596846, "sortOrder", newJString(sortOrder))
  add(query_596846, "prettyPrint", newJBool(prettyPrint))
  result = call_596844.call(path_596845, query_596846, nil, nil, nil)

var dfareportingRemarketingListsList* = Call_DfareportingRemarketingListsList_596824(
    name: "dfareportingRemarketingListsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsList_596825,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsList_596826,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsPatch_596881 = ref object of OpenApiRestCall_593437
proc url_DfareportingRemarketingListsPatch_596883(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsPatch_596882(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing remarketing list. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596884 = path.getOrDefault("profileId")
  valid_596884 = validateParameter(valid_596884, JString, required = true,
                                 default = nil)
  if valid_596884 != nil:
    section.add "profileId", valid_596884
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Remarketing list ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596885 = query.getOrDefault("fields")
  valid_596885 = validateParameter(valid_596885, JString, required = false,
                                 default = nil)
  if valid_596885 != nil:
    section.add "fields", valid_596885
  var valid_596886 = query.getOrDefault("quotaUser")
  valid_596886 = validateParameter(valid_596886, JString, required = false,
                                 default = nil)
  if valid_596886 != nil:
    section.add "quotaUser", valid_596886
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_596887 = query.getOrDefault("id")
  valid_596887 = validateParameter(valid_596887, JString, required = true,
                                 default = nil)
  if valid_596887 != nil:
    section.add "id", valid_596887
  var valid_596888 = query.getOrDefault("alt")
  valid_596888 = validateParameter(valid_596888, JString, required = false,
                                 default = newJString("json"))
  if valid_596888 != nil:
    section.add "alt", valid_596888
  var valid_596889 = query.getOrDefault("oauth_token")
  valid_596889 = validateParameter(valid_596889, JString, required = false,
                                 default = nil)
  if valid_596889 != nil:
    section.add "oauth_token", valid_596889
  var valid_596890 = query.getOrDefault("userIp")
  valid_596890 = validateParameter(valid_596890, JString, required = false,
                                 default = nil)
  if valid_596890 != nil:
    section.add "userIp", valid_596890
  var valid_596891 = query.getOrDefault("key")
  valid_596891 = validateParameter(valid_596891, JString, required = false,
                                 default = nil)
  if valid_596891 != nil:
    section.add "key", valid_596891
  var valid_596892 = query.getOrDefault("prettyPrint")
  valid_596892 = validateParameter(valid_596892, JBool, required = false,
                                 default = newJBool(true))
  if valid_596892 != nil:
    section.add "prettyPrint", valid_596892
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596894: Call_DfareportingRemarketingListsPatch_596881;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing remarketing list. This method supports patch semantics.
  ## 
  let valid = call_596894.validator(path, query, header, formData, body)
  let scheme = call_596894.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596894.url(scheme.get, call_596894.host, call_596894.base,
                         call_596894.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596894, url, valid)

proc call*(call_596895: Call_DfareportingRemarketingListsPatch_596881;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsPatch
  ## Updates an existing remarketing list. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Remarketing list ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596896 = newJObject()
  var query_596897 = newJObject()
  var body_596898 = newJObject()
  add(path_596896, "profileId", newJString(profileId))
  add(query_596897, "fields", newJString(fields))
  add(query_596897, "quotaUser", newJString(quotaUser))
  add(query_596897, "id", newJString(id))
  add(query_596897, "alt", newJString(alt))
  add(query_596897, "oauth_token", newJString(oauthToken))
  add(query_596897, "userIp", newJString(userIp))
  add(query_596897, "key", newJString(key))
  if body != nil:
    body_596898 = body
  add(query_596897, "prettyPrint", newJBool(prettyPrint))
  result = call_596895.call(path_596896, query_596897, nil, nil, body_596898)

var dfareportingRemarketingListsPatch* = Call_DfareportingRemarketingListsPatch_596881(
    name: "dfareportingRemarketingListsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists",
    validator: validate_DfareportingRemarketingListsPatch_596882,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsPatch_596883,
    schemes: {Scheme.Https})
type
  Call_DfareportingRemarketingListsGet_596899 = ref object of OpenApiRestCall_593437
proc url_DfareportingRemarketingListsGet_596901(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/remarketingLists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingRemarketingListsGet_596900(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one remarketing list by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Remarketing list ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596902 = path.getOrDefault("profileId")
  valid_596902 = validateParameter(valid_596902, JString, required = true,
                                 default = nil)
  if valid_596902 != nil:
    section.add "profileId", valid_596902
  var valid_596903 = path.getOrDefault("id")
  valid_596903 = validateParameter(valid_596903, JString, required = true,
                                 default = nil)
  if valid_596903 != nil:
    section.add "id", valid_596903
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596904 = query.getOrDefault("fields")
  valid_596904 = validateParameter(valid_596904, JString, required = false,
                                 default = nil)
  if valid_596904 != nil:
    section.add "fields", valid_596904
  var valid_596905 = query.getOrDefault("quotaUser")
  valid_596905 = validateParameter(valid_596905, JString, required = false,
                                 default = nil)
  if valid_596905 != nil:
    section.add "quotaUser", valid_596905
  var valid_596906 = query.getOrDefault("alt")
  valid_596906 = validateParameter(valid_596906, JString, required = false,
                                 default = newJString("json"))
  if valid_596906 != nil:
    section.add "alt", valid_596906
  var valid_596907 = query.getOrDefault("oauth_token")
  valid_596907 = validateParameter(valid_596907, JString, required = false,
                                 default = nil)
  if valid_596907 != nil:
    section.add "oauth_token", valid_596907
  var valid_596908 = query.getOrDefault("userIp")
  valid_596908 = validateParameter(valid_596908, JString, required = false,
                                 default = nil)
  if valid_596908 != nil:
    section.add "userIp", valid_596908
  var valid_596909 = query.getOrDefault("key")
  valid_596909 = validateParameter(valid_596909, JString, required = false,
                                 default = nil)
  if valid_596909 != nil:
    section.add "key", valid_596909
  var valid_596910 = query.getOrDefault("prettyPrint")
  valid_596910 = validateParameter(valid_596910, JBool, required = false,
                                 default = newJBool(true))
  if valid_596910 != nil:
    section.add "prettyPrint", valid_596910
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596911: Call_DfareportingRemarketingListsGet_596899;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one remarketing list by ID.
  ## 
  let valid = call_596911.validator(path, query, header, formData, body)
  let scheme = call_596911.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596911.url(scheme.get, call_596911.host, call_596911.base,
                         call_596911.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596911, url, valid)

proc call*(call_596912: Call_DfareportingRemarketingListsGet_596899;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingRemarketingListsGet
  ## Gets one remarketing list by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Remarketing list ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596913 = newJObject()
  var query_596914 = newJObject()
  add(path_596913, "profileId", newJString(profileId))
  add(query_596914, "fields", newJString(fields))
  add(query_596914, "quotaUser", newJString(quotaUser))
  add(query_596914, "alt", newJString(alt))
  add(query_596914, "oauth_token", newJString(oauthToken))
  add(query_596914, "userIp", newJString(userIp))
  add(path_596913, "id", newJString(id))
  add(query_596914, "key", newJString(key))
  add(query_596914, "prettyPrint", newJBool(prettyPrint))
  result = call_596912.call(path_596913, query_596914, nil, nil, nil)

var dfareportingRemarketingListsGet* = Call_DfareportingRemarketingListsGet_596899(
    name: "dfareportingRemarketingListsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/remarketingLists/{id}",
    validator: validate_DfareportingRemarketingListsGet_596900,
    base: "/dfareporting/v2.7", url: url_DfareportingRemarketingListsGet_596901,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsInsert_596935 = ref object of OpenApiRestCall_593437
proc url_DfareportingReportsInsert_596937(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsInsert_596936(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596938 = path.getOrDefault("profileId")
  valid_596938 = validateParameter(valid_596938, JString, required = true,
                                 default = nil)
  if valid_596938 != nil:
    section.add "profileId", valid_596938
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596939 = query.getOrDefault("fields")
  valid_596939 = validateParameter(valid_596939, JString, required = false,
                                 default = nil)
  if valid_596939 != nil:
    section.add "fields", valid_596939
  var valid_596940 = query.getOrDefault("quotaUser")
  valid_596940 = validateParameter(valid_596940, JString, required = false,
                                 default = nil)
  if valid_596940 != nil:
    section.add "quotaUser", valid_596940
  var valid_596941 = query.getOrDefault("alt")
  valid_596941 = validateParameter(valid_596941, JString, required = false,
                                 default = newJString("json"))
  if valid_596941 != nil:
    section.add "alt", valid_596941
  var valid_596942 = query.getOrDefault("oauth_token")
  valid_596942 = validateParameter(valid_596942, JString, required = false,
                                 default = nil)
  if valid_596942 != nil:
    section.add "oauth_token", valid_596942
  var valid_596943 = query.getOrDefault("userIp")
  valid_596943 = validateParameter(valid_596943, JString, required = false,
                                 default = nil)
  if valid_596943 != nil:
    section.add "userIp", valid_596943
  var valid_596944 = query.getOrDefault("key")
  valid_596944 = validateParameter(valid_596944, JString, required = false,
                                 default = nil)
  if valid_596944 != nil:
    section.add "key", valid_596944
  var valid_596945 = query.getOrDefault("prettyPrint")
  valid_596945 = validateParameter(valid_596945, JBool, required = false,
                                 default = newJBool(true))
  if valid_596945 != nil:
    section.add "prettyPrint", valid_596945
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596947: Call_DfareportingReportsInsert_596935; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a report.
  ## 
  let valid = call_596947.validator(path, query, header, formData, body)
  let scheme = call_596947.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596947.url(scheme.get, call_596947.host, call_596947.base,
                         call_596947.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596947, url, valid)

proc call*(call_596948: Call_DfareportingReportsInsert_596935; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsInsert
  ## Creates a report.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596949 = newJObject()
  var query_596950 = newJObject()
  var body_596951 = newJObject()
  add(path_596949, "profileId", newJString(profileId))
  add(query_596950, "fields", newJString(fields))
  add(query_596950, "quotaUser", newJString(quotaUser))
  add(query_596950, "alt", newJString(alt))
  add(query_596950, "oauth_token", newJString(oauthToken))
  add(query_596950, "userIp", newJString(userIp))
  add(query_596950, "key", newJString(key))
  if body != nil:
    body_596951 = body
  add(query_596950, "prettyPrint", newJBool(prettyPrint))
  result = call_596948.call(path_596949, query_596950, nil, nil, body_596951)

var dfareportingReportsInsert* = Call_DfareportingReportsInsert_596935(
    name: "dfareportingReportsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/reports",
    validator: validate_DfareportingReportsInsert_596936,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsInsert_596937,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsList_596915 = ref object of OpenApiRestCall_593437
proc url_DfareportingReportsList_596917(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsList_596916(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves list of reports.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596918 = path.getOrDefault("profileId")
  valid_596918 = validateParameter(valid_596918, JString, required = true,
                                 default = nil)
  if valid_596918 != nil:
    section.add "profileId", valid_596918
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : The field by which to sort the list.
  ##   scope: JString
  ##        : The scope that defines which results are returned.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596919 = query.getOrDefault("fields")
  valid_596919 = validateParameter(valid_596919, JString, required = false,
                                 default = nil)
  if valid_596919 != nil:
    section.add "fields", valid_596919
  var valid_596920 = query.getOrDefault("pageToken")
  valid_596920 = validateParameter(valid_596920, JString, required = false,
                                 default = nil)
  if valid_596920 != nil:
    section.add "pageToken", valid_596920
  var valid_596921 = query.getOrDefault("quotaUser")
  valid_596921 = validateParameter(valid_596921, JString, required = false,
                                 default = nil)
  if valid_596921 != nil:
    section.add "quotaUser", valid_596921
  var valid_596922 = query.getOrDefault("sortField")
  valid_596922 = validateParameter(valid_596922, JString, required = false,
                                 default = newJString("LAST_MODIFIED_TIME"))
  if valid_596922 != nil:
    section.add "sortField", valid_596922
  var valid_596923 = query.getOrDefault("scope")
  valid_596923 = validateParameter(valid_596923, JString, required = false,
                                 default = newJString("MINE"))
  if valid_596923 != nil:
    section.add "scope", valid_596923
  var valid_596924 = query.getOrDefault("alt")
  valid_596924 = validateParameter(valid_596924, JString, required = false,
                                 default = newJString("json"))
  if valid_596924 != nil:
    section.add "alt", valid_596924
  var valid_596925 = query.getOrDefault("oauth_token")
  valid_596925 = validateParameter(valid_596925, JString, required = false,
                                 default = nil)
  if valid_596925 != nil:
    section.add "oauth_token", valid_596925
  var valid_596926 = query.getOrDefault("userIp")
  valid_596926 = validateParameter(valid_596926, JString, required = false,
                                 default = nil)
  if valid_596926 != nil:
    section.add "userIp", valid_596926
  var valid_596927 = query.getOrDefault("maxResults")
  valid_596927 = validateParameter(valid_596927, JInt, required = false,
                                 default = newJInt(10))
  if valid_596927 != nil:
    section.add "maxResults", valid_596927
  var valid_596928 = query.getOrDefault("key")
  valid_596928 = validateParameter(valid_596928, JString, required = false,
                                 default = nil)
  if valid_596928 != nil:
    section.add "key", valid_596928
  var valid_596929 = query.getOrDefault("sortOrder")
  valid_596929 = validateParameter(valid_596929, JString, required = false,
                                 default = newJString("DESCENDING"))
  if valid_596929 != nil:
    section.add "sortOrder", valid_596929
  var valid_596930 = query.getOrDefault("prettyPrint")
  valid_596930 = validateParameter(valid_596930, JBool, required = false,
                                 default = newJBool(true))
  if valid_596930 != nil:
    section.add "prettyPrint", valid_596930
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596931: Call_DfareportingReportsList_596915; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves list of reports.
  ## 
  let valid = call_596931.validator(path, query, header, formData, body)
  let scheme = call_596931.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596931.url(scheme.get, call_596931.host, call_596931.base,
                         call_596931.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596931, url, valid)

proc call*(call_596932: Call_DfareportingReportsList_596915; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "LAST_MODIFIED_TIME"; scope: string = "MINE";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          maxResults: int = 10; key: string = ""; sortOrder: string = "DESCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingReportsList
  ## Retrieves list of reports.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : The field by which to sort the list.
  ##   scope: string
  ##        : The scope that defines which results are returned.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596933 = newJObject()
  var query_596934 = newJObject()
  add(path_596933, "profileId", newJString(profileId))
  add(query_596934, "fields", newJString(fields))
  add(query_596934, "pageToken", newJString(pageToken))
  add(query_596934, "quotaUser", newJString(quotaUser))
  add(query_596934, "sortField", newJString(sortField))
  add(query_596934, "scope", newJString(scope))
  add(query_596934, "alt", newJString(alt))
  add(query_596934, "oauth_token", newJString(oauthToken))
  add(query_596934, "userIp", newJString(userIp))
  add(query_596934, "maxResults", newJInt(maxResults))
  add(query_596934, "key", newJString(key))
  add(query_596934, "sortOrder", newJString(sortOrder))
  add(query_596934, "prettyPrint", newJBool(prettyPrint))
  result = call_596932.call(path_596933, query_596934, nil, nil, nil)

var dfareportingReportsList* = Call_DfareportingReportsList_596915(
    name: "dfareportingReportsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/reports",
    validator: validate_DfareportingReportsList_596916,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsList_596917,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsCompatibleFieldsQuery_596952 = ref object of OpenApiRestCall_593437
proc url_DfareportingReportsCompatibleFieldsQuery_596954(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"), (kind: ConstantSegment,
        value: "/reports/compatiblefields/query")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsCompatibleFieldsQuery_596953(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the fields that are compatible to be selected in the respective sections of a report criteria, given the fields already selected in the input report and user permissions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596955 = path.getOrDefault("profileId")
  valid_596955 = validateParameter(valid_596955, JString, required = true,
                                 default = nil)
  if valid_596955 != nil:
    section.add "profileId", valid_596955
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596956 = query.getOrDefault("fields")
  valid_596956 = validateParameter(valid_596956, JString, required = false,
                                 default = nil)
  if valid_596956 != nil:
    section.add "fields", valid_596956
  var valid_596957 = query.getOrDefault("quotaUser")
  valid_596957 = validateParameter(valid_596957, JString, required = false,
                                 default = nil)
  if valid_596957 != nil:
    section.add "quotaUser", valid_596957
  var valid_596958 = query.getOrDefault("alt")
  valid_596958 = validateParameter(valid_596958, JString, required = false,
                                 default = newJString("json"))
  if valid_596958 != nil:
    section.add "alt", valid_596958
  var valid_596959 = query.getOrDefault("oauth_token")
  valid_596959 = validateParameter(valid_596959, JString, required = false,
                                 default = nil)
  if valid_596959 != nil:
    section.add "oauth_token", valid_596959
  var valid_596960 = query.getOrDefault("userIp")
  valid_596960 = validateParameter(valid_596960, JString, required = false,
                                 default = nil)
  if valid_596960 != nil:
    section.add "userIp", valid_596960
  var valid_596961 = query.getOrDefault("key")
  valid_596961 = validateParameter(valid_596961, JString, required = false,
                                 default = nil)
  if valid_596961 != nil:
    section.add "key", valid_596961
  var valid_596962 = query.getOrDefault("prettyPrint")
  valid_596962 = validateParameter(valid_596962, JBool, required = false,
                                 default = newJBool(true))
  if valid_596962 != nil:
    section.add "prettyPrint", valid_596962
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596964: Call_DfareportingReportsCompatibleFieldsQuery_596952;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the fields that are compatible to be selected in the respective sections of a report criteria, given the fields already selected in the input report and user permissions.
  ## 
  let valid = call_596964.validator(path, query, header, formData, body)
  let scheme = call_596964.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596964.url(scheme.get, call_596964.host, call_596964.base,
                         call_596964.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596964, url, valid)

proc call*(call_596965: Call_DfareportingReportsCompatibleFieldsQuery_596952;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsCompatibleFieldsQuery
  ## Returns the fields that are compatible to be selected in the respective sections of a report criteria, given the fields already selected in the input report and user permissions.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596966 = newJObject()
  var query_596967 = newJObject()
  var body_596968 = newJObject()
  add(path_596966, "profileId", newJString(profileId))
  add(query_596967, "fields", newJString(fields))
  add(query_596967, "quotaUser", newJString(quotaUser))
  add(query_596967, "alt", newJString(alt))
  add(query_596967, "oauth_token", newJString(oauthToken))
  add(query_596967, "userIp", newJString(userIp))
  add(query_596967, "key", newJString(key))
  if body != nil:
    body_596968 = body
  add(query_596967, "prettyPrint", newJBool(prettyPrint))
  result = call_596965.call(path_596966, query_596967, nil, nil, body_596968)

var dfareportingReportsCompatibleFieldsQuery* = Call_DfareportingReportsCompatibleFieldsQuery_596952(
    name: "dfareportingReportsCompatibleFieldsQuery", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/compatiblefields/query",
    validator: validate_DfareportingReportsCompatibleFieldsQuery_596953,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsCompatibleFieldsQuery_596954,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsUpdate_596985 = ref object of OpenApiRestCall_593437
proc url_DfareportingReportsUpdate_596987(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsUpdate_596986(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596988 = path.getOrDefault("profileId")
  valid_596988 = validateParameter(valid_596988, JString, required = true,
                                 default = nil)
  if valid_596988 != nil:
    section.add "profileId", valid_596988
  var valid_596989 = path.getOrDefault("reportId")
  valid_596989 = validateParameter(valid_596989, JString, required = true,
                                 default = nil)
  if valid_596989 != nil:
    section.add "reportId", valid_596989
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596990 = query.getOrDefault("fields")
  valid_596990 = validateParameter(valid_596990, JString, required = false,
                                 default = nil)
  if valid_596990 != nil:
    section.add "fields", valid_596990
  var valid_596991 = query.getOrDefault("quotaUser")
  valid_596991 = validateParameter(valid_596991, JString, required = false,
                                 default = nil)
  if valid_596991 != nil:
    section.add "quotaUser", valid_596991
  var valid_596992 = query.getOrDefault("alt")
  valid_596992 = validateParameter(valid_596992, JString, required = false,
                                 default = newJString("json"))
  if valid_596992 != nil:
    section.add "alt", valid_596992
  var valid_596993 = query.getOrDefault("oauth_token")
  valid_596993 = validateParameter(valid_596993, JString, required = false,
                                 default = nil)
  if valid_596993 != nil:
    section.add "oauth_token", valid_596993
  var valid_596994 = query.getOrDefault("userIp")
  valid_596994 = validateParameter(valid_596994, JString, required = false,
                                 default = nil)
  if valid_596994 != nil:
    section.add "userIp", valid_596994
  var valid_596995 = query.getOrDefault("key")
  valid_596995 = validateParameter(valid_596995, JString, required = false,
                                 default = nil)
  if valid_596995 != nil:
    section.add "key", valid_596995
  var valid_596996 = query.getOrDefault("prettyPrint")
  valid_596996 = validateParameter(valid_596996, JBool, required = false,
                                 default = newJBool(true))
  if valid_596996 != nil:
    section.add "prettyPrint", valid_596996
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596998: Call_DfareportingReportsUpdate_596985; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a report.
  ## 
  let valid = call_596998.validator(path, query, header, formData, body)
  let scheme = call_596998.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596998.url(scheme.get, call_596998.host, call_596998.base,
                         call_596998.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596998, url, valid)

proc call*(call_596999: Call_DfareportingReportsUpdate_596985; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsUpdate
  ## Updates a report.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597000 = newJObject()
  var query_597001 = newJObject()
  var body_597002 = newJObject()
  add(path_597000, "profileId", newJString(profileId))
  add(query_597001, "fields", newJString(fields))
  add(query_597001, "quotaUser", newJString(quotaUser))
  add(query_597001, "alt", newJString(alt))
  add(query_597001, "oauth_token", newJString(oauthToken))
  add(query_597001, "userIp", newJString(userIp))
  add(query_597001, "key", newJString(key))
  add(path_597000, "reportId", newJString(reportId))
  if body != nil:
    body_597002 = body
  add(query_597001, "prettyPrint", newJBool(prettyPrint))
  result = call_596999.call(path_597000, query_597001, nil, nil, body_597002)

var dfareportingReportsUpdate* = Call_DfareportingReportsUpdate_596985(
    name: "dfareportingReportsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsUpdate_596986,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsUpdate_596987,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsGet_596969 = ref object of OpenApiRestCall_593437
proc url_DfareportingReportsGet_596971(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsGet_596970(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a report by its ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_596972 = path.getOrDefault("profileId")
  valid_596972 = validateParameter(valid_596972, JString, required = true,
                                 default = nil)
  if valid_596972 != nil:
    section.add "profileId", valid_596972
  var valid_596973 = path.getOrDefault("reportId")
  valid_596973 = validateParameter(valid_596973, JString, required = true,
                                 default = nil)
  if valid_596973 != nil:
    section.add "reportId", valid_596973
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_596974 = query.getOrDefault("fields")
  valid_596974 = validateParameter(valid_596974, JString, required = false,
                                 default = nil)
  if valid_596974 != nil:
    section.add "fields", valid_596974
  var valid_596975 = query.getOrDefault("quotaUser")
  valid_596975 = validateParameter(valid_596975, JString, required = false,
                                 default = nil)
  if valid_596975 != nil:
    section.add "quotaUser", valid_596975
  var valid_596976 = query.getOrDefault("alt")
  valid_596976 = validateParameter(valid_596976, JString, required = false,
                                 default = newJString("json"))
  if valid_596976 != nil:
    section.add "alt", valid_596976
  var valid_596977 = query.getOrDefault("oauth_token")
  valid_596977 = validateParameter(valid_596977, JString, required = false,
                                 default = nil)
  if valid_596977 != nil:
    section.add "oauth_token", valid_596977
  var valid_596978 = query.getOrDefault("userIp")
  valid_596978 = validateParameter(valid_596978, JString, required = false,
                                 default = nil)
  if valid_596978 != nil:
    section.add "userIp", valid_596978
  var valid_596979 = query.getOrDefault("key")
  valid_596979 = validateParameter(valid_596979, JString, required = false,
                                 default = nil)
  if valid_596979 != nil:
    section.add "key", valid_596979
  var valid_596980 = query.getOrDefault("prettyPrint")
  valid_596980 = validateParameter(valid_596980, JBool, required = false,
                                 default = newJBool(true))
  if valid_596980 != nil:
    section.add "prettyPrint", valid_596980
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596981: Call_DfareportingReportsGet_596969; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a report by its ID.
  ## 
  let valid = call_596981.validator(path, query, header, formData, body)
  let scheme = call_596981.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596981.url(scheme.get, call_596981.host, call_596981.base,
                         call_596981.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596981, url, valid)

proc call*(call_596982: Call_DfareportingReportsGet_596969; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsGet
  ## Retrieves a report by its ID.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_596983 = newJObject()
  var query_596984 = newJObject()
  add(path_596983, "profileId", newJString(profileId))
  add(query_596984, "fields", newJString(fields))
  add(query_596984, "quotaUser", newJString(quotaUser))
  add(query_596984, "alt", newJString(alt))
  add(query_596984, "oauth_token", newJString(oauthToken))
  add(query_596984, "userIp", newJString(userIp))
  add(query_596984, "key", newJString(key))
  add(path_596983, "reportId", newJString(reportId))
  add(query_596984, "prettyPrint", newJBool(prettyPrint))
  result = call_596982.call(path_596983, query_596984, nil, nil, nil)

var dfareportingReportsGet* = Call_DfareportingReportsGet_596969(
    name: "dfareportingReportsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsGet_596970, base: "/dfareporting/v2.7",
    url: url_DfareportingReportsGet_596971, schemes: {Scheme.Https})
type
  Call_DfareportingReportsPatch_597019 = ref object of OpenApiRestCall_593437
proc url_DfareportingReportsPatch_597021(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsPatch_597020(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a report. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597022 = path.getOrDefault("profileId")
  valid_597022 = validateParameter(valid_597022, JString, required = true,
                                 default = nil)
  if valid_597022 != nil:
    section.add "profileId", valid_597022
  var valid_597023 = path.getOrDefault("reportId")
  valid_597023 = validateParameter(valid_597023, JString, required = true,
                                 default = nil)
  if valid_597023 != nil:
    section.add "reportId", valid_597023
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597024 = query.getOrDefault("fields")
  valid_597024 = validateParameter(valid_597024, JString, required = false,
                                 default = nil)
  if valid_597024 != nil:
    section.add "fields", valid_597024
  var valid_597025 = query.getOrDefault("quotaUser")
  valid_597025 = validateParameter(valid_597025, JString, required = false,
                                 default = nil)
  if valid_597025 != nil:
    section.add "quotaUser", valid_597025
  var valid_597026 = query.getOrDefault("alt")
  valid_597026 = validateParameter(valid_597026, JString, required = false,
                                 default = newJString("json"))
  if valid_597026 != nil:
    section.add "alt", valid_597026
  var valid_597027 = query.getOrDefault("oauth_token")
  valid_597027 = validateParameter(valid_597027, JString, required = false,
                                 default = nil)
  if valid_597027 != nil:
    section.add "oauth_token", valid_597027
  var valid_597028 = query.getOrDefault("userIp")
  valid_597028 = validateParameter(valid_597028, JString, required = false,
                                 default = nil)
  if valid_597028 != nil:
    section.add "userIp", valid_597028
  var valid_597029 = query.getOrDefault("key")
  valid_597029 = validateParameter(valid_597029, JString, required = false,
                                 default = nil)
  if valid_597029 != nil:
    section.add "key", valid_597029
  var valid_597030 = query.getOrDefault("prettyPrint")
  valid_597030 = validateParameter(valid_597030, JBool, required = false,
                                 default = newJBool(true))
  if valid_597030 != nil:
    section.add "prettyPrint", valid_597030
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_597032: Call_DfareportingReportsPatch_597019; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a report. This method supports patch semantics.
  ## 
  let valid = call_597032.validator(path, query, header, formData, body)
  let scheme = call_597032.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597032.url(scheme.get, call_597032.host, call_597032.base,
                         call_597032.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597032, url, valid)

proc call*(call_597033: Call_DfareportingReportsPatch_597019; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsPatch
  ## Updates a report. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597034 = newJObject()
  var query_597035 = newJObject()
  var body_597036 = newJObject()
  add(path_597034, "profileId", newJString(profileId))
  add(query_597035, "fields", newJString(fields))
  add(query_597035, "quotaUser", newJString(quotaUser))
  add(query_597035, "alt", newJString(alt))
  add(query_597035, "oauth_token", newJString(oauthToken))
  add(query_597035, "userIp", newJString(userIp))
  add(query_597035, "key", newJString(key))
  add(path_597034, "reportId", newJString(reportId))
  if body != nil:
    body_597036 = body
  add(query_597035, "prettyPrint", newJBool(prettyPrint))
  result = call_597033.call(path_597034, query_597035, nil, nil, body_597036)

var dfareportingReportsPatch* = Call_DfareportingReportsPatch_597019(
    name: "dfareportingReportsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsPatch_597020,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsPatch_597021,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsDelete_597003 = ref object of OpenApiRestCall_593437
proc url_DfareportingReportsDelete_597005(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsDelete_597004(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a report by its ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA user profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597006 = path.getOrDefault("profileId")
  valid_597006 = validateParameter(valid_597006, JString, required = true,
                                 default = nil)
  if valid_597006 != nil:
    section.add "profileId", valid_597006
  var valid_597007 = path.getOrDefault("reportId")
  valid_597007 = validateParameter(valid_597007, JString, required = true,
                                 default = nil)
  if valid_597007 != nil:
    section.add "reportId", valid_597007
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597008 = query.getOrDefault("fields")
  valid_597008 = validateParameter(valid_597008, JString, required = false,
                                 default = nil)
  if valid_597008 != nil:
    section.add "fields", valid_597008
  var valid_597009 = query.getOrDefault("quotaUser")
  valid_597009 = validateParameter(valid_597009, JString, required = false,
                                 default = nil)
  if valid_597009 != nil:
    section.add "quotaUser", valid_597009
  var valid_597010 = query.getOrDefault("alt")
  valid_597010 = validateParameter(valid_597010, JString, required = false,
                                 default = newJString("json"))
  if valid_597010 != nil:
    section.add "alt", valid_597010
  var valid_597011 = query.getOrDefault("oauth_token")
  valid_597011 = validateParameter(valid_597011, JString, required = false,
                                 default = nil)
  if valid_597011 != nil:
    section.add "oauth_token", valid_597011
  var valid_597012 = query.getOrDefault("userIp")
  valid_597012 = validateParameter(valid_597012, JString, required = false,
                                 default = nil)
  if valid_597012 != nil:
    section.add "userIp", valid_597012
  var valid_597013 = query.getOrDefault("key")
  valid_597013 = validateParameter(valid_597013, JString, required = false,
                                 default = nil)
  if valid_597013 != nil:
    section.add "key", valid_597013
  var valid_597014 = query.getOrDefault("prettyPrint")
  valid_597014 = validateParameter(valid_597014, JBool, required = false,
                                 default = newJBool(true))
  if valid_597014 != nil:
    section.add "prettyPrint", valid_597014
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597015: Call_DfareportingReportsDelete_597003; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a report by its ID.
  ## 
  let valid = call_597015.validator(path, query, header, formData, body)
  let scheme = call_597015.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597015.url(scheme.get, call_597015.host, call_597015.base,
                         call_597015.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597015, url, valid)

proc call*(call_597016: Call_DfareportingReportsDelete_597003; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsDelete
  ## Deletes a report by its ID.
  ##   profileId: string (required)
  ##            : The DFA user profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597017 = newJObject()
  var query_597018 = newJObject()
  add(path_597017, "profileId", newJString(profileId))
  add(query_597018, "fields", newJString(fields))
  add(query_597018, "quotaUser", newJString(quotaUser))
  add(query_597018, "alt", newJString(alt))
  add(query_597018, "oauth_token", newJString(oauthToken))
  add(query_597018, "userIp", newJString(userIp))
  add(query_597018, "key", newJString(key))
  add(path_597017, "reportId", newJString(reportId))
  add(query_597018, "prettyPrint", newJBool(prettyPrint))
  result = call_597016.call(path_597017, query_597018, nil, nil, nil)

var dfareportingReportsDelete* = Call_DfareportingReportsDelete_597003(
    name: "dfareportingReportsDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}",
    validator: validate_DfareportingReportsDelete_597004,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsDelete_597005,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsFilesList_597037 = ref object of OpenApiRestCall_593437
proc url_DfareportingReportsFilesList_597039(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsFilesList_597038(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists files for a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the parent report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597040 = path.getOrDefault("profileId")
  valid_597040 = validateParameter(valid_597040, JString, required = true,
                                 default = nil)
  if valid_597040 != nil:
    section.add "profileId", valid_597040
  var valid_597041 = path.getOrDefault("reportId")
  valid_597041 = validateParameter(valid_597041, JString, required = true,
                                 default = nil)
  if valid_597041 != nil:
    section.add "reportId", valid_597041
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : The field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597042 = query.getOrDefault("fields")
  valid_597042 = validateParameter(valid_597042, JString, required = false,
                                 default = nil)
  if valid_597042 != nil:
    section.add "fields", valid_597042
  var valid_597043 = query.getOrDefault("pageToken")
  valid_597043 = validateParameter(valid_597043, JString, required = false,
                                 default = nil)
  if valid_597043 != nil:
    section.add "pageToken", valid_597043
  var valid_597044 = query.getOrDefault("quotaUser")
  valid_597044 = validateParameter(valid_597044, JString, required = false,
                                 default = nil)
  if valid_597044 != nil:
    section.add "quotaUser", valid_597044
  var valid_597045 = query.getOrDefault("sortField")
  valid_597045 = validateParameter(valid_597045, JString, required = false,
                                 default = newJString("LAST_MODIFIED_TIME"))
  if valid_597045 != nil:
    section.add "sortField", valid_597045
  var valid_597046 = query.getOrDefault("alt")
  valid_597046 = validateParameter(valid_597046, JString, required = false,
                                 default = newJString("json"))
  if valid_597046 != nil:
    section.add "alt", valid_597046
  var valid_597047 = query.getOrDefault("oauth_token")
  valid_597047 = validateParameter(valid_597047, JString, required = false,
                                 default = nil)
  if valid_597047 != nil:
    section.add "oauth_token", valid_597047
  var valid_597048 = query.getOrDefault("userIp")
  valid_597048 = validateParameter(valid_597048, JString, required = false,
                                 default = nil)
  if valid_597048 != nil:
    section.add "userIp", valid_597048
  var valid_597049 = query.getOrDefault("maxResults")
  valid_597049 = validateParameter(valid_597049, JInt, required = false,
                                 default = newJInt(10))
  if valid_597049 != nil:
    section.add "maxResults", valid_597049
  var valid_597050 = query.getOrDefault("key")
  valid_597050 = validateParameter(valid_597050, JString, required = false,
                                 default = nil)
  if valid_597050 != nil:
    section.add "key", valid_597050
  var valid_597051 = query.getOrDefault("sortOrder")
  valid_597051 = validateParameter(valid_597051, JString, required = false,
                                 default = newJString("DESCENDING"))
  if valid_597051 != nil:
    section.add "sortOrder", valid_597051
  var valid_597052 = query.getOrDefault("prettyPrint")
  valid_597052 = validateParameter(valid_597052, JBool, required = false,
                                 default = newJBool(true))
  if valid_597052 != nil:
    section.add "prettyPrint", valid_597052
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597053: Call_DfareportingReportsFilesList_597037; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists files for a report.
  ## 
  let valid = call_597053.validator(path, query, header, formData, body)
  let scheme = call_597053.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597053.url(scheme.get, call_597053.host, call_597053.base,
                         call_597053.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597053, url, valid)

proc call*(call_597054: Call_DfareportingReportsFilesList_597037;
          profileId: string; reportId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = "";
          sortField: string = "LAST_MODIFIED_TIME"; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 10;
          key: string = ""; sortOrder: string = "DESCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsFilesList
  ## Lists files for a report.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : The value of the nextToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : The field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   reportId: string (required)
  ##           : The ID of the parent report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597055 = newJObject()
  var query_597056 = newJObject()
  add(path_597055, "profileId", newJString(profileId))
  add(query_597056, "fields", newJString(fields))
  add(query_597056, "pageToken", newJString(pageToken))
  add(query_597056, "quotaUser", newJString(quotaUser))
  add(query_597056, "sortField", newJString(sortField))
  add(query_597056, "alt", newJString(alt))
  add(query_597056, "oauth_token", newJString(oauthToken))
  add(query_597056, "userIp", newJString(userIp))
  add(query_597056, "maxResults", newJInt(maxResults))
  add(query_597056, "key", newJString(key))
  add(query_597056, "sortOrder", newJString(sortOrder))
  add(path_597055, "reportId", newJString(reportId))
  add(query_597056, "prettyPrint", newJBool(prettyPrint))
  result = call_597054.call(path_597055, query_597056, nil, nil, nil)

var dfareportingReportsFilesList* = Call_DfareportingReportsFilesList_597037(
    name: "dfareportingReportsFilesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}/files",
    validator: validate_DfareportingReportsFilesList_597038,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsFilesList_597039,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsFilesGet_597057 = ref object of OpenApiRestCall_593437
proc url_DfareportingReportsFilesGet_597059(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  assert "fileId" in path, "`fileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/files/"),
               (kind: VariableSegment, value: "fileId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsFilesGet_597058(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a report file. This method supports media download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  ##   fileId: JString (required)
  ##         : The ID of the report file.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597060 = path.getOrDefault("profileId")
  valid_597060 = validateParameter(valid_597060, JString, required = true,
                                 default = nil)
  if valid_597060 != nil:
    section.add "profileId", valid_597060
  var valid_597061 = path.getOrDefault("fileId")
  valid_597061 = validateParameter(valid_597061, JString, required = true,
                                 default = nil)
  if valid_597061 != nil:
    section.add "fileId", valid_597061
  var valid_597062 = path.getOrDefault("reportId")
  valid_597062 = validateParameter(valid_597062, JString, required = true,
                                 default = nil)
  if valid_597062 != nil:
    section.add "reportId", valid_597062
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597063 = query.getOrDefault("fields")
  valid_597063 = validateParameter(valid_597063, JString, required = false,
                                 default = nil)
  if valid_597063 != nil:
    section.add "fields", valid_597063
  var valid_597064 = query.getOrDefault("quotaUser")
  valid_597064 = validateParameter(valid_597064, JString, required = false,
                                 default = nil)
  if valid_597064 != nil:
    section.add "quotaUser", valid_597064
  var valid_597065 = query.getOrDefault("alt")
  valid_597065 = validateParameter(valid_597065, JString, required = false,
                                 default = newJString("json"))
  if valid_597065 != nil:
    section.add "alt", valid_597065
  var valid_597066 = query.getOrDefault("oauth_token")
  valid_597066 = validateParameter(valid_597066, JString, required = false,
                                 default = nil)
  if valid_597066 != nil:
    section.add "oauth_token", valid_597066
  var valid_597067 = query.getOrDefault("userIp")
  valid_597067 = validateParameter(valid_597067, JString, required = false,
                                 default = nil)
  if valid_597067 != nil:
    section.add "userIp", valid_597067
  var valid_597068 = query.getOrDefault("key")
  valid_597068 = validateParameter(valid_597068, JString, required = false,
                                 default = nil)
  if valid_597068 != nil:
    section.add "key", valid_597068
  var valid_597069 = query.getOrDefault("prettyPrint")
  valid_597069 = validateParameter(valid_597069, JBool, required = false,
                                 default = newJBool(true))
  if valid_597069 != nil:
    section.add "prettyPrint", valid_597069
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597070: Call_DfareportingReportsFilesGet_597057; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a report file. This method supports media download.
  ## 
  let valid = call_597070.validator(path, query, header, formData, body)
  let scheme = call_597070.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597070.url(scheme.get, call_597070.host, call_597070.base,
                         call_597070.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597070, url, valid)

proc call*(call_597071: Call_DfareportingReportsFilesGet_597057; profileId: string;
          fileId: string; reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsFilesGet
  ## Retrieves a report file. This method supports media download.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   fileId: string (required)
  ##         : The ID of the report file.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597072 = newJObject()
  var query_597073 = newJObject()
  add(path_597072, "profileId", newJString(profileId))
  add(query_597073, "fields", newJString(fields))
  add(query_597073, "quotaUser", newJString(quotaUser))
  add(path_597072, "fileId", newJString(fileId))
  add(query_597073, "alt", newJString(alt))
  add(query_597073, "oauth_token", newJString(oauthToken))
  add(query_597073, "userIp", newJString(userIp))
  add(query_597073, "key", newJString(key))
  add(path_597072, "reportId", newJString(reportId))
  add(query_597073, "prettyPrint", newJBool(prettyPrint))
  result = call_597071.call(path_597072, query_597073, nil, nil, nil)

var dfareportingReportsFilesGet* = Call_DfareportingReportsFilesGet_597057(
    name: "dfareportingReportsFilesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}/files/{fileId}",
    validator: validate_DfareportingReportsFilesGet_597058,
    base: "/dfareporting/v2.7", url: url_DfareportingReportsFilesGet_597059,
    schemes: {Scheme.Https})
type
  Call_DfareportingReportsRun_597074 = ref object of OpenApiRestCall_593437
proc url_DfareportingReportsRun_597076(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "reportId" in path, "`reportId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/reports/"),
               (kind: VariableSegment, value: "reportId"),
               (kind: ConstantSegment, value: "/run")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingReportsRun_597075(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Runs a report.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : The DFA profile ID.
  ##   reportId: JString (required)
  ##           : The ID of the report.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597077 = path.getOrDefault("profileId")
  valid_597077 = validateParameter(valid_597077, JString, required = true,
                                 default = nil)
  if valid_597077 != nil:
    section.add "profileId", valid_597077
  var valid_597078 = path.getOrDefault("reportId")
  valid_597078 = validateParameter(valid_597078, JString, required = true,
                                 default = nil)
  if valid_597078 != nil:
    section.add "reportId", valid_597078
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   synchronous: JBool
  ##              : If set and true, tries to run the report synchronously.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597079 = query.getOrDefault("fields")
  valid_597079 = validateParameter(valid_597079, JString, required = false,
                                 default = nil)
  if valid_597079 != nil:
    section.add "fields", valid_597079
  var valid_597080 = query.getOrDefault("quotaUser")
  valid_597080 = validateParameter(valid_597080, JString, required = false,
                                 default = nil)
  if valid_597080 != nil:
    section.add "quotaUser", valid_597080
  var valid_597081 = query.getOrDefault("alt")
  valid_597081 = validateParameter(valid_597081, JString, required = false,
                                 default = newJString("json"))
  if valid_597081 != nil:
    section.add "alt", valid_597081
  var valid_597082 = query.getOrDefault("oauth_token")
  valid_597082 = validateParameter(valid_597082, JString, required = false,
                                 default = nil)
  if valid_597082 != nil:
    section.add "oauth_token", valid_597082
  var valid_597083 = query.getOrDefault("userIp")
  valid_597083 = validateParameter(valid_597083, JString, required = false,
                                 default = nil)
  if valid_597083 != nil:
    section.add "userIp", valid_597083
  var valid_597084 = query.getOrDefault("synchronous")
  valid_597084 = validateParameter(valid_597084, JBool, required = false,
                                 default = newJBool(false))
  if valid_597084 != nil:
    section.add "synchronous", valid_597084
  var valid_597085 = query.getOrDefault("key")
  valid_597085 = validateParameter(valid_597085, JString, required = false,
                                 default = nil)
  if valid_597085 != nil:
    section.add "key", valid_597085
  var valid_597086 = query.getOrDefault("prettyPrint")
  valid_597086 = validateParameter(valid_597086, JBool, required = false,
                                 default = newJBool(true))
  if valid_597086 != nil:
    section.add "prettyPrint", valid_597086
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597087: Call_DfareportingReportsRun_597074; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Runs a report.
  ## 
  let valid = call_597087.validator(path, query, header, formData, body)
  let scheme = call_597087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597087.url(scheme.get, call_597087.host, call_597087.base,
                         call_597087.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597087, url, valid)

proc call*(call_597088: Call_DfareportingReportsRun_597074; profileId: string;
          reportId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          synchronous: bool = false; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingReportsRun
  ## Runs a report.
  ##   profileId: string (required)
  ##            : The DFA profile ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   synchronous: bool
  ##              : If set and true, tries to run the report synchronously.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   reportId: string (required)
  ##           : The ID of the report.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597089 = newJObject()
  var query_597090 = newJObject()
  add(path_597089, "profileId", newJString(profileId))
  add(query_597090, "fields", newJString(fields))
  add(query_597090, "quotaUser", newJString(quotaUser))
  add(query_597090, "alt", newJString(alt))
  add(query_597090, "oauth_token", newJString(oauthToken))
  add(query_597090, "userIp", newJString(userIp))
  add(query_597090, "synchronous", newJBool(synchronous))
  add(query_597090, "key", newJString(key))
  add(path_597089, "reportId", newJString(reportId))
  add(query_597090, "prettyPrint", newJBool(prettyPrint))
  result = call_597088.call(path_597089, query_597090, nil, nil, nil)

var dfareportingReportsRun* = Call_DfareportingReportsRun_597074(
    name: "dfareportingReportsRun", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/reports/{reportId}/run",
    validator: validate_DfareportingReportsRun_597075, base: "/dfareporting/v2.7",
    url: url_DfareportingReportsRun_597076, schemes: {Scheme.Https})
type
  Call_DfareportingSitesUpdate_597121 = ref object of OpenApiRestCall_593437
proc url_DfareportingSitesUpdate_597123(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesUpdate_597122(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing site.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597124 = path.getOrDefault("profileId")
  valid_597124 = validateParameter(valid_597124, JString, required = true,
                                 default = nil)
  if valid_597124 != nil:
    section.add "profileId", valid_597124
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597125 = query.getOrDefault("fields")
  valid_597125 = validateParameter(valid_597125, JString, required = false,
                                 default = nil)
  if valid_597125 != nil:
    section.add "fields", valid_597125
  var valid_597126 = query.getOrDefault("quotaUser")
  valid_597126 = validateParameter(valid_597126, JString, required = false,
                                 default = nil)
  if valid_597126 != nil:
    section.add "quotaUser", valid_597126
  var valid_597127 = query.getOrDefault("alt")
  valid_597127 = validateParameter(valid_597127, JString, required = false,
                                 default = newJString("json"))
  if valid_597127 != nil:
    section.add "alt", valid_597127
  var valid_597128 = query.getOrDefault("oauth_token")
  valid_597128 = validateParameter(valid_597128, JString, required = false,
                                 default = nil)
  if valid_597128 != nil:
    section.add "oauth_token", valid_597128
  var valid_597129 = query.getOrDefault("userIp")
  valid_597129 = validateParameter(valid_597129, JString, required = false,
                                 default = nil)
  if valid_597129 != nil:
    section.add "userIp", valid_597129
  var valid_597130 = query.getOrDefault("key")
  valid_597130 = validateParameter(valid_597130, JString, required = false,
                                 default = nil)
  if valid_597130 != nil:
    section.add "key", valid_597130
  var valid_597131 = query.getOrDefault("prettyPrint")
  valid_597131 = validateParameter(valid_597131, JBool, required = false,
                                 default = newJBool(true))
  if valid_597131 != nil:
    section.add "prettyPrint", valid_597131
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_597133: Call_DfareportingSitesUpdate_597121; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing site.
  ## 
  let valid = call_597133.validator(path, query, header, formData, body)
  let scheme = call_597133.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597133.url(scheme.get, call_597133.host, call_597133.base,
                         call_597133.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597133, url, valid)

proc call*(call_597134: Call_DfareportingSitesUpdate_597121; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSitesUpdate
  ## Updates an existing site.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597135 = newJObject()
  var query_597136 = newJObject()
  var body_597137 = newJObject()
  add(path_597135, "profileId", newJString(profileId))
  add(query_597136, "fields", newJString(fields))
  add(query_597136, "quotaUser", newJString(quotaUser))
  add(query_597136, "alt", newJString(alt))
  add(query_597136, "oauth_token", newJString(oauthToken))
  add(query_597136, "userIp", newJString(userIp))
  add(query_597136, "key", newJString(key))
  if body != nil:
    body_597137 = body
  add(query_597136, "prettyPrint", newJBool(prettyPrint))
  result = call_597134.call(path_597135, query_597136, nil, nil, body_597137)

var dfareportingSitesUpdate* = Call_DfareportingSitesUpdate_597121(
    name: "dfareportingSitesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesUpdate_597122,
    base: "/dfareporting/v2.7", url: url_DfareportingSitesUpdate_597123,
    schemes: {Scheme.Https})
type
  Call_DfareportingSitesInsert_597138 = ref object of OpenApiRestCall_593437
proc url_DfareportingSitesInsert_597140(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesInsert_597139(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new site.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597141 = path.getOrDefault("profileId")
  valid_597141 = validateParameter(valid_597141, JString, required = true,
                                 default = nil)
  if valid_597141 != nil:
    section.add "profileId", valid_597141
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597142 = query.getOrDefault("fields")
  valid_597142 = validateParameter(valid_597142, JString, required = false,
                                 default = nil)
  if valid_597142 != nil:
    section.add "fields", valid_597142
  var valid_597143 = query.getOrDefault("quotaUser")
  valid_597143 = validateParameter(valid_597143, JString, required = false,
                                 default = nil)
  if valid_597143 != nil:
    section.add "quotaUser", valid_597143
  var valid_597144 = query.getOrDefault("alt")
  valid_597144 = validateParameter(valid_597144, JString, required = false,
                                 default = newJString("json"))
  if valid_597144 != nil:
    section.add "alt", valid_597144
  var valid_597145 = query.getOrDefault("oauth_token")
  valid_597145 = validateParameter(valid_597145, JString, required = false,
                                 default = nil)
  if valid_597145 != nil:
    section.add "oauth_token", valid_597145
  var valid_597146 = query.getOrDefault("userIp")
  valid_597146 = validateParameter(valid_597146, JString, required = false,
                                 default = nil)
  if valid_597146 != nil:
    section.add "userIp", valid_597146
  var valid_597147 = query.getOrDefault("key")
  valid_597147 = validateParameter(valid_597147, JString, required = false,
                                 default = nil)
  if valid_597147 != nil:
    section.add "key", valid_597147
  var valid_597148 = query.getOrDefault("prettyPrint")
  valid_597148 = validateParameter(valid_597148, JBool, required = false,
                                 default = newJBool(true))
  if valid_597148 != nil:
    section.add "prettyPrint", valid_597148
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_597150: Call_DfareportingSitesInsert_597138; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new site.
  ## 
  let valid = call_597150.validator(path, query, header, formData, body)
  let scheme = call_597150.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597150.url(scheme.get, call_597150.host, call_597150.base,
                         call_597150.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597150, url, valid)

proc call*(call_597151: Call_DfareportingSitesInsert_597138; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSitesInsert
  ## Inserts a new site.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597152 = newJObject()
  var query_597153 = newJObject()
  var body_597154 = newJObject()
  add(path_597152, "profileId", newJString(profileId))
  add(query_597153, "fields", newJString(fields))
  add(query_597153, "quotaUser", newJString(quotaUser))
  add(query_597153, "alt", newJString(alt))
  add(query_597153, "oauth_token", newJString(oauthToken))
  add(query_597153, "userIp", newJString(userIp))
  add(query_597153, "key", newJString(key))
  if body != nil:
    body_597154 = body
  add(query_597153, "prettyPrint", newJBool(prettyPrint))
  result = call_597151.call(path_597152, query_597153, nil, nil, body_597154)

var dfareportingSitesInsert* = Call_DfareportingSitesInsert_597138(
    name: "dfareportingSitesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesInsert_597139,
    base: "/dfareporting/v2.7", url: url_DfareportingSitesInsert_597140,
    schemes: {Scheme.Https})
type
  Call_DfareportingSitesList_597091 = ref object of OpenApiRestCall_593437
proc url_DfareportingSitesList_597093(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesList_597092(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of sites, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597094 = path.getOrDefault("profileId")
  valid_597094 = validateParameter(valid_597094, JString, required = true,
                                 default = nil)
  if valid_597094 != nil:
    section.add "profileId", valid_597094
  result.add "path", section
  ## parameters in `query` object:
  ##   subaccountId: JString
  ##               : Select only sites with this subaccount ID.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name, ID or keyName. Wildcards (*) are allowed. For example, "site*2015" will return objects with names like "site June 2015", "site April 2015", or simply "site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "site" will match objects with name "my site", "site 2015", or simply "site".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   campaignIds: JArray
  ##              : Select only sites with these campaign IDs.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only sites with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsInterstitialPlacements: JBool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   acceptsInStreamVideoPlacements: JBool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   adWordsSite: JBool
  ##              : Select only AdWords sites.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   approved: JBool
  ##           : Select only approved sites.
  ##   unmappedSite: JBool
  ##               : Select only sites that have not been mapped to a directory site.
  ##   acceptsPublisherPaidPlacements: JBool
  ##                                 : Select only sites that accept publisher paid placements.
  ##   directorySiteIds: JArray
  ##                   : Select only sites with these directory site IDs.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597095 = query.getOrDefault("subaccountId")
  valid_597095 = validateParameter(valid_597095, JString, required = false,
                                 default = nil)
  if valid_597095 != nil:
    section.add "subaccountId", valid_597095
  var valid_597096 = query.getOrDefault("fields")
  valid_597096 = validateParameter(valid_597096, JString, required = false,
                                 default = nil)
  if valid_597096 != nil:
    section.add "fields", valid_597096
  var valid_597097 = query.getOrDefault("pageToken")
  valid_597097 = validateParameter(valid_597097, JString, required = false,
                                 default = nil)
  if valid_597097 != nil:
    section.add "pageToken", valid_597097
  var valid_597098 = query.getOrDefault("quotaUser")
  valid_597098 = validateParameter(valid_597098, JString, required = false,
                                 default = nil)
  if valid_597098 != nil:
    section.add "quotaUser", valid_597098
  var valid_597099 = query.getOrDefault("sortField")
  valid_597099 = validateParameter(valid_597099, JString, required = false,
                                 default = newJString("ID"))
  if valid_597099 != nil:
    section.add "sortField", valid_597099
  var valid_597100 = query.getOrDefault("alt")
  valid_597100 = validateParameter(valid_597100, JString, required = false,
                                 default = newJString("json"))
  if valid_597100 != nil:
    section.add "alt", valid_597100
  var valid_597101 = query.getOrDefault("searchString")
  valid_597101 = validateParameter(valid_597101, JString, required = false,
                                 default = nil)
  if valid_597101 != nil:
    section.add "searchString", valid_597101
  var valid_597102 = query.getOrDefault("oauth_token")
  valid_597102 = validateParameter(valid_597102, JString, required = false,
                                 default = nil)
  if valid_597102 != nil:
    section.add "oauth_token", valid_597102
  var valid_597103 = query.getOrDefault("campaignIds")
  valid_597103 = validateParameter(valid_597103, JArray, required = false,
                                 default = nil)
  if valid_597103 != nil:
    section.add "campaignIds", valid_597103
  var valid_597104 = query.getOrDefault("userIp")
  valid_597104 = validateParameter(valid_597104, JString, required = false,
                                 default = nil)
  if valid_597104 != nil:
    section.add "userIp", valid_597104
  var valid_597105 = query.getOrDefault("maxResults")
  valid_597105 = validateParameter(valid_597105, JInt, required = false,
                                 default = newJInt(1000))
  if valid_597105 != nil:
    section.add "maxResults", valid_597105
  var valid_597106 = query.getOrDefault("ids")
  valid_597106 = validateParameter(valid_597106, JArray, required = false,
                                 default = nil)
  if valid_597106 != nil:
    section.add "ids", valid_597106
  var valid_597107 = query.getOrDefault("key")
  valid_597107 = validateParameter(valid_597107, JString, required = false,
                                 default = nil)
  if valid_597107 != nil:
    section.add "key", valid_597107
  var valid_597108 = query.getOrDefault("acceptsInterstitialPlacements")
  valid_597108 = validateParameter(valid_597108, JBool, required = false, default = nil)
  if valid_597108 != nil:
    section.add "acceptsInterstitialPlacements", valid_597108
  var valid_597109 = query.getOrDefault("acceptsInStreamVideoPlacements")
  valid_597109 = validateParameter(valid_597109, JBool, required = false, default = nil)
  if valid_597109 != nil:
    section.add "acceptsInStreamVideoPlacements", valid_597109
  var valid_597110 = query.getOrDefault("adWordsSite")
  valid_597110 = validateParameter(valid_597110, JBool, required = false, default = nil)
  if valid_597110 != nil:
    section.add "adWordsSite", valid_597110
  var valid_597111 = query.getOrDefault("sortOrder")
  valid_597111 = validateParameter(valid_597111, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_597111 != nil:
    section.add "sortOrder", valid_597111
  var valid_597112 = query.getOrDefault("approved")
  valid_597112 = validateParameter(valid_597112, JBool, required = false, default = nil)
  if valid_597112 != nil:
    section.add "approved", valid_597112
  var valid_597113 = query.getOrDefault("unmappedSite")
  valid_597113 = validateParameter(valid_597113, JBool, required = false, default = nil)
  if valid_597113 != nil:
    section.add "unmappedSite", valid_597113
  var valid_597114 = query.getOrDefault("acceptsPublisherPaidPlacements")
  valid_597114 = validateParameter(valid_597114, JBool, required = false, default = nil)
  if valid_597114 != nil:
    section.add "acceptsPublisherPaidPlacements", valid_597114
  var valid_597115 = query.getOrDefault("directorySiteIds")
  valid_597115 = validateParameter(valid_597115, JArray, required = false,
                                 default = nil)
  if valid_597115 != nil:
    section.add "directorySiteIds", valid_597115
  var valid_597116 = query.getOrDefault("prettyPrint")
  valid_597116 = validateParameter(valid_597116, JBool, required = false,
                                 default = newJBool(true))
  if valid_597116 != nil:
    section.add "prettyPrint", valid_597116
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597117: Call_DfareportingSitesList_597091; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of sites, possibly filtered. This method supports paging.
  ## 
  let valid = call_597117.validator(path, query, header, formData, body)
  let scheme = call_597117.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597117.url(scheme.get, call_597117.host, call_597117.base,
                         call_597117.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597117, url, valid)

proc call*(call_597118: Call_DfareportingSitesList_597091; profileId: string;
          subaccountId: string = ""; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = "";
          campaignIds: JsonNode = nil; userIp: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = "";
          acceptsInterstitialPlacements: bool = false;
          acceptsInStreamVideoPlacements: bool = false; adWordsSite: bool = false;
          sortOrder: string = "ASCENDING"; approved: bool = false;
          unmappedSite: bool = false; acceptsPublisherPaidPlacements: bool = false;
          directorySiteIds: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSitesList
  ## Retrieves a list of sites, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only sites with this subaccount ID.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name, ID or keyName. Wildcards (*) are allowed. For example, "site*2015" will return objects with names like "site June 2015", "site April 2015", or simply "site 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "site" will match objects with name "my site", "site 2015", or simply "site".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   campaignIds: JArray
  ##              : Select only sites with these campaign IDs.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only sites with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   acceptsInterstitialPlacements: bool
  ##                                : This search filter is no longer supported and will have no effect on the results returned.
  ##   acceptsInStreamVideoPlacements: bool
  ##                                 : This search filter is no longer supported and will have no effect on the results returned.
  ##   adWordsSite: bool
  ##              : Select only AdWords sites.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   approved: bool
  ##           : Select only approved sites.
  ##   unmappedSite: bool
  ##               : Select only sites that have not been mapped to a directory site.
  ##   acceptsPublisherPaidPlacements: bool
  ##                                 : Select only sites that accept publisher paid placements.
  ##   directorySiteIds: JArray
  ##                   : Select only sites with these directory site IDs.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597119 = newJObject()
  var query_597120 = newJObject()
  add(path_597119, "profileId", newJString(profileId))
  add(query_597120, "subaccountId", newJString(subaccountId))
  add(query_597120, "fields", newJString(fields))
  add(query_597120, "pageToken", newJString(pageToken))
  add(query_597120, "quotaUser", newJString(quotaUser))
  add(query_597120, "sortField", newJString(sortField))
  add(query_597120, "alt", newJString(alt))
  add(query_597120, "searchString", newJString(searchString))
  add(query_597120, "oauth_token", newJString(oauthToken))
  if campaignIds != nil:
    query_597120.add "campaignIds", campaignIds
  add(query_597120, "userIp", newJString(userIp))
  add(query_597120, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_597120.add "ids", ids
  add(query_597120, "key", newJString(key))
  add(query_597120, "acceptsInterstitialPlacements",
      newJBool(acceptsInterstitialPlacements))
  add(query_597120, "acceptsInStreamVideoPlacements",
      newJBool(acceptsInStreamVideoPlacements))
  add(query_597120, "adWordsSite", newJBool(adWordsSite))
  add(query_597120, "sortOrder", newJString(sortOrder))
  add(query_597120, "approved", newJBool(approved))
  add(query_597120, "unmappedSite", newJBool(unmappedSite))
  add(query_597120, "acceptsPublisherPaidPlacements",
      newJBool(acceptsPublisherPaidPlacements))
  if directorySiteIds != nil:
    query_597120.add "directorySiteIds", directorySiteIds
  add(query_597120, "prettyPrint", newJBool(prettyPrint))
  result = call_597118.call(path_597119, query_597120, nil, nil, nil)

var dfareportingSitesList* = Call_DfareportingSitesList_597091(
    name: "dfareportingSitesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesList_597092, base: "/dfareporting/v2.7",
    url: url_DfareportingSitesList_597093, schemes: {Scheme.Https})
type
  Call_DfareportingSitesPatch_597155 = ref object of OpenApiRestCall_593437
proc url_DfareportingSitesPatch_597157(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesPatch_597156(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing site. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597158 = path.getOrDefault("profileId")
  valid_597158 = validateParameter(valid_597158, JString, required = true,
                                 default = nil)
  if valid_597158 != nil:
    section.add "profileId", valid_597158
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Site ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597159 = query.getOrDefault("fields")
  valid_597159 = validateParameter(valid_597159, JString, required = false,
                                 default = nil)
  if valid_597159 != nil:
    section.add "fields", valid_597159
  var valid_597160 = query.getOrDefault("quotaUser")
  valid_597160 = validateParameter(valid_597160, JString, required = false,
                                 default = nil)
  if valid_597160 != nil:
    section.add "quotaUser", valid_597160
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_597161 = query.getOrDefault("id")
  valid_597161 = validateParameter(valid_597161, JString, required = true,
                                 default = nil)
  if valid_597161 != nil:
    section.add "id", valid_597161
  var valid_597162 = query.getOrDefault("alt")
  valid_597162 = validateParameter(valid_597162, JString, required = false,
                                 default = newJString("json"))
  if valid_597162 != nil:
    section.add "alt", valid_597162
  var valid_597163 = query.getOrDefault("oauth_token")
  valid_597163 = validateParameter(valid_597163, JString, required = false,
                                 default = nil)
  if valid_597163 != nil:
    section.add "oauth_token", valid_597163
  var valid_597164 = query.getOrDefault("userIp")
  valid_597164 = validateParameter(valid_597164, JString, required = false,
                                 default = nil)
  if valid_597164 != nil:
    section.add "userIp", valid_597164
  var valid_597165 = query.getOrDefault("key")
  valid_597165 = validateParameter(valid_597165, JString, required = false,
                                 default = nil)
  if valid_597165 != nil:
    section.add "key", valid_597165
  var valid_597166 = query.getOrDefault("prettyPrint")
  valid_597166 = validateParameter(valid_597166, JBool, required = false,
                                 default = newJBool(true))
  if valid_597166 != nil:
    section.add "prettyPrint", valid_597166
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_597168: Call_DfareportingSitesPatch_597155; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing site. This method supports patch semantics.
  ## 
  let valid = call_597168.validator(path, query, header, formData, body)
  let scheme = call_597168.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597168.url(scheme.get, call_597168.host, call_597168.base,
                         call_597168.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597168, url, valid)

proc call*(call_597169: Call_DfareportingSitesPatch_597155; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSitesPatch
  ## Updates an existing site. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Site ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597170 = newJObject()
  var query_597171 = newJObject()
  var body_597172 = newJObject()
  add(path_597170, "profileId", newJString(profileId))
  add(query_597171, "fields", newJString(fields))
  add(query_597171, "quotaUser", newJString(quotaUser))
  add(query_597171, "id", newJString(id))
  add(query_597171, "alt", newJString(alt))
  add(query_597171, "oauth_token", newJString(oauthToken))
  add(query_597171, "userIp", newJString(userIp))
  add(query_597171, "key", newJString(key))
  if body != nil:
    body_597172 = body
  add(query_597171, "prettyPrint", newJBool(prettyPrint))
  result = call_597169.call(path_597170, query_597171, nil, nil, body_597172)

var dfareportingSitesPatch* = Call_DfareportingSitesPatch_597155(
    name: "dfareportingSitesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites",
    validator: validate_DfareportingSitesPatch_597156, base: "/dfareporting/v2.7",
    url: url_DfareportingSitesPatch_597157, schemes: {Scheme.Https})
type
  Call_DfareportingSitesGet_597173 = ref object of OpenApiRestCall_593437
proc url_DfareportingSitesGet_597175(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sites/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSitesGet_597174(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one site by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Site ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597176 = path.getOrDefault("profileId")
  valid_597176 = validateParameter(valid_597176, JString, required = true,
                                 default = nil)
  if valid_597176 != nil:
    section.add "profileId", valid_597176
  var valid_597177 = path.getOrDefault("id")
  valid_597177 = validateParameter(valid_597177, JString, required = true,
                                 default = nil)
  if valid_597177 != nil:
    section.add "id", valid_597177
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597178 = query.getOrDefault("fields")
  valid_597178 = validateParameter(valid_597178, JString, required = false,
                                 default = nil)
  if valid_597178 != nil:
    section.add "fields", valid_597178
  var valid_597179 = query.getOrDefault("quotaUser")
  valid_597179 = validateParameter(valid_597179, JString, required = false,
                                 default = nil)
  if valid_597179 != nil:
    section.add "quotaUser", valid_597179
  var valid_597180 = query.getOrDefault("alt")
  valid_597180 = validateParameter(valid_597180, JString, required = false,
                                 default = newJString("json"))
  if valid_597180 != nil:
    section.add "alt", valid_597180
  var valid_597181 = query.getOrDefault("oauth_token")
  valid_597181 = validateParameter(valid_597181, JString, required = false,
                                 default = nil)
  if valid_597181 != nil:
    section.add "oauth_token", valid_597181
  var valid_597182 = query.getOrDefault("userIp")
  valid_597182 = validateParameter(valid_597182, JString, required = false,
                                 default = nil)
  if valid_597182 != nil:
    section.add "userIp", valid_597182
  var valid_597183 = query.getOrDefault("key")
  valid_597183 = validateParameter(valid_597183, JString, required = false,
                                 default = nil)
  if valid_597183 != nil:
    section.add "key", valid_597183
  var valid_597184 = query.getOrDefault("prettyPrint")
  valid_597184 = validateParameter(valid_597184, JBool, required = false,
                                 default = newJBool(true))
  if valid_597184 != nil:
    section.add "prettyPrint", valid_597184
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597185: Call_DfareportingSitesGet_597173; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one site by ID.
  ## 
  let valid = call_597185.validator(path, query, header, formData, body)
  let scheme = call_597185.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597185.url(scheme.get, call_597185.host, call_597185.base,
                         call_597185.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597185, url, valid)

proc call*(call_597186: Call_DfareportingSitesGet_597173; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingSitesGet
  ## Gets one site by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Site ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597187 = newJObject()
  var query_597188 = newJObject()
  add(path_597187, "profileId", newJString(profileId))
  add(query_597188, "fields", newJString(fields))
  add(query_597188, "quotaUser", newJString(quotaUser))
  add(query_597188, "alt", newJString(alt))
  add(query_597188, "oauth_token", newJString(oauthToken))
  add(query_597188, "userIp", newJString(userIp))
  add(path_597187, "id", newJString(id))
  add(query_597188, "key", newJString(key))
  add(query_597188, "prettyPrint", newJBool(prettyPrint))
  result = call_597186.call(path_597187, query_597188, nil, nil, nil)

var dfareportingSitesGet* = Call_DfareportingSitesGet_597173(
    name: "dfareportingSitesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sites/{id}",
    validator: validate_DfareportingSitesGet_597174, base: "/dfareporting/v2.7",
    url: url_DfareportingSitesGet_597175, schemes: {Scheme.Https})
type
  Call_DfareportingSizesInsert_597208 = ref object of OpenApiRestCall_593437
proc url_DfareportingSizesInsert_597210(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sizes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSizesInsert_597209(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new size.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597211 = path.getOrDefault("profileId")
  valid_597211 = validateParameter(valid_597211, JString, required = true,
                                 default = nil)
  if valid_597211 != nil:
    section.add "profileId", valid_597211
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597212 = query.getOrDefault("fields")
  valid_597212 = validateParameter(valid_597212, JString, required = false,
                                 default = nil)
  if valid_597212 != nil:
    section.add "fields", valid_597212
  var valid_597213 = query.getOrDefault("quotaUser")
  valid_597213 = validateParameter(valid_597213, JString, required = false,
                                 default = nil)
  if valid_597213 != nil:
    section.add "quotaUser", valid_597213
  var valid_597214 = query.getOrDefault("alt")
  valid_597214 = validateParameter(valid_597214, JString, required = false,
                                 default = newJString("json"))
  if valid_597214 != nil:
    section.add "alt", valid_597214
  var valid_597215 = query.getOrDefault("oauth_token")
  valid_597215 = validateParameter(valid_597215, JString, required = false,
                                 default = nil)
  if valid_597215 != nil:
    section.add "oauth_token", valid_597215
  var valid_597216 = query.getOrDefault("userIp")
  valid_597216 = validateParameter(valid_597216, JString, required = false,
                                 default = nil)
  if valid_597216 != nil:
    section.add "userIp", valid_597216
  var valid_597217 = query.getOrDefault("key")
  valid_597217 = validateParameter(valid_597217, JString, required = false,
                                 default = nil)
  if valid_597217 != nil:
    section.add "key", valid_597217
  var valid_597218 = query.getOrDefault("prettyPrint")
  valid_597218 = validateParameter(valid_597218, JBool, required = false,
                                 default = newJBool(true))
  if valid_597218 != nil:
    section.add "prettyPrint", valid_597218
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_597220: Call_DfareportingSizesInsert_597208; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new size.
  ## 
  let valid = call_597220.validator(path, query, header, formData, body)
  let scheme = call_597220.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597220.url(scheme.get, call_597220.host, call_597220.base,
                         call_597220.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597220, url, valid)

proc call*(call_597221: Call_DfareportingSizesInsert_597208; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSizesInsert
  ## Inserts a new size.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597222 = newJObject()
  var query_597223 = newJObject()
  var body_597224 = newJObject()
  add(path_597222, "profileId", newJString(profileId))
  add(query_597223, "fields", newJString(fields))
  add(query_597223, "quotaUser", newJString(quotaUser))
  add(query_597223, "alt", newJString(alt))
  add(query_597223, "oauth_token", newJString(oauthToken))
  add(query_597223, "userIp", newJString(userIp))
  add(query_597223, "key", newJString(key))
  if body != nil:
    body_597224 = body
  add(query_597223, "prettyPrint", newJBool(prettyPrint))
  result = call_597221.call(path_597222, query_597223, nil, nil, body_597224)

var dfareportingSizesInsert* = Call_DfareportingSizesInsert_597208(
    name: "dfareportingSizesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sizes",
    validator: validate_DfareportingSizesInsert_597209,
    base: "/dfareporting/v2.7", url: url_DfareportingSizesInsert_597210,
    schemes: {Scheme.Https})
type
  Call_DfareportingSizesList_597189 = ref object of OpenApiRestCall_593437
proc url_DfareportingSizesList_597191(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sizes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSizesList_597190(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of sizes, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597192 = path.getOrDefault("profileId")
  valid_597192 = validateParameter(valid_597192, JString, required = true,
                                 default = nil)
  if valid_597192 != nil:
    section.add "profileId", valid_597192
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   height: JInt
  ##         : Select only sizes with this height.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Select only sizes with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   iabStandard: JBool
  ##              : Select only IAB standard sizes.
  ##   width: JInt
  ##        : Select only sizes with this width.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597193 = query.getOrDefault("fields")
  valid_597193 = validateParameter(valid_597193, JString, required = false,
                                 default = nil)
  if valid_597193 != nil:
    section.add "fields", valid_597193
  var valid_597194 = query.getOrDefault("quotaUser")
  valid_597194 = validateParameter(valid_597194, JString, required = false,
                                 default = nil)
  if valid_597194 != nil:
    section.add "quotaUser", valid_597194
  var valid_597195 = query.getOrDefault("alt")
  valid_597195 = validateParameter(valid_597195, JString, required = false,
                                 default = newJString("json"))
  if valid_597195 != nil:
    section.add "alt", valid_597195
  var valid_597196 = query.getOrDefault("oauth_token")
  valid_597196 = validateParameter(valid_597196, JString, required = false,
                                 default = nil)
  if valid_597196 != nil:
    section.add "oauth_token", valid_597196
  var valid_597197 = query.getOrDefault("height")
  valid_597197 = validateParameter(valid_597197, JInt, required = false, default = nil)
  if valid_597197 != nil:
    section.add "height", valid_597197
  var valid_597198 = query.getOrDefault("userIp")
  valid_597198 = validateParameter(valid_597198, JString, required = false,
                                 default = nil)
  if valid_597198 != nil:
    section.add "userIp", valid_597198
  var valid_597199 = query.getOrDefault("ids")
  valid_597199 = validateParameter(valid_597199, JArray, required = false,
                                 default = nil)
  if valid_597199 != nil:
    section.add "ids", valid_597199
  var valid_597200 = query.getOrDefault("key")
  valid_597200 = validateParameter(valid_597200, JString, required = false,
                                 default = nil)
  if valid_597200 != nil:
    section.add "key", valid_597200
  var valid_597201 = query.getOrDefault("iabStandard")
  valid_597201 = validateParameter(valid_597201, JBool, required = false, default = nil)
  if valid_597201 != nil:
    section.add "iabStandard", valid_597201
  var valid_597202 = query.getOrDefault("width")
  valid_597202 = validateParameter(valid_597202, JInt, required = false, default = nil)
  if valid_597202 != nil:
    section.add "width", valid_597202
  var valid_597203 = query.getOrDefault("prettyPrint")
  valid_597203 = validateParameter(valid_597203, JBool, required = false,
                                 default = newJBool(true))
  if valid_597203 != nil:
    section.add "prettyPrint", valid_597203
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597204: Call_DfareportingSizesList_597189; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of sizes, possibly filtered.
  ## 
  let valid = call_597204.validator(path, query, header, formData, body)
  let scheme = call_597204.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597204.url(scheme.get, call_597204.host, call_597204.base,
                         call_597204.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597204, url, valid)

proc call*(call_597205: Call_DfareportingSizesList_597189; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; height: int = 0; userIp: string = "";
          ids: JsonNode = nil; key: string = ""; iabStandard: bool = false; width: int = 0;
          prettyPrint: bool = true): Recallable =
  ## dfareportingSizesList
  ## Retrieves a list of sizes, possibly filtered.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   height: int
  ##         : Select only sizes with this height.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Select only sizes with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   iabStandard: bool
  ##              : Select only IAB standard sizes.
  ##   width: int
  ##        : Select only sizes with this width.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597206 = newJObject()
  var query_597207 = newJObject()
  add(path_597206, "profileId", newJString(profileId))
  add(query_597207, "fields", newJString(fields))
  add(query_597207, "quotaUser", newJString(quotaUser))
  add(query_597207, "alt", newJString(alt))
  add(query_597207, "oauth_token", newJString(oauthToken))
  add(query_597207, "height", newJInt(height))
  add(query_597207, "userIp", newJString(userIp))
  if ids != nil:
    query_597207.add "ids", ids
  add(query_597207, "key", newJString(key))
  add(query_597207, "iabStandard", newJBool(iabStandard))
  add(query_597207, "width", newJInt(width))
  add(query_597207, "prettyPrint", newJBool(prettyPrint))
  result = call_597205.call(path_597206, query_597207, nil, nil, nil)

var dfareportingSizesList* = Call_DfareportingSizesList_597189(
    name: "dfareportingSizesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sizes",
    validator: validate_DfareportingSizesList_597190, base: "/dfareporting/v2.7",
    url: url_DfareportingSizesList_597191, schemes: {Scheme.Https})
type
  Call_DfareportingSizesGet_597225 = ref object of OpenApiRestCall_593437
proc url_DfareportingSizesGet_597227(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/sizes/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSizesGet_597226(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one size by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Size ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597228 = path.getOrDefault("profileId")
  valid_597228 = validateParameter(valid_597228, JString, required = true,
                                 default = nil)
  if valid_597228 != nil:
    section.add "profileId", valid_597228
  var valid_597229 = path.getOrDefault("id")
  valid_597229 = validateParameter(valid_597229, JString, required = true,
                                 default = nil)
  if valid_597229 != nil:
    section.add "id", valid_597229
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597230 = query.getOrDefault("fields")
  valid_597230 = validateParameter(valid_597230, JString, required = false,
                                 default = nil)
  if valid_597230 != nil:
    section.add "fields", valid_597230
  var valid_597231 = query.getOrDefault("quotaUser")
  valid_597231 = validateParameter(valid_597231, JString, required = false,
                                 default = nil)
  if valid_597231 != nil:
    section.add "quotaUser", valid_597231
  var valid_597232 = query.getOrDefault("alt")
  valid_597232 = validateParameter(valid_597232, JString, required = false,
                                 default = newJString("json"))
  if valid_597232 != nil:
    section.add "alt", valid_597232
  var valid_597233 = query.getOrDefault("oauth_token")
  valid_597233 = validateParameter(valid_597233, JString, required = false,
                                 default = nil)
  if valid_597233 != nil:
    section.add "oauth_token", valid_597233
  var valid_597234 = query.getOrDefault("userIp")
  valid_597234 = validateParameter(valid_597234, JString, required = false,
                                 default = nil)
  if valid_597234 != nil:
    section.add "userIp", valid_597234
  var valid_597235 = query.getOrDefault("key")
  valid_597235 = validateParameter(valid_597235, JString, required = false,
                                 default = nil)
  if valid_597235 != nil:
    section.add "key", valid_597235
  var valid_597236 = query.getOrDefault("prettyPrint")
  valid_597236 = validateParameter(valid_597236, JBool, required = false,
                                 default = newJBool(true))
  if valid_597236 != nil:
    section.add "prettyPrint", valid_597236
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597237: Call_DfareportingSizesGet_597225; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one size by ID.
  ## 
  let valid = call_597237.validator(path, query, header, formData, body)
  let scheme = call_597237.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597237.url(scheme.get, call_597237.host, call_597237.base,
                         call_597237.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597237, url, valid)

proc call*(call_597238: Call_DfareportingSizesGet_597225; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingSizesGet
  ## Gets one size by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Size ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597239 = newJObject()
  var query_597240 = newJObject()
  add(path_597239, "profileId", newJString(profileId))
  add(query_597240, "fields", newJString(fields))
  add(query_597240, "quotaUser", newJString(quotaUser))
  add(query_597240, "alt", newJString(alt))
  add(query_597240, "oauth_token", newJString(oauthToken))
  add(query_597240, "userIp", newJString(userIp))
  add(path_597239, "id", newJString(id))
  add(query_597240, "key", newJString(key))
  add(query_597240, "prettyPrint", newJBool(prettyPrint))
  result = call_597238.call(path_597239, query_597240, nil, nil, nil)

var dfareportingSizesGet* = Call_DfareportingSizesGet_597225(
    name: "dfareportingSizesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/sizes/{id}",
    validator: validate_DfareportingSizesGet_597226, base: "/dfareporting/v2.7",
    url: url_DfareportingSizesGet_597227, schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsUpdate_597262 = ref object of OpenApiRestCall_593437
proc url_DfareportingSubaccountsUpdate_597264(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsUpdate_597263(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing subaccount.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597265 = path.getOrDefault("profileId")
  valid_597265 = validateParameter(valid_597265, JString, required = true,
                                 default = nil)
  if valid_597265 != nil:
    section.add "profileId", valid_597265
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597266 = query.getOrDefault("fields")
  valid_597266 = validateParameter(valid_597266, JString, required = false,
                                 default = nil)
  if valid_597266 != nil:
    section.add "fields", valid_597266
  var valid_597267 = query.getOrDefault("quotaUser")
  valid_597267 = validateParameter(valid_597267, JString, required = false,
                                 default = nil)
  if valid_597267 != nil:
    section.add "quotaUser", valid_597267
  var valid_597268 = query.getOrDefault("alt")
  valid_597268 = validateParameter(valid_597268, JString, required = false,
                                 default = newJString("json"))
  if valid_597268 != nil:
    section.add "alt", valid_597268
  var valid_597269 = query.getOrDefault("oauth_token")
  valid_597269 = validateParameter(valid_597269, JString, required = false,
                                 default = nil)
  if valid_597269 != nil:
    section.add "oauth_token", valid_597269
  var valid_597270 = query.getOrDefault("userIp")
  valid_597270 = validateParameter(valid_597270, JString, required = false,
                                 default = nil)
  if valid_597270 != nil:
    section.add "userIp", valid_597270
  var valid_597271 = query.getOrDefault("key")
  valid_597271 = validateParameter(valid_597271, JString, required = false,
                                 default = nil)
  if valid_597271 != nil:
    section.add "key", valid_597271
  var valid_597272 = query.getOrDefault("prettyPrint")
  valid_597272 = validateParameter(valid_597272, JBool, required = false,
                                 default = newJBool(true))
  if valid_597272 != nil:
    section.add "prettyPrint", valid_597272
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_597274: Call_DfareportingSubaccountsUpdate_597262; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing subaccount.
  ## 
  let valid = call_597274.validator(path, query, header, formData, body)
  let scheme = call_597274.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597274.url(scheme.get, call_597274.host, call_597274.base,
                         call_597274.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597274, url, valid)

proc call*(call_597275: Call_DfareportingSubaccountsUpdate_597262;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsUpdate
  ## Updates an existing subaccount.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597276 = newJObject()
  var query_597277 = newJObject()
  var body_597278 = newJObject()
  add(path_597276, "profileId", newJString(profileId))
  add(query_597277, "fields", newJString(fields))
  add(query_597277, "quotaUser", newJString(quotaUser))
  add(query_597277, "alt", newJString(alt))
  add(query_597277, "oauth_token", newJString(oauthToken))
  add(query_597277, "userIp", newJString(userIp))
  add(query_597277, "key", newJString(key))
  if body != nil:
    body_597278 = body
  add(query_597277, "prettyPrint", newJBool(prettyPrint))
  result = call_597275.call(path_597276, query_597277, nil, nil, body_597278)

var dfareportingSubaccountsUpdate* = Call_DfareportingSubaccountsUpdate_597262(
    name: "dfareportingSubaccountsUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsUpdate_597263,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsUpdate_597264,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsInsert_597279 = ref object of OpenApiRestCall_593437
proc url_DfareportingSubaccountsInsert_597281(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsInsert_597280(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new subaccount.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597282 = path.getOrDefault("profileId")
  valid_597282 = validateParameter(valid_597282, JString, required = true,
                                 default = nil)
  if valid_597282 != nil:
    section.add "profileId", valid_597282
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597283 = query.getOrDefault("fields")
  valid_597283 = validateParameter(valid_597283, JString, required = false,
                                 default = nil)
  if valid_597283 != nil:
    section.add "fields", valid_597283
  var valid_597284 = query.getOrDefault("quotaUser")
  valid_597284 = validateParameter(valid_597284, JString, required = false,
                                 default = nil)
  if valid_597284 != nil:
    section.add "quotaUser", valid_597284
  var valid_597285 = query.getOrDefault("alt")
  valid_597285 = validateParameter(valid_597285, JString, required = false,
                                 default = newJString("json"))
  if valid_597285 != nil:
    section.add "alt", valid_597285
  var valid_597286 = query.getOrDefault("oauth_token")
  valid_597286 = validateParameter(valid_597286, JString, required = false,
                                 default = nil)
  if valid_597286 != nil:
    section.add "oauth_token", valid_597286
  var valid_597287 = query.getOrDefault("userIp")
  valid_597287 = validateParameter(valid_597287, JString, required = false,
                                 default = nil)
  if valid_597287 != nil:
    section.add "userIp", valid_597287
  var valid_597288 = query.getOrDefault("key")
  valid_597288 = validateParameter(valid_597288, JString, required = false,
                                 default = nil)
  if valid_597288 != nil:
    section.add "key", valid_597288
  var valid_597289 = query.getOrDefault("prettyPrint")
  valid_597289 = validateParameter(valid_597289, JBool, required = false,
                                 default = newJBool(true))
  if valid_597289 != nil:
    section.add "prettyPrint", valid_597289
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_597291: Call_DfareportingSubaccountsInsert_597279; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new subaccount.
  ## 
  let valid = call_597291.validator(path, query, header, formData, body)
  let scheme = call_597291.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597291.url(scheme.get, call_597291.host, call_597291.base,
                         call_597291.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597291, url, valid)

proc call*(call_597292: Call_DfareportingSubaccountsInsert_597279;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsInsert
  ## Inserts a new subaccount.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597293 = newJObject()
  var query_597294 = newJObject()
  var body_597295 = newJObject()
  add(path_597293, "profileId", newJString(profileId))
  add(query_597294, "fields", newJString(fields))
  add(query_597294, "quotaUser", newJString(quotaUser))
  add(query_597294, "alt", newJString(alt))
  add(query_597294, "oauth_token", newJString(oauthToken))
  add(query_597294, "userIp", newJString(userIp))
  add(query_597294, "key", newJString(key))
  if body != nil:
    body_597295 = body
  add(query_597294, "prettyPrint", newJBool(prettyPrint))
  result = call_597292.call(path_597293, query_597294, nil, nil, body_597295)

var dfareportingSubaccountsInsert* = Call_DfareportingSubaccountsInsert_597279(
    name: "dfareportingSubaccountsInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsInsert_597280,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsInsert_597281,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsList_597241 = ref object of OpenApiRestCall_593437
proc url_DfareportingSubaccountsList_597243(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsList_597242(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of subaccounts, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597244 = path.getOrDefault("profileId")
  valid_597244 = validateParameter(valid_597244, JString, required = true,
                                 default = nil)
  if valid_597244 != nil:
    section.add "profileId", valid_597244
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "subaccount*2015" will return objects with names like "subaccount June 2015", "subaccount April 2015", or simply "subaccount 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "subaccount" will match objects with name "my subaccount", "subaccount 2015", or simply "subaccount".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only subaccounts with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597245 = query.getOrDefault("fields")
  valid_597245 = validateParameter(valid_597245, JString, required = false,
                                 default = nil)
  if valid_597245 != nil:
    section.add "fields", valid_597245
  var valid_597246 = query.getOrDefault("pageToken")
  valid_597246 = validateParameter(valid_597246, JString, required = false,
                                 default = nil)
  if valid_597246 != nil:
    section.add "pageToken", valid_597246
  var valid_597247 = query.getOrDefault("quotaUser")
  valid_597247 = validateParameter(valid_597247, JString, required = false,
                                 default = nil)
  if valid_597247 != nil:
    section.add "quotaUser", valid_597247
  var valid_597248 = query.getOrDefault("sortField")
  valid_597248 = validateParameter(valid_597248, JString, required = false,
                                 default = newJString("ID"))
  if valid_597248 != nil:
    section.add "sortField", valid_597248
  var valid_597249 = query.getOrDefault("alt")
  valid_597249 = validateParameter(valid_597249, JString, required = false,
                                 default = newJString("json"))
  if valid_597249 != nil:
    section.add "alt", valid_597249
  var valid_597250 = query.getOrDefault("searchString")
  valid_597250 = validateParameter(valid_597250, JString, required = false,
                                 default = nil)
  if valid_597250 != nil:
    section.add "searchString", valid_597250
  var valid_597251 = query.getOrDefault("oauth_token")
  valid_597251 = validateParameter(valid_597251, JString, required = false,
                                 default = nil)
  if valid_597251 != nil:
    section.add "oauth_token", valid_597251
  var valid_597252 = query.getOrDefault("userIp")
  valid_597252 = validateParameter(valid_597252, JString, required = false,
                                 default = nil)
  if valid_597252 != nil:
    section.add "userIp", valid_597252
  var valid_597253 = query.getOrDefault("maxResults")
  valid_597253 = validateParameter(valid_597253, JInt, required = false,
                                 default = newJInt(1000))
  if valid_597253 != nil:
    section.add "maxResults", valid_597253
  var valid_597254 = query.getOrDefault("ids")
  valid_597254 = validateParameter(valid_597254, JArray, required = false,
                                 default = nil)
  if valid_597254 != nil:
    section.add "ids", valid_597254
  var valid_597255 = query.getOrDefault("key")
  valid_597255 = validateParameter(valid_597255, JString, required = false,
                                 default = nil)
  if valid_597255 != nil:
    section.add "key", valid_597255
  var valid_597256 = query.getOrDefault("sortOrder")
  valid_597256 = validateParameter(valid_597256, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_597256 != nil:
    section.add "sortOrder", valid_597256
  var valid_597257 = query.getOrDefault("prettyPrint")
  valid_597257 = validateParameter(valid_597257, JBool, required = false,
                                 default = newJBool(true))
  if valid_597257 != nil:
    section.add "prettyPrint", valid_597257
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597258: Call_DfareportingSubaccountsList_597241; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of subaccounts, possibly filtered. This method supports paging.
  ## 
  let valid = call_597258.validator(path, query, header, formData, body)
  let scheme = call_597258.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597258.url(scheme.get, call_597258.host, call_597258.base,
                         call_597258.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597258, url, valid)

proc call*(call_597259: Call_DfareportingSubaccountsList_597241; profileId: string;
          fields: string = ""; pageToken: string = ""; quotaUser: string = "";
          sortField: string = "ID"; alt: string = "json"; searchString: string = "";
          oauthToken: string = ""; userIp: string = ""; maxResults: int = 1000;
          ids: JsonNode = nil; key: string = ""; sortOrder: string = "ASCENDING";
          prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsList
  ## Gets a list of subaccounts, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "subaccount*2015" will return objects with names like "subaccount June 2015", "subaccount April 2015", or simply "subaccount 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "subaccount" will match objects with name "my subaccount", "subaccount 2015", or simply "subaccount".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only subaccounts with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597260 = newJObject()
  var query_597261 = newJObject()
  add(path_597260, "profileId", newJString(profileId))
  add(query_597261, "fields", newJString(fields))
  add(query_597261, "pageToken", newJString(pageToken))
  add(query_597261, "quotaUser", newJString(quotaUser))
  add(query_597261, "sortField", newJString(sortField))
  add(query_597261, "alt", newJString(alt))
  add(query_597261, "searchString", newJString(searchString))
  add(query_597261, "oauth_token", newJString(oauthToken))
  add(query_597261, "userIp", newJString(userIp))
  add(query_597261, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_597261.add "ids", ids
  add(query_597261, "key", newJString(key))
  add(query_597261, "sortOrder", newJString(sortOrder))
  add(query_597261, "prettyPrint", newJBool(prettyPrint))
  result = call_597259.call(path_597260, query_597261, nil, nil, nil)

var dfareportingSubaccountsList* = Call_DfareportingSubaccountsList_597241(
    name: "dfareportingSubaccountsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsList_597242,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsList_597243,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsPatch_597296 = ref object of OpenApiRestCall_593437
proc url_DfareportingSubaccountsPatch_597298(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsPatch_597297(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing subaccount. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597299 = path.getOrDefault("profileId")
  valid_597299 = validateParameter(valid_597299, JString, required = true,
                                 default = nil)
  if valid_597299 != nil:
    section.add "profileId", valid_597299
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Subaccount ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597300 = query.getOrDefault("fields")
  valid_597300 = validateParameter(valid_597300, JString, required = false,
                                 default = nil)
  if valid_597300 != nil:
    section.add "fields", valid_597300
  var valid_597301 = query.getOrDefault("quotaUser")
  valid_597301 = validateParameter(valid_597301, JString, required = false,
                                 default = nil)
  if valid_597301 != nil:
    section.add "quotaUser", valid_597301
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_597302 = query.getOrDefault("id")
  valid_597302 = validateParameter(valid_597302, JString, required = true,
                                 default = nil)
  if valid_597302 != nil:
    section.add "id", valid_597302
  var valid_597303 = query.getOrDefault("alt")
  valid_597303 = validateParameter(valid_597303, JString, required = false,
                                 default = newJString("json"))
  if valid_597303 != nil:
    section.add "alt", valid_597303
  var valid_597304 = query.getOrDefault("oauth_token")
  valid_597304 = validateParameter(valid_597304, JString, required = false,
                                 default = nil)
  if valid_597304 != nil:
    section.add "oauth_token", valid_597304
  var valid_597305 = query.getOrDefault("userIp")
  valid_597305 = validateParameter(valid_597305, JString, required = false,
                                 default = nil)
  if valid_597305 != nil:
    section.add "userIp", valid_597305
  var valid_597306 = query.getOrDefault("key")
  valid_597306 = validateParameter(valid_597306, JString, required = false,
                                 default = nil)
  if valid_597306 != nil:
    section.add "key", valid_597306
  var valid_597307 = query.getOrDefault("prettyPrint")
  valid_597307 = validateParameter(valid_597307, JBool, required = false,
                                 default = newJBool(true))
  if valid_597307 != nil:
    section.add "prettyPrint", valid_597307
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_597309: Call_DfareportingSubaccountsPatch_597296; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing subaccount. This method supports patch semantics.
  ## 
  let valid = call_597309.validator(path, query, header, formData, body)
  let scheme = call_597309.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597309.url(scheme.get, call_597309.host, call_597309.base,
                         call_597309.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597309, url, valid)

proc call*(call_597310: Call_DfareportingSubaccountsPatch_597296;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsPatch
  ## Updates an existing subaccount. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Subaccount ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597311 = newJObject()
  var query_597312 = newJObject()
  var body_597313 = newJObject()
  add(path_597311, "profileId", newJString(profileId))
  add(query_597312, "fields", newJString(fields))
  add(query_597312, "quotaUser", newJString(quotaUser))
  add(query_597312, "id", newJString(id))
  add(query_597312, "alt", newJString(alt))
  add(query_597312, "oauth_token", newJString(oauthToken))
  add(query_597312, "userIp", newJString(userIp))
  add(query_597312, "key", newJString(key))
  if body != nil:
    body_597313 = body
  add(query_597312, "prettyPrint", newJBool(prettyPrint))
  result = call_597310.call(path_597311, query_597312, nil, nil, body_597313)

var dfareportingSubaccountsPatch* = Call_DfareportingSubaccountsPatch_597296(
    name: "dfareportingSubaccountsPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/subaccounts",
    validator: validate_DfareportingSubaccountsPatch_597297,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsPatch_597298,
    schemes: {Scheme.Https})
type
  Call_DfareportingSubaccountsGet_597314 = ref object of OpenApiRestCall_593437
proc url_DfareportingSubaccountsGet_597316(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/subaccounts/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingSubaccountsGet_597315(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one subaccount by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Subaccount ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597317 = path.getOrDefault("profileId")
  valid_597317 = validateParameter(valid_597317, JString, required = true,
                                 default = nil)
  if valid_597317 != nil:
    section.add "profileId", valid_597317
  var valid_597318 = path.getOrDefault("id")
  valid_597318 = validateParameter(valid_597318, JString, required = true,
                                 default = nil)
  if valid_597318 != nil:
    section.add "id", valid_597318
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597319 = query.getOrDefault("fields")
  valid_597319 = validateParameter(valid_597319, JString, required = false,
                                 default = nil)
  if valid_597319 != nil:
    section.add "fields", valid_597319
  var valid_597320 = query.getOrDefault("quotaUser")
  valid_597320 = validateParameter(valid_597320, JString, required = false,
                                 default = nil)
  if valid_597320 != nil:
    section.add "quotaUser", valid_597320
  var valid_597321 = query.getOrDefault("alt")
  valid_597321 = validateParameter(valid_597321, JString, required = false,
                                 default = newJString("json"))
  if valid_597321 != nil:
    section.add "alt", valid_597321
  var valid_597322 = query.getOrDefault("oauth_token")
  valid_597322 = validateParameter(valid_597322, JString, required = false,
                                 default = nil)
  if valid_597322 != nil:
    section.add "oauth_token", valid_597322
  var valid_597323 = query.getOrDefault("userIp")
  valid_597323 = validateParameter(valid_597323, JString, required = false,
                                 default = nil)
  if valid_597323 != nil:
    section.add "userIp", valid_597323
  var valid_597324 = query.getOrDefault("key")
  valid_597324 = validateParameter(valid_597324, JString, required = false,
                                 default = nil)
  if valid_597324 != nil:
    section.add "key", valid_597324
  var valid_597325 = query.getOrDefault("prettyPrint")
  valid_597325 = validateParameter(valid_597325, JBool, required = false,
                                 default = newJBool(true))
  if valid_597325 != nil:
    section.add "prettyPrint", valid_597325
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597326: Call_DfareportingSubaccountsGet_597314; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one subaccount by ID.
  ## 
  let valid = call_597326.validator(path, query, header, formData, body)
  let scheme = call_597326.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597326.url(scheme.get, call_597326.host, call_597326.base,
                         call_597326.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597326, url, valid)

proc call*(call_597327: Call_DfareportingSubaccountsGet_597314; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingSubaccountsGet
  ## Gets one subaccount by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Subaccount ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597328 = newJObject()
  var query_597329 = newJObject()
  add(path_597328, "profileId", newJString(profileId))
  add(query_597329, "fields", newJString(fields))
  add(query_597329, "quotaUser", newJString(quotaUser))
  add(query_597329, "alt", newJString(alt))
  add(query_597329, "oauth_token", newJString(oauthToken))
  add(query_597329, "userIp", newJString(userIp))
  add(path_597328, "id", newJString(id))
  add(query_597329, "key", newJString(key))
  add(query_597329, "prettyPrint", newJBool(prettyPrint))
  result = call_597327.call(path_597328, query_597329, nil, nil, nil)

var dfareportingSubaccountsGet* = Call_DfareportingSubaccountsGet_597314(
    name: "dfareportingSubaccountsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/subaccounts/{id}",
    validator: validate_DfareportingSubaccountsGet_597315,
    base: "/dfareporting/v2.7", url: url_DfareportingSubaccountsGet_597316,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetableRemarketingListsList_597330 = ref object of OpenApiRestCall_593437
proc url_DfareportingTargetableRemarketingListsList_597332(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetableRemarketingLists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetableRemarketingListsList_597331(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of targetable remarketing lists, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597333 = path.getOrDefault("profileId")
  valid_597333 = validateParameter(valid_597333, JString, required = true,
                                 default = nil)
  if valid_597333 != nil:
    section.add "profileId", valid_597333
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   advertiserId: JString (required)
  ##               : Select only targetable remarketing lists targetable by these advertisers.
  ##   active: JBool
  ##         : Select only active or only inactive targetable remarketing lists.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: JString
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597334 = query.getOrDefault("fields")
  valid_597334 = validateParameter(valid_597334, JString, required = false,
                                 default = nil)
  if valid_597334 != nil:
    section.add "fields", valid_597334
  var valid_597335 = query.getOrDefault("pageToken")
  valid_597335 = validateParameter(valid_597335, JString, required = false,
                                 default = nil)
  if valid_597335 != nil:
    section.add "pageToken", valid_597335
  var valid_597336 = query.getOrDefault("quotaUser")
  valid_597336 = validateParameter(valid_597336, JString, required = false,
                                 default = nil)
  if valid_597336 != nil:
    section.add "quotaUser", valid_597336
  var valid_597337 = query.getOrDefault("sortField")
  valid_597337 = validateParameter(valid_597337, JString, required = false,
                                 default = newJString("ID"))
  if valid_597337 != nil:
    section.add "sortField", valid_597337
  var valid_597338 = query.getOrDefault("alt")
  valid_597338 = validateParameter(valid_597338, JString, required = false,
                                 default = newJString("json"))
  if valid_597338 != nil:
    section.add "alt", valid_597338
  assert query != nil,
        "query argument is necessary due to required `advertiserId` field"
  var valid_597339 = query.getOrDefault("advertiserId")
  valid_597339 = validateParameter(valid_597339, JString, required = true,
                                 default = nil)
  if valid_597339 != nil:
    section.add "advertiserId", valid_597339
  var valid_597340 = query.getOrDefault("active")
  valid_597340 = validateParameter(valid_597340, JBool, required = false, default = nil)
  if valid_597340 != nil:
    section.add "active", valid_597340
  var valid_597341 = query.getOrDefault("oauth_token")
  valid_597341 = validateParameter(valid_597341, JString, required = false,
                                 default = nil)
  if valid_597341 != nil:
    section.add "oauth_token", valid_597341
  var valid_597342 = query.getOrDefault("userIp")
  valid_597342 = validateParameter(valid_597342, JString, required = false,
                                 default = nil)
  if valid_597342 != nil:
    section.add "userIp", valid_597342
  var valid_597343 = query.getOrDefault("maxResults")
  valid_597343 = validateParameter(valid_597343, JInt, required = false,
                                 default = newJInt(1000))
  if valid_597343 != nil:
    section.add "maxResults", valid_597343
  var valid_597344 = query.getOrDefault("key")
  valid_597344 = validateParameter(valid_597344, JString, required = false,
                                 default = nil)
  if valid_597344 != nil:
    section.add "key", valid_597344
  var valid_597345 = query.getOrDefault("name")
  valid_597345 = validateParameter(valid_597345, JString, required = false,
                                 default = nil)
  if valid_597345 != nil:
    section.add "name", valid_597345
  var valid_597346 = query.getOrDefault("sortOrder")
  valid_597346 = validateParameter(valid_597346, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_597346 != nil:
    section.add "sortOrder", valid_597346
  var valid_597347 = query.getOrDefault("prettyPrint")
  valid_597347 = validateParameter(valid_597347, JBool, required = false,
                                 default = newJBool(true))
  if valid_597347 != nil:
    section.add "prettyPrint", valid_597347
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597348: Call_DfareportingTargetableRemarketingListsList_597330;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of targetable remarketing lists, possibly filtered. This method supports paging.
  ## 
  let valid = call_597348.validator(path, query, header, formData, body)
  let scheme = call_597348.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597348.url(scheme.get, call_597348.host, call_597348.base,
                         call_597348.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597348, url, valid)

proc call*(call_597349: Call_DfareportingTargetableRemarketingListsList_597330;
          profileId: string; advertiserId: string; fields: string = "";
          pageToken: string = ""; quotaUser: string = ""; sortField: string = "ID";
          alt: string = "json"; active: bool = false; oauthToken: string = "";
          userIp: string = ""; maxResults: int = 1000; key: string = ""; name: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetableRemarketingListsList
  ## Retrieves a list of targetable remarketing lists, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   advertiserId: string (required)
  ##               : Select only targetable remarketing lists targetable by these advertisers.
  ##   active: bool
  ##         : Select only active or only inactive targetable remarketing lists.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   name: string
  ##       : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "remarketing list*2015" will return objects with names like "remarketing list June 2015", "remarketing list April 2015", or simply "remarketing list 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "remarketing list" will match objects with name "my remarketing list", "remarketing list 2015", or simply "remarketing list".
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597350 = newJObject()
  var query_597351 = newJObject()
  add(path_597350, "profileId", newJString(profileId))
  add(query_597351, "fields", newJString(fields))
  add(query_597351, "pageToken", newJString(pageToken))
  add(query_597351, "quotaUser", newJString(quotaUser))
  add(query_597351, "sortField", newJString(sortField))
  add(query_597351, "alt", newJString(alt))
  add(query_597351, "advertiserId", newJString(advertiserId))
  add(query_597351, "active", newJBool(active))
  add(query_597351, "oauth_token", newJString(oauthToken))
  add(query_597351, "userIp", newJString(userIp))
  add(query_597351, "maxResults", newJInt(maxResults))
  add(query_597351, "key", newJString(key))
  add(query_597351, "name", newJString(name))
  add(query_597351, "sortOrder", newJString(sortOrder))
  add(query_597351, "prettyPrint", newJBool(prettyPrint))
  result = call_597349.call(path_597350, query_597351, nil, nil, nil)

var dfareportingTargetableRemarketingListsList* = Call_DfareportingTargetableRemarketingListsList_597330(
    name: "dfareportingTargetableRemarketingListsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetableRemarketingLists",
    validator: validate_DfareportingTargetableRemarketingListsList_597331,
    base: "/dfareporting/v2.7",
    url: url_DfareportingTargetableRemarketingListsList_597332,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetableRemarketingListsGet_597352 = ref object of OpenApiRestCall_593437
proc url_DfareportingTargetableRemarketingListsGet_597354(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetableRemarketingLists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetableRemarketingListsGet_597353(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one remarketing list by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Remarketing list ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597355 = path.getOrDefault("profileId")
  valid_597355 = validateParameter(valid_597355, JString, required = true,
                                 default = nil)
  if valid_597355 != nil:
    section.add "profileId", valid_597355
  var valid_597356 = path.getOrDefault("id")
  valid_597356 = validateParameter(valid_597356, JString, required = true,
                                 default = nil)
  if valid_597356 != nil:
    section.add "id", valid_597356
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597357 = query.getOrDefault("fields")
  valid_597357 = validateParameter(valid_597357, JString, required = false,
                                 default = nil)
  if valid_597357 != nil:
    section.add "fields", valid_597357
  var valid_597358 = query.getOrDefault("quotaUser")
  valid_597358 = validateParameter(valid_597358, JString, required = false,
                                 default = nil)
  if valid_597358 != nil:
    section.add "quotaUser", valid_597358
  var valid_597359 = query.getOrDefault("alt")
  valid_597359 = validateParameter(valid_597359, JString, required = false,
                                 default = newJString("json"))
  if valid_597359 != nil:
    section.add "alt", valid_597359
  var valid_597360 = query.getOrDefault("oauth_token")
  valid_597360 = validateParameter(valid_597360, JString, required = false,
                                 default = nil)
  if valid_597360 != nil:
    section.add "oauth_token", valid_597360
  var valid_597361 = query.getOrDefault("userIp")
  valid_597361 = validateParameter(valid_597361, JString, required = false,
                                 default = nil)
  if valid_597361 != nil:
    section.add "userIp", valid_597361
  var valid_597362 = query.getOrDefault("key")
  valid_597362 = validateParameter(valid_597362, JString, required = false,
                                 default = nil)
  if valid_597362 != nil:
    section.add "key", valid_597362
  var valid_597363 = query.getOrDefault("prettyPrint")
  valid_597363 = validateParameter(valid_597363, JBool, required = false,
                                 default = newJBool(true))
  if valid_597363 != nil:
    section.add "prettyPrint", valid_597363
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597364: Call_DfareportingTargetableRemarketingListsGet_597352;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one remarketing list by ID.
  ## 
  let valid = call_597364.validator(path, query, header, formData, body)
  let scheme = call_597364.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597364.url(scheme.get, call_597364.host, call_597364.base,
                         call_597364.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597364, url, valid)

proc call*(call_597365: Call_DfareportingTargetableRemarketingListsGet_597352;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetableRemarketingListsGet
  ## Gets one remarketing list by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Remarketing list ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597366 = newJObject()
  var query_597367 = newJObject()
  add(path_597366, "profileId", newJString(profileId))
  add(query_597367, "fields", newJString(fields))
  add(query_597367, "quotaUser", newJString(quotaUser))
  add(query_597367, "alt", newJString(alt))
  add(query_597367, "oauth_token", newJString(oauthToken))
  add(query_597367, "userIp", newJString(userIp))
  add(path_597366, "id", newJString(id))
  add(query_597367, "key", newJString(key))
  add(query_597367, "prettyPrint", newJBool(prettyPrint))
  result = call_597365.call(path_597366, query_597367, nil, nil, nil)

var dfareportingTargetableRemarketingListsGet* = Call_DfareportingTargetableRemarketingListsGet_597352(
    name: "dfareportingTargetableRemarketingListsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetableRemarketingLists/{id}",
    validator: validate_DfareportingTargetableRemarketingListsGet_597353,
    base: "/dfareporting/v2.7",
    url: url_DfareportingTargetableRemarketingListsGet_597354,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesUpdate_597390 = ref object of OpenApiRestCall_593437
proc url_DfareportingTargetingTemplatesUpdate_597392(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesUpdate_597391(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing targeting template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597393 = path.getOrDefault("profileId")
  valid_597393 = validateParameter(valid_597393, JString, required = true,
                                 default = nil)
  if valid_597393 != nil:
    section.add "profileId", valid_597393
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597394 = query.getOrDefault("fields")
  valid_597394 = validateParameter(valid_597394, JString, required = false,
                                 default = nil)
  if valid_597394 != nil:
    section.add "fields", valid_597394
  var valid_597395 = query.getOrDefault("quotaUser")
  valid_597395 = validateParameter(valid_597395, JString, required = false,
                                 default = nil)
  if valid_597395 != nil:
    section.add "quotaUser", valid_597395
  var valid_597396 = query.getOrDefault("alt")
  valid_597396 = validateParameter(valid_597396, JString, required = false,
                                 default = newJString("json"))
  if valid_597396 != nil:
    section.add "alt", valid_597396
  var valid_597397 = query.getOrDefault("oauth_token")
  valid_597397 = validateParameter(valid_597397, JString, required = false,
                                 default = nil)
  if valid_597397 != nil:
    section.add "oauth_token", valid_597397
  var valid_597398 = query.getOrDefault("userIp")
  valid_597398 = validateParameter(valid_597398, JString, required = false,
                                 default = nil)
  if valid_597398 != nil:
    section.add "userIp", valid_597398
  var valid_597399 = query.getOrDefault("key")
  valid_597399 = validateParameter(valid_597399, JString, required = false,
                                 default = nil)
  if valid_597399 != nil:
    section.add "key", valid_597399
  var valid_597400 = query.getOrDefault("prettyPrint")
  valid_597400 = validateParameter(valid_597400, JBool, required = false,
                                 default = newJBool(true))
  if valid_597400 != nil:
    section.add "prettyPrint", valid_597400
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_597402: Call_DfareportingTargetingTemplatesUpdate_597390;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing targeting template.
  ## 
  let valid = call_597402.validator(path, query, header, formData, body)
  let scheme = call_597402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597402.url(scheme.get, call_597402.host, call_597402.base,
                         call_597402.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597402, url, valid)

proc call*(call_597403: Call_DfareportingTargetingTemplatesUpdate_597390;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesUpdate
  ## Updates an existing targeting template.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597404 = newJObject()
  var query_597405 = newJObject()
  var body_597406 = newJObject()
  add(path_597404, "profileId", newJString(profileId))
  add(query_597405, "fields", newJString(fields))
  add(query_597405, "quotaUser", newJString(quotaUser))
  add(query_597405, "alt", newJString(alt))
  add(query_597405, "oauth_token", newJString(oauthToken))
  add(query_597405, "userIp", newJString(userIp))
  add(query_597405, "key", newJString(key))
  if body != nil:
    body_597406 = body
  add(query_597405, "prettyPrint", newJBool(prettyPrint))
  result = call_597403.call(path_597404, query_597405, nil, nil, body_597406)

var dfareportingTargetingTemplatesUpdate* = Call_DfareportingTargetingTemplatesUpdate_597390(
    name: "dfareportingTargetingTemplatesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesUpdate_597391,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesUpdate_597392,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesInsert_597407 = ref object of OpenApiRestCall_593437
proc url_DfareportingTargetingTemplatesInsert_597409(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesInsert_597408(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new targeting template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597410 = path.getOrDefault("profileId")
  valid_597410 = validateParameter(valid_597410, JString, required = true,
                                 default = nil)
  if valid_597410 != nil:
    section.add "profileId", valid_597410
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597411 = query.getOrDefault("fields")
  valid_597411 = validateParameter(valid_597411, JString, required = false,
                                 default = nil)
  if valid_597411 != nil:
    section.add "fields", valid_597411
  var valid_597412 = query.getOrDefault("quotaUser")
  valid_597412 = validateParameter(valid_597412, JString, required = false,
                                 default = nil)
  if valid_597412 != nil:
    section.add "quotaUser", valid_597412
  var valid_597413 = query.getOrDefault("alt")
  valid_597413 = validateParameter(valid_597413, JString, required = false,
                                 default = newJString("json"))
  if valid_597413 != nil:
    section.add "alt", valid_597413
  var valid_597414 = query.getOrDefault("oauth_token")
  valid_597414 = validateParameter(valid_597414, JString, required = false,
                                 default = nil)
  if valid_597414 != nil:
    section.add "oauth_token", valid_597414
  var valid_597415 = query.getOrDefault("userIp")
  valid_597415 = validateParameter(valid_597415, JString, required = false,
                                 default = nil)
  if valid_597415 != nil:
    section.add "userIp", valid_597415
  var valid_597416 = query.getOrDefault("key")
  valid_597416 = validateParameter(valid_597416, JString, required = false,
                                 default = nil)
  if valid_597416 != nil:
    section.add "key", valid_597416
  var valid_597417 = query.getOrDefault("prettyPrint")
  valid_597417 = validateParameter(valid_597417, JBool, required = false,
                                 default = newJBool(true))
  if valid_597417 != nil:
    section.add "prettyPrint", valid_597417
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_597419: Call_DfareportingTargetingTemplatesInsert_597407;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Inserts a new targeting template.
  ## 
  let valid = call_597419.validator(path, query, header, formData, body)
  let scheme = call_597419.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597419.url(scheme.get, call_597419.host, call_597419.base,
                         call_597419.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597419, url, valid)

proc call*(call_597420: Call_DfareportingTargetingTemplatesInsert_597407;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesInsert
  ## Inserts a new targeting template.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597421 = newJObject()
  var query_597422 = newJObject()
  var body_597423 = newJObject()
  add(path_597421, "profileId", newJString(profileId))
  add(query_597422, "fields", newJString(fields))
  add(query_597422, "quotaUser", newJString(quotaUser))
  add(query_597422, "alt", newJString(alt))
  add(query_597422, "oauth_token", newJString(oauthToken))
  add(query_597422, "userIp", newJString(userIp))
  add(query_597422, "key", newJString(key))
  if body != nil:
    body_597423 = body
  add(query_597422, "prettyPrint", newJBool(prettyPrint))
  result = call_597420.call(path_597421, query_597422, nil, nil, body_597423)

var dfareportingTargetingTemplatesInsert* = Call_DfareportingTargetingTemplatesInsert_597407(
    name: "dfareportingTargetingTemplatesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesInsert_597408,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesInsert_597409,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesList_597368 = ref object of OpenApiRestCall_593437
proc url_DfareportingTargetingTemplatesList_597370(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesList_597369(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of targeting templates, optionally filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597371 = path.getOrDefault("profileId")
  valid_597371 = validateParameter(valid_597371, JString, required = true,
                                 default = nil)
  if valid_597371 != nil:
    section.add "profileId", valid_597371
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "template*2015" will return objects with names like "template June 2015", "template April 2015", or simply "template 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "template" will match objects with name "my template", "template 2015", or simply "template".
  ##   advertiserId: JString
  ##               : Select only targeting templates with this advertiser ID.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only targeting templates with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597372 = query.getOrDefault("fields")
  valid_597372 = validateParameter(valid_597372, JString, required = false,
                                 default = nil)
  if valid_597372 != nil:
    section.add "fields", valid_597372
  var valid_597373 = query.getOrDefault("pageToken")
  valid_597373 = validateParameter(valid_597373, JString, required = false,
                                 default = nil)
  if valid_597373 != nil:
    section.add "pageToken", valid_597373
  var valid_597374 = query.getOrDefault("quotaUser")
  valid_597374 = validateParameter(valid_597374, JString, required = false,
                                 default = nil)
  if valid_597374 != nil:
    section.add "quotaUser", valid_597374
  var valid_597375 = query.getOrDefault("sortField")
  valid_597375 = validateParameter(valid_597375, JString, required = false,
                                 default = newJString("ID"))
  if valid_597375 != nil:
    section.add "sortField", valid_597375
  var valid_597376 = query.getOrDefault("alt")
  valid_597376 = validateParameter(valid_597376, JString, required = false,
                                 default = newJString("json"))
  if valid_597376 != nil:
    section.add "alt", valid_597376
  var valid_597377 = query.getOrDefault("searchString")
  valid_597377 = validateParameter(valid_597377, JString, required = false,
                                 default = nil)
  if valid_597377 != nil:
    section.add "searchString", valid_597377
  var valid_597378 = query.getOrDefault("advertiserId")
  valid_597378 = validateParameter(valid_597378, JString, required = false,
                                 default = nil)
  if valid_597378 != nil:
    section.add "advertiserId", valid_597378
  var valid_597379 = query.getOrDefault("oauth_token")
  valid_597379 = validateParameter(valid_597379, JString, required = false,
                                 default = nil)
  if valid_597379 != nil:
    section.add "oauth_token", valid_597379
  var valid_597380 = query.getOrDefault("userIp")
  valid_597380 = validateParameter(valid_597380, JString, required = false,
                                 default = nil)
  if valid_597380 != nil:
    section.add "userIp", valid_597380
  var valid_597381 = query.getOrDefault("maxResults")
  valid_597381 = validateParameter(valid_597381, JInt, required = false,
                                 default = newJInt(1000))
  if valid_597381 != nil:
    section.add "maxResults", valid_597381
  var valid_597382 = query.getOrDefault("ids")
  valid_597382 = validateParameter(valid_597382, JArray, required = false,
                                 default = nil)
  if valid_597382 != nil:
    section.add "ids", valid_597382
  var valid_597383 = query.getOrDefault("key")
  valid_597383 = validateParameter(valid_597383, JString, required = false,
                                 default = nil)
  if valid_597383 != nil:
    section.add "key", valid_597383
  var valid_597384 = query.getOrDefault("sortOrder")
  valid_597384 = validateParameter(valid_597384, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_597384 != nil:
    section.add "sortOrder", valid_597384
  var valid_597385 = query.getOrDefault("prettyPrint")
  valid_597385 = validateParameter(valid_597385, JBool, required = false,
                                 default = newJBool(true))
  if valid_597385 != nil:
    section.add "prettyPrint", valid_597385
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597386: Call_DfareportingTargetingTemplatesList_597368;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retrieves a list of targeting templates, optionally filtered. This method supports paging.
  ## 
  let valid = call_597386.validator(path, query, header, formData, body)
  let scheme = call_597386.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597386.url(scheme.get, call_597386.host, call_597386.base,
                         call_597386.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597386, url, valid)

proc call*(call_597387: Call_DfareportingTargetingTemplatesList_597368;
          profileId: string; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; advertiserId: string = ""; oauthToken: string = "";
          userIp: string = ""; maxResults: int = 1000; ids: JsonNode = nil;
          key: string = ""; sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesList
  ## Retrieves a list of targeting templates, optionally filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "template*2015" will return objects with names like "template June 2015", "template April 2015", or simply "template 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "template" will match objects with name "my template", "template 2015", or simply "template".
  ##   advertiserId: string
  ##               : Select only targeting templates with this advertiser ID.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only targeting templates with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597388 = newJObject()
  var query_597389 = newJObject()
  add(path_597388, "profileId", newJString(profileId))
  add(query_597389, "fields", newJString(fields))
  add(query_597389, "pageToken", newJString(pageToken))
  add(query_597389, "quotaUser", newJString(quotaUser))
  add(query_597389, "sortField", newJString(sortField))
  add(query_597389, "alt", newJString(alt))
  add(query_597389, "searchString", newJString(searchString))
  add(query_597389, "advertiserId", newJString(advertiserId))
  add(query_597389, "oauth_token", newJString(oauthToken))
  add(query_597389, "userIp", newJString(userIp))
  add(query_597389, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_597389.add "ids", ids
  add(query_597389, "key", newJString(key))
  add(query_597389, "sortOrder", newJString(sortOrder))
  add(query_597389, "prettyPrint", newJBool(prettyPrint))
  result = call_597387.call(path_597388, query_597389, nil, nil, nil)

var dfareportingTargetingTemplatesList* = Call_DfareportingTargetingTemplatesList_597368(
    name: "dfareportingTargetingTemplatesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesList_597369,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesList_597370,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesPatch_597424 = ref object of OpenApiRestCall_593437
proc url_DfareportingTargetingTemplatesPatch_597426(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesPatch_597425(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing targeting template. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597427 = path.getOrDefault("profileId")
  valid_597427 = validateParameter(valid_597427, JString, required = true,
                                 default = nil)
  if valid_597427 != nil:
    section.add "profileId", valid_597427
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : Targeting template ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597428 = query.getOrDefault("fields")
  valid_597428 = validateParameter(valid_597428, JString, required = false,
                                 default = nil)
  if valid_597428 != nil:
    section.add "fields", valid_597428
  var valid_597429 = query.getOrDefault("quotaUser")
  valid_597429 = validateParameter(valid_597429, JString, required = false,
                                 default = nil)
  if valid_597429 != nil:
    section.add "quotaUser", valid_597429
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_597430 = query.getOrDefault("id")
  valid_597430 = validateParameter(valid_597430, JString, required = true,
                                 default = nil)
  if valid_597430 != nil:
    section.add "id", valid_597430
  var valid_597431 = query.getOrDefault("alt")
  valid_597431 = validateParameter(valid_597431, JString, required = false,
                                 default = newJString("json"))
  if valid_597431 != nil:
    section.add "alt", valid_597431
  var valid_597432 = query.getOrDefault("oauth_token")
  valid_597432 = validateParameter(valid_597432, JString, required = false,
                                 default = nil)
  if valid_597432 != nil:
    section.add "oauth_token", valid_597432
  var valid_597433 = query.getOrDefault("userIp")
  valid_597433 = validateParameter(valid_597433, JString, required = false,
                                 default = nil)
  if valid_597433 != nil:
    section.add "userIp", valid_597433
  var valid_597434 = query.getOrDefault("key")
  valid_597434 = validateParameter(valid_597434, JString, required = false,
                                 default = nil)
  if valid_597434 != nil:
    section.add "key", valid_597434
  var valid_597435 = query.getOrDefault("prettyPrint")
  valid_597435 = validateParameter(valid_597435, JBool, required = false,
                                 default = newJBool(true))
  if valid_597435 != nil:
    section.add "prettyPrint", valid_597435
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_597437: Call_DfareportingTargetingTemplatesPatch_597424;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Updates an existing targeting template. This method supports patch semantics.
  ## 
  let valid = call_597437.validator(path, query, header, formData, body)
  let scheme = call_597437.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597437.url(scheme.get, call_597437.host, call_597437.base,
                         call_597437.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597437, url, valid)

proc call*(call_597438: Call_DfareportingTargetingTemplatesPatch_597424;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesPatch
  ## Updates an existing targeting template. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : Targeting template ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597439 = newJObject()
  var query_597440 = newJObject()
  var body_597441 = newJObject()
  add(path_597439, "profileId", newJString(profileId))
  add(query_597440, "fields", newJString(fields))
  add(query_597440, "quotaUser", newJString(quotaUser))
  add(query_597440, "id", newJString(id))
  add(query_597440, "alt", newJString(alt))
  add(query_597440, "oauth_token", newJString(oauthToken))
  add(query_597440, "userIp", newJString(userIp))
  add(query_597440, "key", newJString(key))
  if body != nil:
    body_597441 = body
  add(query_597440, "prettyPrint", newJBool(prettyPrint))
  result = call_597438.call(path_597439, query_597440, nil, nil, body_597441)

var dfareportingTargetingTemplatesPatch* = Call_DfareportingTargetingTemplatesPatch_597424(
    name: "dfareportingTargetingTemplatesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates",
    validator: validate_DfareportingTargetingTemplatesPatch_597425,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesPatch_597426,
    schemes: {Scheme.Https})
type
  Call_DfareportingTargetingTemplatesGet_597442 = ref object of OpenApiRestCall_593437
proc url_DfareportingTargetingTemplatesGet_597444(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/targetingTemplates/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingTargetingTemplatesGet_597443(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one targeting template by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : Targeting template ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597445 = path.getOrDefault("profileId")
  valid_597445 = validateParameter(valid_597445, JString, required = true,
                                 default = nil)
  if valid_597445 != nil:
    section.add "profileId", valid_597445
  var valid_597446 = path.getOrDefault("id")
  valid_597446 = validateParameter(valid_597446, JString, required = true,
                                 default = nil)
  if valid_597446 != nil:
    section.add "id", valid_597446
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597447 = query.getOrDefault("fields")
  valid_597447 = validateParameter(valid_597447, JString, required = false,
                                 default = nil)
  if valid_597447 != nil:
    section.add "fields", valid_597447
  var valid_597448 = query.getOrDefault("quotaUser")
  valid_597448 = validateParameter(valid_597448, JString, required = false,
                                 default = nil)
  if valid_597448 != nil:
    section.add "quotaUser", valid_597448
  var valid_597449 = query.getOrDefault("alt")
  valid_597449 = validateParameter(valid_597449, JString, required = false,
                                 default = newJString("json"))
  if valid_597449 != nil:
    section.add "alt", valid_597449
  var valid_597450 = query.getOrDefault("oauth_token")
  valid_597450 = validateParameter(valid_597450, JString, required = false,
                                 default = nil)
  if valid_597450 != nil:
    section.add "oauth_token", valid_597450
  var valid_597451 = query.getOrDefault("userIp")
  valid_597451 = validateParameter(valid_597451, JString, required = false,
                                 default = nil)
  if valid_597451 != nil:
    section.add "userIp", valid_597451
  var valid_597452 = query.getOrDefault("key")
  valid_597452 = validateParameter(valid_597452, JString, required = false,
                                 default = nil)
  if valid_597452 != nil:
    section.add "key", valid_597452
  var valid_597453 = query.getOrDefault("prettyPrint")
  valid_597453 = validateParameter(valid_597453, JBool, required = false,
                                 default = newJBool(true))
  if valid_597453 != nil:
    section.add "prettyPrint", valid_597453
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597454: Call_DfareportingTargetingTemplatesGet_597442;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one targeting template by ID.
  ## 
  let valid = call_597454.validator(path, query, header, formData, body)
  let scheme = call_597454.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597454.url(scheme.get, call_597454.host, call_597454.base,
                         call_597454.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597454, url, valid)

proc call*(call_597455: Call_DfareportingTargetingTemplatesGet_597442;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingTargetingTemplatesGet
  ## Gets one targeting template by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : Targeting template ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597456 = newJObject()
  var query_597457 = newJObject()
  add(path_597456, "profileId", newJString(profileId))
  add(query_597457, "fields", newJString(fields))
  add(query_597457, "quotaUser", newJString(quotaUser))
  add(query_597457, "alt", newJString(alt))
  add(query_597457, "oauth_token", newJString(oauthToken))
  add(query_597457, "userIp", newJString(userIp))
  add(path_597456, "id", newJString(id))
  add(query_597457, "key", newJString(key))
  add(query_597457, "prettyPrint", newJBool(prettyPrint))
  result = call_597455.call(path_597456, query_597457, nil, nil, nil)

var dfareportingTargetingTemplatesGet* = Call_DfareportingTargetingTemplatesGet_597442(
    name: "dfareportingTargetingTemplatesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/targetingTemplates/{id}",
    validator: validate_DfareportingTargetingTemplatesGet_597443,
    base: "/dfareporting/v2.7", url: url_DfareportingTargetingTemplatesGet_597444,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionGroupsList_597458 = ref object of OpenApiRestCall_593437
proc url_DfareportingUserRolePermissionGroupsList_597460(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissionGroups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionGroupsList_597459(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of all supported user role permission groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597461 = path.getOrDefault("profileId")
  valid_597461 = validateParameter(valid_597461, JString, required = true,
                                 default = nil)
  if valid_597461 != nil:
    section.add "profileId", valid_597461
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597462 = query.getOrDefault("fields")
  valid_597462 = validateParameter(valid_597462, JString, required = false,
                                 default = nil)
  if valid_597462 != nil:
    section.add "fields", valid_597462
  var valid_597463 = query.getOrDefault("quotaUser")
  valid_597463 = validateParameter(valid_597463, JString, required = false,
                                 default = nil)
  if valid_597463 != nil:
    section.add "quotaUser", valid_597463
  var valid_597464 = query.getOrDefault("alt")
  valid_597464 = validateParameter(valid_597464, JString, required = false,
                                 default = newJString("json"))
  if valid_597464 != nil:
    section.add "alt", valid_597464
  var valid_597465 = query.getOrDefault("oauth_token")
  valid_597465 = validateParameter(valid_597465, JString, required = false,
                                 default = nil)
  if valid_597465 != nil:
    section.add "oauth_token", valid_597465
  var valid_597466 = query.getOrDefault("userIp")
  valid_597466 = validateParameter(valid_597466, JString, required = false,
                                 default = nil)
  if valid_597466 != nil:
    section.add "userIp", valid_597466
  var valid_597467 = query.getOrDefault("key")
  valid_597467 = validateParameter(valid_597467, JString, required = false,
                                 default = nil)
  if valid_597467 != nil:
    section.add "key", valid_597467
  var valid_597468 = query.getOrDefault("prettyPrint")
  valid_597468 = validateParameter(valid_597468, JBool, required = false,
                                 default = newJBool(true))
  if valid_597468 != nil:
    section.add "prettyPrint", valid_597468
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597469: Call_DfareportingUserRolePermissionGroupsList_597458;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of all supported user role permission groups.
  ## 
  let valid = call_597469.validator(path, query, header, formData, body)
  let scheme = call_597469.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597469.url(scheme.get, call_597469.host, call_597469.base,
                         call_597469.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597469, url, valid)

proc call*(call_597470: Call_DfareportingUserRolePermissionGroupsList_597458;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolePermissionGroupsList
  ## Gets a list of all supported user role permission groups.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597471 = newJObject()
  var query_597472 = newJObject()
  add(path_597471, "profileId", newJString(profileId))
  add(query_597472, "fields", newJString(fields))
  add(query_597472, "quotaUser", newJString(quotaUser))
  add(query_597472, "alt", newJString(alt))
  add(query_597472, "oauth_token", newJString(oauthToken))
  add(query_597472, "userIp", newJString(userIp))
  add(query_597472, "key", newJString(key))
  add(query_597472, "prettyPrint", newJBool(prettyPrint))
  result = call_597470.call(path_597471, query_597472, nil, nil, nil)

var dfareportingUserRolePermissionGroupsList* = Call_DfareportingUserRolePermissionGroupsList_597458(
    name: "dfareportingUserRolePermissionGroupsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissionGroups",
    validator: validate_DfareportingUserRolePermissionGroupsList_597459,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionGroupsList_597460,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionGroupsGet_597473 = ref object of OpenApiRestCall_593437
proc url_DfareportingUserRolePermissionGroupsGet_597475(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissionGroups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionGroupsGet_597474(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user role permission group by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role permission group ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597476 = path.getOrDefault("profileId")
  valid_597476 = validateParameter(valid_597476, JString, required = true,
                                 default = nil)
  if valid_597476 != nil:
    section.add "profileId", valid_597476
  var valid_597477 = path.getOrDefault("id")
  valid_597477 = validateParameter(valid_597477, JString, required = true,
                                 default = nil)
  if valid_597477 != nil:
    section.add "id", valid_597477
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597478 = query.getOrDefault("fields")
  valid_597478 = validateParameter(valid_597478, JString, required = false,
                                 default = nil)
  if valid_597478 != nil:
    section.add "fields", valid_597478
  var valid_597479 = query.getOrDefault("quotaUser")
  valid_597479 = validateParameter(valid_597479, JString, required = false,
                                 default = nil)
  if valid_597479 != nil:
    section.add "quotaUser", valid_597479
  var valid_597480 = query.getOrDefault("alt")
  valid_597480 = validateParameter(valid_597480, JString, required = false,
                                 default = newJString("json"))
  if valid_597480 != nil:
    section.add "alt", valid_597480
  var valid_597481 = query.getOrDefault("oauth_token")
  valid_597481 = validateParameter(valid_597481, JString, required = false,
                                 default = nil)
  if valid_597481 != nil:
    section.add "oauth_token", valid_597481
  var valid_597482 = query.getOrDefault("userIp")
  valid_597482 = validateParameter(valid_597482, JString, required = false,
                                 default = nil)
  if valid_597482 != nil:
    section.add "userIp", valid_597482
  var valid_597483 = query.getOrDefault("key")
  valid_597483 = validateParameter(valid_597483, JString, required = false,
                                 default = nil)
  if valid_597483 != nil:
    section.add "key", valid_597483
  var valid_597484 = query.getOrDefault("prettyPrint")
  valid_597484 = validateParameter(valid_597484, JBool, required = false,
                                 default = newJBool(true))
  if valid_597484 != nil:
    section.add "prettyPrint", valid_597484
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597485: Call_DfareportingUserRolePermissionGroupsGet_597473;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one user role permission group by ID.
  ## 
  let valid = call_597485.validator(path, query, header, formData, body)
  let scheme = call_597485.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597485.url(scheme.get, call_597485.host, call_597485.base,
                         call_597485.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597485, url, valid)

proc call*(call_597486: Call_DfareportingUserRolePermissionGroupsGet_597473;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolePermissionGroupsGet
  ## Gets one user role permission group by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User role permission group ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597487 = newJObject()
  var query_597488 = newJObject()
  add(path_597487, "profileId", newJString(profileId))
  add(query_597488, "fields", newJString(fields))
  add(query_597488, "quotaUser", newJString(quotaUser))
  add(query_597488, "alt", newJString(alt))
  add(query_597488, "oauth_token", newJString(oauthToken))
  add(query_597488, "userIp", newJString(userIp))
  add(path_597487, "id", newJString(id))
  add(query_597488, "key", newJString(key))
  add(query_597488, "prettyPrint", newJBool(prettyPrint))
  result = call_597486.call(path_597487, query_597488, nil, nil, nil)

var dfareportingUserRolePermissionGroupsGet* = Call_DfareportingUserRolePermissionGroupsGet_597473(
    name: "dfareportingUserRolePermissionGroupsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissionGroups/{id}",
    validator: validate_DfareportingUserRolePermissionGroupsGet_597474,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionGroupsGet_597475,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionsList_597489 = ref object of OpenApiRestCall_593437
proc url_DfareportingUserRolePermissionsList_597491(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionsList_597490(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of user role permissions, possibly filtered.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597492 = path.getOrDefault("profileId")
  valid_597492 = validateParameter(valid_597492, JString, required = true,
                                 default = nil)
  if valid_597492 != nil:
    section.add "profileId", valid_597492
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Select only user role permissions with these IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597493 = query.getOrDefault("fields")
  valid_597493 = validateParameter(valid_597493, JString, required = false,
                                 default = nil)
  if valid_597493 != nil:
    section.add "fields", valid_597493
  var valid_597494 = query.getOrDefault("quotaUser")
  valid_597494 = validateParameter(valid_597494, JString, required = false,
                                 default = nil)
  if valid_597494 != nil:
    section.add "quotaUser", valid_597494
  var valid_597495 = query.getOrDefault("alt")
  valid_597495 = validateParameter(valid_597495, JString, required = false,
                                 default = newJString("json"))
  if valid_597495 != nil:
    section.add "alt", valid_597495
  var valid_597496 = query.getOrDefault("oauth_token")
  valid_597496 = validateParameter(valid_597496, JString, required = false,
                                 default = nil)
  if valid_597496 != nil:
    section.add "oauth_token", valid_597496
  var valid_597497 = query.getOrDefault("userIp")
  valid_597497 = validateParameter(valid_597497, JString, required = false,
                                 default = nil)
  if valid_597497 != nil:
    section.add "userIp", valid_597497
  var valid_597498 = query.getOrDefault("ids")
  valid_597498 = validateParameter(valid_597498, JArray, required = false,
                                 default = nil)
  if valid_597498 != nil:
    section.add "ids", valid_597498
  var valid_597499 = query.getOrDefault("key")
  valid_597499 = validateParameter(valid_597499, JString, required = false,
                                 default = nil)
  if valid_597499 != nil:
    section.add "key", valid_597499
  var valid_597500 = query.getOrDefault("prettyPrint")
  valid_597500 = validateParameter(valid_597500, JBool, required = false,
                                 default = newJBool(true))
  if valid_597500 != nil:
    section.add "prettyPrint", valid_597500
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597501: Call_DfareportingUserRolePermissionsList_597489;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of user role permissions, possibly filtered.
  ## 
  let valid = call_597501.validator(path, query, header, formData, body)
  let scheme = call_597501.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597501.url(scheme.get, call_597501.host, call_597501.base,
                         call_597501.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597501, url, valid)

proc call*(call_597502: Call_DfareportingUserRolePermissionsList_597489;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          ids: JsonNode = nil; key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolePermissionsList
  ## Gets a list of user role permissions, possibly filtered.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   ids: JArray
  ##      : Select only user role permissions with these IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597503 = newJObject()
  var query_597504 = newJObject()
  add(path_597503, "profileId", newJString(profileId))
  add(query_597504, "fields", newJString(fields))
  add(query_597504, "quotaUser", newJString(quotaUser))
  add(query_597504, "alt", newJString(alt))
  add(query_597504, "oauth_token", newJString(oauthToken))
  add(query_597504, "userIp", newJString(userIp))
  if ids != nil:
    query_597504.add "ids", ids
  add(query_597504, "key", newJString(key))
  add(query_597504, "prettyPrint", newJBool(prettyPrint))
  result = call_597502.call(path_597503, query_597504, nil, nil, nil)

var dfareportingUserRolePermissionsList* = Call_DfareportingUserRolePermissionsList_597489(
    name: "dfareportingUserRolePermissionsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissions",
    validator: validate_DfareportingUserRolePermissionsList_597490,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionsList_597491,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolePermissionsGet_597505 = ref object of OpenApiRestCall_593437
proc url_DfareportingUserRolePermissionsGet_597507(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRolePermissions/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolePermissionsGet_597506(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user role permission by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role permission ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597508 = path.getOrDefault("profileId")
  valid_597508 = validateParameter(valid_597508, JString, required = true,
                                 default = nil)
  if valid_597508 != nil:
    section.add "profileId", valid_597508
  var valid_597509 = path.getOrDefault("id")
  valid_597509 = validateParameter(valid_597509, JString, required = true,
                                 default = nil)
  if valid_597509 != nil:
    section.add "id", valid_597509
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597510 = query.getOrDefault("fields")
  valid_597510 = validateParameter(valid_597510, JString, required = false,
                                 default = nil)
  if valid_597510 != nil:
    section.add "fields", valid_597510
  var valid_597511 = query.getOrDefault("quotaUser")
  valid_597511 = validateParameter(valid_597511, JString, required = false,
                                 default = nil)
  if valid_597511 != nil:
    section.add "quotaUser", valid_597511
  var valid_597512 = query.getOrDefault("alt")
  valid_597512 = validateParameter(valid_597512, JString, required = false,
                                 default = newJString("json"))
  if valid_597512 != nil:
    section.add "alt", valid_597512
  var valid_597513 = query.getOrDefault("oauth_token")
  valid_597513 = validateParameter(valid_597513, JString, required = false,
                                 default = nil)
  if valid_597513 != nil:
    section.add "oauth_token", valid_597513
  var valid_597514 = query.getOrDefault("userIp")
  valid_597514 = validateParameter(valid_597514, JString, required = false,
                                 default = nil)
  if valid_597514 != nil:
    section.add "userIp", valid_597514
  var valid_597515 = query.getOrDefault("key")
  valid_597515 = validateParameter(valid_597515, JString, required = false,
                                 default = nil)
  if valid_597515 != nil:
    section.add "key", valid_597515
  var valid_597516 = query.getOrDefault("prettyPrint")
  valid_597516 = validateParameter(valid_597516, JBool, required = false,
                                 default = newJBool(true))
  if valid_597516 != nil:
    section.add "prettyPrint", valid_597516
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597517: Call_DfareportingUserRolePermissionsGet_597505;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets one user role permission by ID.
  ## 
  let valid = call_597517.validator(path, query, header, formData, body)
  let scheme = call_597517.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597517.url(scheme.get, call_597517.host, call_597517.base,
                         call_597517.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597517, url, valid)

proc call*(call_597518: Call_DfareportingUserRolePermissionsGet_597505;
          profileId: string; id: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolePermissionsGet
  ## Gets one user role permission by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User role permission ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597519 = newJObject()
  var query_597520 = newJObject()
  add(path_597519, "profileId", newJString(profileId))
  add(query_597520, "fields", newJString(fields))
  add(query_597520, "quotaUser", newJString(quotaUser))
  add(query_597520, "alt", newJString(alt))
  add(query_597520, "oauth_token", newJString(oauthToken))
  add(query_597520, "userIp", newJString(userIp))
  add(path_597519, "id", newJString(id))
  add(query_597520, "key", newJString(key))
  add(query_597520, "prettyPrint", newJBool(prettyPrint))
  result = call_597518.call(path_597519, query_597520, nil, nil, nil)

var dfareportingUserRolePermissionsGet* = Call_DfareportingUserRolePermissionsGet_597505(
    name: "dfareportingUserRolePermissionsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/userRolePermissions/{id}",
    validator: validate_DfareportingUserRolePermissionsGet_597506,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolePermissionsGet_597507,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesUpdate_597544 = ref object of OpenApiRestCall_593437
proc url_DfareportingUserRolesUpdate_597546(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesUpdate_597545(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing user role.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597547 = path.getOrDefault("profileId")
  valid_597547 = validateParameter(valid_597547, JString, required = true,
                                 default = nil)
  if valid_597547 != nil:
    section.add "profileId", valid_597547
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597548 = query.getOrDefault("fields")
  valid_597548 = validateParameter(valid_597548, JString, required = false,
                                 default = nil)
  if valid_597548 != nil:
    section.add "fields", valid_597548
  var valid_597549 = query.getOrDefault("quotaUser")
  valid_597549 = validateParameter(valid_597549, JString, required = false,
                                 default = nil)
  if valid_597549 != nil:
    section.add "quotaUser", valid_597549
  var valid_597550 = query.getOrDefault("alt")
  valid_597550 = validateParameter(valid_597550, JString, required = false,
                                 default = newJString("json"))
  if valid_597550 != nil:
    section.add "alt", valid_597550
  var valid_597551 = query.getOrDefault("oauth_token")
  valid_597551 = validateParameter(valid_597551, JString, required = false,
                                 default = nil)
  if valid_597551 != nil:
    section.add "oauth_token", valid_597551
  var valid_597552 = query.getOrDefault("userIp")
  valid_597552 = validateParameter(valid_597552, JString, required = false,
                                 default = nil)
  if valid_597552 != nil:
    section.add "userIp", valid_597552
  var valid_597553 = query.getOrDefault("key")
  valid_597553 = validateParameter(valid_597553, JString, required = false,
                                 default = nil)
  if valid_597553 != nil:
    section.add "key", valid_597553
  var valid_597554 = query.getOrDefault("prettyPrint")
  valid_597554 = validateParameter(valid_597554, JBool, required = false,
                                 default = newJBool(true))
  if valid_597554 != nil:
    section.add "prettyPrint", valid_597554
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_597556: Call_DfareportingUserRolesUpdate_597544; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing user role.
  ## 
  let valid = call_597556.validator(path, query, header, formData, body)
  let scheme = call_597556.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597556.url(scheme.get, call_597556.host, call_597556.base,
                         call_597556.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597556, url, valid)

proc call*(call_597557: Call_DfareportingUserRolesUpdate_597544; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesUpdate
  ## Updates an existing user role.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597558 = newJObject()
  var query_597559 = newJObject()
  var body_597560 = newJObject()
  add(path_597558, "profileId", newJString(profileId))
  add(query_597559, "fields", newJString(fields))
  add(query_597559, "quotaUser", newJString(quotaUser))
  add(query_597559, "alt", newJString(alt))
  add(query_597559, "oauth_token", newJString(oauthToken))
  add(query_597559, "userIp", newJString(userIp))
  add(query_597559, "key", newJString(key))
  if body != nil:
    body_597560 = body
  add(query_597559, "prettyPrint", newJBool(prettyPrint))
  result = call_597557.call(path_597558, query_597559, nil, nil, body_597560)

var dfareportingUserRolesUpdate* = Call_DfareportingUserRolesUpdate_597544(
    name: "dfareportingUserRolesUpdate", meth: HttpMethod.HttpPut,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesUpdate_597545,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesUpdate_597546,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesInsert_597561 = ref object of OpenApiRestCall_593437
proc url_DfareportingUserRolesInsert_597563(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesInsert_597562(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Inserts a new user role.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597564 = path.getOrDefault("profileId")
  valid_597564 = validateParameter(valid_597564, JString, required = true,
                                 default = nil)
  if valid_597564 != nil:
    section.add "profileId", valid_597564
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597565 = query.getOrDefault("fields")
  valid_597565 = validateParameter(valid_597565, JString, required = false,
                                 default = nil)
  if valid_597565 != nil:
    section.add "fields", valid_597565
  var valid_597566 = query.getOrDefault("quotaUser")
  valid_597566 = validateParameter(valid_597566, JString, required = false,
                                 default = nil)
  if valid_597566 != nil:
    section.add "quotaUser", valid_597566
  var valid_597567 = query.getOrDefault("alt")
  valid_597567 = validateParameter(valid_597567, JString, required = false,
                                 default = newJString("json"))
  if valid_597567 != nil:
    section.add "alt", valid_597567
  var valid_597568 = query.getOrDefault("oauth_token")
  valid_597568 = validateParameter(valid_597568, JString, required = false,
                                 default = nil)
  if valid_597568 != nil:
    section.add "oauth_token", valid_597568
  var valid_597569 = query.getOrDefault("userIp")
  valid_597569 = validateParameter(valid_597569, JString, required = false,
                                 default = nil)
  if valid_597569 != nil:
    section.add "userIp", valid_597569
  var valid_597570 = query.getOrDefault("key")
  valid_597570 = validateParameter(valid_597570, JString, required = false,
                                 default = nil)
  if valid_597570 != nil:
    section.add "key", valid_597570
  var valid_597571 = query.getOrDefault("prettyPrint")
  valid_597571 = validateParameter(valid_597571, JBool, required = false,
                                 default = newJBool(true))
  if valid_597571 != nil:
    section.add "prettyPrint", valid_597571
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_597573: Call_DfareportingUserRolesInsert_597561; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Inserts a new user role.
  ## 
  let valid = call_597573.validator(path, query, header, formData, body)
  let scheme = call_597573.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597573.url(scheme.get, call_597573.host, call_597573.base,
                         call_597573.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597573, url, valid)

proc call*(call_597574: Call_DfareportingUserRolesInsert_597561; profileId: string;
          fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesInsert
  ## Inserts a new user role.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597575 = newJObject()
  var query_597576 = newJObject()
  var body_597577 = newJObject()
  add(path_597575, "profileId", newJString(profileId))
  add(query_597576, "fields", newJString(fields))
  add(query_597576, "quotaUser", newJString(quotaUser))
  add(query_597576, "alt", newJString(alt))
  add(query_597576, "oauth_token", newJString(oauthToken))
  add(query_597576, "userIp", newJString(userIp))
  add(query_597576, "key", newJString(key))
  if body != nil:
    body_597577 = body
  add(query_597576, "prettyPrint", newJBool(prettyPrint))
  result = call_597574.call(path_597575, query_597576, nil, nil, body_597577)

var dfareportingUserRolesInsert* = Call_DfareportingUserRolesInsert_597561(
    name: "dfareportingUserRolesInsert", meth: HttpMethod.HttpPost,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesInsert_597562,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesInsert_597563,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesList_597521 = ref object of OpenApiRestCall_593437
proc url_DfareportingUserRolesList_597523(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesList_597522(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retrieves a list of user roles, possibly filtered. This method supports paging.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597524 = path.getOrDefault("profileId")
  valid_597524 = validateParameter(valid_597524, JString, required = true,
                                 default = nil)
  if valid_597524 != nil:
    section.add "profileId", valid_597524
  result.add "path", section
  ## parameters in `query` object:
  ##   subaccountId: JString
  ##               : Select only user roles that belong to this subaccount.
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: JString
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: JString
  ##            : Field by which to sort the list.
  ##   alt: JString
  ##      : Data format for the response.
  ##   searchString: JString
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "userrole*2015" will return objects with names like "userrole June 2015", "userrole April 2015", or simply "userrole 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "userrole" will match objects with name "my userrole", "userrole 2015", or simply "userrole".
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   accountUserRoleOnly: JBool
  ##                      : Select only account level user roles not associated with any specific subaccount.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: JInt
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only user roles with the specified IDs.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: JString
  ##            : Order of sorted results.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597525 = query.getOrDefault("subaccountId")
  valid_597525 = validateParameter(valid_597525, JString, required = false,
                                 default = nil)
  if valid_597525 != nil:
    section.add "subaccountId", valid_597525
  var valid_597526 = query.getOrDefault("fields")
  valid_597526 = validateParameter(valid_597526, JString, required = false,
                                 default = nil)
  if valid_597526 != nil:
    section.add "fields", valid_597526
  var valid_597527 = query.getOrDefault("pageToken")
  valid_597527 = validateParameter(valid_597527, JString, required = false,
                                 default = nil)
  if valid_597527 != nil:
    section.add "pageToken", valid_597527
  var valid_597528 = query.getOrDefault("quotaUser")
  valid_597528 = validateParameter(valid_597528, JString, required = false,
                                 default = nil)
  if valid_597528 != nil:
    section.add "quotaUser", valid_597528
  var valid_597529 = query.getOrDefault("sortField")
  valid_597529 = validateParameter(valid_597529, JString, required = false,
                                 default = newJString("ID"))
  if valid_597529 != nil:
    section.add "sortField", valid_597529
  var valid_597530 = query.getOrDefault("alt")
  valid_597530 = validateParameter(valid_597530, JString, required = false,
                                 default = newJString("json"))
  if valid_597530 != nil:
    section.add "alt", valid_597530
  var valid_597531 = query.getOrDefault("searchString")
  valid_597531 = validateParameter(valid_597531, JString, required = false,
                                 default = nil)
  if valid_597531 != nil:
    section.add "searchString", valid_597531
  var valid_597532 = query.getOrDefault("oauth_token")
  valid_597532 = validateParameter(valid_597532, JString, required = false,
                                 default = nil)
  if valid_597532 != nil:
    section.add "oauth_token", valid_597532
  var valid_597533 = query.getOrDefault("accountUserRoleOnly")
  valid_597533 = validateParameter(valid_597533, JBool, required = false, default = nil)
  if valid_597533 != nil:
    section.add "accountUserRoleOnly", valid_597533
  var valid_597534 = query.getOrDefault("userIp")
  valid_597534 = validateParameter(valid_597534, JString, required = false,
                                 default = nil)
  if valid_597534 != nil:
    section.add "userIp", valid_597534
  var valid_597535 = query.getOrDefault("maxResults")
  valid_597535 = validateParameter(valid_597535, JInt, required = false,
                                 default = newJInt(1000))
  if valid_597535 != nil:
    section.add "maxResults", valid_597535
  var valid_597536 = query.getOrDefault("ids")
  valid_597536 = validateParameter(valid_597536, JArray, required = false,
                                 default = nil)
  if valid_597536 != nil:
    section.add "ids", valid_597536
  var valid_597537 = query.getOrDefault("key")
  valid_597537 = validateParameter(valid_597537, JString, required = false,
                                 default = nil)
  if valid_597537 != nil:
    section.add "key", valid_597537
  var valid_597538 = query.getOrDefault("sortOrder")
  valid_597538 = validateParameter(valid_597538, JString, required = false,
                                 default = newJString("ASCENDING"))
  if valid_597538 != nil:
    section.add "sortOrder", valid_597538
  var valid_597539 = query.getOrDefault("prettyPrint")
  valid_597539 = validateParameter(valid_597539, JBool, required = false,
                                 default = newJBool(true))
  if valid_597539 != nil:
    section.add "prettyPrint", valid_597539
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597540: Call_DfareportingUserRolesList_597521; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Retrieves a list of user roles, possibly filtered. This method supports paging.
  ## 
  let valid = call_597540.validator(path, query, header, formData, body)
  let scheme = call_597540.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597540.url(scheme.get, call_597540.host, call_597540.base,
                         call_597540.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597540, url, valid)

proc call*(call_597541: Call_DfareportingUserRolesList_597521; profileId: string;
          subaccountId: string = ""; fields: string = ""; pageToken: string = "";
          quotaUser: string = ""; sortField: string = "ID"; alt: string = "json";
          searchString: string = ""; oauthToken: string = "";
          accountUserRoleOnly: bool = false; userIp: string = "";
          maxResults: int = 1000; ids: JsonNode = nil; key: string = "";
          sortOrder: string = "ASCENDING"; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesList
  ## Retrieves a list of user roles, possibly filtered. This method supports paging.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   subaccountId: string
  ##               : Select only user roles that belong to this subaccount.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   pageToken: string
  ##            : Value of the nextPageToken from the previous result page.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   sortField: string
  ##            : Field by which to sort the list.
  ##   alt: string
  ##      : Data format for the response.
  ##   searchString: string
  ##               : Allows searching for objects by name or ID. Wildcards (*) are allowed. For example, "userrole*2015" will return objects with names like "userrole June 2015", "userrole April 2015", or simply "userrole 2015". Most of the searches also add wildcards implicitly at the start and the end of the search string. For example, a search string of "userrole" will match objects with name "my userrole", "userrole 2015", or simply "userrole".
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   accountUserRoleOnly: bool
  ##                      : Select only account level user roles not associated with any specific subaccount.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   maxResults: int
  ##             : Maximum number of results to return.
  ##   ids: JArray
  ##      : Select only user roles with the specified IDs.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   sortOrder: string
  ##            : Order of sorted results.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597542 = newJObject()
  var query_597543 = newJObject()
  add(path_597542, "profileId", newJString(profileId))
  add(query_597543, "subaccountId", newJString(subaccountId))
  add(query_597543, "fields", newJString(fields))
  add(query_597543, "pageToken", newJString(pageToken))
  add(query_597543, "quotaUser", newJString(quotaUser))
  add(query_597543, "sortField", newJString(sortField))
  add(query_597543, "alt", newJString(alt))
  add(query_597543, "searchString", newJString(searchString))
  add(query_597543, "oauth_token", newJString(oauthToken))
  add(query_597543, "accountUserRoleOnly", newJBool(accountUserRoleOnly))
  add(query_597543, "userIp", newJString(userIp))
  add(query_597543, "maxResults", newJInt(maxResults))
  if ids != nil:
    query_597543.add "ids", ids
  add(query_597543, "key", newJString(key))
  add(query_597543, "sortOrder", newJString(sortOrder))
  add(query_597543, "prettyPrint", newJBool(prettyPrint))
  result = call_597541.call(path_597542, query_597543, nil, nil, nil)

var dfareportingUserRolesList* = Call_DfareportingUserRolesList_597521(
    name: "dfareportingUserRolesList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesList_597522,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesList_597523,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesPatch_597578 = ref object of OpenApiRestCall_593437
proc url_DfareportingUserRolesPatch_597580(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesPatch_597579(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing user role. This method supports patch semantics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597581 = path.getOrDefault("profileId")
  valid_597581 = validateParameter(valid_597581, JString, required = true,
                                 default = nil)
  if valid_597581 != nil:
    section.add "profileId", valid_597581
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: JString (required)
  ##     : User role ID.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597582 = query.getOrDefault("fields")
  valid_597582 = validateParameter(valid_597582, JString, required = false,
                                 default = nil)
  if valid_597582 != nil:
    section.add "fields", valid_597582
  var valid_597583 = query.getOrDefault("quotaUser")
  valid_597583 = validateParameter(valid_597583, JString, required = false,
                                 default = nil)
  if valid_597583 != nil:
    section.add "quotaUser", valid_597583
  assert query != nil, "query argument is necessary due to required `id` field"
  var valid_597584 = query.getOrDefault("id")
  valid_597584 = validateParameter(valid_597584, JString, required = true,
                                 default = nil)
  if valid_597584 != nil:
    section.add "id", valid_597584
  var valid_597585 = query.getOrDefault("alt")
  valid_597585 = validateParameter(valid_597585, JString, required = false,
                                 default = newJString("json"))
  if valid_597585 != nil:
    section.add "alt", valid_597585
  var valid_597586 = query.getOrDefault("oauth_token")
  valid_597586 = validateParameter(valid_597586, JString, required = false,
                                 default = nil)
  if valid_597586 != nil:
    section.add "oauth_token", valid_597586
  var valid_597587 = query.getOrDefault("userIp")
  valid_597587 = validateParameter(valid_597587, JString, required = false,
                                 default = nil)
  if valid_597587 != nil:
    section.add "userIp", valid_597587
  var valid_597588 = query.getOrDefault("key")
  valid_597588 = validateParameter(valid_597588, JString, required = false,
                                 default = nil)
  if valid_597588 != nil:
    section.add "key", valid_597588
  var valid_597589 = query.getOrDefault("prettyPrint")
  valid_597589 = validateParameter(valid_597589, JBool, required = false,
                                 default = newJBool(true))
  if valid_597589 != nil:
    section.add "prettyPrint", valid_597589
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_597591: Call_DfareportingUserRolesPatch_597578; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing user role. This method supports patch semantics.
  ## 
  let valid = call_597591.validator(path, query, header, formData, body)
  let scheme = call_597591.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597591.url(scheme.get, call_597591.host, call_597591.base,
                         call_597591.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597591, url, valid)

proc call*(call_597592: Call_DfareportingUserRolesPatch_597578; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          body: JsonNode = nil; prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesPatch
  ## Updates an existing user role. This method supports patch semantics.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   id: string (required)
  ##     : User role ID.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   body: JObject
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597593 = newJObject()
  var query_597594 = newJObject()
  var body_597595 = newJObject()
  add(path_597593, "profileId", newJString(profileId))
  add(query_597594, "fields", newJString(fields))
  add(query_597594, "quotaUser", newJString(quotaUser))
  add(query_597594, "id", newJString(id))
  add(query_597594, "alt", newJString(alt))
  add(query_597594, "oauth_token", newJString(oauthToken))
  add(query_597594, "userIp", newJString(userIp))
  add(query_597594, "key", newJString(key))
  if body != nil:
    body_597595 = body
  add(query_597594, "prettyPrint", newJBool(prettyPrint))
  result = call_597592.call(path_597593, query_597594, nil, nil, body_597595)

var dfareportingUserRolesPatch* = Call_DfareportingUserRolesPatch_597578(
    name: "dfareportingUserRolesPatch", meth: HttpMethod.HttpPatch,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles",
    validator: validate_DfareportingUserRolesPatch_597579,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesPatch_597580,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesGet_597596 = ref object of OpenApiRestCall_593437
proc url_DfareportingUserRolesGet_597598(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesGet_597597(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one user role by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597599 = path.getOrDefault("profileId")
  valid_597599 = validateParameter(valid_597599, JString, required = true,
                                 default = nil)
  if valid_597599 != nil:
    section.add "profileId", valid_597599
  var valid_597600 = path.getOrDefault("id")
  valid_597600 = validateParameter(valid_597600, JString, required = true,
                                 default = nil)
  if valid_597600 != nil:
    section.add "id", valid_597600
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597601 = query.getOrDefault("fields")
  valid_597601 = validateParameter(valid_597601, JString, required = false,
                                 default = nil)
  if valid_597601 != nil:
    section.add "fields", valid_597601
  var valid_597602 = query.getOrDefault("quotaUser")
  valid_597602 = validateParameter(valid_597602, JString, required = false,
                                 default = nil)
  if valid_597602 != nil:
    section.add "quotaUser", valid_597602
  var valid_597603 = query.getOrDefault("alt")
  valid_597603 = validateParameter(valid_597603, JString, required = false,
                                 default = newJString("json"))
  if valid_597603 != nil:
    section.add "alt", valid_597603
  var valid_597604 = query.getOrDefault("oauth_token")
  valid_597604 = validateParameter(valid_597604, JString, required = false,
                                 default = nil)
  if valid_597604 != nil:
    section.add "oauth_token", valid_597604
  var valid_597605 = query.getOrDefault("userIp")
  valid_597605 = validateParameter(valid_597605, JString, required = false,
                                 default = nil)
  if valid_597605 != nil:
    section.add "userIp", valid_597605
  var valid_597606 = query.getOrDefault("key")
  valid_597606 = validateParameter(valid_597606, JString, required = false,
                                 default = nil)
  if valid_597606 != nil:
    section.add "key", valid_597606
  var valid_597607 = query.getOrDefault("prettyPrint")
  valid_597607 = validateParameter(valid_597607, JBool, required = false,
                                 default = newJBool(true))
  if valid_597607 != nil:
    section.add "prettyPrint", valid_597607
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597608: Call_DfareportingUserRolesGet_597596; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one user role by ID.
  ## 
  let valid = call_597608.validator(path, query, header, formData, body)
  let scheme = call_597608.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597608.url(scheme.get, call_597608.host, call_597608.base,
                         call_597608.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597608, url, valid)

proc call*(call_597609: Call_DfareportingUserRolesGet_597596; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesGet
  ## Gets one user role by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User role ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597610 = newJObject()
  var query_597611 = newJObject()
  add(path_597610, "profileId", newJString(profileId))
  add(query_597611, "fields", newJString(fields))
  add(query_597611, "quotaUser", newJString(quotaUser))
  add(query_597611, "alt", newJString(alt))
  add(query_597611, "oauth_token", newJString(oauthToken))
  add(query_597611, "userIp", newJString(userIp))
  add(path_597610, "id", newJString(id))
  add(query_597611, "key", newJString(key))
  add(query_597611, "prettyPrint", newJBool(prettyPrint))
  result = call_597609.call(path_597610, query_597611, nil, nil, nil)

var dfareportingUserRolesGet* = Call_DfareportingUserRolesGet_597596(
    name: "dfareportingUserRolesGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles/{id}",
    validator: validate_DfareportingUserRolesGet_597597,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesGet_597598,
    schemes: {Scheme.Https})
type
  Call_DfareportingUserRolesDelete_597612 = ref object of OpenApiRestCall_593437
proc url_DfareportingUserRolesDelete_597614(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/userRoles/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingUserRolesDelete_597613(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing user role.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JString (required)
  ##     : User role ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597615 = path.getOrDefault("profileId")
  valid_597615 = validateParameter(valid_597615, JString, required = true,
                                 default = nil)
  if valid_597615 != nil:
    section.add "profileId", valid_597615
  var valid_597616 = path.getOrDefault("id")
  valid_597616 = validateParameter(valid_597616, JString, required = true,
                                 default = nil)
  if valid_597616 != nil:
    section.add "id", valid_597616
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597617 = query.getOrDefault("fields")
  valid_597617 = validateParameter(valid_597617, JString, required = false,
                                 default = nil)
  if valid_597617 != nil:
    section.add "fields", valid_597617
  var valid_597618 = query.getOrDefault("quotaUser")
  valid_597618 = validateParameter(valid_597618, JString, required = false,
                                 default = nil)
  if valid_597618 != nil:
    section.add "quotaUser", valid_597618
  var valid_597619 = query.getOrDefault("alt")
  valid_597619 = validateParameter(valid_597619, JString, required = false,
                                 default = newJString("json"))
  if valid_597619 != nil:
    section.add "alt", valid_597619
  var valid_597620 = query.getOrDefault("oauth_token")
  valid_597620 = validateParameter(valid_597620, JString, required = false,
                                 default = nil)
  if valid_597620 != nil:
    section.add "oauth_token", valid_597620
  var valid_597621 = query.getOrDefault("userIp")
  valid_597621 = validateParameter(valid_597621, JString, required = false,
                                 default = nil)
  if valid_597621 != nil:
    section.add "userIp", valid_597621
  var valid_597622 = query.getOrDefault("key")
  valid_597622 = validateParameter(valid_597622, JString, required = false,
                                 default = nil)
  if valid_597622 != nil:
    section.add "key", valid_597622
  var valid_597623 = query.getOrDefault("prettyPrint")
  valid_597623 = validateParameter(valid_597623, JBool, required = false,
                                 default = newJBool(true))
  if valid_597623 != nil:
    section.add "prettyPrint", valid_597623
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597624: Call_DfareportingUserRolesDelete_597612; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing user role.
  ## 
  let valid = call_597624.validator(path, query, header, formData, body)
  let scheme = call_597624.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597624.url(scheme.get, call_597624.host, call_597624.base,
                         call_597624.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597624, url, valid)

proc call*(call_597625: Call_DfareportingUserRolesDelete_597612; profileId: string;
          id: string; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingUserRolesDelete
  ## Deletes an existing user role.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: string (required)
  ##     : User role ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597626 = newJObject()
  var query_597627 = newJObject()
  add(path_597626, "profileId", newJString(profileId))
  add(query_597627, "fields", newJString(fields))
  add(query_597627, "quotaUser", newJString(quotaUser))
  add(query_597627, "alt", newJString(alt))
  add(query_597627, "oauth_token", newJString(oauthToken))
  add(query_597627, "userIp", newJString(userIp))
  add(path_597626, "id", newJString(id))
  add(query_597627, "key", newJString(key))
  add(query_597627, "prettyPrint", newJBool(prettyPrint))
  result = call_597625.call(path_597626, query_597627, nil, nil, nil)

var dfareportingUserRolesDelete* = Call_DfareportingUserRolesDelete_597612(
    name: "dfareportingUserRolesDelete", meth: HttpMethod.HttpDelete,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/userRoles/{id}",
    validator: validate_DfareportingUserRolesDelete_597613,
    base: "/dfareporting/v2.7", url: url_DfareportingUserRolesDelete_597614,
    schemes: {Scheme.Https})
type
  Call_DfareportingVideoFormatsList_597628 = ref object of OpenApiRestCall_593437
proc url_DfareportingVideoFormatsList_597630(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/videoFormats")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingVideoFormatsList_597629(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists available video formats.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597631 = path.getOrDefault("profileId")
  valid_597631 = validateParameter(valid_597631, JString, required = true,
                                 default = nil)
  if valid_597631 != nil:
    section.add "profileId", valid_597631
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597632 = query.getOrDefault("fields")
  valid_597632 = validateParameter(valid_597632, JString, required = false,
                                 default = nil)
  if valid_597632 != nil:
    section.add "fields", valid_597632
  var valid_597633 = query.getOrDefault("quotaUser")
  valid_597633 = validateParameter(valid_597633, JString, required = false,
                                 default = nil)
  if valid_597633 != nil:
    section.add "quotaUser", valid_597633
  var valid_597634 = query.getOrDefault("alt")
  valid_597634 = validateParameter(valid_597634, JString, required = false,
                                 default = newJString("json"))
  if valid_597634 != nil:
    section.add "alt", valid_597634
  var valid_597635 = query.getOrDefault("oauth_token")
  valid_597635 = validateParameter(valid_597635, JString, required = false,
                                 default = nil)
  if valid_597635 != nil:
    section.add "oauth_token", valid_597635
  var valid_597636 = query.getOrDefault("userIp")
  valid_597636 = validateParameter(valid_597636, JString, required = false,
                                 default = nil)
  if valid_597636 != nil:
    section.add "userIp", valid_597636
  var valid_597637 = query.getOrDefault("key")
  valid_597637 = validateParameter(valid_597637, JString, required = false,
                                 default = nil)
  if valid_597637 != nil:
    section.add "key", valid_597637
  var valid_597638 = query.getOrDefault("prettyPrint")
  valid_597638 = validateParameter(valid_597638, JBool, required = false,
                                 default = newJBool(true))
  if valid_597638 != nil:
    section.add "prettyPrint", valid_597638
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597639: Call_DfareportingVideoFormatsList_597628; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists available video formats.
  ## 
  let valid = call_597639.validator(path, query, header, formData, body)
  let scheme = call_597639.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597639.url(scheme.get, call_597639.host, call_597639.base,
                         call_597639.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597639, url, valid)

proc call*(call_597640: Call_DfareportingVideoFormatsList_597628;
          profileId: string; fields: string = ""; quotaUser: string = "";
          alt: string = "json"; oauthToken: string = ""; userIp: string = "";
          key: string = ""; prettyPrint: bool = true): Recallable =
  ## dfareportingVideoFormatsList
  ## Lists available video formats.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597641 = newJObject()
  var query_597642 = newJObject()
  add(path_597641, "profileId", newJString(profileId))
  add(query_597642, "fields", newJString(fields))
  add(query_597642, "quotaUser", newJString(quotaUser))
  add(query_597642, "alt", newJString(alt))
  add(query_597642, "oauth_token", newJString(oauthToken))
  add(query_597642, "userIp", newJString(userIp))
  add(query_597642, "key", newJString(key))
  add(query_597642, "prettyPrint", newJBool(prettyPrint))
  result = call_597640.call(path_597641, query_597642, nil, nil, nil)

var dfareportingVideoFormatsList* = Call_DfareportingVideoFormatsList_597628(
    name: "dfareportingVideoFormatsList", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com", route: "/userprofiles/{profileId}/videoFormats",
    validator: validate_DfareportingVideoFormatsList_597629,
    base: "/dfareporting/v2.7", url: url_DfareportingVideoFormatsList_597630,
    schemes: {Scheme.Https})
type
  Call_DfareportingVideoFormatsGet_597643 = ref object of OpenApiRestCall_593437
proc url_DfareportingVideoFormatsGet_597645(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "profileId" in path, "`profileId` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/userprofiles/"),
               (kind: VariableSegment, value: "profileId"),
               (kind: ConstantSegment, value: "/videoFormats/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DfareportingVideoFormatsGet_597644(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets one video format by ID.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   profileId: JString (required)
  ##            : User profile ID associated with this request.
  ##   id: JInt (required)
  ##     : Video format ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `profileId` field"
  var valid_597646 = path.getOrDefault("profileId")
  valid_597646 = validateParameter(valid_597646, JString, required = true,
                                 default = nil)
  if valid_597646 != nil:
    section.add "profileId", valid_597646
  var valid_597647 = path.getOrDefault("id")
  valid_597647 = validateParameter(valid_597647, JInt, required = true, default = nil)
  if valid_597647 != nil:
    section.add "id", valid_597647
  result.add "path", section
  ## parameters in `query` object:
  ##   fields: JString
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: JString
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: JString
  ##      : Data format for the response.
  ##   oauth_token: JString
  ##              : OAuth 2.0 token for the current user.
  ##   userIp: JString
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   key: JString
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: JBool
  ##              : Returns response with indentations and line breaks.
  section = newJObject()
  var valid_597648 = query.getOrDefault("fields")
  valid_597648 = validateParameter(valid_597648, JString, required = false,
                                 default = nil)
  if valid_597648 != nil:
    section.add "fields", valid_597648
  var valid_597649 = query.getOrDefault("quotaUser")
  valid_597649 = validateParameter(valid_597649, JString, required = false,
                                 default = nil)
  if valid_597649 != nil:
    section.add "quotaUser", valid_597649
  var valid_597650 = query.getOrDefault("alt")
  valid_597650 = validateParameter(valid_597650, JString, required = false,
                                 default = newJString("json"))
  if valid_597650 != nil:
    section.add "alt", valid_597650
  var valid_597651 = query.getOrDefault("oauth_token")
  valid_597651 = validateParameter(valid_597651, JString, required = false,
                                 default = nil)
  if valid_597651 != nil:
    section.add "oauth_token", valid_597651
  var valid_597652 = query.getOrDefault("userIp")
  valid_597652 = validateParameter(valid_597652, JString, required = false,
                                 default = nil)
  if valid_597652 != nil:
    section.add "userIp", valid_597652
  var valid_597653 = query.getOrDefault("key")
  valid_597653 = validateParameter(valid_597653, JString, required = false,
                                 default = nil)
  if valid_597653 != nil:
    section.add "key", valid_597653
  var valid_597654 = query.getOrDefault("prettyPrint")
  valid_597654 = validateParameter(valid_597654, JBool, required = false,
                                 default = newJBool(true))
  if valid_597654 != nil:
    section.add "prettyPrint", valid_597654
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597655: Call_DfareportingVideoFormatsGet_597643; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets one video format by ID.
  ## 
  let valid = call_597655.validator(path, query, header, formData, body)
  let scheme = call_597655.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597655.url(scheme.get, call_597655.host, call_597655.base,
                         call_597655.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597655, url, valid)

proc call*(call_597656: Call_DfareportingVideoFormatsGet_597643; profileId: string;
          id: int; fields: string = ""; quotaUser: string = ""; alt: string = "json";
          oauthToken: string = ""; userIp: string = ""; key: string = "";
          prettyPrint: bool = true): Recallable =
  ## dfareportingVideoFormatsGet
  ## Gets one video format by ID.
  ##   profileId: string (required)
  ##            : User profile ID associated with this request.
  ##   fields: string
  ##         : Selector specifying which fields to include in a partial response.
  ##   quotaUser: string
  ##            : Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
  ##   alt: string
  ##      : Data format for the response.
  ##   oauthToken: string
  ##             : OAuth 2.0 token for the current user.
  ##   userIp: string
  ##         : IP address of the site where the request originates. Use this if you want to enforce per-user limits.
  ##   id: int (required)
  ##     : Video format ID.
  ##   key: string
  ##      : API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
  ##   prettyPrint: bool
  ##              : Returns response with indentations and line breaks.
  var path_597657 = newJObject()
  var query_597658 = newJObject()
  add(path_597657, "profileId", newJString(profileId))
  add(query_597658, "fields", newJString(fields))
  add(query_597658, "quotaUser", newJString(quotaUser))
  add(query_597658, "alt", newJString(alt))
  add(query_597658, "oauth_token", newJString(oauthToken))
  add(query_597658, "userIp", newJString(userIp))
  add(path_597657, "id", newJInt(id))
  add(query_597658, "key", newJString(key))
  add(query_597658, "prettyPrint", newJBool(prettyPrint))
  result = call_597656.call(path_597657, query_597658, nil, nil, nil)

var dfareportingVideoFormatsGet* = Call_DfareportingVideoFormatsGet_597643(
    name: "dfareportingVideoFormatsGet", meth: HttpMethod.HttpGet,
    host: "www.googleapis.com",
    route: "/userprofiles/{profileId}/videoFormats/{id}",
    validator: validate_DfareportingVideoFormatsGet_597644,
    base: "/dfareporting/v2.7", url: url_DfareportingVideoFormatsGet_597645,
    schemes: {Scheme.Https})
export
  rest

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
